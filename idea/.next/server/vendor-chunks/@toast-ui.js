/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@toast-ui";
exports.ids = ["vendor-chunks/@toast-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@toast-ui/editor/dist/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ ToastUIEditor),\n/* harmony export */   EditorCore: () => (/* binding */ ToastUIEditorCore),\n/* harmony export */   \"default\": () => (/* binding */ ToastUIEditor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n/* harmony import */ var prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-inputrules */ \"(ssr)/./node_modules/prosemirror-inputrules/dist/index.js\");\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n/**\n * @toast-ui/editor\n * @version 3.2.2 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n\n\n\n\n\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics$1 = function(d, b) {\r\n    extendStatics$1 = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics$1(d, b);\r\n};\r\n\r\nfunction __extends$1(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics$1(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign$1 = function() {\r\n    __assign$1 = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$1.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray$1(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n}\n\n/**\n * @fileoverview Execute the provided callback once for each property of object which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Execute the provided callback once for each property of object which actually exist.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property\n *  2) The name of the property\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee  Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachOwnProperties from 'tui-code-snippet/collection/forEachOwnProperties';\n * \n * // CommonJS\n * const forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); \n *\n * let sum = 0;\n *\n * forEachOwnProperties({a:1,b:2,c:3}, function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachOwnProperties$2(obj, iteratee, context) {\n  var key;\n\n  context = context || null;\n\n  for (key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (iteratee.call(context, obj[key], key, obj) === false) {\n        break;\n      }\n    }\n  }\n}\n\nvar forEachOwnProperties_1 = forEachOwnProperties$2;\n\n/**\n * @fileoverview Extend the target object from other objects.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * @module object\n */\n\n/**\n * Extend the target object from other objects.\n * @param {object} target - Object that will be extended\n * @param {...object} objects - Objects as sources\n * @returns {object} Extended object\n * @memberof module:object\n */\nfunction extend(target, objects) { // eslint-disable-line no-unused-vars\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n  var source, prop, i, len;\n\n  for (i = 1, len = arguments.length; i < len; i += 1) {\n    source = arguments[i];\n    for (prop in source) {\n      if (hasOwnProp.call(source, prop)) {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\n\nvar extend_1 = extend;\n\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a string or not.\n * If the given variable is a string, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is string?\n * @memberof module:type\n */\nfunction isString$3(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\n\nvar isString_1 = isString$3;\n\n/**\n * @fileoverview Check whether the given variable is an instance of Array or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is an instance of Array or not.\n * If the given variable is an instance of Array, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is array instance?\n * @memberof module:type\n */\nfunction isArray$3(obj) {\n  return obj instanceof Array;\n}\n\nvar isArray_1 = isArray$3;\n\n/**\n * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Execute the provided callback once for each element present\n * in the array(or Array-like object) in ascending order.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the element\n *  2) The index of the element\n *  3) The array(or Array-like object) being traversed\n * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachArray from 'tui-code-snippet/collection/forEachArray';\n * \n * // CommonJS\n * const forEachArray = require('tui-code-snippet/collection/forEachArray'); \n *\n * let sum = 0;\n *\n * forEachArray([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachArray$3(arr, iteratee, context) {\n  var index = 0;\n  var len = arr.length;\n\n  context = context || null;\n\n  for (; index < len; index += 1) {\n    if (iteratee.call(context, arr[index], index, arr) === false) {\n      break;\n    }\n  }\n}\n\nvar forEachArray_1 = forEachArray$3;\n\n/**\n * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isArray$2 = isArray_1;\nvar forEachArray$2 = forEachArray_1;\nvar forEachOwnProperties$1 = forEachOwnProperties_1;\n\n/**\n * @module collection\n */\n\n/**\n * Execute the provided callback once for each property of object(or element of array) which actually exist.\n * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property(or The value of the element)\n *  2) The name of the property(or The index of the element)\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEach from 'tui-code-snippet/collection/forEach'; \n * \n * // CommonJS\n * const forEach = require('tui-code-snippet/collection/forEach'); \n *\n * let sum = 0;\n *\n * forEach([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n *\n * // In case of Array-like object\n * const array = Array.prototype.slice.call(arrayLike); // change to array\n * forEach(array, function(value){\n *   sum += value;\n * });\n */\nfunction forEach$4(obj, iteratee, context) {\n  if (isArray$2(obj)) {\n    forEachArray$2(obj, iteratee, context);\n  } else {\n    forEachOwnProperties$1(obj, iteratee, context);\n  }\n}\n\nvar forEach_1 = forEach$4;\n\n/**\n * @fileoverview Setting element style\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString$2 = isString_1;\nvar forEach$3 = forEach_1;\n\n/**\n * Setting element style\n * @param {(HTMLElement|SVGElement)} element - element to setting style\n * @param {(string|object)} key - style prop name or {prop: value} pair object\n * @param {string} [value] - style value\n * @memberof module:domUtil\n */\nfunction css(element, key, value) {\n  var style = element.style;\n\n  if (isString$2(key)) {\n    style[key] = value;\n\n    return;\n  }\n\n  forEach$3(key, function(v, k) {\n    style[k] = v;\n  });\n}\n\nvar css_1 = css;\n\n/* eslint-disable complexity */\n\nvar isArray$1 = isArray_1;\n\n/**\n * @module array\n */\n\n/**\n * Returns the first index at which a given element can be found in the array\n * from start index(default 0), or -1 if it is not present.\n * It compares searchElement to elements of the Array using strict equality\n * (the same method used by the ===, or triple-equals, operator).\n * @param {*} searchElement Element to locate in the array\n * @param {Array} array Array that will be traversed.\n * @param {number} startIndex Start index in array for searching (default 0)\n * @returns {number} the First index at which a given element, or -1 if it is not present\n * @memberof module:array\n * @example\n * // ES6\n * import inArray from 'tui-code-snippet/array/inArray';\n * \n * // CommonJS\n * const inArray = require('tui-code-snippet/array/inArray');\n *\n * const arr = ['one', 'two', 'three', 'four'];\n * const idx1 = inArray('one', arr, 3); // -1\n * const idx2 = inArray('one', arr); // 0\n */\nfunction inArray$4(searchElement, array, startIndex) {\n  var i;\n  var length;\n  startIndex = startIndex || 0;\n\n  if (!isArray$1(array)) {\n    return -1;\n  }\n\n  if (Array.prototype.indexOf) {\n    return Array.prototype.indexOf.call(array, searchElement, startIndex);\n  }\n\n  length = array.length;\n  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {\n    if (array[i] === searchElement) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nvar inArray_1 = inArray$4;\n\n/**\n * @fileoverview Check whether the given variable is undefined or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is undefined or not.\n * If the given variable is undefined, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is undefined?\n * @memberof module:type\n */\nfunction isUndefined$4(obj) {\n  return obj === undefined; // eslint-disable-line no-undefined\n}\n\nvar isUndefined_1 = isUndefined$4;\n\n/**\n * @fileoverview Get HTML element's design classes.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined$3 = isUndefined_1;\n\n/**\n * Get HTML element's design classes.\n * @param {(HTMLElement|SVGElement)} element target element\n * @returns {string} element css class name\n * @memberof module:domUtil\n */\nfunction getClass$3(element) {\n  if (!element || !element.className) {\n    return '';\n  }\n\n  if (isUndefined$3(element.className.baseVal)) {\n    return element.className;\n  }\n\n  return element.className.baseVal;\n}\n\nvar getClass_1 = getClass$3;\n\n/**\n * @fileoverview Set className value\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isArray = isArray_1;\nvar isUndefined$2 = isUndefined_1;\n\n/**\n * Set className value\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {(string|string[])} cssClass - class names\n * @private\n */\nfunction setClassName$2(element, cssClass) {\n  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;\n\n  cssClass = cssClass.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n  if (isUndefined$2(element.className.baseVal)) {\n    element.className = cssClass;\n\n    return;\n  }\n\n  element.className.baseVal = cssClass;\n}\n\nvar _setClassName = setClassName$2;\n\n/**\n * @fileoverview Add css class to element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEach$2 = forEach_1;\nvar inArray$3 = inArray_1;\nvar getClass$2 = getClass_1;\nvar setClassName$1 = _setClassName;\n\n/**\n * domUtil module\n * @module domUtil\n */\n\n/**\n * Add css class to element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to add\n * @memberof module:domUtil\n */\nfunction addClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var newClass = [];\n  var origin;\n\n  if (classList) {\n    forEach$2(cssClass, function(name) {\n      element.classList.add(name);\n    });\n\n    return;\n  }\n\n  origin = getClass$2(element);\n\n  if (origin) {\n    cssClass = [].concat(origin.split(/\\s+/), cssClass);\n  }\n\n  forEach$2(cssClass, function(cls) {\n    if (inArray$3(cls, newClass) < 0) {\n      newClass.push(cls);\n    }\n  });\n\n  setClassName$1(element, newClass);\n}\n\nvar addClass_1 = addClass;\n\n/**\n * @fileoverview Remove css class from element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachArray$1 = forEachArray_1;\nvar inArray$2 = inArray_1;\nvar getClass$1 = getClass_1;\nvar setClassName = _setClassName;\n\n/**\n * Remove css class from element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to remove\n * @memberof module:domUtil\n */\nfunction removeClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var origin, newClass;\n\n  if (classList) {\n    forEachArray$1(cssClass, function(name) {\n      classList.remove(name);\n    });\n\n    return;\n  }\n\n  origin = getClass$1(element).split(/\\s+/);\n  newClass = [];\n  forEachArray$1(origin, function(name) {\n    if (inArray$2(name, cssClass) < 0) {\n      newClass.push(name);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nvar removeClass_1 = removeClass;\n\n/**\n * @fileoverview Check whether the given variable is a number or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a number or not.\n * If the given variable is a number, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is number?\n * @memberof module:type\n */\nfunction isNumber(obj) {\n  return typeof obj === 'number' || obj instanceof Number;\n}\n\nvar isNumber_1 = isNumber;\n\n/**\n * @fileoverview Check whether the given variable is null or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is null or not.\n * If the given variable(arguments[0]) is null, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is null?\n * @memberof module:type\n */\nfunction isNull$1(obj) {\n  return obj === null;\n}\n\nvar isNull_1 = isNull$1;\n\n/**\n * @fileoverview Request image ping.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachOwnProperties = forEachOwnProperties_1;\n\n/**\n * @module request\n */\n\n/**\n * Request image ping.\n * @param {String} url url for ping request\n * @param {Object} trackingInfo infos for make query string\n * @returns {HTMLElement}\n * @memberof module:request\n * @example\n * // ES6\n * import imagePing from 'tui-code-snippet/request/imagePing';\n * \n * // CommonJS\n * const imagePing = require('tui-code-snippet/request/imagePing');\n *\n * imagePing('https://www.google-analytics.com/collect', {\n *   v: 1,\n *   t: 'event',\n *   tid: 'trackingid',\n *   cid: 'cid',\n *   dp: 'dp',\n *   dh: 'dh'\n * });\n */\nfunction imagePing$1(url, trackingInfo) {\n  var trackingElement = document.createElement('img');\n  var queryString = '';\n  forEachOwnProperties(trackingInfo, function(value, key) {\n    queryString += '&' + key + '=' + value;\n  });\n  queryString = queryString.substring(1);\n\n  trackingElement.src = url + '?' + queryString;\n\n  trackingElement.style.display = 'none';\n  document.body.appendChild(trackingElement);\n  document.body.removeChild(trackingElement);\n\n  return trackingElement;\n}\n\nvar imagePing_1 = imagePing$1;\n\n/**\n * @fileoverview Send hostname on DOMContentLoaded.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined$1 = isUndefined_1;\nvar imagePing = imagePing_1;\n\nvar ms7days = 7 * 24 * 60 * 60 * 1000;\n\n/**\n * Check if the date has passed 7 days\n * @param {number} date - milliseconds\n * @returns {boolean}\n * @private\n */\nfunction isExpired(date) {\n  var now = new Date().getTime();\n\n  return now - date > ms7days;\n}\n\n/**\n * Send hostname on DOMContentLoaded.\n * To prevent hostname set tui.usageStatistics to false.\n * @param {string} appName - application name\n * @param {string} trackingId - GA tracking ID\n * @ignore\n */\nfunction sendHostname(appName, trackingId) {\n  var url = 'https://www.google-analytics.com/collect';\n  var hostname = location.hostname;\n  var hitType = 'event';\n  var eventCategory = 'use';\n  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';\n  var date = window.localStorage.getItem(applicationKeyForStorage);\n\n  // skip if the flag is defined and is set to false explicitly\n  if (!isUndefined$1(window.tui) && window.tui.usageStatistics === false) {\n    return;\n  }\n\n  // skip if not pass seven days old\n  if (date && !isExpired(date)) {\n    return;\n  }\n\n  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());\n\n  setTimeout(function() {\n    if (document.readyState === 'interactive' || document.readyState === 'complete') {\n      imagePing(url, {\n        v: 1,\n        t: hitType,\n        tid: trackingId,\n        cid: hostname,\n        dp: hostname,\n        dh: appName,\n        el: appName,\n        ec: eventCategory\n      });\n    }\n  }, 1000);\n}\n\nvar sendHostname_1 = sendHostname;\n\n/Mac/.test(navigator.platform);\nvar reSpaceMoreThanOne = /[\\u0020]+/g;\nvar reEscapeChars$1 = /[>(){}[\\]+-.!#|]/g;\nvar reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\\-._]*)(\\s|[^\\\\>])*\\/?>|<(\\/)([a-zA-Z_][a-zA-Z0-9\\-._]*)\\s*\\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\\-.:/]*)>/g;\nvar reEscapeBackSlash = /\\\\[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]/g;\nvar reEscapePairedChars = /[*_~`]/g;\nvar reMdImageSyntax = /!\\[.*\\]\\(.*\\)/g;\nvar reEscapedCharInLinkSyntax = /[[\\]]/g;\nvar reEscapeBackSlashInSentence = /(?:^|[^\\\\])\\\\(?!\\\\)/g;\nvar XMLSPECIAL$1 = '[&<>\"]';\nvar reXmlSpecial$1 = new RegExp(XMLSPECIAL$1, 'g');\nfunction replaceUnsafeChar$1(char) {\n    switch (char) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return char;\n    }\n}\nfunction escapeXml$1(text) {\n    if (reXmlSpecial$1.test(text)) {\n        return text.replace(reXmlSpecial$1, replaceUnsafeChar$1);\n    }\n    return text;\n}\nfunction sendHostName() {\n    sendHostname_1('editor', 'UA-129966929-1');\n}\nfunction includes(arr, targetItem) {\n    return arr.indexOf(targetItem) !== -1;\n}\nvar availableLinkAttributes = ['rel', 'target', 'hreflang', 'type'];\nvar reMarkdownTextToEscapeMap = {\n    codeblock: /(^ {4}[^\\n]+\\n*)+/,\n    thematicBreak: /^ *((\\* *){3,}|(- *){3,} *|(_ *){3,}) */,\n    atxHeading: /^(#{1,6}) +[\\s\\S]+/,\n    seTextheading: /^([^\\n]+)\\n *(=|-){2,} */,\n    blockquote: /^( *>[^\\n]+.*)+/,\n    list: /^ *(\\*+|-+|\\d+\\.) [\\s\\S]+/,\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? */,\n    link: /!?\\[.*\\]\\(.*\\)/,\n    reflink: /!?\\[.*\\]\\s*\\[([^\\]]*)\\]/,\n    verticalBar: /\\u007C/,\n    fencedCodeblock: /^((`|~){3,})/,\n};\nfunction sanitizeLinkAttribute(attribute) {\n    if (!attribute) {\n        return null;\n    }\n    var linkAttributes = {};\n    availableLinkAttributes.forEach(function (key) {\n        if (!isUndefined_1(attribute[key])) {\n            linkAttributes[key] = attribute[key];\n        }\n    });\n    return linkAttributes;\n}\nfunction repeat$1(text, count) {\n    var result = '';\n    for (var i = 0; i < count; i += 1) {\n        result += text;\n    }\n    return result;\n}\nfunction isNeedEscapeText(text) {\n    var needEscape = false;\n    forEachOwnProperties_1(reMarkdownTextToEscapeMap, function (reMarkdownTextToEscape) {\n        if (reMarkdownTextToEscape.test(text)) {\n            needEscape = true;\n        }\n        return !needEscape;\n    });\n    return needEscape;\n}\nfunction escapeTextForLink(text) {\n    var imageSyntaxRanges = [];\n    var result = reMdImageSyntax.exec(text);\n    while (result) {\n        imageSyntaxRanges.push([result.index, result.index + result[0].length]);\n        result = reMdImageSyntax.exec(text);\n    }\n    return text.replace(reEscapedCharInLinkSyntax, function (matched, offset) {\n        var isDelimiter = imageSyntaxRanges.some(function (range) { return offset > range[0] && offset < range[1]; });\n        return isDelimiter ? matched : \"\\\\\" + matched;\n    });\n}\nfunction escape$1(text) {\n    var aheadReplacer = function (matched) { return \"\\\\\" + matched; };\n    var behindReplacer = function (matched) { return matched + \"\\\\\"; };\n    var escapedText = text.replace(reSpaceMoreThanOne, ' ');\n    if (reEscapeBackSlash.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlash, aheadReplacer);\n    }\n    if (reEscapeBackSlashInSentence.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlashInSentence, behindReplacer);\n    }\n    escapedText = escapedText.replace(reEscapePairedChars, aheadReplacer);\n    if (reEscapeHTML.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeHTML, aheadReplacer);\n    }\n    if (isNeedEscapeText(escapedText)) {\n        escapedText = escapedText.replace(reEscapeChars$1, aheadReplacer);\n    }\n    return escapedText;\n}\nfunction quote(text) {\n    var result;\n    if (text.indexOf('\"') === -1) {\n        result = '\"\"';\n    }\n    else {\n        result = text.indexOf(\"'\") === -1 ? \"''\" : '()';\n    }\n    return result[0] + text + result[1];\n}\nfunction isNil(value) {\n    return isNull_1(value) || isUndefined_1(value);\n}\nfunction shallowEqual(o1, o2) {\n    if (o1 === null && o1 === o2) {\n        return true;\n    }\n    if (typeof o1 !== 'object' || typeof o2 !== 'object' || isNil(o1) || isNil(o2)) {\n        return o1 === o2;\n    }\n    for (var key in o1) {\n        if (o1[key] !== o2[key]) {\n            return false;\n        }\n    }\n    for (var key in o2) {\n        if (!(key in o1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\nfunction between$1(value, min, max) {\n    return value >= min && value <= max;\n}\nfunction isObject$1(obj) {\n    return typeof obj === 'object' && obj !== null;\n}\nfunction deepMergedCopy(targetObj, obj) {\n    var resultObj = __assign$1({}, targetObj);\n    if (targetObj && obj) {\n        Object.keys(obj).forEach(function (prop) {\n            if (isObject$1(resultObj[prop])) {\n                if (Array.isArray(obj[prop])) {\n                    resultObj[prop] = deepCopyArray(obj[prop]);\n                }\n                else if (resultObj.hasOwnProperty(prop)) {\n                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);\n                }\n                else {\n                    resultObj[prop] = deepCopy(obj[prop]);\n                }\n            }\n            else {\n                resultObj[prop] = obj[prop];\n            }\n        });\n    }\n    return resultObj;\n}\nfunction deepCopyArray(items) {\n    return items.map(function (item) {\n        if (isObject$1(item)) {\n            return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);\n        }\n        return item;\n    });\n}\nfunction deepCopy(obj) {\n    var keys = Object.keys(obj);\n    if (!keys.length) {\n        return obj;\n    }\n    return keys.reduce(function (acc, prop) {\n        if (isObject$1(obj[prop])) {\n            acc[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);\n        }\n        else {\n            acc[prop] = obj[prop];\n        }\n        return acc;\n    }, {});\n}\nfunction assign(targetObj, obj) {\n    if (obj === void 0) { obj = {}; }\n    Object.keys(obj).forEach(function (prop) {\n        if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === 'object') {\n            if (Array.isArray(obj[prop])) {\n                targetObj[prop] = obj[prop];\n            }\n            else {\n                assign(targetObj[prop], obj[prop]);\n            }\n        }\n        else {\n            targetObj[prop] = obj[prop];\n        }\n    });\n    return targetObj;\n}\nfunction getSortedNumPair(valueA, valueB) {\n    return valueA > valueB ? [valueB, valueA] : [valueA, valueB];\n}\n\n/**\n * @fileoverview Transform the Array-like object to Array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachArray = forEachArray_1;\n\n/**\n * Transform the Array-like object to Array.\n * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.\n * @param {*} arrayLike Array-like object\n * @returns {Array} Array\n * @memberof module:collection\n * @example\n * // ES6\n * import toArray from 'tui-code-snippet/collection/toArray'; \n * \n * // CommonJS\n * const toArray = require('tui-code-snippet/collection/toArray'); \n *\n * const arrayLike = {\n *   0: 'one',\n *   1: 'two',\n *   2: 'three',\n *   3: 'four',\n *   length: 4\n * };\n * const result = toArray(arrayLike);\n *\n * alert(result instanceof Array); // true\n * alert(result); // one,two,three,four\n */\nfunction toArray$1(arrayLike) {\n  var arr;\n  try {\n    arr = Array.prototype.slice.call(arrayLike);\n  } catch (e) {\n    arr = [];\n    forEachArray(arrayLike, function(value) {\n      arr.push(value);\n    });\n  }\n\n  return arr;\n}\n\nvar toArray_1 = toArray$1;\n\nfunction createParagraph(schema, content) {\n    var paragraph = schema.nodes.paragraph;\n    if (!content) {\n        return paragraph.createAndFill();\n    }\n    return paragraph.create(null, isString_1(content) ? schema.text(content) : content);\n}\nfunction createTextNode$1(schema, text, marks) {\n    return schema.text(text, marks);\n}\nfunction createTextSelection(tr, from, to) {\n    if (to === void 0) { to = from; }\n    var contentSize = tr.doc.content.size;\n    var size = contentSize > 0 ? contentSize - 1 : 1;\n    return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, Math.min(from, size), Math.min(to, size));\n}\nfunction addParagraph(tr, _a, schema) {\n    var pos = _a.pos;\n    tr.replaceWith(pos, pos, createParagraph(schema));\n    return tr.setSelection(createTextSelection(tr, pos + 1));\n}\nfunction replaceTextNode(_a) {\n    var state = _a.state, from = _a.from, startIndex = _a.startIndex, endIndex = _a.endIndex, createText = _a.createText;\n    var tr = state.tr, doc = state.doc, schema = state.schema;\n    for (var i = startIndex; i <= endIndex; i += 1) {\n        var _b = doc.child(i), nodeSize = _b.nodeSize, textContent = _b.textContent, content = _b.content;\n        var text = createText(textContent);\n        var node = text ? createTextNode$1(schema, text) : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n        var mappedFrom = tr.mapping.map(from);\n        var mappedTo = mappedFrom + content.size;\n        tr.replaceWith(mappedFrom, mappedTo, node);\n        from += nodeSize;\n    }\n    return tr;\n}\nfunction splitAndExtendBlock(tr, pos, text, node) {\n    var textLen = text.length;\n    tr.split(pos)\n        .delete(pos - textLen, pos)\n        .insert(tr.mapping.map(pos), node)\n        .setSelection(createTextSelection(tr, tr.mapping.map(pos) - textLen));\n}\n\nfunction getMdStartLine(mdNode) {\n    return mdNode.sourcepos[0][0];\n}\nfunction getMdEndLine(mdNode) {\n    return mdNode.sourcepos[1][0];\n}\nfunction getMdStartCh(mdNode) {\n    return mdNode.sourcepos[0][1];\n}\nfunction getMdEndCh(mdNode) {\n    return mdNode.sourcepos[1][1];\n}\nfunction isHTMLNode(mdNode) {\n    var type = mdNode.type;\n    return type === 'htmlBlock' || type === 'htmlInline';\n}\nfunction isStyledInlineNode(mdNode) {\n    var type = mdNode.type;\n    return (type === 'strike' ||\n        type === 'strong' ||\n        type === 'emph' ||\n        type === 'code' ||\n        type === 'link' ||\n        type === 'image');\n}\nfunction isCodeBlockNode(mdNode) {\n    return mdNode && mdNode.type === 'codeBlock';\n}\nfunction isListNode$1(mdNode) {\n    return mdNode && (mdNode.type === 'item' || mdNode.type === 'list');\n}\nfunction isOrderedListNode(mdNode) {\n    return isListNode$1(mdNode) && mdNode.listData.type === 'ordered';\n}\nfunction isBulletListNode(mdNode) {\n    return isListNode$1(mdNode) && mdNode.listData.type !== 'ordered';\n}\nfunction isTableCellNode(mdNode) {\n    return mdNode && (mdNode.type === 'tableCell' || mdNode.type === 'tableDelimCell');\n}\nfunction isInlineNode$1(mdNode) {\n    switch (mdNode.type) {\n        case 'code':\n        case 'text':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'htmlInline':\n        case 'linebreak':\n        case 'softbreak':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction findClosestNode(mdNode, condition, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        if (condition(mdNode)) {\n            return mdNode;\n        }\n        mdNode = mdNode.parent;\n    }\n    return null;\n}\nfunction traverseParentNodes(mdNode, iteratee, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        iteratee(mdNode);\n        mdNode = mdNode.parent;\n    }\n}\nfunction addOffsetPos(originPos, offset) {\n    return [originPos[0], originPos[1] + offset];\n}\nfunction setOffsetPos(originPos, newOffset) {\n    return [originPos[0], newOffset];\n}\nfunction getInlineMarkdownText(mdNode) {\n    var text = mdNode.firstChild.literal;\n    switch (mdNode.type) {\n        case 'emph':\n            return \"*\" + text + \"*\";\n        case 'strong':\n            return \"**\" + text + \"**\";\n        case 'strike':\n            return \"~~\" + text + \"~~\";\n        case 'code':\n            return \"`\" + text + \"`\";\n        case 'link':\n        case 'image':\n            /* eslint-disable no-case-declarations */\n            var _a = mdNode, destination = _a.destination, title = _a.title;\n            var delim = mdNode.type === 'link' ? '' : '!';\n            return delim + \"[\" + text + \"](\" + destination + (title ? \" \\\"\" + title + \"\\\"\" : '') + \")\";\n        default:\n            return null;\n    }\n}\nfunction isContainer$2(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getChildrenText$1(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var childNode = event.node;\n        if (childNode.type === 'text') {\n            buffer.push(childNode.literal);\n        }\n    }\n    return buffer.join('');\n}\n\nvar widgetRules = [];\nvar widgetRuleMap = {};\nvar reWidgetPrefix = /\\$\\$widget\\d+\\s/;\nfunction unwrapWidgetSyntax(text) {\n    var index = text.search(reWidgetPrefix);\n    if (index !== -1) {\n        var rest = text.substring(index);\n        var replaced = rest.replace(reWidgetPrefix, '').replace('$$', '');\n        text = text.substring(0, index);\n        text += unwrapWidgetSyntax(replaced);\n    }\n    return text;\n}\nfunction createWidgetContent(info, text) {\n    return \"$$\" + info + \" \" + text + \"$$\";\n}\nfunction widgetToDOM(info, text) {\n    var _a = widgetRuleMap[info], rule = _a.rule, toDOM = _a.toDOM;\n    var matches = unwrapWidgetSyntax(text).match(rule);\n    if (matches) {\n        text = matches[0];\n    }\n    return toDOM(text);\n}\nfunction getWidgetRules() {\n    return widgetRules;\n}\nfunction setWidgetRules(rules) {\n    widgetRules = rules;\n    widgetRules.forEach(function (rule, index) {\n        widgetRuleMap[\"widget\" + index] = rule;\n    });\n}\nfunction mergeNodes(nodes, text, schema, ruleIndex) {\n    return nodes.concat(createNodesWithWidget(text, schema, ruleIndex));\n}\n/**\n * create nodes with plain text and replace text matched to the widget rules with the widget node\n * For example, in case the text and widget rules as below\n *\n * text: $test plain text #test\n * widget rules: [{ rule: /$.+/ }, { rule: /#.+/ }]\n *\n * The creating node process is recursive and is as follows.\n *\n * in first widget rule(/$.+/)\n *  $test -> widget node\n *  plain text -> match with next widget rule\n *  #test -> match with next widget rule\n *\n * in second widget rule(/#.+/)\n *  plain text -> text node(no rule for matching)\n *  #test -> widget node\n */\nfunction createNodesWithWidget(text, schema, ruleIndex) {\n    if (ruleIndex === void 0) { ruleIndex = 0; }\n    var nodes = [];\n    var rule = (widgetRules[ruleIndex] || {}).rule;\n    var nextRuleIndex = ruleIndex + 1;\n    text = unwrapWidgetSyntax(text);\n    if (rule && rule.test(text)) {\n        var index = void 0;\n        while ((index = text.search(rule)) !== -1) {\n            var prev = text.substring(0, index);\n            // get widget node on first splitted text using next widget rule\n            if (prev) {\n                nodes = mergeNodes(nodes, prev, schema, nextRuleIndex);\n            }\n            // build widget node using current widget rule\n            text = text.substring(index);\n            var literal = text.match(rule)[0];\n            var info = \"widget\" + ruleIndex;\n            nodes.push(schema.nodes.widget.create({ info: info }, schema.text(createWidgetContent(info, literal))));\n            text = text.substring(literal.length);\n        }\n        // get widget node on last splitted text using next widget rule\n        if (text) {\n            nodes = mergeNodes(nodes, text, schema, nextRuleIndex);\n        }\n    }\n    else if (text) {\n        nodes =\n            ruleIndex < widgetRules.length - 1\n                ? mergeNodes(nodes, text, schema, nextRuleIndex)\n                : [schema.text(text)];\n    }\n    return nodes;\n}\nfunction getWidgetContent(widgetNode) {\n    var event;\n    var text = '';\n    var walker = widgetNode.walker();\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            if (node !== widgetNode && node.type !== 'text') {\n                text += getInlineMarkdownText(node);\n                // skip the children\n                walker.resumeAt(widgetNode, false);\n                walker.next();\n            }\n            else if (node.type === 'text') {\n                text += node.literal;\n            }\n        }\n    }\n    return text;\n}\n\nfunction getDefaultCommands() {\n    return {\n        deleteSelection: function () { return prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.deleteSelection; },\n        selectAll: function () { return prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.selectAll; },\n        undo: function () { return prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo; },\n        redo: function () { return prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.redo; },\n    };\n}\n\nfunction placeholder(options) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: function (state) {\n                var doc = state.doc;\n                if (options.text &&\n                    doc.childCount === 1 &&\n                    doc.firstChild.isTextblock &&\n                    doc.firstChild.content.size === 0) {\n                    var placeHolder = document.createElement('span');\n                    addClass_1(placeHolder, 'placeholder');\n                    if (options.className) {\n                        addClass_1(placeHolder, options.className);\n                    }\n                    placeHolder.textContent = options.text;\n                    return prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet.create(doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.widget(1, placeHolder)]);\n                }\n                return null;\n            },\n        },\n    });\n}\n\n/**\n * @fileoverview Check element has specific css class\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar inArray$1 = inArray_1;\nvar getClass = getClass_1;\n\n/**\n * Check element has specific css class\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {string} cssClass - css class\n * @returns {boolean}\n * @memberof module:domUtil\n */\nfunction hasClass(element, cssClass) {\n  var origin;\n\n  if (element.classList) {\n    return element.classList.contains(cssClass);\n  }\n\n  origin = getClass(element).split(/\\s+/);\n\n  return inArray$1(cssClass, origin) > -1;\n}\n\nvar hasClass_1 = hasClass;\n\n/**\n * @fileoverview Check element match selector\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar inArray = inArray_1;\nvar toArray = toArray_1;\n\nvar elProto = Element.prototype;\nvar matchSelector = elProto.matches ||\n    elProto.webkitMatchesSelector ||\n    elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector ||\n    function(selector) {\n      var doc = this.document || this.ownerDocument;\n\n      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;\n    };\n\n/**\n * Check element match selector\n * @param {HTMLElement} element - element to check\n * @param {string} selector - selector to check\n * @returns {boolean} is selector matched to element?\n * @memberof module:domUtil\n */\nfunction matches(element, selector) {\n  return matchSelector.call(element, selector);\n}\n\nvar matches_1 = matches;\n\nvar TAG_NAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTE_NAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTED_VALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLE_QUOTED_VALUE = \"'[^']*'\";\nvar DOUBLE_QUOTED_VALUE = '\"[^\"]*\"';\nvar ATTRIBUTE_VALUE = \"(?:\" + UNQUOTED_VALUE + \"|\" + SINGLE_QUOTED_VALUE + \"|\" + DOUBLE_QUOTED_VALUE + \")\";\nvar ATTRIBUTE_VALUE_SPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTE_VALUE + \")\";\nvar ATTRIBUTE$1 = \"\" + '(?:\\\\s+' + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + \"?)\";\nvar OPEN_TAG = \"<(\" + TAG_NAME + \")(\" + ATTRIBUTE$1 + \")*\\\\s*/?>\";\nvar CLOSE_TAG = \"</(\" + TAG_NAME + \")\\\\s*[>]\";\nvar HTML_TAG = \"(?:\" + OPEN_TAG + \"|\" + CLOSE_TAG + \")\";\nvar reHTMLTag = new RegExp(\"^\" + HTML_TAG, 'i');\nvar reBR = /<br\\s*\\/*>/i;\nvar reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar ALTERNATIVE_TAG_FOR_BR = '</p><p>';\n\nfunction isPositionInBox(style, offsetX, offsetY) {\n    var left = parseInt(style.left, 10);\n    var top = parseInt(style.top, 10);\n    var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);\n    var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);\n    return offsetX >= left && offsetX <= left + width && offsetY >= top && offsetY <= top + height;\n}\nvar CLS_PREFIX = 'toastui-editor-';\nfunction cls() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    var result = [];\n    for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {\n        var name_1 = names_1[_a];\n        var className = void 0;\n        if (Array.isArray(name_1)) {\n            className = name_1[0] ? name_1[1] : null;\n        }\n        else {\n            className = name_1;\n        }\n        if (className) {\n            result.push(\"\" + CLS_PREFIX + className);\n        }\n    }\n    return result.join(' ');\n}\nfunction clsWithMdPrefix() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    return names.map(function (className) { return CLS_PREFIX + \"md-\" + className; }).join(' ');\n}\nfunction isTextNode(node) {\n    return (node === null || node === void 0 ? void 0 : node.nodeType) === Node.TEXT_NODE;\n}\nfunction isElemNode(node) {\n    return node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction findNodes(element, selector) {\n    var nodeList = toArray_1(element.querySelectorAll(selector));\n    if (nodeList.length) {\n        return nodeList;\n    }\n    return [];\n}\nfunction appendNodes(node, nodesToAppend) {\n    nodesToAppend = isArray_1(nodesToAppend) ? toArray_1(nodesToAppend) : [nodesToAppend];\n    nodesToAppend.forEach(function (nodeToAppend) {\n        node.appendChild(nodeToAppend);\n    });\n}\nfunction insertBeforeNode(insertedNode, node) {\n    if (node.parentNode) {\n        node.parentNode.insertBefore(insertedNode, node);\n    }\n}\nfunction removeNode$1(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction unwrapNode(node) {\n    var result = [];\n    while (node.firstChild) {\n        result.push(node.firstChild);\n        if (node.parentNode) {\n            node.parentNode.insertBefore(node.firstChild, node);\n        }\n    }\n    removeNode$1(node);\n    return result;\n}\nfunction toggleClass(element, className, state) {\n    if (isUndefined_1(state)) {\n        state = !hasClass_1(element, className);\n    }\n    var toggleFn = state ? addClass_1 : removeClass_1;\n    toggleFn(element, className);\n}\nfunction createElementWith(contents, target) {\n    var container = document.createElement('div');\n    if (isString_1(contents)) {\n        container.innerHTML = contents;\n    }\n    else {\n        container.appendChild(contents);\n    }\n    var firstChild = container.firstChild;\n    if (target) {\n        target.appendChild(firstChild);\n    }\n    return firstChild;\n}\nfunction getOuterWidth(el) {\n    var computed = window.getComputedStyle(el);\n    return (['margin-left', 'margin-right'].reduce(function (acc, type) { return acc + parseInt(computed.getPropertyValue(type), 10); }, 0) + el.offsetWidth);\n}\nfunction closest(node, found) {\n    var condition;\n    if (isString_1(found)) {\n        condition = function (target) { return matches_1(target, found); };\n    }\n    else {\n        condition = function (target) { return target === found; };\n    }\n    while (node && node !== document) {\n        if (isElemNode(node) && condition(node)) {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction getTotalOffset(el, root) {\n    var offsetTop = 0;\n    var offsetLeft = 0;\n    while (el && el !== root) {\n        var top_1 = el.offsetTop, left = el.offsetLeft, offsetParent = el.offsetParent;\n        offsetTop += top_1;\n        offsetLeft += left;\n        if (offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.offsetParent;\n    }\n    return { offsetTop: offsetTop, offsetLeft: offsetLeft };\n}\nfunction setAttributes(attributes, element) {\n    Object.keys(attributes).forEach(function (attrName) {\n        if (isNil(attributes[attrName])) {\n            element.removeAttribute(attrName);\n        }\n        else {\n            element.setAttribute(attrName, attributes[attrName]);\n        }\n    });\n}\nfunction replaceBRWithEmptyBlock(html) {\n    // remove br in paragraph to compatible with markdown\n    var replacedHTML = html.replace(/<p><br\\s*\\/*><\\/p>/gi, '<p></p>');\n    var reHTMLTag = new RegExp(HTML_TAG, 'ig');\n    var htmlTagMatched = replacedHTML.match(reHTMLTag);\n    htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function (htmlTag, index) {\n        if (reBR.test(htmlTag)) {\n            var alternativeTag = ALTERNATIVE_TAG_FOR_BR;\n            if (index) {\n                var prevTag = htmlTagMatched[index - 1];\n                var openTagMatched = prevTag.match(OPEN_TAG);\n                if (openTagMatched && !/br/i.test(openTagMatched[1])) {\n                    var tagName = openTagMatched[1];\n                    alternativeTag = \"</\" + tagName + \"><\" + tagName + \">\";\n                }\n            }\n            replacedHTML = replacedHTML.replace(reBR, alternativeTag);\n        }\n    });\n    return replacedHTML;\n}\nfunction removeProseMirrorHackNodes(html) {\n    var reProseMirrorImage = /<img class=\"ProseMirror-separator\" alt=\"\">/g;\n    var reProseMirrorTrailingBreak = / class=\"ProseMirror-trailingBreak\"/g;\n    var resultHTML = html;\n    resultHTML = resultHTML.replace(reProseMirrorImage, '');\n    resultHTML = resultHTML.replace(reProseMirrorTrailingBreak, '');\n    return resultHTML;\n}\n\nvar pluginKey$1 = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('widget');\nvar MARGIN = 5;\nvar PopupWidget = /** @class */ (function () {\n    function PopupWidget(view, eventEmitter) {\n        var _this = this;\n        this.popup = null;\n        this.removeWidget = function () {\n            if (_this.popup) {\n                _this.rootEl.removeChild(_this.popup);\n                _this.popup = null;\n            }\n        };\n        this.rootEl = view.dom.parentElement;\n        this.eventEmitter = eventEmitter;\n        this.eventEmitter.listen('blur', this.removeWidget);\n        this.eventEmitter.listen('loadUI', function () {\n            _this.rootEl = closest(view.dom.parentElement, \".\" + cls('defaultUI'));\n        });\n        this.eventEmitter.listen('removePopupWidget', this.removeWidget);\n    }\n    PopupWidget.prototype.update = function (view) {\n        var widget = pluginKey$1.getState(view.state);\n        this.removeWidget();\n        if (widget) {\n            var node = widget.node, style = widget.style;\n            var _a = view.coordsAtPos(widget.pos), top_1 = _a.top, left = _a.left, bottom = _a.bottom;\n            var height = bottom - top_1;\n            var rect = this.rootEl.getBoundingClientRect();\n            var relTopPos = top_1 - rect.top;\n            css_1(node, { opacity: '0' });\n            this.rootEl.appendChild(node);\n            css_1(node, {\n                position: 'absolute',\n                left: left - rect.left + MARGIN + \"px\",\n                top: (style === 'bottom' ? relTopPos + height - MARGIN : relTopPos - height) + \"px\",\n                opacity: '1',\n            });\n            this.popup = node;\n            view.focus();\n        }\n    };\n    PopupWidget.prototype.destroy = function () {\n        this.eventEmitter.removeEventHandler('blur', this.removeWidget);\n    };\n    return PopupWidget;\n}());\nfunction addWidget(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey$1,\n        state: {\n            init: function () {\n                return null;\n            },\n            apply: function (tr) {\n                return tr.getMeta('widget');\n            },\n        },\n        view: function (editorView) {\n            return new PopupWidget(editorView, eventEmitter);\n        },\n    });\n}\n\nfunction addDefaultImageBlobHook(eventEmitter) {\n    eventEmitter.listen('addImageBlobHook', function (blob, callback) {\n        var reader = new FileReader();\n        reader.onload = function (_a) {\n            var target = _a.target;\n            return callback(target.result);\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nfunction emitImageBlobHook(eventEmitter, blob, type) {\n    var hook = function (imageUrl, altText) {\n        eventEmitter.emit('command', 'addImage', {\n            imageUrl: imageUrl,\n            altText: altText || blob.name || 'image',\n        });\n    };\n    eventEmitter.emit('addImageBlobHook', blob, hook, type);\n}\nfunction pasteImageOnly(items) {\n    var images = toArray_1(items).filter(function (_a) {\n        var type = _a.type;\n        return type.indexOf('image') !== -1;\n    });\n    if (images.length === 1) {\n        var item = images[0];\n        if (item) {\n            return item.getAsFile();\n        }\n    }\n    return null;\n}\n\nfunction dropImage(_a) {\n    var eventEmitter = _a.eventEmitter;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                drop: function (_, ev) {\n                    var _a;\n                    var items = (_a = ev.dataTransfer) === null || _a === void 0 ? void 0 : _a.files;\n                    if (items) {\n                        forEachArray_1(items, function (item) {\n                            if (item.type.indexOf('image') !== -1) {\n                                ev.preventDefault();\n                                ev.stopPropagation();\n                                emitImageBlobHook(eventEmitter, item, ev.type);\n                                return false;\n                            }\n                            return true;\n                        });\n                    }\n                    return true;\n                },\n            },\n        },\n    });\n}\n\nvar Node$2 = /** @class */ (function () {\n    function Node() {\n    }\n    Object.defineProperty(Node.prototype, \"type\", {\n        get: function () {\n            return 'node';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Node.prototype.setContext = function (context) {\n        this.context = context;\n    };\n    return Node;\n}());\n\nfunction widgetNodeView(pmNode) {\n    var dom = document.createElement('span');\n    var node = widgetToDOM(pmNode.attrs.info, pmNode.textContent);\n    dom.className = 'tui-widget';\n    dom.appendChild(node);\n    return { dom: dom };\n}\nfunction isWidgetNode(pmNode) {\n    return pmNode.type.name === 'widget';\n}\nvar Widget = /** @class */ (function (_super) {\n    __extends$1(Widget, _super);\n    function Widget() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Widget.prototype, \"name\", {\n        get: function () {\n            return 'widget';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    info: { default: null },\n                },\n                group: 'inline',\n                inline: true,\n                content: 'text*',\n                selectable: false,\n                atom: true,\n                toDOM: function () {\n                    return ['span', { class: 'tui-widget' }, 0];\n                },\n                parseDOM: [\n                    {\n                        tag: 'span.tui-widget',\n                        getAttrs: function (dom) {\n                            var text = dom.textContent;\n                            var _a = text.match(/\\$\\$(widget\\d+)/), info = _a[1];\n                            return { info: info };\n                        },\n                    },\n                ],\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Widget;\n}(Node$2));\n\nvar EditorBase = /** @class */ (function () {\n    function EditorBase(eventEmitter) {\n        this.timer = null;\n        this.el = document.createElement('div');\n        this.el.className = 'toastui-editor';\n        this.eventEmitter = eventEmitter;\n        this.placeholder = { text: '' };\n    }\n    EditorBase.prototype.createState = function () {\n        return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n            schema: this.schema,\n            plugins: this.createPlugins(),\n        });\n    };\n    EditorBase.prototype.initEvent = function () {\n        var _a = this, eventEmitter = _a.eventEmitter, view = _a.view, editorType = _a.editorType;\n        view.dom.addEventListener('focus', function () { return eventEmitter.emit('focus', editorType); });\n        view.dom.addEventListener('blur', function () { return eventEmitter.emit('blur', editorType); });\n    };\n    EditorBase.prototype.emitChangeEvent = function (tr) {\n        this.eventEmitter.emit('caretChange', this.editorType);\n        if (tr.docChanged) {\n            this.eventEmitter.emit('change', this.editorType);\n        }\n    };\n    Object.defineProperty(EditorBase.prototype, \"defaultPlugins\", {\n        get: function () {\n            var rules = this.createInputRules();\n            var plugins = __spreadArray$1(__spreadArray$1([], this.keymaps), [\n                (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(__assign$1({ 'Shift-Enter': prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap.Enter }, prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap)),\n                (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.history)(),\n                placeholder(this.placeholder),\n                addWidget(this.eventEmitter),\n                dropImage(this.context),\n            ]);\n            return rules ? plugins.concat(rules) : plugins;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EditorBase.prototype.createInputRules = function () {\n        var widgetRules = getWidgetRules();\n        var rules = widgetRules.map(function (_a) {\n            var rule = _a.rule;\n            return new prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.InputRule(rule, function (state, match, start, end) {\n                var schema = state.schema, tr = state.tr, doc = state.doc;\n                var allMatched = match.input.match(new RegExp(rule, 'g'));\n                var pos = doc.resolve(start);\n                var parent = pos.parent;\n                var count = 0;\n                if (isWidgetNode(parent)) {\n                    parent = pos.node(pos.depth - 1);\n                }\n                parent.forEach(function (child) { return isWidgetNode(child) && (count += 1); });\n                // replace the content only if the count of matched rules in whole text is greater than current widget node count\n                if (allMatched.length > count) {\n                    var content = last$1(allMatched);\n                    var nodes = createNodesWithWidget(content, schema);\n                    // adjust start position based on widget content\n                    return tr.replaceWith(end - content.length + 1, end, nodes);\n                }\n                return null;\n            });\n        });\n        return rules.length ? (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.inputRules)({ rules: rules }) : null;\n    };\n    EditorBase.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    EditorBase.prototype.createSchema = function () {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Schema({\n            nodes: this.specs.nodes,\n            marks: this.specs.marks,\n        });\n    };\n    EditorBase.prototype.createKeymaps = function (useCommandShortcut) {\n        var _a = getDefaultCommands(), undo = _a.undo, redo = _a.redo;\n        var allKeymaps = this.specs.keymaps(useCommandShortcut);\n        var historyKeymap = {\n            'Mod-z': undo(),\n            'Shift-Mod-z': redo(),\n        };\n        return useCommandShortcut ? allKeymaps.concat((0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(historyKeymap)) : allKeymaps;\n    };\n    EditorBase.prototype.createCommands = function () {\n        return this.specs.commands(this.view);\n    };\n    EditorBase.prototype.createPluginProps = function () {\n        var _this = this;\n        return this.extraPlugins.map(function (plugin) { return plugin(_this.eventEmitter); });\n    };\n    EditorBase.prototype.focus = function () {\n        var _this = this;\n        this.clearTimer();\n        // prevent the error for IE11\n        this.timer = setTimeout(function () {\n            _this.view.focus();\n            _this.view.dispatch(_this.view.state.tr.scrollIntoView());\n        });\n    };\n    EditorBase.prototype.blur = function () {\n        this.view.dom.blur();\n    };\n    EditorBase.prototype.destroy = function () {\n        var _this = this;\n        this.clearTimer();\n        this.view.destroy();\n        Object.keys(this).forEach(function (prop) {\n            delete _this[prop];\n        });\n    };\n    EditorBase.prototype.moveCursorToStart = function (focus) {\n        var tr = this.view.state.tr;\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, 1)).scrollIntoView());\n        if (focus) {\n            this.focus();\n        }\n    };\n    EditorBase.prototype.moveCursorToEnd = function (focus) {\n        var tr = this.view.state.tr;\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, tr.doc.content.size - 1)).scrollIntoView());\n        if (focus) {\n            this.focus();\n        }\n    };\n    EditorBase.prototype.setScrollTop = function (top) {\n        this.view.dom.scrollTop = top;\n    };\n    EditorBase.prototype.getScrollTop = function () {\n        return this.view.dom.scrollTop;\n    };\n    EditorBase.prototype.setPlaceholder = function (text) {\n        this.placeholder.text = text;\n        this.view.dispatch(this.view.state.tr.scrollIntoView());\n    };\n    EditorBase.prototype.setHeight = function (height) {\n        css_1(this.el, { height: height + \"px\" });\n    };\n    EditorBase.prototype.setMinHeight = function (minHeight) {\n        css_1(this.el, { minHeight: minHeight + \"px\" });\n    };\n    EditorBase.prototype.getElement = function () {\n        return this.el;\n    };\n    return EditorBase;\n}());\n\n/**\n * @fileoverview Check whether the given variable is a function or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a function or not.\n * If the given variable is a function, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is function?\n * @memberof module:type\n */\nfunction isFunction(obj) {\n  return obj instanceof Function;\n}\n\nvar isFunction_1 = isFunction;\n\nvar defaultCommandShortcuts = [\n    'Enter',\n    'Shift-Enter',\n    'Mod-Enter',\n    'Tab',\n    'Shift-Tab',\n    'Delete',\n    'Backspace',\n    'Mod-Delete',\n    'Mod-Backspace',\n    'ArrowUp',\n    'ArrowDown',\n    'ArrowLeft',\n    'ArrowRight',\n    'Mod-d',\n    'Mod-D',\n    'Alt-ArrowUp',\n    'Alt-ArrowDown',\n];\nfunction execCommand(view, command, payload) {\n    view.focus();\n    return command(payload)(view.state, view.dispatch, view);\n}\nvar SpecManager = /** @class */ (function () {\n    function SpecManager(specs) {\n        this.specs = specs;\n    }\n    Object.defineProperty(SpecManager.prototype, \"nodes\", {\n        get: function () {\n            return this.specs\n                .filter(function (spec) { return spec.type === 'node'; })\n                .reduce(function (nodes, _a) {\n                var _b;\n                var name = _a.name, schema = _a.schema;\n                return __assign$1(__assign$1({}, nodes), (_b = {}, _b[name] = schema, _b));\n            }, {});\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpecManager.prototype, \"marks\", {\n        get: function () {\n            return this.specs\n                .filter(function (spec) { return spec.type === 'mark'; })\n                .reduce(function (marks, _a) {\n                var _b;\n                var name = _a.name, schema = _a.schema;\n                return __assign$1(__assign$1({}, marks), (_b = {}, _b[name] = schema, _b));\n            }, {});\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SpecManager.prototype.commands = function (view, addedCommands) {\n        var specCommands = this.specs\n            .filter(function (_a) {\n            var commands = _a.commands;\n            return commands;\n        })\n            .reduce(function (allCommands, spec) {\n            var commands = {};\n            var specCommand = spec.commands();\n            if (isFunction_1(specCommand)) {\n                commands[spec.name] = function (payload) { return execCommand(view, specCommand, payload); };\n            }\n            else {\n                Object.keys(specCommand).forEach(function (name) {\n                    commands[name] = function (payload) { return execCommand(view, specCommand[name], payload); };\n                });\n            }\n            return __assign$1(__assign$1({}, allCommands), commands);\n        }, {});\n        var defaultCommands = getDefaultCommands();\n        Object.keys(defaultCommands).forEach(function (name) {\n            specCommands[name] = function (payload) { return execCommand(view, defaultCommands[name], payload); };\n        });\n        if (addedCommands) {\n            Object.keys(addedCommands).forEach(function (name) {\n                specCommands[name] = function (payload) { return execCommand(view, addedCommands[name], payload); };\n            });\n        }\n        return specCommands;\n    };\n    SpecManager.prototype.keymaps = function (useCommandShortcut) {\n        var specKeymaps = this.specs.filter(function (spec) { return spec.keymaps; }).map(function (spec) { return spec.keymaps(); });\n        return specKeymaps.map(function (keys) {\n            if (!useCommandShortcut) {\n                Object.keys(keys).forEach(function (key) {\n                    if (!includes(defaultCommandShortcuts, key)) {\n                        delete keys[key];\n                    }\n                });\n            }\n            return (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(keys);\n        });\n    };\n    SpecManager.prototype.setContext = function (context) {\n        this.specs.forEach(function (spec) {\n            spec.setContext(context);\n        });\n    };\n    return SpecManager;\n}());\n\nfunction resolveSelectionPos(selection) {\n    var from = selection.from, to = selection.to;\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection) {\n        return [from + 1, to - 1];\n    }\n    return [from, to];\n}\nfunction getMdLine(resolvedPos) {\n    return resolvedPos.index(0) + 1;\n}\nfunction getWidgetNodePos(node, chPos, direction) {\n    if (direction === void 0) { direction = 1; }\n    var additionalPos = 0;\n    node.forEach(function (child, pos) {\n        // add or subtract widget node tag\n        if (isWidgetNode(child) && pos + 2 < chPos) {\n            additionalPos += 2 * direction;\n        }\n    });\n    return additionalPos;\n}\nfunction getEditorToMdPos(doc, from, to) {\n    if (to === void 0) { to = from; }\n    var collapsed = from === to;\n    var startResolvedPos = doc.resolve(from);\n    var startLine = getMdLine(startResolvedPos);\n    var endLine = startLine;\n    var startOffset = startResolvedPos.start(1);\n    var endOffset = startOffset;\n    if (!collapsed) {\n        // prevent the end offset from pointing to the root document position\n        var endResolvedPos = doc.resolve(to === doc.content.size ? to - 1 : to);\n        endOffset = endResolvedPos.start(1);\n        endLine = getMdLine(endResolvedPos);\n        // To resolve the end offset excluding document tag size\n        if (endResolvedPos.pos === doc.content.size) {\n            to = doc.content.size - 2;\n        }\n    }\n    var startCh = Math.max(from - startOffset + 1, 1);\n    var endCh = Math.max(to - endOffset + 1, 1);\n    return [\n        [startLine, startCh + getWidgetNodePos(doc.child(startLine - 1), startCh, -1)],\n        [endLine, endCh + getWidgetNodePos(doc.child(endLine - 1), endCh, -1)],\n    ];\n}\nfunction getStartPosListPerLine(doc, endIndex) {\n    var startPosListPerLine = [];\n    for (var i = 0, pos = 0; i < endIndex; i += 1) {\n        var child = doc.child(i);\n        startPosListPerLine[i] = pos;\n        pos += child.nodeSize;\n    }\n    return startPosListPerLine;\n}\nfunction getMdToEditorPos(doc, startPos, endPos) {\n    var startPosListPerLine = getStartPosListPerLine(doc, endPos[0]);\n    var startIndex = startPos[0] - 1;\n    var endIndex = endPos[0] - 1;\n    var startNode = doc.child(startIndex);\n    var endNode = doc.child(endIndex);\n    // calculate the position corresponding to the line\n    var from = startPosListPerLine[startIndex];\n    var to = startPosListPerLine[endIndex];\n    // calculate the position corresponding to the character offset of the line\n    from += startPos[1] + getWidgetNodePos(startNode, startPos[1] - 1);\n    to += endPos[1] + getWidgetNodePos(endNode, endPos[1] - 1);\n    return [from, Math.min(to, doc.content.size)];\n}\nfunction getRangeInfo(selection) {\n    var $from = selection.$from, $to = selection.$to;\n    var from = selection.from, to = selection.to;\n    var doc = $from.doc;\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection) {\n        $from = doc.resolve(from + 1);\n        $to = doc.resolve(to - 1);\n    }\n    if ($from.depth === 0) {\n        $from = doc.resolve(from - 1);\n        $to = $from;\n    }\n    return {\n        startFromOffset: $from.start(1),\n        endFromOffset: $to.start(1),\n        startToOffset: $from.end(1),\n        endToOffset: $to.end(1),\n        startIndex: $from.index(0),\n        endIndex: $to.index(0),\n        from: $from.pos,\n        to: $to.pos,\n    };\n}\nfunction getNodeContentOffsetRange(doc, targetIndex) {\n    var startOffset = 1;\n    var endOffset = 1;\n    for (var i = 0, offset = 0; i < doc.childCount; i += 1) {\n        var nodeSize = doc.child(i).nodeSize;\n        // calculate content start, end offset(not node offset)\n        startOffset = offset + 1;\n        endOffset = offset + nodeSize - 1;\n        if (i === targetIndex) {\n            break;\n        }\n        offset += nodeSize;\n    }\n    return { startOffset: startOffset, endOffset: endOffset };\n}\n\nvar HEADING = 'heading';\nvar BLOCK_QUOTE = 'blockQuote';\nvar LIST_ITEM = 'listItem';\nvar TABLE = 'table';\nvar TABLE_CELL = 'tableCell';\nvar CODE_BLOCK = 'codeBlock';\nvar THEMATIC_BREAK = 'thematicBreak';\nvar LINK = 'link';\nvar CODE = 'code';\nvar META = 'meta';\nvar DELIM = 'delimiter';\nvar TASK_DELIM = 'taskDelimiter';\nvar TEXT = 'markedText';\nvar HTML = 'html';\nvar CUSTOM_BLOCK = 'customBlock';\nvar delimSize = {\n    strong: 2,\n    emph: 1,\n    strike: 2,\n};\nfunction markInfo(start, end, type, attrs) {\n    return { start: start, end: end, spec: { type: type, attrs: attrs } };\n}\nfunction heading$1(_a, start, end) {\n    var level = _a.level, headingType = _a.headingType;\n    var marks = [markInfo(start, end, HEADING, { level: level })];\n    if (headingType === 'atx') {\n        marks.push(markInfo(start, addOffsetPos(start, level), DELIM));\n    }\n    else {\n        marks.push(markInfo(setOffsetPos(end, 0), end, HEADING, { seText: true }));\n    }\n    return marks;\n}\nfunction emphasisAndStrikethrough(_a, start, end) {\n    var type = _a.type;\n    var startDelimPos = addOffsetPos(start, delimSize[type]);\n    var endDelimPos = addOffsetPos(end, -delimSize[type]);\n    return [\n        markInfo(startDelimPos, endDelimPos, type),\n        markInfo(start, startDelimPos, DELIM),\n        markInfo(endDelimPos, end, DELIM),\n    ];\n}\nfunction markLink(start, end, linkTextStart, lastChildCh) {\n    return [\n        markInfo(start, end, LINK),\n        markInfo(setOffsetPos(start, linkTextStart[1] + 1), setOffsetPos(end, lastChildCh), LINK, {\n            desc: true,\n        }),\n        markInfo(setOffsetPos(end, lastChildCh + 2), addOffsetPos(end, -1), LINK, { url: true }),\n    ];\n}\nfunction image$1(_a, start, end) {\n    var lastChild = _a.lastChild;\n    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 3; // 3: length of '![]'\n    var linkTextEnd = addOffsetPos(start, 1);\n    return __spreadArray$1([markInfo(start, linkTextEnd, META)], markLink(start, end, linkTextEnd, lastChildCh));\n}\nfunction link(_a, start, end) {\n    var lastChild = _a.lastChild, extendedAutolink = _a.extendedAutolink;\n    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 2; // 2: length of '[]'\n    return extendedAutolink\n        ? [markInfo(start, end, LINK, { desc: true })]\n        : markLink(start, end, start, lastChildCh);\n}\nfunction code(_a, start, end) {\n    var tickCount = _a.tickCount;\n    var openDelimEnd = addOffsetPos(start, tickCount);\n    var closeDelimStart = addOffsetPos(end, -tickCount);\n    return [\n        markInfo(start, end, CODE),\n        markInfo(start, openDelimEnd, CODE, { start: true }),\n        markInfo(openDelimEnd, closeDelimStart, CODE, { marked: true }),\n        markInfo(closeDelimStart, end, CODE, { end: true }),\n    ];\n}\nfunction lineBackground(parent, start, end, prefix) {\n    var defaultBackground = {\n        start: start,\n        end: end,\n        spec: {\n            attrs: { className: prefix + \"-line-background\", codeStart: start[0], codeEnd: end[0] },\n        },\n        lineBackground: true,\n    };\n    return parent.type !== 'item' && parent.type !== 'blockQuote'\n        ? [\n            __assign$1(__assign$1({}, defaultBackground), { end: start, spec: { attrs: { className: prefix + \"-line-background start\" } } }),\n            __assign$1(__assign$1({}, defaultBackground), { start: [Math.min(start[0] + 1, end[0]), start[1]] }),\n        ]\n        : null;\n}\nfunction codeBlock$1(node, start, end, endLine) {\n    var fenceOffset = node.fenceOffset, fenceLength = node.fenceLength, fenceChar = node.fenceChar, info = node.info, infoPadding = node.infoPadding, parent = node.parent;\n    var fenceEnd = fenceOffset + fenceLength;\n    var marks = [markInfo(setOffsetPos(start, 1), end, CODE_BLOCK)];\n    if (fenceChar) {\n        marks.push(markInfo(start, addOffsetPos(start, fenceEnd), DELIM));\n    }\n    if (info) {\n        marks.push(markInfo(addOffsetPos(start, fenceLength), addOffsetPos(start, fenceLength + infoPadding + info.length), META));\n    }\n    var codeBlockEnd = \"^(\\\\s{0,4})(\" + fenceChar + \"{\" + fenceLength + \",})\";\n    var reCodeBlockEnd = new RegExp(codeBlockEnd);\n    if (reCodeBlockEnd.test(endLine)) {\n        marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));\n    }\n    var lineBackgroundMarkInfo = lineBackground(parent, start, end, 'code-block');\n    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;\n}\nfunction customBlock$2(node, start, end) {\n    var _a = node, offset = _a.offset, syntaxLength = _a.syntaxLength, info = _a.info, parent = _a.parent;\n    var syntaxEnd = offset + syntaxLength;\n    var marks = [markInfo(setOffsetPos(start, 1), end, CUSTOM_BLOCK)];\n    marks.push(markInfo(start, addOffsetPos(start, syntaxEnd), DELIM));\n    if (info) {\n        marks.push(markInfo(addOffsetPos(start, syntaxEnd), addOffsetPos(start, syntaxLength + info.length), META));\n    }\n    marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));\n    var lineBackgroundMarkInfo = lineBackground(parent, start, end, 'custom-block');\n    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;\n}\nfunction markListItemChildren(node, markType) {\n    var marks = [];\n    while (node) {\n        var type = node.type;\n        if (type === 'paragraph' || type === 'codeBlock') {\n            marks.push(markInfo([getMdStartLine(node), getMdStartCh(node) - 1], [getMdEndLine(node), getMdEndCh(node) + 1], markType));\n        }\n        node = node.next;\n    }\n    return marks;\n}\nfunction markParagraphInBlockQuote(node) {\n    var marks = [];\n    while (node) {\n        marks.push(markInfo([getMdStartLine(node), getMdStartCh(node)], [getMdEndLine(node), getMdEndCh(node) + 1], TEXT));\n        node = node.next;\n    }\n    return marks;\n}\nfunction blockQuote$2(node, start, end) {\n    var marks = node.parent && node.parent.type !== 'blockQuote' ? [markInfo(start, end, BLOCK_QUOTE)] : [];\n    if (node.firstChild) {\n        var childMarks = [];\n        if (node.firstChild.type === 'paragraph') {\n            childMarks = markParagraphInBlockQuote(node.firstChild.firstChild);\n        }\n        else if (node.firstChild.type === 'list') {\n            childMarks = markListItemChildren(node.firstChild, TEXT);\n        }\n        marks = __spreadArray$1(__spreadArray$1([], marks), childMarks);\n    }\n    return marks;\n}\nfunction getSpecOfListItemStyle(node) {\n    var depth = 0;\n    while (node.parent.parent && node.parent.parent.type === 'item') {\n        node = node.parent.parent;\n        depth += 1;\n    }\n    var attrs = [{ odd: true }, { even: true }][depth % 2];\n    return [LIST_ITEM, __assign$1(__assign$1({}, attrs), { listStyle: true })];\n}\nfunction item$1(node, start) {\n    var _a = node.listData, padding = _a.padding, task = _a.task;\n    var spec = getSpecOfListItemStyle(node);\n    var marks = [markInfo.apply(void 0, __spreadArray$1([start, addOffsetPos(start, padding)], spec))];\n    if (task) {\n        marks.push(markInfo(addOffsetPos(start, padding), addOffsetPos(start, padding + 3), TASK_DELIM));\n        marks.push(markInfo(addOffsetPos(start, padding + 1), addOffsetPos(start, padding + 2), META));\n    }\n    return marks.concat(markListItemChildren(node.firstChild, TEXT));\n}\nvar markNodeFuncMap = {\n    heading: heading$1,\n    strong: emphasisAndStrikethrough,\n    emph: emphasisAndStrikethrough,\n    strike: emphasisAndStrikethrough,\n    link: link,\n    image: image$1,\n    code: code,\n    codeBlock: codeBlock$1,\n    blockQuote: blockQuote$2,\n    item: item$1,\n    customBlock: customBlock$2,\n};\nvar simpleMarkClassNameMap = {\n    thematicBreak: THEMATIC_BREAK,\n    table: TABLE,\n    tableCell: TABLE_CELL,\n    htmlInline: HTML,\n};\nfunction getMarkInfo(node, start, end, endLine) {\n    var type = node.type;\n    if (isFunction_1(markNodeFuncMap[type])) {\n        // @ts-ignore\n        return markNodeFuncMap[type](node, start, end, endLine);\n    }\n    if (simpleMarkClassNameMap[type]) {\n        return [markInfo(start, end, simpleMarkClassNameMap[type])];\n    }\n    return null;\n}\n\nvar removingBackgroundIndexMap = {};\nfunction syntaxHighlight(_a) {\n    var schema = _a.schema, toastMark = _a.toastMark;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        appendTransaction: function (transactions, _, newState) {\n            var tr = transactions[0];\n            var newTr = newState.tr;\n            if (tr.docChanged) {\n                var markInfo_1 = [];\n                var editResult = tr.getMeta('editResult');\n                editResult.forEach(function (result) {\n                    var nodes = result.nodes, removedNodeRange = result.removedNodeRange;\n                    if (nodes.length) {\n                        markInfo_1 = markInfo_1.concat(getMarkForRemoving(newTr, nodes));\n                        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                            var parent_1 = nodes_1[_i];\n                            var walker = parent_1.walker();\n                            var event_1 = walker.next();\n                            while (event_1) {\n                                var node = event_1.node, entering = event_1.entering;\n                                if (entering) {\n                                    markInfo_1 = markInfo_1.concat(getMarkForAdding(node, toastMark));\n                                }\n                                event_1 = walker.next();\n                            }\n                        }\n                    }\n                    else if (removedNodeRange) {\n                        var maxIndex = newTr.doc.childCount - 1;\n                        var _a = removedNodeRange.line, startLine = _a[0], endLine = _a[1];\n                        var startIndex = Math.min(startLine, maxIndex);\n                        var endIndex = Math.min(endLine, maxIndex);\n                        // cache the index to remove code block, custom block background when there are no adding nodes\n                        for (var i = startIndex; i <= endIndex; i += 1) {\n                            removingBackgroundIndexMap[i] = true;\n                        }\n                    }\n                });\n                appendMarkTr(newTr, schema, markInfo_1);\n            }\n            return newTr.setMeta('widget', tr.getMeta('widget'));\n        },\n    });\n}\nfunction isDifferentBlock(doc, index, attrs) {\n    return Object.keys(attrs).some(function (name) { return attrs[name] !== doc.child(index).attrs[name]; });\n}\nfunction addLineBackground(tr, doc, paragraph, blockPosInfo, attrs) {\n    if (attrs === void 0) { attrs = {}; }\n    var startIndex = blockPosInfo.startIndex, endIndex = blockPosInfo.endIndex, from = blockPosInfo.from, to = blockPosInfo.to;\n    var shouldChangeBlockType = false;\n    for (var i = startIndex; i <= endIndex; i += 1) {\n        // prevent to remove background of the node that need to have background\n        delete removingBackgroundIndexMap[i];\n        shouldChangeBlockType = isDifferentBlock(doc, i, attrs);\n    }\n    if (shouldChangeBlockType) {\n        tr.setBlockType(from, to, paragraph, attrs);\n    }\n}\nfunction appendMarkTr(tr, schema, marks) {\n    var doc = tr.doc;\n    var paragraph = schema.nodes.paragraph;\n    // get start position per line for lazy calculation\n    var startPosListPerLine = getStartPosListPerLine(doc, doc.childCount);\n    marks.forEach(function (_a) {\n        var start = _a.start, end = _a.end, spec = _a.spec, lineBackground = _a.lineBackground;\n        var startIndex = Math.min(start[0], doc.childCount) - 1;\n        var endIndex = Math.min(end[0], doc.childCount) - 1;\n        var startNode = doc.child(startIndex);\n        var endNode = doc.child(endIndex);\n        // calculate the position corresponding to the line\n        var from = startPosListPerLine[startIndex];\n        var to = startPosListPerLine[endIndex];\n        // calculate the position corresponding to the character offset of the line\n        from += start[1] + getWidgetNodePos(startNode, start[1] - 1);\n        to += end[1] + getWidgetNodePos(endNode, end[1] - 1);\n        if (spec) {\n            if (lineBackground) {\n                var posInfo = { from: from, to: to, startIndex: startIndex, endIndex: endIndex };\n                addLineBackground(tr, doc, paragraph, posInfo, spec.attrs);\n            }\n            else {\n                tr.addMark(from, to, schema.mark(spec.type, spec.attrs));\n            }\n        }\n        else {\n            tr.removeMark(from, to);\n        }\n    });\n    removeBlockBackground(tr, startPosListPerLine, paragraph);\n}\nfunction removeBlockBackground(tr, startPosListPerLine, paragraph) {\n    Object.keys(removingBackgroundIndexMap).forEach(function (index) {\n        var startIndex = Number(index);\n        // get the end position of the current line with the next node start position.\n        var endIndex = Math.min(Number(index) + 1, tr.doc.childCount - 1);\n        var from = startPosListPerLine[startIndex];\n        // subtract '1' for getting end position of the line\n        var to = startPosListPerLine[endIndex] - 1;\n        if (startIndex === endIndex) {\n            to += 2;\n        }\n        tr.setBlockType(from, to, paragraph);\n    });\n}\nfunction cacheIndexToRemoveBackground(doc, start, end) {\n    var skipLines = [];\n    removingBackgroundIndexMap = {};\n    for (var i = start[0] - 1; i < end[0]; i += 1) {\n        var node = doc.child(i);\n        var codeEnd = node.attrs.codeEnd;\n        var codeStart = node.attrs.codeStart;\n        if (codeStart && codeEnd && !includes(skipLines, codeStart)) {\n            skipLines.push(codeStart);\n            codeEnd = Math.min(codeEnd, doc.childCount);\n            // should subtract '1' to markdown line position\n            // because markdown parser has '1'(not zero) as the start number\n            var startIndex = codeStart - 1;\n            var endIndex = end[0];\n            for (var index = startIndex; index < endIndex; index += 1) {\n                removingBackgroundIndexMap[index] = true;\n            }\n        }\n    }\n}\nfunction getMarkForRemoving(_a, nodes) {\n    var doc = _a.doc;\n    var start = nodes[0].sourcepos[0];\n    var _b = last$1(nodes).sourcepos, end = _b[1];\n    var startPos = [start[0], start[1]];\n    var endPos = [end[0], end[1] + 1];\n    var marks = [];\n    cacheIndexToRemoveBackground(doc, start, end);\n    marks.push({ start: startPos, end: endPos });\n    return marks;\n}\nfunction getMarkForAdding(node, toastMark) {\n    var lineTexts = toastMark.getLineTexts();\n    var startPos = [getMdStartLine(node), getMdStartCh(node)];\n    var endPos = [getMdEndLine(node), getMdEndCh(node) + 1];\n    var markInfo = getMarkInfo(node, startPos, endPos, lineTexts[endPos[0] - 1]);\n    return markInfo !== null && markInfo !== void 0 ? markInfo : [];\n}\n\nvar defaultToolbarStateKeys = [\n    'taskList',\n    'orderedList',\n    'bulletList',\n    'table',\n    'strong',\n    'emph',\n    'strike',\n    'heading',\n    'thematicBreak',\n    'blockQuote',\n    'code',\n    'codeBlock',\n    'indent',\n    'outdent',\n];\nfunction getToolbarStateType$1(mdNode) {\n    var type = mdNode.type;\n    if (isListNode$1(mdNode)) {\n        if (mdNode.listData.task) {\n            return 'taskList';\n        }\n        return mdNode.listData.type === 'ordered' ? 'orderedList' : 'bulletList';\n    }\n    if (type.indexOf('table') !== -1) {\n        return 'table';\n    }\n    if (!includes(defaultToolbarStateKeys, type)) {\n        return null;\n    }\n    return type;\n}\nfunction getToolbarState$1(targetNode) {\n    var toolbarState = {\n        indent: { active: false, disabled: true },\n        outdent: { active: false, disabled: true },\n    };\n    var listEnabled = true;\n    traverseParentNodes(targetNode, function (mdNode) {\n        var type = getToolbarStateType$1(mdNode);\n        if (!type) {\n            return;\n        }\n        if (type === 'bulletList' || type === 'orderedList') {\n            // to apply the nearlist list state in the nested list\n            if (listEnabled) {\n                toolbarState[type] = { active: true };\n                toolbarState.indent.disabled = false;\n                toolbarState.outdent.disabled = false;\n                listEnabled = false;\n            }\n        }\n        else {\n            toolbarState[type] = { active: true };\n        }\n    });\n    return toolbarState;\n}\nfunction previewHighlight(_a) {\n    var toastMark = _a.toastMark, eventEmitter = _a.eventEmitter;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view: function () {\n            return {\n                update: function (view, prevState) {\n                    var state = view.state;\n                    var doc = state.doc, selection = state.selection;\n                    if (prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection)) {\n                        return;\n                    }\n                    var from = selection.from;\n                    var startChOffset = state.doc.resolve(from).start();\n                    var line = state.doc.content.findIndex(from).index + 1;\n                    var ch = from - startChOffset;\n                    if (from === startChOffset) {\n                        ch += 1;\n                    }\n                    var cursorPos = [line, ch];\n                    var mdNode = toastMark.findNodeAtPosition(cursorPos);\n                    var toolbarState = getToolbarState$1(mdNode);\n                    eventEmitter.emit('changeToolbarState', {\n                        cursorPos: cursorPos,\n                        mdNode: mdNode,\n                        toolbarState: toolbarState,\n                    });\n                    eventEmitter.emit('setFocusedNode', mdNode);\n                },\n            };\n        },\n    });\n}\n\nvar Doc$1 = /** @class */ (function (_super) {\n    __extends$1(Doc, _super);\n    function Doc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Doc.prototype, \"name\", {\n        get: function () {\n            return 'doc';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Doc.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'block+',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Doc;\n}(Node$2));\n\nvar Mark = /** @class */ (function () {\n    function Mark() {\n    }\n    Object.defineProperty(Mark.prototype, \"type\", {\n        get: function () {\n            return 'mark';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Mark.prototype.setContext = function (context) {\n        this.context = context;\n    };\n    return Mark;\n}());\n\nfunction getTextByMdLine(doc, mdLine) {\n    return getTextContent(doc, mdLine - 1);\n}\nfunction getTextContent(doc, index) {\n    return doc.child(index).textContent;\n}\n\nvar reBlockQuote = /^\\s*> ?/;\nvar BlockQuote$1 = /** @class */ (function (_super) {\n    __extends$1(BlockQuote, _super);\n    function BlockQuote() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BlockQuote.prototype, \"name\", {\n        get: function () {\n            return 'blockQuote';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BlockQuote.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('block-quote') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BlockQuote.prototype.createBlockQuoteText = function (text, isBlockQuote) {\n        return isBlockQuote ? text.replace(reBlockQuote, '').trim() : \"> \" + text.trim();\n    };\n    BlockQuote.prototype.extendBlockQuote = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            var isBlockQuote = reBlockQuote.test(textContent);\n            if (isBlockQuote && to > endFromOffset && selection.empty) {\n                var isEmpty = !textContent.replace(reBlockQuote, '').trim();\n                if (isEmpty) {\n                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n                }\n                else {\n                    var slicedText = textContent.slice(to - endFromOffset).trim();\n                    var node = createTextNode$1(schema, _this.createBlockQuoteText(slicedText));\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    BlockQuote.prototype.commands = function () {\n        var _this = this;\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, doc = state.doc;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            var isBlockQuote = reBlockQuote.test(getTextContent(doc, startIndex));\n            var tr = replaceTextNode({\n                state: state,\n                startIndex: startIndex,\n                endIndex: endIndex,\n                from: startFromOffset,\n                createText: function (textContent) { return _this.createBlockQuoteText(textContent, isBlockQuote); },\n            });\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    BlockQuote.prototype.keymaps = function () {\n        var blockQuoteCommand = this.commands()();\n        return {\n            'alt-q': blockQuoteCommand,\n            'alt-Q': blockQuoteCommand,\n            Enter: this.extendBlockQuote(),\n        };\n    };\n    return BlockQuote;\n}(Mark));\n\nvar reList = /(^\\s*)([-*+] |[\\d]+\\. )/;\nvar reOrderedList = /(^\\s*)([\\d])+\\.( \\[[ xX]])? /;\nvar reOrderedListGroup = /^(\\s*)((\\d+)([.)]\\s(?:\\[(?:x|\\s)\\]\\s)?))(.*)/;\nvar reCanBeTaskList = /(^\\s*)([-*+]|[\\d]+\\.)( \\[[ xX]])? /;\nvar reBulletListGroup = /^(\\s*)([-*+]+(\\s(?:\\[(?:x|\\s)\\]\\s)?))(.*)/;\nvar reTaskList = /(^\\s*)([-*+] |[\\d]+\\. )(\\[[ xX]] )/;\nvar reBulletTaskList = /(^\\s*)([-*+])( \\[[ xX]]) /;\nfunction getListType(text) {\n    return reOrderedList.test(text) ? 'ordered' : 'bullet';\n}\nfunction getListDepth(mdNode) {\n    var depth = 0;\n    while (mdNode && mdNode.type !== 'document') {\n        if (mdNode.type === 'list') {\n            depth += 1;\n        }\n        mdNode = mdNode.parent;\n    }\n    return depth;\n}\nfunction findSameDepthList(toastMark, currentLine, depth, backward) {\n    var lineTexts = toastMark.getLineTexts();\n    var lineLen = lineTexts.length;\n    var result = [];\n    var line = currentLine;\n    while (backward ? line < lineLen : line > 1) {\n        line = backward ? line + 1 : line - 1;\n        var mdNode = toastMark.findFirstNodeAtLine(line);\n        var currentListDepth = getListDepth(mdNode);\n        if (currentListDepth === depth) {\n            result.push({ line: line, depth: depth, mdNode: mdNode });\n        }\n        else if (currentListDepth < depth) {\n            break;\n        }\n    }\n    return result;\n}\nfunction getSameDepthItems(_a) {\n    var toastMark = _a.toastMark, mdNode = _a.mdNode, line = _a.line;\n    var depth = getListDepth(mdNode);\n    var forwardList = findSameDepthList(toastMark, line, depth, false).reverse();\n    var backwardList = findSameDepthList(toastMark, line, depth, true);\n    return forwardList.concat([{ line: line, depth: depth, mdNode: mdNode }]).concat(backwardList);\n}\nfunction textToBullet(text) {\n    if (!reList.test(text)) {\n        return \"* \" + text;\n    }\n    var type = getListType(text);\n    if (type === 'bullet' && reCanBeTaskList.test(text)) {\n        text = text.replace(reBulletTaskList, '$1$2 ');\n    }\n    else if (type === 'ordered') {\n        text = text.replace(reOrderedList, '$1* ');\n    }\n    return text;\n}\nfunction textToOrdered(text, ordinalNum) {\n    if (!reList.test(text)) {\n        return ordinalNum + \". \" + text;\n    }\n    var type = getListType(text);\n    if (type === 'bullet' || (type === 'ordered' && reCanBeTaskList.test(text))) {\n        text = text.replace(reCanBeTaskList, \"$1\" + ordinalNum + \". \");\n    }\n    else if (type === 'ordered') {\n        // eslint-disable-next-line prefer-destructuring\n        var start = reOrderedListGroup.exec(text)[3];\n        if (Number(start) !== ordinalNum) {\n            text = text.replace(reOrderedList, \"$1\" + ordinalNum + \". \");\n        }\n    }\n    return text;\n}\nfunction getChangedInfo(doc, sameDepthItems, type, start) {\n    if (start === void 0) { start = 0; }\n    var firstIndex = Number.MAX_VALUE;\n    var lastIndex = 0;\n    var changedResults = sameDepthItems.map(function (_a, index) {\n        var line = _a.line;\n        firstIndex = Math.min(line - 1, firstIndex);\n        lastIndex = Math.max(line - 1, lastIndex);\n        var text = getTextByMdLine(doc, line);\n        text = type === 'bullet' ? textToBullet(text) : textToOrdered(text, index + 1 + start);\n        return { text: text, line: line };\n    });\n    return { changedResults: changedResults, firstIndex: firstIndex, lastIndex: lastIndex };\n}\nfunction getBulletOrOrdered(type, context) {\n    var sameDepthListInfo = getSameDepthItems(context);\n    return getChangedInfo(context.doc, sameDepthListInfo, type);\n}\nvar otherListToList = {\n    bullet: function (context) {\n        return getBulletOrOrdered('bullet', context);\n    },\n    ordered: function (context) {\n        return getBulletOrOrdered('ordered', context);\n    },\n    task: function (_a) {\n        var mdNode = _a.mdNode, doc = _a.doc, line = _a.line;\n        var text = getTextByMdLine(doc, line);\n        if (mdNode.listData.task) {\n            text = text.replace(reTaskList, '$1$2');\n        }\n        else if (isListNode$1(mdNode)) {\n            text = text.replace(reList, '$1$2[ ] ');\n        }\n        return { changedResults: [{ text: text, line: line }] };\n    },\n};\nvar otherNodeToList = {\n    bullet: function (_a) {\n        var doc = _a.doc, line = _a.line;\n        var lineText = getTextByMdLine(doc, line);\n        var changedResults = [{ text: \"* \" + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n    ordered: function (_a) {\n        var toastMark = _a.toastMark, doc = _a.doc, line = _a.line, startLine = _a.startLine;\n        var lineText = getTextByMdLine(doc, line);\n        var firstOrderedListNum = 1;\n        var firstOrderedListLine = startLine;\n        var skipped = 0;\n        for (var i = startLine - 1; i > 0; i -= 1) {\n            var mdNode = toastMark.findFirstNodeAtLine(i);\n            var text = getTextByMdLine(doc, i);\n            var canBeListNode = text && !!findClosestNode(mdNode, function (targetNode) { return isListNode$1(targetNode); });\n            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, i));\n            if (!searchResult && !canBeListNode) {\n                break;\n            }\n            if (!searchResult && canBeListNode) {\n                skipped += 1;\n                continue;\n            }\n            var _b = searchResult, indent = _b[1], start = _b[3];\n            // basis on one depth list\n            if (!indent) {\n                firstOrderedListNum = Number(start);\n                firstOrderedListLine = i;\n                break;\n            }\n        }\n        var ordinalNum = firstOrderedListNum + line - firstOrderedListLine - skipped;\n        var changedResults = [{ text: ordinalNum + \". \" + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n    task: function (_a) {\n        var doc = _a.doc, line = _a.line;\n        var lineText = getTextByMdLine(doc, line);\n        var changedResults = [{ text: \"* [ ] \" + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n};\nvar extendList = {\n    bullet: function (_a) {\n        var line = _a.line, doc = _a.doc;\n        var lineText = getTextByMdLine(doc, line);\n        var _b = reBulletListGroup.exec(lineText), indent = _b[1], delimiter = _b[2];\n        return { listSyntax: \"\" + indent + delimiter };\n    },\n    ordered: function (_a) {\n        var toastMark = _a.toastMark, line = _a.line, mdNode = _a.mdNode, doc = _a.doc;\n        var depth = getListDepth(mdNode);\n        var lineText = getTextByMdLine(doc, line);\n        var _b = reOrderedListGroup.exec(lineText), indent = _b[1], start = _b[3], delimiter = _b[4];\n        var ordinalNum = Number(start) + 1;\n        var listSyntax = \"\" + indent + ordinalNum + delimiter;\n        var backwardList = findSameDepthList(toastMark, line, depth, true);\n        var filteredList = backwardList.filter(function (info) {\n            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, info.line));\n            return (searchResult &&\n                searchResult[1].length === indent.length &&\n                !!findClosestNode(info.mdNode, function (targetNode) { return isOrderedListNode(targetNode); }));\n        });\n        return __assign$1({ listSyntax: listSyntax }, getChangedInfo(doc, filteredList, 'ordered', ordinalNum));\n    },\n};\nfunction getReorderedListInfo(doc, schema, line, ordinalNum, prevIndentLength) {\n    var nodes = [];\n    var lineText = getTextByMdLine(doc, line);\n    var searchResult = reOrderedListGroup.exec(lineText);\n    while (searchResult) {\n        var indent = searchResult[1], delimiter = searchResult[4], text = searchResult[5];\n        var indentLength = indent.length;\n        if (indentLength === prevIndentLength) {\n            nodes.push(createTextNode$1(schema, \"\" + indent + ordinalNum + delimiter + text));\n            ordinalNum += 1;\n            line += 1;\n        }\n        else if (indentLength > prevIndentLength) {\n            var nestedListInfo = getReorderedListInfo(doc, schema, line, 1, indentLength);\n            line = nestedListInfo.line;\n            nodes = nodes.concat(nestedListInfo.nodes);\n        }\n        if (indentLength < prevIndentLength || line > doc.childCount) {\n            break;\n        }\n        lineText = getTextByMdLine(doc, line);\n        searchResult = reOrderedListGroup.exec(lineText);\n    }\n    return { nodes: nodes, line: line };\n}\n\nvar reStartSpace = /(^\\s{1,4})(.*)/;\nfunction isBlockUnit(from, to, text) {\n    return from < to || reList.test(text) || reBlockQuote.test(text);\n}\nfunction isInTableCellNode(doc, schema, selection) {\n    var $pos = selection.$from;\n    if ($pos.depth === 0) {\n        $pos = doc.resolve($pos.pos - 1);\n    }\n    var node = $pos.node(1);\n    var startOffset = $pos.start(1);\n    var contentSize = node.content.size;\n    return (node.rangeHasMark(0, contentSize, schema.marks.table) &&\n        $pos.pos - startOffset !== contentSize &&\n        $pos.pos !== startOffset);\n}\nfunction createSelection(tr, posInfo) {\n    var from = posInfo.from, to = posInfo.to;\n    if (posInfo.type === 'indent') {\n        var softTabLen = 4;\n        from += softTabLen;\n        to += (posInfo.lineLen + 1) * softTabLen;\n    }\n    else {\n        var spaceLenList = posInfo.spaceLenList;\n        from -= spaceLenList[0];\n        for (var i = 0; i < spaceLenList.length; i += 1) {\n            to -= spaceLenList[i];\n        }\n    }\n    return createTextSelection(tr, from, to);\n}\nvar Paragraph$1 = /** @class */ (function (_super) {\n    __extends$1(Paragraph, _super);\n    function Paragraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Paragraph.prototype, \"name\", {\n        get: function () {\n            return 'paragraph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Paragraph.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'inline*',\n                attrs: {\n                    className: { default: null },\n                    codeStart: { default: null },\n                    codeEnd: { default: null },\n                },\n                selectable: false,\n                group: 'block',\n                parseDOM: [{ tag: 'div' }],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return attrs.className\n                        ? ['div', { class: clsWithMdPrefix(attrs.className) }, 0]\n                        : ['div', 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Paragraph.prototype.reorderList = function (startLine, endLine) {\n        var _a = this.context, view = _a.view, toastMark = _a.toastMark, schema = _a.schema;\n        var _b = view.state, tr = _b.tr, selection = _b.selection, doc = _b.doc;\n        var mdNode = toastMark.findFirstNodeAtLine(startLine);\n        var topListNode = mdNode;\n        while (mdNode && !isBulletListNode(mdNode) && mdNode.parent.type !== 'document') {\n            mdNode = mdNode.parent;\n            if (isOrderedListNode(mdNode)) {\n                topListNode = mdNode;\n                break;\n            }\n        }\n        if (topListNode) {\n            startLine = topListNode.sourcepos[0][0];\n        }\n        var _c = reOrderedListGroup.exec(getTextByMdLine(doc, startLine)), indent = _c[1], start = _c[3];\n        var indentLen = indent.length;\n        var _d = getReorderedListInfo(doc, schema, startLine, Number(start), indentLen), line = _d.line, nodes = _d.nodes;\n        endLine = Math.max(endLine, line - 1);\n        var startOffset = getNodeContentOffsetRange(doc, startLine - 1).startOffset;\n        for (var i = startLine - 1; i <= endLine - 1; i += 1) {\n            var _e = doc.child(i), nodeSize = _e.nodeSize, content = _e.content;\n            var mappedFrom = tr.mapping.map(startOffset);\n            var mappedTo = mappedFrom + content.size;\n            tr.replaceWith(mappedFrom, mappedTo, nodes[i - startLine + 1]);\n            startOffset += nodeSize;\n        }\n        var newSelection = createTextSelection(tr, selection.from, selection.to);\n        view.dispatch(tr.setSelection(newSelection));\n    };\n    Paragraph.prototype.indent = function (tabKey) {\n        var _this = this;\n        if (tabKey === void 0) { tabKey = false; }\n        return function () { return function (state, dispatch) {\n            var schema = state.schema, selection = state.selection, doc = state.doc;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            if (tabKey && isInTableCellNode(doc, schema, selection)) {\n                return false;\n            }\n            var startLineText = getTextContent(doc, startIndex);\n            if ((tabKey && isBlockUnit(from, to, startLineText)) ||\n                (!tabKey && reList.test(startLineText))) {\n                var tr = replaceTextNode({\n                    state: state,\n                    from: startFromOffset,\n                    startIndex: startIndex,\n                    endIndex: endIndex,\n                    createText: function (textContent) { return \"    \" + textContent; },\n                });\n                var posInfo = {\n                    type: 'indent',\n                    from: from,\n                    to: to,\n                    lineLen: endIndex - startIndex,\n                };\n                dispatch(tr.setSelection(createSelection(tr, posInfo)));\n                if (reOrderedListGroup.test(startLineText)) {\n                    _this.reorderList(startIndex + 1, endIndex + 1);\n                }\n            }\n            else if (tabKey) {\n                dispatch(state.tr.insert(to, createTextNode$1(schema, '    ')));\n            }\n            return true;\n        }; };\n    };\n    Paragraph.prototype.outdent = function (tabKey) {\n        var _this = this;\n        if (tabKey === void 0) { tabKey = false; }\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, doc = state.doc, schema = state.schema;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            if (tabKey && isInTableCellNode(doc, schema, selection)) {\n                return false;\n            }\n            var startLineText = getTextContent(doc, startIndex);\n            if ((tabKey && isBlockUnit(from, to, startLineText)) ||\n                (!tabKey && reList.test(startLineText))) {\n                var spaceLenList_1 = [];\n                var tr = replaceTextNode({\n                    state: state,\n                    from: startFromOffset,\n                    startIndex: startIndex,\n                    endIndex: endIndex,\n                    createText: function (textContent) {\n                        var searchResult = reStartSpace.exec(textContent);\n                        spaceLenList_1.push(searchResult ? searchResult[1].length : 0);\n                        return textContent.replace(reStartSpace, '$2');\n                    },\n                });\n                var posInfo = { type: 'outdent', from: from, to: to, spaceLenList: spaceLenList_1 };\n                dispatch(tr.setSelection(createSelection(tr, posInfo)));\n                if (reOrderedListGroup.test(startLineText)) {\n                    _this.reorderList(startIndex + 1, endIndex + 1);\n                }\n            }\n            else if (tabKey) {\n                var startText = startLineText.slice(0, to - startFromOffset);\n                var startTextWithoutSpace = startText.replace(/\\s{1,4}$/, '');\n                var deletStart = to - (startText.length - startTextWithoutSpace.length);\n                dispatch(state.tr.delete(deletStart, to));\n            }\n            return true;\n        }; };\n    };\n    Paragraph.prototype.deleteLines = function () {\n        var _this = this;\n        return function (state, dispatch) {\n            var view = _this.context.view;\n            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            var deleteRange = function () {\n                dispatch(state.tr.deleteRange(startFromOffset, endToOffset));\n                return true;\n            };\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.chainCommands)(deleteRange, prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.joinForward)(state, dispatch, view);\n        };\n    };\n    Paragraph.prototype.moveDown = function () {\n        return function (state, dispatch) {\n            var doc = state.doc, tr = state.tr, selection = state.selection, schema = state.schema;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, endIndex = _a.endIndex;\n            if (endIndex < doc.content.childCount - 1) {\n                var _b = doc.child(endIndex + 1), nodeSize = _b.nodeSize, textContent = _b.textContent;\n                tr.delete(endToOffset, endToOffset + nodeSize)\n                    .split(startFromOffset)\n                    // subtract 2(start, end tag length) to insert prev line\n                    .insert(tr.mapping.map(startFromOffset) - 2, createTextNode$1(schema, textContent));\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Paragraph.prototype.moveUp = function () {\n        return function (state, dispatch) {\n            var tr = state.tr, doc = state.doc, selection = state.selection, schema = state.schema;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex;\n            if (startIndex > 0) {\n                var _b = doc.child(startIndex - 1), nodeSize = _b.nodeSize, textContent = _b.textContent;\n                tr.delete(startFromOffset - nodeSize, startFromOffset)\n                    .split(tr.mapping.map(endToOffset))\n                    .insert(tr.mapping.map(endToOffset), createTextNode$1(schema, textContent));\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Paragraph.prototype.commands = function () {\n        return {\n            indent: this.indent(),\n            outdent: this.outdent(),\n        };\n    };\n    Paragraph.prototype.keymaps = function () {\n        return {\n            Tab: this.indent(true)(),\n            'Shift-Tab': this.outdent(true)(),\n            'Mod-d': this.deleteLines(),\n            'Mod-D': this.deleteLines(),\n            'Alt-ArrowUp': this.moveUp(),\n            'Alt-ArrowDown': this.moveDown(),\n        };\n    };\n    return Paragraph;\n}(Node$2));\n\nvar Text$1 = /** @class */ (function (_super) {\n    __extends$1(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Text.prototype, \"name\", {\n        get: function () {\n            return 'text';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"schema\", {\n        get: function () {\n            return {\n                group: 'inline',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Text;\n}(Node$2));\n\nvar reHeading = /^#{1,6}\\s/;\nvar Heading$1 = /** @class */ (function (_super) {\n    __extends$1(Heading, _super);\n    function Heading() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Heading.prototype, \"name\", {\n        get: function () {\n            return 'heading';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    level: { default: 1 },\n                    seText: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var level = attrs.level, seText = attrs.seText;\n                    var classNames = \"heading|heading\" + level;\n                    if (seText) {\n                        classNames += '|delimiter|setext';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Heading.prototype.createHeadingText = function (level, text, curHeadingSyntax) {\n        var textContent = text.replace(curHeadingSyntax, '').trim();\n        var headingText = '';\n        while (level > 0) {\n            headingText += '#';\n            level -= 1;\n        }\n        return headingText + \" \" + textContent;\n    };\n    Heading.prototype.commands = function () {\n        var _this = this;\n        return function (payload) { return function (state, dispatch) {\n            var level = payload.level;\n            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            var tr = replaceTextNode({\n                state: state,\n                from: startFromOffset,\n                startIndex: startIndex,\n                endIndex: endIndex,\n                createText: function (textContent) {\n                    var matchedHeading = textContent.match(reHeading);\n                    var curHeadingSyntax = matchedHeading ? matchedHeading[0] : '';\n                    return _this.createHeadingText(level, textContent, curHeadingSyntax);\n                },\n            });\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    return Heading;\n}(Mark));\n\nvar fencedCodeBlockSyntax = '```';\nvar CodeBlock$1 = /** @class */ (function (_super) {\n    __extends$1(CodeBlock, _super);\n    function CodeBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CodeBlock.prototype, \"name\", {\n        get: function () {\n            return 'codeBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CodeBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('code-block') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CodeBlock.prototype.commands = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            var fencedNode = createTextNode$1(schema, fencedCodeBlockSyntax);\n            // add fenced start block\n            tr.insert(startFromOffset, fencedNode).split(startFromOffset + fencedCodeBlockSyntax.length);\n            // add fenced end block\n            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), fencedNode);\n            dispatch(tr.setSelection(\n            // subtract fenced syntax length and open, close tag(2)\n            createTextSelection(tr, tr.mapping.map(endToOffset) - (fencedCodeBlockSyntax.length + 2))));\n            return true;\n        }; };\n    };\n    CodeBlock.prototype.keepIndentation = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), startFromOffset = _b.startFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, from = _b.from, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            if (from === to && textContent.trim()) {\n                var matched = textContent.match(/^\\s+/);\n                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);\n                if (isCodeBlockNode(mdNode) && matched) {\n                    var spaces = matched[0];\n                    var slicedText = textContent.slice(to - startFromOffset);\n                    var node = createTextNode$1(schema, spaces + slicedText);\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                    dispatch(tr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    CodeBlock.prototype.keymaps = function () {\n        var codeBlockCommand = this.commands()();\n        return {\n            'Shift-Mod-p': codeBlockCommand,\n            'Shift-Mod-P': codeBlockCommand,\n            Enter: this.keepIndentation(),\n        };\n    };\n    return CodeBlock;\n}(Mark));\n\nvar reEmptyTable = /\\||\\s/g;\nfunction createTableHeader(columnCount) {\n    return [createTableRow(columnCount), createTableRow(columnCount, true)];\n}\nfunction createTableBody$1(columnCount, rowCount) {\n    var bodyRows = [];\n    for (var i = 0; i < rowCount; i += 1) {\n        bodyRows.push(createTableRow(columnCount));\n    }\n    return bodyRows;\n}\nfunction createTableRow(columnCount, delim) {\n    var row = '|';\n    for (var i = 0; i < columnCount; i += 1) {\n        row += delim ? ' --- |' : '  |';\n    }\n    return row;\n}\nfunction createTargetTypes(moveNext) {\n    return moveNext\n        ? { type: 'next', parentType: 'tableHead', childType: 'firstChild' }\n        : { type: 'prev', parentType: 'tableBody', childType: 'lastChild' };\n}\nvar Table$1 = /** @class */ (function (_super) {\n    __extends$1(Table, _super);\n    function Table() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Table.prototype, \"name\", {\n        get: function () {\n            return 'table';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Table.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('table') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Table.prototype.extendTable = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;\n            if (!selection.empty) {\n                return false;\n            }\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            // should add `1` to line for the markdown parser\n            // because markdown parser has `1`(not zero) as the start number\n            var mdPos = [endIndex + 1, to - endFromOffset + 1];\n            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);\n            var cellNode = findClosestNode(mdNode, function (node) {\n                return isTableCellNode(node) &&\n                    (node.parent.type === 'tableDelimRow' || node.parent.parent.type === 'tableBody');\n            });\n            if (cellNode) {\n                var isEmpty = !textContent.replace(reEmptyTable, '').trim();\n                var parent_1 = cellNode.parent;\n                var columnCount = parent_1.parent.parent.columns.length;\n                var row = createTableRow(columnCount);\n                if (isEmpty) {\n                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n                }\n                else {\n                    tr\n                        .split(endToOffset)\n                        .insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row))\n                        // should subtract `2` to selection end position considering ` |` text\n                        .setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - 2));\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.moveTableCell = function (moveNext) {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, to = _b.to;\n            var mdPos = [endIndex + 1, to - endFromOffset];\n            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);\n            var cellNode = findClosestNode(mdNode, function (node) { return isTableCellNode(node); });\n            if (cellNode) {\n                var parent_2 = cellNode.parent;\n                var _c = createTargetTypes(moveNext), type = _c.type, parentType = _c.parentType, childType = _c.childType;\n                var chOffset = getMdEndCh(cellNode);\n                if (cellNode[type]) {\n                    chOffset = getMdEndCh(cellNode[type]) - 1;\n                }\n                else {\n                    var row = !parent_2[type] && parent_2.parent.type === parentType\n                        ? parent_2.parent[type][childType]\n                        : parent_2[type];\n                    if (type === 'next') {\n                        // if there is next row, the base offset would be end position of the next row's first child.\n                        // Otherwise, the base offset is zero.\n                        var baseOffset = row ? getMdEndCh(row[childType]) : 0;\n                        // calculate tag(open, close) position('2') for selection\n                        chOffset += baseOffset + 2;\n                    }\n                    else if (type === 'prev') {\n                        // if there is prev row, the target position would be '-4' for calculating ' |' characters and tag(open, close)\n                        // Otherwise, the target position is zero.\n                        chOffset = row ? -4 : 0;\n                    }\n                }\n                dispatch(tr.setSelection(createTextSelection(tr, endFromOffset + chOffset)));\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.addTable = function () {\n        return function (payload) { return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n            var _b = payload, columnCount = _b.columnCount, rowCount = _b.rowCount;\n            var endToOffset = getRangeInfo(selection).endToOffset;\n            var headerRows = createTableHeader(columnCount);\n            var bodyRows = createTableBody$1(columnCount, rowCount - 1);\n            var rows = __spreadArray$1(__spreadArray$1([], headerRows), bodyRows);\n            rows.forEach(function (row) {\n                tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row));\n            });\n            // should add `4` to selection position considering `| ` text and start block tag length\n            dispatch(tr.setSelection(createTextSelection(tr, endToOffset + 4)));\n            return true;\n        }; };\n    };\n    Table.prototype.commands = function () {\n        return { addTable: this.addTable() };\n    };\n    Table.prototype.keymaps = function () {\n        return {\n            Enter: this.extendTable(),\n            Tab: this.moveTableCell(true),\n            'Shift-Tab': this.moveTableCell(false),\n        };\n    };\n    return Table;\n}(Mark));\n\nvar thematicBreakSyntax = '***';\nvar ThematicBreak$1 = /** @class */ (function (_super) {\n    __extends$1(ThematicBreak, _super);\n    function ThematicBreak() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ThematicBreak.prototype, \"name\", {\n        get: function () {\n            return 'thematicBreak';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThematicBreak.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('thematic-break') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ThematicBreak.prototype.hr = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, endToOffset = _a.endToOffset;\n            var node = createTextNode$1(schema, thematicBreakSyntax);\n            tr\n                .split(from)\n                .replaceWith(tr.mapping.map(from), tr.mapping.map(to), node)\n                .split(tr.mapping.map(to)).setSelection(createTextSelection(tr, tr.mapping.map(endToOffset)));\n            dispatch(tr);\n            return true;\n        }; };\n    };\n    ThematicBreak.prototype.commands = function () {\n        return { hr: this.hr() };\n    };\n    ThematicBreak.prototype.keymaps = function () {\n        var lineCommand = this.hr()();\n        return { 'Mod-l': lineCommand, 'Mod-L': lineCommand };\n    };\n    return ThematicBreak;\n}(Mark));\n\nfunction cannotBeListNode(_a, line) {\n    var type = _a.type, sourcepos = _a.sourcepos;\n    // eslint-disable-next-line prefer-destructuring\n    var startLine = sourcepos[0][0];\n    return line <= startLine && (type === 'codeBlock' || type === 'heading' || type.match('table'));\n}\nvar ListItem$1 = /** @class */ (function (_super) {\n    __extends$1(ListItem, _super);\n    function ListItem() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ListItem.prototype, \"name\", {\n        get: function () {\n            return 'listItem';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ListItem.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    odd: { default: false },\n                    even: { default: false },\n                    listStyle: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var odd = attrs.odd, even = attrs.even, listStyle = attrs.listStyle;\n                    var classNames = 'list-item';\n                    if (listStyle) {\n                        classNames += '|list-item-style';\n                    }\n                    if (odd) {\n                        classNames += '|list-item-odd';\n                    }\n                    if (even) {\n                        classNames += '|list-item-even';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ListItem.prototype.extendList = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, schema = _a.schema, tr = _a.tr;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), to = _b.to, startFromOffset = _b.startFromOffset, endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, endToOffset = _b.endToOffset;\n            var textContent = getTextContent(doc, endIndex);\n            var isList = reList.test(textContent);\n            if (!isList || selection.from === startFromOffset || !selection.empty) {\n                return false;\n            }\n            var isEmpty = !textContent.replace(reCanBeTaskList, '').trim();\n            if (isEmpty) {\n                tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n            }\n            else {\n                var commandType = getListType(textContent);\n                // should add `1` to line for the markdown parser\n                // because markdown parser has `1`(not zero) as the start number\n                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);\n                var slicedText = textContent.slice(to - endFromOffset);\n                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: endIndex + 1 };\n                var _c = extendList[commandType](context), listSyntax = _c.listSyntax, changedResults = _c.changedResults;\n                // change ordinal number of backward ordered list\n                if (changedResults === null || changedResults === void 0 ? void 0 : changedResults.length) {\n                    // split the block\n                    tr.split(to);\n                    // set first ordered list info\n                    changedResults.unshift({ text: listSyntax + slicedText, line: endIndex + 1 });\n                    _this.changeToListPerLine(tr, changedResults, {\n                        from: to,\n                        // don't subtract 1 because the line has increased through 'split' command.\n                        startLine: changedResults[0].line,\n                        endLine: last$1(changedResults).line,\n                    });\n                    var pos = tr.mapping.map(endToOffset) - slicedText.length;\n                    tr.setSelection(createTextSelection(tr, pos));\n                }\n                else {\n                    var node = createTextNode$1(schema, listSyntax + slicedText);\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                }\n            }\n            dispatch(tr);\n            return true;\n        };\n    };\n    ListItem.prototype.toList = function (commandType) {\n        var _this = this;\n        return function () { return function (_a, dispatch) {\n            var doc = _a.doc, tr = _a.tr, selection = _a.selection;\n            var toastMark = _this.context.toastMark;\n            var rangeInfo = getRangeInfo(selection);\n            // should add `1` to line for the markdown parser\n            // because markdown parser has `1`(not zero) as the start number\n            var startLine = rangeInfo.startIndex + 1;\n            var endLine = rangeInfo.endIndex + 1;\n            var endToOffset = rangeInfo.endToOffset;\n            var skipLines = [];\n            for (var line = startLine; line <= endLine; line += 1) {\n                var mdNode = toastMark.findFirstNodeAtLine(line);\n                if (mdNode && cannotBeListNode(mdNode, line)) {\n                    break;\n                }\n                // to skip unnecessary processing\n                if (skipLines.indexOf(line) !== -1) {\n                    continue;\n                }\n                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: line, startLine: startLine };\n                var changedResults = (isListNode$1(mdNode)\n                    ? otherListToList[commandType](context)\n                    : otherNodeToList[commandType](context)).changedResults;\n                var endOffset = _this.changeToListPerLine(tr, changedResults, {\n                    from: getNodeContentOffsetRange(doc, changedResults[0].line - 1).startOffset,\n                    startLine: changedResults[0].line,\n                    endLine: last$1(changedResults).line,\n                    indexDiff: 1,\n                });\n                endToOffset = Math.max(endOffset, endToOffset);\n                if (changedResults) {\n                    skipLines = skipLines.concat(changedResults.map(function (info) { return info.line; }));\n                }\n            }\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    ListItem.prototype.changeToListPerLine = function (tr, changedResults, _a) {\n        var from = _a.from, startLine = _a.startLine, endLine = _a.endLine, _b = _a.indexDiff, indexDiff = _b === void 0 ? 0 : _b;\n        var maxEndOffset = 0;\n        var _loop_1 = function (i) {\n            var _c = tr.doc.child(i), nodeSize = _c.nodeSize, content = _c.content;\n            var mappedFrom = tr.mapping.map(from);\n            var mappedTo = mappedFrom + content.size;\n            var changedResult = changedResults.filter(function (result) { return result.line - indexDiff === i; })[0];\n            if (changedResult) {\n                tr.replaceWith(mappedFrom, mappedTo, createTextNode$1(this_1.context.schema, changedResult.text));\n                maxEndOffset = Math.max(maxEndOffset, from + content.size);\n            }\n            from += nodeSize;\n        };\n        var this_1 = this;\n        for (var i = startLine - indexDiff; i <= endLine - indexDiff; i += 1) {\n            _loop_1(i);\n        }\n        return maxEndOffset;\n    };\n    ListItem.prototype.toggleTask = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), startIndex = _b.startIndex, endIndex = _b.endIndex;\n            var newTr = null;\n            for (var i = startIndex; i <= endIndex; i += 1) {\n                var mdNode = toastMark.findFirstNodeAtLine(i + 1);\n                if (isListNode$1(mdNode) && mdNode.listData.task) {\n                    var _c = mdNode.listData, checked = _c.checked, padding = _c.padding;\n                    var stateChar = checked ? ' ' : 'x';\n                    var mdPos = mdNode.sourcepos[0];\n                    var startOffset = getNodeContentOffsetRange(doc, mdPos[0] - 1).startOffset;\n                    startOffset += mdPos[1] + padding;\n                    newTr = tr.replaceWith(startOffset, startOffset + 1, schema.text(stateChar));\n                }\n            }\n            if (newTr) {\n                dispatch(newTr);\n                return true;\n            }\n            return false;\n        };\n    };\n    ListItem.prototype.commands = function () {\n        return {\n            bulletList: this.toList('bullet'),\n            orderedList: this.toList('ordered'),\n            taskList: this.toList('task'),\n        };\n    };\n    ListItem.prototype.keymaps = function () {\n        var bulletCommand = this.toList('bullet')();\n        var orderedCommand = this.toList('ordered')();\n        var taskCommand = this.toList('task')();\n        var togleTaskCommand = this.toggleTask();\n        return {\n            'Mod-u': bulletCommand,\n            'Mod-U': bulletCommand,\n            'Mod-o': orderedCommand,\n            'Mod-O': orderedCommand,\n            'alt-t': taskCommand,\n            'alt-T': taskCommand,\n            'Shift-Ctrl-x': togleTaskCommand,\n            'Shift-Ctrl-X': togleTaskCommand,\n            Enter: this.extendList(),\n        };\n    };\n    return ListItem;\n}(Mark));\n\nfunction toggleMark(condition, syntax) {\n    return function () { return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var conditionFn = !isFunction_1(condition)\n            ? function (text) { return condition.test(text); }\n            : condition;\n        var syntaxLen = syntax.length;\n        var doc = tr.doc;\n        var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];\n        var prevPos = Math.max(from - syntaxLen, 1);\n        var nextPos = Math.min(to + syntaxLen, doc.content.size - 1);\n        var slice = selection.content();\n        var textContent = slice.content.textBetween(0, slice.content.size, '\\n');\n        var prevText = doc.textBetween(prevPos, from, '\\n');\n        var nextText = doc.textBetween(to, nextPos, '\\n');\n        textContent = \"\" + prevText + textContent + nextText;\n        if (prevText && nextText && conditionFn(textContent)) {\n            tr.delete(nextPos - syntaxLen, nextPos).delete(prevPos, prevPos + syntaxLen);\n        }\n        else {\n            tr.insertText(syntax, to).insertText(syntax, from);\n            var newSelection = selection.empty\n                ? createTextSelection(tr, from + syntaxLen)\n                : createTextSelection(tr, from + syntaxLen, to + syntaxLen);\n            tr.setSelection(newSelection);\n        }\n        dispatch(tr);\n        return true;\n    }; };\n}\n\nvar reStrong = /^(\\*{2}|_{2}).*([\\s\\S]*)\\1$/m;\nvar strongSyntax = '**';\nvar Strong$1 = /** @class */ (function (_super) {\n    __extends$1(Strong, _super);\n    function Strong() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strong.prototype, \"name\", {\n        get: function () {\n            return 'strong';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strong.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('strong') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strong.prototype.bold = function () {\n        return toggleMark(reStrong, strongSyntax);\n    };\n    Strong.prototype.commands = function () {\n        return { bold: this.bold() };\n    };\n    Strong.prototype.keymaps = function () {\n        var boldCommand = this.bold()();\n        return { 'Mod-b': boldCommand, 'Mod-B': boldCommand };\n    };\n    return Strong;\n}(Mark));\n\nvar reStrike = /^(~{2}).*([\\s\\S]*)\\1$/m;\nvar strikeSyntax = '~~';\nvar Strike$1 = /** @class */ (function (_super) {\n    __extends$1(Strike, _super);\n    function Strike() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strike.prototype, \"name\", {\n        get: function () {\n            return 'strike';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strike.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('strike') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strike.prototype.commands = function () {\n        return toggleMark(reStrike, strikeSyntax);\n    };\n    Strike.prototype.keymaps = function () {\n        var strikeCommand = this.commands()();\n        return { 'Mod-s': strikeCommand, 'Mod-S': strikeCommand };\n    };\n    return Strike;\n}(Mark));\n\nvar reEmph = /^(\\*|_).*([\\s\\S]*)\\1$/m;\nvar emphSyntax = '*';\nvar Emph$1 = /** @class */ (function (_super) {\n    __extends$1(Emph, _super);\n    function Emph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Emph.prototype, \"name\", {\n        get: function () {\n            return 'emph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Emph.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('emph') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Emph.prototype.italic = function () {\n        return toggleMark(reEmph, emphSyntax);\n    };\n    Emph.prototype.commands = function () {\n        return { italic: this.italic() };\n    };\n    Emph.prototype.keymaps = function () {\n        var italicCommand = this.italic()();\n        return { 'Mod-i': italicCommand, 'Mod-I': italicCommand };\n    };\n    return Emph;\n}(Mark));\n\nvar reCode = /^(`).*([\\s\\S]*)\\1$/m;\nvar codeSyntax = '`';\nvar Code$1 = /** @class */ (function (_super) {\n    __extends$1(Code, _super);\n    function Code() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Code.prototype, \"name\", {\n        get: function () {\n            return 'code';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Code.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    start: { default: false },\n                    end: { default: false },\n                    marked: { default: false },\n                },\n                toDOM: function (mark) {\n                    var _a = mark.attrs, start = _a.start, end = _a.end, marked = _a.marked;\n                    var classNames = 'code';\n                    if (start) {\n                        classNames += '|delimiter|start';\n                    }\n                    if (end) {\n                        classNames += '|delimiter|end';\n                    }\n                    if (marked) {\n                        classNames += '|marked-text';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Code.prototype.commands = function () {\n        return toggleMark(reCode, codeSyntax);\n    };\n    Code.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return { 'Shift-Mod-c': codeCommand, 'Shift-Mod-C': codeCommand };\n    };\n    return Code;\n}(Mark));\n\nvar Link$1 = /** @class */ (function (_super) {\n    __extends$1(Link, _super);\n    function Link() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Link.prototype, \"name\", {\n        get: function () {\n            return 'link';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Link.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    url: { default: false },\n                    desc: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var url = attrs.url, desc = attrs.desc;\n                    var classNames = 'link';\n                    if (url) {\n                        classNames += '|link-url|marked-text';\n                    }\n                    if (desc) {\n                        classNames += '|link-desc|marked-text';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Link.prototype.addLinkOrImage = function (commandType) {\n        return function (payload) { return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n            var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];\n            var _c = payload, linkText = _c.linkText, altText = _c.altText, linkUrl = _c.linkUrl, imageUrl = _c.imageUrl;\n            var text = linkText;\n            var url = linkUrl;\n            var syntax = '';\n            if (commandType === 'image') {\n                text = altText;\n                url = imageUrl;\n                syntax = '!';\n            }\n            text = escapeTextForLink(text);\n            syntax += \"[\" + text + \"](\" + url + \")\";\n            dispatch(tr.replaceWith(from, to, createTextNode$1(schema, syntax)));\n            return true;\n        }; };\n    };\n    Link.prototype.commands = function () {\n        return {\n            addImage: this.addLinkOrImage('image'),\n            addLink: this.addLinkOrImage('link'),\n        };\n    };\n    return Link;\n}(Mark));\n\nvar TaskDelimiter = /** @class */ (function (_super) {\n    __extends$1(TaskDelimiter, _super);\n    function TaskDelimiter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TaskDelimiter.prototype, \"name\", {\n        get: function () {\n            return 'taskDelimiter';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TaskDelimiter.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('delimiter', 'list-item') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TaskDelimiter;\n}(Mark));\nvar Delimiter = /** @class */ (function (_super) {\n    __extends$1(Delimiter, _super);\n    function Delimiter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Delimiter.prototype, \"name\", {\n        get: function () {\n            return 'delimiter';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Delimiter.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('delimiter') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Delimiter;\n}(Mark));\nvar Meta = /** @class */ (function (_super) {\n    __extends$1(Meta, _super);\n    function Meta() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Meta.prototype, \"name\", {\n        get: function () {\n            return 'meta';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Meta.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('meta') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Meta;\n}(Mark));\nvar MarkedText = /** @class */ (function (_super) {\n    __extends$1(MarkedText, _super);\n    function MarkedText() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(MarkedText.prototype, \"name\", {\n        get: function () {\n            return 'markedText';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MarkedText.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('marked-text') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return MarkedText;\n}(Mark));\nvar TableCell = /** @class */ (function (_super) {\n    __extends$1(TableCell, _super);\n    function TableCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableCell.prototype, \"name\", {\n        get: function () {\n            return 'tableCell';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableCell.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('table-cell') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableCell;\n}(Mark));\n\nvar Html = /** @class */ (function (_super) {\n    __extends$1(Html, _super);\n    function Html() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Html.prototype, \"name\", {\n        get: function () {\n            return 'html';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Html.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('html') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Html;\n}(Mark));\n\nvar customBlockSyntax = '$$';\nvar CustomBlock$1 = /** @class */ (function (_super) {\n    __extends$1(CustomBlock, _super);\n    function CustomBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CustomBlock.prototype, \"name\", {\n        get: function () {\n            return 'customBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('custom-block') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CustomBlock.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            if (!(payload === null || payload === void 0 ? void 0 : payload.info)) {\n                return false;\n            }\n            var customBlock = \"\" + customBlockSyntax + payload.info;\n            var startNode = createTextNode$1(schema, customBlock);\n            var endNode = createTextNode$1(schema, customBlockSyntax);\n            tr.insert(startFromOffset, startNode).split(startFromOffset + customBlock.length);\n            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), endNode);\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - (customBlockSyntax.length + 2))));\n            return true;\n        }; };\n    };\n    return CustomBlock;\n}(Mark));\n\nvar reTaskMarkerKey = /x|backspace/i;\nvar reTaskMarker = /^\\[(\\s*)(x?)(\\s*)\\](?:\\s+)/i;\nfunction smartTask(_a) {\n    var schema = _a.schema, toastMark = _a.toastMark;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                keyup: function (view, ev) {\n                    var _a;\n                    var _b = view.state, doc = _b.doc, tr = _b.tr, selection = _b.selection;\n                    if (selection.empty && reTaskMarkerKey.test(ev.key)) {\n                        var _c = getRangeInfo(selection), startIndex = _c.startIndex, startFromOffset = _c.startFromOffset, from = _c.from;\n                        // should add `1` to line for the markdown parser\n                        // because markdown parser has `1`(not zero) as the start number\n                        var mdPos = [startIndex + 1, from - startFromOffset + 1];\n                        var mdNode = toastMark.findNodeAtPosition(mdPos);\n                        var paraNode = findClosestNode(mdNode, function (node) { var _a; return node.type === 'paragraph' && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'item'; });\n                        if ((_a = paraNode === null || paraNode === void 0 ? void 0 : paraNode.firstChild) === null || _a === void 0 ? void 0 : _a.literal) {\n                            var firstChild = paraNode.firstChild;\n                            var matched = firstChild.literal.match(reTaskMarker);\n                            if (matched) {\n                                var startMdPos = firstChild.sourcepos[0];\n                                var startSpaces = matched[1], stateChar = matched[2], lastSpaces = matched[3];\n                                var spaces = startSpaces.length + lastSpaces.length;\n                                var startOffset = getNodeContentOffsetRange(doc, startMdPos[0] - 1).startOffset;\n                                var startPos = startMdPos[1] + startOffset;\n                                if (stateChar) {\n                                    var addedPos = spaces ? spaces + 1 : 0;\n                                    tr.replaceWith(startPos, addedPos + startPos, schema.text(stateChar));\n                                    view.dispatch(tr);\n                                }\n                                else if (!spaces) {\n                                    tr.insertText(' ', startPos);\n                                    view.dispatch(tr);\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nvar EVENT_TYPE = 'cut';\nvar reLineEnding$2 = /\\r\\n|\\n|\\r/;\nvar MdEditor = /** @class */ (function (_super) {\n    __extends$1(MdEditor, _super);\n    function MdEditor(eventEmitter, options) {\n        var _this = _super.call(this, eventEmitter) || this;\n        var toastMark = options.toastMark, _a = options.useCommandShortcut, useCommandShortcut = _a === void 0 ? true : _a, _b = options.mdPlugins, mdPlugins = _b === void 0 ? [] : _b;\n        _this.editorType = 'markdown';\n        _this.el.classList.add('md-mode');\n        _this.toastMark = toastMark;\n        _this.extraPlugins = mdPlugins;\n        _this.specs = _this.createSpecs();\n        _this.schema = _this.createSchema();\n        _this.context = _this.createContext();\n        _this.keymaps = _this.createKeymaps(useCommandShortcut);\n        _this.view = _this.createView();\n        _this.commands = _this.createCommands();\n        _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));\n        _this.createClipboard();\n        // To prevent unnecessary focus setting during initial rendering\n        _this.eventEmitter.listen('changePreviewTabWrite', function (isMarkdownTabMounted) {\n            return _this.toggleActive(true, isMarkdownTabMounted);\n        });\n        _this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(false); });\n        _this.initEvent();\n        return _this;\n    }\n    MdEditor.prototype.toggleActive = function (active, isMarkdownTabMounted) {\n        toggleClass(this.el, 'active', active);\n        if (active) {\n            if (!isMarkdownTabMounted) {\n                this.focus();\n            }\n        }\n        else {\n            this.blur();\n        }\n    };\n    MdEditor.prototype.createClipboard = function () {\n        var _this = this;\n        this.clipboard = document.createElement('textarea');\n        this.clipboard.className = cls('pseudo-clipboard');\n        this.clipboard.addEventListener('paste', function (ev) {\n            var clipboardData = ev.clipboardData || window.clipboardData;\n            var items = clipboardData && clipboardData.items;\n            if (items) {\n                var containRtfItem = toArray_1(items).some(function (item) { return item.kind === 'string' && item.type === 'text/rtf'; });\n                // if it contains rtf, it's most likely copy paste from office -> no image\n                if (!containRtfItem) {\n                    var imageBlob = pasteImageOnly(items);\n                    if (imageBlob) {\n                        ev.preventDefault();\n                        emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);\n                    }\n                }\n            }\n        });\n        // process the pasted data in input event for IE11\n        this.clipboard.addEventListener('input', function (ev) {\n            var text = ev.target.value;\n            _this.replaceSelection(text);\n            ev.preventDefault();\n            ev.target.value = '';\n        });\n        this.el.insertBefore(this.clipboard, this.view.dom);\n    };\n    MdEditor.prototype.createContext = function () {\n        return {\n            toastMark: this.toastMark,\n            schema: this.schema,\n            eventEmitter: this.eventEmitter,\n        };\n    };\n    MdEditor.prototype.createSpecs = function () {\n        return new SpecManager([\n            new Doc$1(),\n            new Paragraph$1(),\n            new Widget(),\n            new Text$1(),\n            new Heading$1(),\n            new BlockQuote$1(),\n            new CodeBlock$1(),\n            new CustomBlock$1(),\n            new Table$1(),\n            new TableCell(),\n            new ThematicBreak$1(),\n            new ListItem$1(),\n            new Strong$1(),\n            new Strike$1(),\n            new Emph$1(),\n            new Code$1(),\n            new Link$1(),\n            new Delimiter(),\n            new TaskDelimiter(),\n            new MarkedText(),\n            new Meta(),\n            new Html(),\n        ]);\n    };\n    MdEditor.prototype.createPlugins = function () {\n        return __spreadArray$1([\n            syntaxHighlight(this.context),\n            previewHighlight(this.context),\n            smartTask(this.context)\n        ], this.createPluginProps()).concat(this.defaultPlugins);\n    };\n    MdEditor.prototype.createView = function () {\n        var _this = this;\n        return new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(this.el, {\n            state: this.createState(),\n            dispatchTransaction: function (tr) {\n                _this.updateMarkdown(tr);\n                var state = _this.view.state.applyTransaction(tr).state;\n                _this.view.updateState(state);\n                _this.emitChangeEvent(tr);\n            },\n            handleKeyDown: function (_, ev) {\n                if ((ev.metaKey || ev.ctrlKey) && ev.key.toUpperCase() === 'V') {\n                    _this.clipboard.focus();\n                }\n                _this.eventEmitter.emit('keydown', _this.editorType, ev);\n                return false;\n            },\n            handleDOMEvents: {\n                copy: function (_, ev) { return _this.captureCopy(ev); },\n                cut: function (_, ev) { return _this.captureCopy(ev, EVENT_TYPE); },\n                scroll: function () {\n                    _this.eventEmitter.emit('scroll', 'editor');\n                    return true;\n                },\n                keyup: function (_, ev) {\n                    _this.eventEmitter.emit('keyup', _this.editorType, ev);\n                    return false;\n                },\n            },\n            nodeViews: {\n                widget: widgetNodeView,\n            },\n        });\n    };\n    MdEditor.prototype.createCommands = function () {\n        return this.specs.commands(this.view);\n    };\n    MdEditor.prototype.captureCopy = function (ev, type) {\n        ev.preventDefault();\n        var _a = this.view.state, selection = _a.selection, tr = _a.tr;\n        if (selection.empty) {\n            return true;\n        }\n        var text = this.getChanged(selection.content());\n        if (ev.clipboardData) {\n            ev.clipboardData.setData('text/plain', text);\n        }\n        else {\n            window.clipboardData.setData('Text', text);\n        }\n        if (type === EVENT_TYPE) {\n            this.view.dispatch(tr.deleteSelection().scrollIntoView().setMeta('uiEvent', EVENT_TYPE));\n        }\n        return true;\n    };\n    MdEditor.prototype.updateMarkdown = function (tr) {\n        var _this = this;\n        if (tr.docChanged) {\n            tr.steps.forEach(function (step, index) {\n                if (step.slice && !(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep)) {\n                    var doc = tr.docs[index];\n                    var _a = [step.from, step.to], from = _a[0], to = _a[1];\n                    var _b = getEditorToMdPos(doc, from, to), startPos = _b[0], endPos = _b[1];\n                    var changed = _this.getChanged(step.slice);\n                    if (startPos[0] === endPos[0] && startPos[1] === endPos[1] && changed === '') {\n                        changed = '\\n';\n                    }\n                    var editResult = _this.toastMark.editMarkdown(startPos, endPos, changed);\n                    _this.eventEmitter.emit('updatePreview', editResult);\n                    tr.setMeta('editResult', editResult).scrollIntoView();\n                }\n            });\n        }\n    };\n    MdEditor.prototype.getChanged = function (slice) {\n        var changed = '';\n        var from = 0;\n        var to = slice.content.size;\n        slice.content.nodesBetween(from, to, function (node, pos) {\n            if (node.isText) {\n                changed += node.text.slice(Math.max(from, pos) - pos, to - pos);\n            }\n            else if (node.isBlock && pos > 0) {\n                changed += '\\n';\n            }\n        });\n        return changed;\n    };\n    MdEditor.prototype.setSelection = function (start, end) {\n        if (end === void 0) { end = start; }\n        var tr = this.view.state.tr;\n        var _a = getMdToEditorPos(tr.doc, start, end), from = _a[0], to = _a[1];\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, from, to)).scrollIntoView());\n    };\n    MdEditor.prototype.replaceSelection = function (text, start, end) {\n        var newTr;\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;\n        var lineTexts = text.split(reLineEnding$2);\n        var nodes = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nodes), 1, 1);\n        this.focus();\n        if (start && end) {\n            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];\n            newTr = tr.replaceRange(from, to, slice);\n        }\n        else {\n            newTr = tr.replaceSelection(slice);\n        }\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    MdEditor.prototype.deleteSelection = function (start, end) {\n        var newTr;\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc;\n        if (start && end) {\n            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];\n            newTr = tr.deleteRange(from, to);\n        }\n        else {\n            newTr = tr.deleteSelection();\n        }\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    MdEditor.prototype.getSelectedText = function (start, end) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var from = selection.from, to = selection.to;\n        if (start && end) {\n            var pos = getMdToEditorPos(doc, start, end);\n            from = pos[0];\n            to = pos[1];\n        }\n        return doc.textBetween(from, to, '\\n');\n    };\n    MdEditor.prototype.getSelection = function () {\n        var _a = this.view.state.selection, from = _a.from, to = _a.to;\n        return getEditorToMdPos(this.view.state.tr.doc, from, to);\n    };\n    MdEditor.prototype.setMarkdown = function (markdown, cursorToEnd) {\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        var lineTexts = markdown.split(reLineEnding$2);\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n        var nodes = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        this.view.dispatch(tr.replaceWith(0, doc.content.size, nodes));\n        if (cursorToEnd) {\n            this.moveCursorToEnd(true);\n        }\n    };\n    MdEditor.prototype.addWidget = function (node, style, mdPos) {\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc, selection = _a.selection;\n        var pos = mdPos ? getMdToEditorPos(doc, mdPos, mdPos)[0] : selection.to;\n        this.view.dispatch(tr.setMeta('widget', { pos: pos, node: node, style: style }));\n    };\n    MdEditor.prototype.replaceWithWidget = function (start, end, text) {\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;\n        var pos = getMdToEditorPos(doc, start, end);\n        var nodes = createNodesWithWidget(text, schema);\n        this.view.dispatch(tr.replaceWith(pos[0], pos[1], nodes));\n    };\n    MdEditor.prototype.getRangeInfoOfNode = function (pos) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var mdPos = pos || getEditorToMdPos(doc, selection.from)[0];\n        var mdNode = this.toastMark.findNodeAtPosition(mdPos);\n        if (mdNode.type === 'text' && mdNode.parent.type !== 'paragraph') {\n            mdNode = mdNode.parent;\n        }\n        // add 1 sync for prosemirror position\n        mdNode.sourcepos[1][1] += 1;\n        return { range: mdNode.sourcepos, type: mdNode.type };\n    };\n    MdEditor.prototype.getMarkdown = function () {\n        return this.toastMark\n            .getLineTexts()\n            .map(function (lineText) { return unwrapWidgetSyntax(lineText); })\n            .join('\\n');\n    };\n    MdEditor.prototype.getToastMark = function () {\n        return this.toastMark;\n    };\n    return MdEditor;\n}(EditorBase));\n\n/**\n * @fileoverview Get event collection for specific HTML element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar EVENT_KEY = '_feEventKey';\n\n/**\n * Get event collection for specific HTML element\n * @param {HTMLElement} element - HTML element\n * @param {string} type - event type\n * @returns {array}\n * @private\n */\nfunction safeEvent$2(element, type) {\n  var events = element[EVENT_KEY];\n  var handlers;\n\n  if (!events) {\n    events = element[EVENT_KEY] = {};\n  }\n\n  handlers = events[type];\n  if (!handlers) {\n    handlers = events[type] = [];\n  }\n\n  return handlers;\n}\n\nvar _safeEvent = safeEvent$2;\n\n/**\n * @fileoverview Unbind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString$1 = isString_1;\nvar forEach$1 = forEach_1;\n\nvar safeEvent$1 = _safeEvent;\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {function} [handler] - handler function\n * @memberof module:domEvent\n * @example\n * // Following the example of domEvent#on\n * \n * // Unbind one event from an element.\n * off(div, 'click', toggle);\n * \n * // Unbind multiple events with a same handler from multiple elements at once.\n * // Use event names splitted by a space.\n * off(element, 'mouseenter mouseleave', changeColor);\n * \n * // Unbind multiple events with different handlers from an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * off(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Unbind events without handlers.\n * off(div, 'drag');\n */\nfunction off(element, types, handler) {\n  if (isString$1(types)) {\n    forEach$1(types.split(/\\s+/g), function(type) {\n      unbindEvent(element, type, handler);\n    });\n\n    return;\n  }\n\n  forEach$1(types, function(func, type) {\n    unbindEvent(element, type, func);\n  });\n}\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {string} type - events name\n * @param {function} [handler] - handler function\n * @private\n */\nfunction unbindEvent(element, type, handler) {\n  var events = safeEvent$1(element, type);\n  var index;\n\n  if (!handler) {\n    forEach$1(events, function(item) {\n      removeHandler(element, type, item.wrappedHandler);\n    });\n    events.splice(0, events.length);\n  } else {\n    forEach$1(events, function(item, idx) {\n      if (handler === item.handler) {\n        removeHandler(element, type, item.wrappedHandler);\n        index = idx;\n\n        return false;\n      }\n\n      return true;\n    });\n    events.splice(index, 1);\n  }\n}\n\n/**\n * Remove an event handler\n * @param {HTMLElement} element - An element to remove an event\n * @param {string} type - event type\n * @param {function} handler - event handler\n * @private\n */\nfunction removeHandler(element, type, handler) {\n  if ('removeEventListener' in element) {\n    element.removeEventListener(type, handler);\n  } else if ('detachEvent' in element) {\n    element.detachEvent('on' + type, handler);\n  }\n}\n\nvar off_1 = off;\n\n/**\n * @fileoverview Bind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString = isString_1;\nvar forEach = forEach_1;\n\nvar safeEvent = _safeEvent;\n\n/**\n * Bind DOM events.\n * @param {HTMLElement} element - element to bind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {(function|object)} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @memberof module:domEvent\n * @example\n * const div = document.querySelector('div');\n * \n * // Bind one event to an element.\n * on(div, 'click', toggle);\n * \n * // Bind multiple events with a same handler to multiple elements at once.\n * // Use event names splitted by a space.\n * on(div, 'mouseenter mouseleave', changeColor);\n * \n * // Bind multiple events with different handlers to an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * on(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Set a context for handler method.\n * const name = 'global';\n * const repository = {name: 'CodeSnippet'};\n * on(div, 'drag', function() {\n *   console.log(this.name);\n * }, repository);\n * // Result when you drag a div: \"CodeSnippet\"\n */\nfunction on(element, types, handler, context) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      bindEvent(element, type, handler, context);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    bindEvent(element, type, func, handler);\n  });\n}\n\n/**\n * Bind DOM events\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @private\n */\nfunction bindEvent(element, type, handler, context) {\n  /**\n     * Event handler\n     * @param {Event} e - event object\n     */\n  function eventHandler(e) {\n    handler.call(context || element, e || window.event);\n  }\n\n  if ('addEventListener' in element) {\n    element.addEventListener(type, eventHandler);\n  } else if ('attachEvent' in element) {\n    element.attachEvent('on' + type, eventHandler);\n  }\n  memorizeHandler(element, type, handler, eventHandler);\n}\n\n/**\n * Memorize DOM event handler for unbinding.\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function that user passed at on() use\n * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features\n * @private\n */\nfunction memorizeHandler(element, type, handler, wrappedHandler) {\n  var events = safeEvent(element, type);\n  var existInEvents = false;\n\n  forEach(events, function(obj) {\n    if (obj.handler === handler) {\n      existInEvents = true;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!existInEvents) {\n    events.push({\n      handler: handler,\n      wrappedHandler: wrappedHandler\n    });\n  }\n}\n\nvar on_1 = on;\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode$1(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = '';\n\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped  = exclude;\n    exclude = encode$1.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode$1.defaultChars   = \";/?:@&=+$,-_.!~*'()#\";\nencode$1.componentChars = \"-_.!~*'()\";\n\n\nvar encode_1 = encode$1;\n\nvar lib = {};\n\nvar decode = {};\n\nvar Aacute$1 = \"Á\";\nvar aacute$1 = \"á\";\nvar Abreve = \"Ă\";\nvar abreve = \"ă\";\nvar ac = \"∾\";\nvar acd = \"∿\";\nvar acE = \"∾̳\";\nvar Acirc$1 = \"Â\";\nvar acirc$1 = \"â\";\nvar acute$1 = \"´\";\nvar Acy = \"А\";\nvar acy = \"а\";\nvar AElig$1 = \"Æ\";\nvar aelig$1 = \"æ\";\nvar af = \"⁡\";\nvar Afr = \"𝔄\";\nvar afr = \"𝔞\";\nvar Agrave$1 = \"À\";\nvar agrave$1 = \"à\";\nvar alefsym = \"ℵ\";\nvar aleph = \"ℵ\";\nvar Alpha = \"Α\";\nvar alpha = \"α\";\nvar Amacr = \"Ā\";\nvar amacr = \"ā\";\nvar amalg = \"⨿\";\nvar amp$2 = \"&\";\nvar AMP$1 = \"&\";\nvar andand = \"⩕\";\nvar And = \"⩓\";\nvar and = \"∧\";\nvar andd = \"⩜\";\nvar andslope = \"⩘\";\nvar andv = \"⩚\";\nvar ang = \"∠\";\nvar ange = \"⦤\";\nvar angle = \"∠\";\nvar angmsdaa = \"⦨\";\nvar angmsdab = \"⦩\";\nvar angmsdac = \"⦪\";\nvar angmsdad = \"⦫\";\nvar angmsdae = \"⦬\";\nvar angmsdaf = \"⦭\";\nvar angmsdag = \"⦮\";\nvar angmsdah = \"⦯\";\nvar angmsd = \"∡\";\nvar angrt = \"∟\";\nvar angrtvb = \"⊾\";\nvar angrtvbd = \"⦝\";\nvar angsph = \"∢\";\nvar angst = \"Å\";\nvar angzarr = \"⍼\";\nvar Aogon = \"Ą\";\nvar aogon = \"ą\";\nvar Aopf = \"𝔸\";\nvar aopf = \"𝕒\";\nvar apacir = \"⩯\";\nvar ap = \"≈\";\nvar apE = \"⩰\";\nvar ape = \"≊\";\nvar apid = \"≋\";\nvar apos$1 = \"'\";\nvar ApplyFunction = \"⁡\";\nvar approx = \"≈\";\nvar approxeq = \"≊\";\nvar Aring$1 = \"Å\";\nvar aring$1 = \"å\";\nvar Ascr = \"𝒜\";\nvar ascr = \"𝒶\";\nvar Assign = \"≔\";\nvar ast = \"*\";\nvar asymp = \"≈\";\nvar asympeq = \"≍\";\nvar Atilde$1 = \"Ã\";\nvar atilde$1 = \"ã\";\nvar Auml$1 = \"Ä\";\nvar auml$1 = \"ä\";\nvar awconint = \"∳\";\nvar awint = \"⨑\";\nvar backcong = \"≌\";\nvar backepsilon = \"϶\";\nvar backprime = \"‵\";\nvar backsim = \"∽\";\nvar backsimeq = \"⋍\";\nvar Backslash = \"∖\";\nvar Barv = \"⫧\";\nvar barvee = \"⊽\";\nvar barwed = \"⌅\";\nvar Barwed = \"⌆\";\nvar barwedge = \"⌅\";\nvar bbrk = \"⎵\";\nvar bbrktbrk = \"⎶\";\nvar bcong = \"≌\";\nvar Bcy = \"Б\";\nvar bcy = \"б\";\nvar bdquo = \"„\";\nvar becaus = \"∵\";\nvar because = \"∵\";\nvar Because = \"∵\";\nvar bemptyv = \"⦰\";\nvar bepsi = \"϶\";\nvar bernou = \"ℬ\";\nvar Bernoullis = \"ℬ\";\nvar Beta = \"Β\";\nvar beta = \"β\";\nvar beth = \"ℶ\";\nvar between = \"≬\";\nvar Bfr = \"𝔅\";\nvar bfr = \"𝔟\";\nvar bigcap = \"⋂\";\nvar bigcirc = \"◯\";\nvar bigcup = \"⋃\";\nvar bigodot = \"⨀\";\nvar bigoplus = \"⨁\";\nvar bigotimes = \"⨂\";\nvar bigsqcup = \"⨆\";\nvar bigstar = \"★\";\nvar bigtriangledown = \"▽\";\nvar bigtriangleup = \"△\";\nvar biguplus = \"⨄\";\nvar bigvee = \"⋁\";\nvar bigwedge = \"⋀\";\nvar bkarow = \"⤍\";\nvar blacklozenge = \"⧫\";\nvar blacksquare = \"▪\";\nvar blacktriangle = \"▴\";\nvar blacktriangledown = \"▾\";\nvar blacktriangleleft = \"◂\";\nvar blacktriangleright = \"▸\";\nvar blank = \"␣\";\nvar blk12 = \"▒\";\nvar blk14 = \"░\";\nvar blk34 = \"▓\";\nvar block = \"█\";\nvar bne = \"=⃥\";\nvar bnequiv = \"≡⃥\";\nvar bNot = \"⫭\";\nvar bnot = \"⌐\";\nvar Bopf = \"𝔹\";\nvar bopf = \"𝕓\";\nvar bot = \"⊥\";\nvar bottom = \"⊥\";\nvar bowtie = \"⋈\";\nvar boxbox = \"⧉\";\nvar boxdl = \"┐\";\nvar boxdL = \"╕\";\nvar boxDl = \"╖\";\nvar boxDL = \"╗\";\nvar boxdr = \"┌\";\nvar boxdR = \"╒\";\nvar boxDr = \"╓\";\nvar boxDR = \"╔\";\nvar boxh = \"─\";\nvar boxH = \"═\";\nvar boxhd = \"┬\";\nvar boxHd = \"╤\";\nvar boxhD = \"╥\";\nvar boxHD = \"╦\";\nvar boxhu = \"┴\";\nvar boxHu = \"╧\";\nvar boxhU = \"╨\";\nvar boxHU = \"╩\";\nvar boxminus = \"⊟\";\nvar boxplus = \"⊞\";\nvar boxtimes = \"⊠\";\nvar boxul = \"┘\";\nvar boxuL = \"╛\";\nvar boxUl = \"╜\";\nvar boxUL = \"╝\";\nvar boxur = \"└\";\nvar boxuR = \"╘\";\nvar boxUr = \"╙\";\nvar boxUR = \"╚\";\nvar boxv = \"│\";\nvar boxV = \"║\";\nvar boxvh = \"┼\";\nvar boxvH = \"╪\";\nvar boxVh = \"╫\";\nvar boxVH = \"╬\";\nvar boxvl = \"┤\";\nvar boxvL = \"╡\";\nvar boxVl = \"╢\";\nvar boxVL = \"╣\";\nvar boxvr = \"├\";\nvar boxvR = \"╞\";\nvar boxVr = \"╟\";\nvar boxVR = \"╠\";\nvar bprime = \"‵\";\nvar breve = \"˘\";\nvar Breve = \"˘\";\nvar brvbar$1 = \"¦\";\nvar bscr = \"𝒷\";\nvar Bscr = \"ℬ\";\nvar bsemi = \"⁏\";\nvar bsim = \"∽\";\nvar bsime = \"⋍\";\nvar bsolb = \"⧅\";\nvar bsol = \"\\\\\";\nvar bsolhsub = \"⟈\";\nvar bull = \"•\";\nvar bullet = \"•\";\nvar bump = \"≎\";\nvar bumpE = \"⪮\";\nvar bumpe = \"≏\";\nvar Bumpeq = \"≎\";\nvar bumpeq = \"≏\";\nvar Cacute = \"Ć\";\nvar cacute = \"ć\";\nvar capand = \"⩄\";\nvar capbrcup = \"⩉\";\nvar capcap = \"⩋\";\nvar cap = \"∩\";\nvar Cap = \"⋒\";\nvar capcup = \"⩇\";\nvar capdot = \"⩀\";\nvar CapitalDifferentialD = \"ⅅ\";\nvar caps = \"∩︀\";\nvar caret = \"⁁\";\nvar caron = \"ˇ\";\nvar Cayleys = \"ℭ\";\nvar ccaps = \"⩍\";\nvar Ccaron = \"Č\";\nvar ccaron = \"č\";\nvar Ccedil$1 = \"Ç\";\nvar ccedil$1 = \"ç\";\nvar Ccirc = \"Ĉ\";\nvar ccirc = \"ĉ\";\nvar Cconint = \"∰\";\nvar ccups = \"⩌\";\nvar ccupssm = \"⩐\";\nvar Cdot = \"Ċ\";\nvar cdot = \"ċ\";\nvar cedil$1 = \"¸\";\nvar Cedilla = \"¸\";\nvar cemptyv = \"⦲\";\nvar cent$1 = \"¢\";\nvar centerdot = \"·\";\nvar CenterDot = \"·\";\nvar cfr = \"𝔠\";\nvar Cfr = \"ℭ\";\nvar CHcy = \"Ч\";\nvar chcy = \"ч\";\nvar check = \"✓\";\nvar checkmark = \"✓\";\nvar Chi = \"Χ\";\nvar chi = \"χ\";\nvar circ = \"ˆ\";\nvar circeq = \"≗\";\nvar circlearrowleft = \"↺\";\nvar circlearrowright = \"↻\";\nvar circledast = \"⊛\";\nvar circledcirc = \"⊚\";\nvar circleddash = \"⊝\";\nvar CircleDot = \"⊙\";\nvar circledR = \"®\";\nvar circledS = \"Ⓢ\";\nvar CircleMinus = \"⊖\";\nvar CirclePlus = \"⊕\";\nvar CircleTimes = \"⊗\";\nvar cir = \"○\";\nvar cirE = \"⧃\";\nvar cire = \"≗\";\nvar cirfnint = \"⨐\";\nvar cirmid = \"⫯\";\nvar cirscir = \"⧂\";\nvar ClockwiseContourIntegral = \"∲\";\nvar CloseCurlyDoubleQuote = \"”\";\nvar CloseCurlyQuote = \"’\";\nvar clubs = \"♣\";\nvar clubsuit = \"♣\";\nvar colon = \":\";\nvar Colon = \"∷\";\nvar Colone = \"⩴\";\nvar colone = \"≔\";\nvar coloneq = \"≔\";\nvar comma = \",\";\nvar commat = \"@\";\nvar comp = \"∁\";\nvar compfn = \"∘\";\nvar complement = \"∁\";\nvar complexes = \"ℂ\";\nvar cong = \"≅\";\nvar congdot = \"⩭\";\nvar Congruent = \"≡\";\nvar conint = \"∮\";\nvar Conint = \"∯\";\nvar ContourIntegral = \"∮\";\nvar copf = \"𝕔\";\nvar Copf = \"ℂ\";\nvar coprod = \"∐\";\nvar Coproduct = \"∐\";\nvar copy$1 = \"©\";\nvar COPY$1 = \"©\";\nvar copysr = \"℗\";\nvar CounterClockwiseContourIntegral = \"∳\";\nvar crarr = \"↵\";\nvar cross = \"✗\";\nvar Cross = \"⨯\";\nvar Cscr = \"𝒞\";\nvar cscr = \"𝒸\";\nvar csub = \"⫏\";\nvar csube = \"⫑\";\nvar csup = \"⫐\";\nvar csupe = \"⫒\";\nvar ctdot = \"⋯\";\nvar cudarrl = \"⤸\";\nvar cudarrr = \"⤵\";\nvar cuepr = \"⋞\";\nvar cuesc = \"⋟\";\nvar cularr = \"↶\";\nvar cularrp = \"⤽\";\nvar cupbrcap = \"⩈\";\nvar cupcap = \"⩆\";\nvar CupCap = \"≍\";\nvar cup = \"∪\";\nvar Cup = \"⋓\";\nvar cupcup = \"⩊\";\nvar cupdot = \"⊍\";\nvar cupor = \"⩅\";\nvar cups = \"∪︀\";\nvar curarr = \"↷\";\nvar curarrm = \"⤼\";\nvar curlyeqprec = \"⋞\";\nvar curlyeqsucc = \"⋟\";\nvar curlyvee = \"⋎\";\nvar curlywedge = \"⋏\";\nvar curren$1 = \"¤\";\nvar curvearrowleft = \"↶\";\nvar curvearrowright = \"↷\";\nvar cuvee = \"⋎\";\nvar cuwed = \"⋏\";\nvar cwconint = \"∲\";\nvar cwint = \"∱\";\nvar cylcty = \"⌭\";\nvar dagger = \"†\";\nvar Dagger = \"‡\";\nvar daleth = \"ℸ\";\nvar darr = \"↓\";\nvar Darr = \"↡\";\nvar dArr = \"⇓\";\nvar dash = \"‐\";\nvar Dashv = \"⫤\";\nvar dashv = \"⊣\";\nvar dbkarow = \"⤏\";\nvar dblac = \"˝\";\nvar Dcaron = \"Ď\";\nvar dcaron = \"ď\";\nvar Dcy = \"Д\";\nvar dcy = \"д\";\nvar ddagger = \"‡\";\nvar ddarr = \"⇊\";\nvar DD = \"ⅅ\";\nvar dd = \"ⅆ\";\nvar DDotrahd = \"⤑\";\nvar ddotseq = \"⩷\";\nvar deg$1 = \"°\";\nvar Del = \"∇\";\nvar Delta = \"Δ\";\nvar delta = \"δ\";\nvar demptyv = \"⦱\";\nvar dfisht = \"⥿\";\nvar Dfr = \"𝔇\";\nvar dfr = \"𝔡\";\nvar dHar = \"⥥\";\nvar dharl = \"⇃\";\nvar dharr = \"⇂\";\nvar DiacriticalAcute = \"´\";\nvar DiacriticalDot = \"˙\";\nvar DiacriticalDoubleAcute = \"˝\";\nvar DiacriticalGrave = \"`\";\nvar DiacriticalTilde = \"˜\";\nvar diam = \"⋄\";\nvar diamond = \"⋄\";\nvar Diamond = \"⋄\";\nvar diamondsuit = \"♦\";\nvar diams = \"♦\";\nvar die = \"¨\";\nvar DifferentialD = \"ⅆ\";\nvar digamma = \"ϝ\";\nvar disin = \"⋲\";\nvar div = \"÷\";\nvar divide$1 = \"÷\";\nvar divideontimes = \"⋇\";\nvar divonx = \"⋇\";\nvar DJcy = \"Ђ\";\nvar djcy = \"ђ\";\nvar dlcorn = \"⌞\";\nvar dlcrop = \"⌍\";\nvar dollar = \"$\";\nvar Dopf = \"𝔻\";\nvar dopf = \"𝕕\";\nvar Dot = \"¨\";\nvar dot = \"˙\";\nvar DotDot = \"⃜\";\nvar doteq = \"≐\";\nvar doteqdot = \"≑\";\nvar DotEqual = \"≐\";\nvar dotminus = \"∸\";\nvar dotplus = \"∔\";\nvar dotsquare = \"⊡\";\nvar doublebarwedge = \"⌆\";\nvar DoubleContourIntegral = \"∯\";\nvar DoubleDot = \"¨\";\nvar DoubleDownArrow = \"⇓\";\nvar DoubleLeftArrow = \"⇐\";\nvar DoubleLeftRightArrow = \"⇔\";\nvar DoubleLeftTee = \"⫤\";\nvar DoubleLongLeftArrow = \"⟸\";\nvar DoubleLongLeftRightArrow = \"⟺\";\nvar DoubleLongRightArrow = \"⟹\";\nvar DoubleRightArrow = \"⇒\";\nvar DoubleRightTee = \"⊨\";\nvar DoubleUpArrow = \"⇑\";\nvar DoubleUpDownArrow = \"⇕\";\nvar DoubleVerticalBar = \"∥\";\nvar DownArrowBar = \"⤓\";\nvar downarrow = \"↓\";\nvar DownArrow = \"↓\";\nvar Downarrow = \"⇓\";\nvar DownArrowUpArrow = \"⇵\";\nvar DownBreve = \"̑\";\nvar downdownarrows = \"⇊\";\nvar downharpoonleft = \"⇃\";\nvar downharpoonright = \"⇂\";\nvar DownLeftRightVector = \"⥐\";\nvar DownLeftTeeVector = \"⥞\";\nvar DownLeftVectorBar = \"⥖\";\nvar DownLeftVector = \"↽\";\nvar DownRightTeeVector = \"⥟\";\nvar DownRightVectorBar = \"⥗\";\nvar DownRightVector = \"⇁\";\nvar DownTeeArrow = \"↧\";\nvar DownTee = \"⊤\";\nvar drbkarow = \"⤐\";\nvar drcorn = \"⌟\";\nvar drcrop = \"⌌\";\nvar Dscr = \"𝒟\";\nvar dscr = \"𝒹\";\nvar DScy = \"Ѕ\";\nvar dscy = \"ѕ\";\nvar dsol = \"⧶\";\nvar Dstrok = \"Đ\";\nvar dstrok = \"đ\";\nvar dtdot = \"⋱\";\nvar dtri = \"▿\";\nvar dtrif = \"▾\";\nvar duarr = \"⇵\";\nvar duhar = \"⥯\";\nvar dwangle = \"⦦\";\nvar DZcy = \"Џ\";\nvar dzcy = \"џ\";\nvar dzigrarr = \"⟿\";\nvar Eacute$1 = \"É\";\nvar eacute$1 = \"é\";\nvar easter = \"⩮\";\nvar Ecaron = \"Ě\";\nvar ecaron = \"ě\";\nvar Ecirc$1 = \"Ê\";\nvar ecirc$1 = \"ê\";\nvar ecir = \"≖\";\nvar ecolon = \"≕\";\nvar Ecy = \"Э\";\nvar ecy = \"э\";\nvar eDDot = \"⩷\";\nvar Edot = \"Ė\";\nvar edot = \"ė\";\nvar eDot = \"≑\";\nvar ee = \"ⅇ\";\nvar efDot = \"≒\";\nvar Efr = \"𝔈\";\nvar efr = \"𝔢\";\nvar eg = \"⪚\";\nvar Egrave$1 = \"È\";\nvar egrave$1 = \"è\";\nvar egs = \"⪖\";\nvar egsdot = \"⪘\";\nvar el = \"⪙\";\nvar Element$1 = \"∈\";\nvar elinters = \"⏧\";\nvar ell = \"ℓ\";\nvar els = \"⪕\";\nvar elsdot = \"⪗\";\nvar Emacr = \"Ē\";\nvar emacr = \"ē\";\nvar empty = \"∅\";\nvar emptyset = \"∅\";\nvar EmptySmallSquare = \"◻\";\nvar emptyv = \"∅\";\nvar EmptyVerySmallSquare = \"▫\";\nvar emsp13 = \" \";\nvar emsp14 = \" \";\nvar emsp = \" \";\nvar ENG = \"Ŋ\";\nvar eng = \"ŋ\";\nvar ensp = \" \";\nvar Eogon = \"Ę\";\nvar eogon = \"ę\";\nvar Eopf = \"𝔼\";\nvar eopf = \"𝕖\";\nvar epar = \"⋕\";\nvar eparsl = \"⧣\";\nvar eplus = \"⩱\";\nvar epsi = \"ε\";\nvar Epsilon = \"Ε\";\nvar epsilon = \"ε\";\nvar epsiv = \"ϵ\";\nvar eqcirc = \"≖\";\nvar eqcolon = \"≕\";\nvar eqsim = \"≂\";\nvar eqslantgtr = \"⪖\";\nvar eqslantless = \"⪕\";\nvar Equal = \"⩵\";\nvar equals = \"=\";\nvar EqualTilde = \"≂\";\nvar equest = \"≟\";\nvar Equilibrium = \"⇌\";\nvar equiv = \"≡\";\nvar equivDD = \"⩸\";\nvar eqvparsl = \"⧥\";\nvar erarr = \"⥱\";\nvar erDot = \"≓\";\nvar escr = \"ℯ\";\nvar Escr = \"ℰ\";\nvar esdot = \"≐\";\nvar Esim = \"⩳\";\nvar esim = \"≂\";\nvar Eta = \"Η\";\nvar eta = \"η\";\nvar ETH$1 = \"Ð\";\nvar eth$1 = \"ð\";\nvar Euml$1 = \"Ë\";\nvar euml$1 = \"ë\";\nvar euro = \"€\";\nvar excl = \"!\";\nvar exist = \"∃\";\nvar Exists = \"∃\";\nvar expectation = \"ℰ\";\nvar exponentiale = \"ⅇ\";\nvar ExponentialE = \"ⅇ\";\nvar fallingdotseq = \"≒\";\nvar Fcy = \"Ф\";\nvar fcy = \"ф\";\nvar female = \"♀\";\nvar ffilig = \"ﬃ\";\nvar fflig = \"ﬀ\";\nvar ffllig = \"ﬄ\";\nvar Ffr = \"𝔉\";\nvar ffr = \"𝔣\";\nvar filig = \"ﬁ\";\nvar FilledSmallSquare = \"◼\";\nvar FilledVerySmallSquare = \"▪\";\nvar fjlig = \"fj\";\nvar flat = \"♭\";\nvar fllig = \"ﬂ\";\nvar fltns = \"▱\";\nvar fnof = \"ƒ\";\nvar Fopf = \"𝔽\";\nvar fopf = \"𝕗\";\nvar forall = \"∀\";\nvar ForAll = \"∀\";\nvar fork = \"⋔\";\nvar forkv = \"⫙\";\nvar Fouriertrf = \"ℱ\";\nvar fpartint = \"⨍\";\nvar frac12$1 = \"½\";\nvar frac13 = \"⅓\";\nvar frac14$1 = \"¼\";\nvar frac15 = \"⅕\";\nvar frac16 = \"⅙\";\nvar frac18 = \"⅛\";\nvar frac23 = \"⅔\";\nvar frac25 = \"⅖\";\nvar frac34$1 = \"¾\";\nvar frac35 = \"⅗\";\nvar frac38 = \"⅜\";\nvar frac45 = \"⅘\";\nvar frac56 = \"⅚\";\nvar frac58 = \"⅝\";\nvar frac78 = \"⅞\";\nvar frasl = \"⁄\";\nvar frown = \"⌢\";\nvar fscr = \"𝒻\";\nvar Fscr = \"ℱ\";\nvar gacute = \"ǵ\";\nvar Gamma = \"Γ\";\nvar gamma = \"γ\";\nvar Gammad = \"Ϝ\";\nvar gammad = \"ϝ\";\nvar gap = \"⪆\";\nvar Gbreve = \"Ğ\";\nvar gbreve = \"ğ\";\nvar Gcedil = \"Ģ\";\nvar Gcirc = \"Ĝ\";\nvar gcirc = \"ĝ\";\nvar Gcy = \"Г\";\nvar gcy = \"г\";\nvar Gdot = \"Ġ\";\nvar gdot = \"ġ\";\nvar ge = \"≥\";\nvar gE = \"≧\";\nvar gEl = \"⪌\";\nvar gel = \"⋛\";\nvar geq = \"≥\";\nvar geqq = \"≧\";\nvar geqslant = \"⩾\";\nvar gescc = \"⪩\";\nvar ges = \"⩾\";\nvar gesdot = \"⪀\";\nvar gesdoto = \"⪂\";\nvar gesdotol = \"⪄\";\nvar gesl = \"⋛︀\";\nvar gesles = \"⪔\";\nvar Gfr = \"𝔊\";\nvar gfr = \"𝔤\";\nvar gg = \"≫\";\nvar Gg = \"⋙\";\nvar ggg = \"⋙\";\nvar gimel = \"ℷ\";\nvar GJcy = \"Ѓ\";\nvar gjcy = \"ѓ\";\nvar gla = \"⪥\";\nvar gl = \"≷\";\nvar glE = \"⪒\";\nvar glj = \"⪤\";\nvar gnap = \"⪊\";\nvar gnapprox = \"⪊\";\nvar gne = \"⪈\";\nvar gnE = \"≩\";\nvar gneq = \"⪈\";\nvar gneqq = \"≩\";\nvar gnsim = \"⋧\";\nvar Gopf = \"𝔾\";\nvar gopf = \"𝕘\";\nvar grave = \"`\";\nvar GreaterEqual = \"≥\";\nvar GreaterEqualLess = \"⋛\";\nvar GreaterFullEqual = \"≧\";\nvar GreaterGreater = \"⪢\";\nvar GreaterLess = \"≷\";\nvar GreaterSlantEqual = \"⩾\";\nvar GreaterTilde = \"≳\";\nvar Gscr = \"𝒢\";\nvar gscr = \"ℊ\";\nvar gsim = \"≳\";\nvar gsime = \"⪎\";\nvar gsiml = \"⪐\";\nvar gtcc = \"⪧\";\nvar gtcir = \"⩺\";\nvar gt$2 = \">\";\nvar GT$1 = \">\";\nvar Gt = \"≫\";\nvar gtdot = \"⋗\";\nvar gtlPar = \"⦕\";\nvar gtquest = \"⩼\";\nvar gtrapprox = \"⪆\";\nvar gtrarr = \"⥸\";\nvar gtrdot = \"⋗\";\nvar gtreqless = \"⋛\";\nvar gtreqqless = \"⪌\";\nvar gtrless = \"≷\";\nvar gtrsim = \"≳\";\nvar gvertneqq = \"≩︀\";\nvar gvnE = \"≩︀\";\nvar Hacek = \"ˇ\";\nvar hairsp = \" \";\nvar half = \"½\";\nvar hamilt = \"ℋ\";\nvar HARDcy = \"Ъ\";\nvar hardcy = \"ъ\";\nvar harrcir = \"⥈\";\nvar harr = \"↔\";\nvar hArr = \"⇔\";\nvar harrw = \"↭\";\nvar Hat = \"^\";\nvar hbar = \"ℏ\";\nvar Hcirc = \"Ĥ\";\nvar hcirc = \"ĥ\";\nvar hearts = \"♥\";\nvar heartsuit = \"♥\";\nvar hellip = \"…\";\nvar hercon = \"⊹\";\nvar hfr = \"𝔥\";\nvar Hfr = \"ℌ\";\nvar HilbertSpace = \"ℋ\";\nvar hksearow = \"⤥\";\nvar hkswarow = \"⤦\";\nvar hoarr = \"⇿\";\nvar homtht = \"∻\";\nvar hookleftarrow = \"↩\";\nvar hookrightarrow = \"↪\";\nvar hopf = \"𝕙\";\nvar Hopf = \"ℍ\";\nvar horbar = \"―\";\nvar HorizontalLine = \"─\";\nvar hscr = \"𝒽\";\nvar Hscr = \"ℋ\";\nvar hslash = \"ℏ\";\nvar Hstrok = \"Ħ\";\nvar hstrok = \"ħ\";\nvar HumpDownHump = \"≎\";\nvar HumpEqual = \"≏\";\nvar hybull = \"⁃\";\nvar hyphen = \"‐\";\nvar Iacute$1 = \"Í\";\nvar iacute$1 = \"í\";\nvar ic = \"⁣\";\nvar Icirc$1 = \"Î\";\nvar icirc$1 = \"î\";\nvar Icy = \"И\";\nvar icy = \"и\";\nvar Idot = \"İ\";\nvar IEcy = \"Е\";\nvar iecy = \"е\";\nvar iexcl$1 = \"¡\";\nvar iff = \"⇔\";\nvar ifr = \"𝔦\";\nvar Ifr = \"ℑ\";\nvar Igrave$1 = \"Ì\";\nvar igrave$1 = \"ì\";\nvar ii = \"ⅈ\";\nvar iiiint = \"⨌\";\nvar iiint = \"∭\";\nvar iinfin = \"⧜\";\nvar iiota = \"℩\";\nvar IJlig = \"Ĳ\";\nvar ijlig = \"ĳ\";\nvar Imacr = \"Ī\";\nvar imacr = \"ī\";\nvar image = \"ℑ\";\nvar ImaginaryI = \"ⅈ\";\nvar imagline = \"ℐ\";\nvar imagpart = \"ℑ\";\nvar imath = \"ı\";\nvar Im = \"ℑ\";\nvar imof = \"⊷\";\nvar imped = \"Ƶ\";\nvar Implies = \"⇒\";\nvar incare = \"℅\";\nvar infin = \"∞\";\nvar infintie = \"⧝\";\nvar inodot = \"ı\";\nvar intcal = \"⊺\";\nvar int = \"∫\";\nvar Int = \"∬\";\nvar integers = \"ℤ\";\nvar Integral = \"∫\";\nvar intercal = \"⊺\";\nvar Intersection = \"⋂\";\nvar intlarhk = \"⨗\";\nvar intprod = \"⨼\";\nvar InvisibleComma = \"⁣\";\nvar InvisibleTimes = \"⁢\";\nvar IOcy = \"Ё\";\nvar iocy = \"ё\";\nvar Iogon = \"Į\";\nvar iogon = \"į\";\nvar Iopf = \"𝕀\";\nvar iopf = \"𝕚\";\nvar Iota = \"Ι\";\nvar iota = \"ι\";\nvar iprod = \"⨼\";\nvar iquest$1 = \"¿\";\nvar iscr = \"𝒾\";\nvar Iscr = \"ℐ\";\nvar isin = \"∈\";\nvar isindot = \"⋵\";\nvar isinE = \"⋹\";\nvar isins = \"⋴\";\nvar isinsv = \"⋳\";\nvar isinv = \"∈\";\nvar it = \"⁢\";\nvar Itilde = \"Ĩ\";\nvar itilde = \"ĩ\";\nvar Iukcy = \"І\";\nvar iukcy = \"і\";\nvar Iuml$1 = \"Ï\";\nvar iuml$1 = \"ï\";\nvar Jcirc = \"Ĵ\";\nvar jcirc = \"ĵ\";\nvar Jcy = \"Й\";\nvar jcy = \"й\";\nvar Jfr = \"𝔍\";\nvar jfr = \"𝔧\";\nvar jmath = \"ȷ\";\nvar Jopf = \"𝕁\";\nvar jopf = \"𝕛\";\nvar Jscr = \"𝒥\";\nvar jscr = \"𝒿\";\nvar Jsercy = \"Ј\";\nvar jsercy = \"ј\";\nvar Jukcy = \"Є\";\nvar jukcy = \"є\";\nvar Kappa = \"Κ\";\nvar kappa = \"κ\";\nvar kappav = \"ϰ\";\nvar Kcedil = \"Ķ\";\nvar kcedil = \"ķ\";\nvar Kcy = \"К\";\nvar kcy = \"к\";\nvar Kfr = \"𝔎\";\nvar kfr = \"𝔨\";\nvar kgreen = \"ĸ\";\nvar KHcy = \"Х\";\nvar khcy = \"х\";\nvar KJcy = \"Ќ\";\nvar kjcy = \"ќ\";\nvar Kopf = \"𝕂\";\nvar kopf = \"𝕜\";\nvar Kscr = \"𝒦\";\nvar kscr = \"𝓀\";\nvar lAarr = \"⇚\";\nvar Lacute = \"Ĺ\";\nvar lacute = \"ĺ\";\nvar laemptyv = \"⦴\";\nvar lagran = \"ℒ\";\nvar Lambda = \"Λ\";\nvar lambda = \"λ\";\nvar lang = \"⟨\";\nvar Lang = \"⟪\";\nvar langd = \"⦑\";\nvar langle = \"⟨\";\nvar lap = \"⪅\";\nvar Laplacetrf = \"ℒ\";\nvar laquo$1 = \"«\";\nvar larrb = \"⇤\";\nvar larrbfs = \"⤟\";\nvar larr = \"←\";\nvar Larr = \"↞\";\nvar lArr = \"⇐\";\nvar larrfs = \"⤝\";\nvar larrhk = \"↩\";\nvar larrlp = \"↫\";\nvar larrpl = \"⤹\";\nvar larrsim = \"⥳\";\nvar larrtl = \"↢\";\nvar latail = \"⤙\";\nvar lAtail = \"⤛\";\nvar lat = \"⪫\";\nvar late = \"⪭\";\nvar lates = \"⪭︀\";\nvar lbarr = \"⤌\";\nvar lBarr = \"⤎\";\nvar lbbrk = \"❲\";\nvar lbrace = \"{\";\nvar lbrack = \"[\";\nvar lbrke = \"⦋\";\nvar lbrksld = \"⦏\";\nvar lbrkslu = \"⦍\";\nvar Lcaron = \"Ľ\";\nvar lcaron = \"ľ\";\nvar Lcedil = \"Ļ\";\nvar lcedil = \"ļ\";\nvar lceil = \"⌈\";\nvar lcub = \"{\";\nvar Lcy = \"Л\";\nvar lcy = \"л\";\nvar ldca = \"⤶\";\nvar ldquo = \"“\";\nvar ldquor = \"„\";\nvar ldrdhar = \"⥧\";\nvar ldrushar = \"⥋\";\nvar ldsh = \"↲\";\nvar le = \"≤\";\nvar lE = \"≦\";\nvar LeftAngleBracket = \"⟨\";\nvar LeftArrowBar = \"⇤\";\nvar leftarrow = \"←\";\nvar LeftArrow = \"←\";\nvar Leftarrow = \"⇐\";\nvar LeftArrowRightArrow = \"⇆\";\nvar leftarrowtail = \"↢\";\nvar LeftCeiling = \"⌈\";\nvar LeftDoubleBracket = \"⟦\";\nvar LeftDownTeeVector = \"⥡\";\nvar LeftDownVectorBar = \"⥙\";\nvar LeftDownVector = \"⇃\";\nvar LeftFloor = \"⌊\";\nvar leftharpoondown = \"↽\";\nvar leftharpoonup = \"↼\";\nvar leftleftarrows = \"⇇\";\nvar leftrightarrow = \"↔\";\nvar LeftRightArrow = \"↔\";\nvar Leftrightarrow = \"⇔\";\nvar leftrightarrows = \"⇆\";\nvar leftrightharpoons = \"⇋\";\nvar leftrightsquigarrow = \"↭\";\nvar LeftRightVector = \"⥎\";\nvar LeftTeeArrow = \"↤\";\nvar LeftTee = \"⊣\";\nvar LeftTeeVector = \"⥚\";\nvar leftthreetimes = \"⋋\";\nvar LeftTriangleBar = \"⧏\";\nvar LeftTriangle = \"⊲\";\nvar LeftTriangleEqual = \"⊴\";\nvar LeftUpDownVector = \"⥑\";\nvar LeftUpTeeVector = \"⥠\";\nvar LeftUpVectorBar = \"⥘\";\nvar LeftUpVector = \"↿\";\nvar LeftVectorBar = \"⥒\";\nvar LeftVector = \"↼\";\nvar lEg = \"⪋\";\nvar leg = \"⋚\";\nvar leq = \"≤\";\nvar leqq = \"≦\";\nvar leqslant = \"⩽\";\nvar lescc = \"⪨\";\nvar les = \"⩽\";\nvar lesdot = \"⩿\";\nvar lesdoto = \"⪁\";\nvar lesdotor = \"⪃\";\nvar lesg = \"⋚︀\";\nvar lesges = \"⪓\";\nvar lessapprox = \"⪅\";\nvar lessdot = \"⋖\";\nvar lesseqgtr = \"⋚\";\nvar lesseqqgtr = \"⪋\";\nvar LessEqualGreater = \"⋚\";\nvar LessFullEqual = \"≦\";\nvar LessGreater = \"≶\";\nvar lessgtr = \"≶\";\nvar LessLess = \"⪡\";\nvar lesssim = \"≲\";\nvar LessSlantEqual = \"⩽\";\nvar LessTilde = \"≲\";\nvar lfisht = \"⥼\";\nvar lfloor = \"⌊\";\nvar Lfr = \"𝔏\";\nvar lfr = \"𝔩\";\nvar lg = \"≶\";\nvar lgE = \"⪑\";\nvar lHar = \"⥢\";\nvar lhard = \"↽\";\nvar lharu = \"↼\";\nvar lharul = \"⥪\";\nvar lhblk = \"▄\";\nvar LJcy = \"Љ\";\nvar ljcy = \"љ\";\nvar llarr = \"⇇\";\nvar ll = \"≪\";\nvar Ll = \"⋘\";\nvar llcorner = \"⌞\";\nvar Lleftarrow = \"⇚\";\nvar llhard = \"⥫\";\nvar lltri = \"◺\";\nvar Lmidot = \"Ŀ\";\nvar lmidot = \"ŀ\";\nvar lmoustache = \"⎰\";\nvar lmoust = \"⎰\";\nvar lnap = \"⪉\";\nvar lnapprox = \"⪉\";\nvar lne = \"⪇\";\nvar lnE = \"≨\";\nvar lneq = \"⪇\";\nvar lneqq = \"≨\";\nvar lnsim = \"⋦\";\nvar loang = \"⟬\";\nvar loarr = \"⇽\";\nvar lobrk = \"⟦\";\nvar longleftarrow = \"⟵\";\nvar LongLeftArrow = \"⟵\";\nvar Longleftarrow = \"⟸\";\nvar longleftrightarrow = \"⟷\";\nvar LongLeftRightArrow = \"⟷\";\nvar Longleftrightarrow = \"⟺\";\nvar longmapsto = \"⟼\";\nvar longrightarrow = \"⟶\";\nvar LongRightArrow = \"⟶\";\nvar Longrightarrow = \"⟹\";\nvar looparrowleft = \"↫\";\nvar looparrowright = \"↬\";\nvar lopar = \"⦅\";\nvar Lopf = \"𝕃\";\nvar lopf = \"𝕝\";\nvar loplus = \"⨭\";\nvar lotimes = \"⨴\";\nvar lowast = \"∗\";\nvar lowbar = \"_\";\nvar LowerLeftArrow = \"↙\";\nvar LowerRightArrow = \"↘\";\nvar loz = \"◊\";\nvar lozenge = \"◊\";\nvar lozf = \"⧫\";\nvar lpar = \"(\";\nvar lparlt = \"⦓\";\nvar lrarr = \"⇆\";\nvar lrcorner = \"⌟\";\nvar lrhar = \"⇋\";\nvar lrhard = \"⥭\";\nvar lrm = \"‎\";\nvar lrtri = \"⊿\";\nvar lsaquo = \"‹\";\nvar lscr = \"𝓁\";\nvar Lscr = \"ℒ\";\nvar lsh = \"↰\";\nvar Lsh = \"↰\";\nvar lsim = \"≲\";\nvar lsime = \"⪍\";\nvar lsimg = \"⪏\";\nvar lsqb = \"[\";\nvar lsquo = \"‘\";\nvar lsquor = \"‚\";\nvar Lstrok = \"Ł\";\nvar lstrok = \"ł\";\nvar ltcc = \"⪦\";\nvar ltcir = \"⩹\";\nvar lt$2 = \"<\";\nvar LT$1 = \"<\";\nvar Lt = \"≪\";\nvar ltdot = \"⋖\";\nvar lthree = \"⋋\";\nvar ltimes = \"⋉\";\nvar ltlarr = \"⥶\";\nvar ltquest = \"⩻\";\nvar ltri = \"◃\";\nvar ltrie = \"⊴\";\nvar ltrif = \"◂\";\nvar ltrPar = \"⦖\";\nvar lurdshar = \"⥊\";\nvar luruhar = \"⥦\";\nvar lvertneqq = \"≨︀\";\nvar lvnE = \"≨︀\";\nvar macr$1 = \"¯\";\nvar male = \"♂\";\nvar malt = \"✠\";\nvar maltese = \"✠\";\nvar map = \"↦\";\nvar mapsto = \"↦\";\nvar mapstodown = \"↧\";\nvar mapstoleft = \"↤\";\nvar mapstoup = \"↥\";\nvar marker = \"▮\";\nvar mcomma = \"⨩\";\nvar Mcy = \"М\";\nvar mcy = \"м\";\nvar mdash = \"—\";\nvar mDDot = \"∺\";\nvar measuredangle = \"∡\";\nvar MediumSpace = \" \";\nvar Mellintrf = \"ℳ\";\nvar Mfr = \"𝔐\";\nvar mfr = \"𝔪\";\nvar mho = \"℧\";\nvar micro$1 = \"µ\";\nvar midast = \"*\";\nvar midcir = \"⫰\";\nvar mid = \"∣\";\nvar middot$1 = \"·\";\nvar minusb = \"⊟\";\nvar minus = \"−\";\nvar minusd = \"∸\";\nvar minusdu = \"⨪\";\nvar MinusPlus = \"∓\";\nvar mlcp = \"⫛\";\nvar mldr = \"…\";\nvar mnplus = \"∓\";\nvar models = \"⊧\";\nvar Mopf = \"𝕄\";\nvar mopf = \"𝕞\";\nvar mp = \"∓\";\nvar mscr = \"𝓂\";\nvar Mscr = \"ℳ\";\nvar mstpos = \"∾\";\nvar Mu = \"Μ\";\nvar mu = \"μ\";\nvar multimap = \"⊸\";\nvar mumap = \"⊸\";\nvar nabla = \"∇\";\nvar Nacute = \"Ń\";\nvar nacute = \"ń\";\nvar nang = \"∠⃒\";\nvar nap = \"≉\";\nvar napE = \"⩰̸\";\nvar napid = \"≋̸\";\nvar napos = \"ŉ\";\nvar napprox = \"≉\";\nvar natural = \"♮\";\nvar naturals = \"ℕ\";\nvar natur = \"♮\";\nvar nbsp$1 = \" \";\nvar nbump = \"≎̸\";\nvar nbumpe = \"≏̸\";\nvar ncap = \"⩃\";\nvar Ncaron = \"Ň\";\nvar ncaron = \"ň\";\nvar Ncedil = \"Ņ\";\nvar ncedil = \"ņ\";\nvar ncong = \"≇\";\nvar ncongdot = \"⩭̸\";\nvar ncup = \"⩂\";\nvar Ncy = \"Н\";\nvar ncy = \"н\";\nvar ndash = \"–\";\nvar nearhk = \"⤤\";\nvar nearr = \"↗\";\nvar neArr = \"⇗\";\nvar nearrow = \"↗\";\nvar ne = \"≠\";\nvar nedot = \"≐̸\";\nvar NegativeMediumSpace = \"​\";\nvar NegativeThickSpace = \"​\";\nvar NegativeThinSpace = \"​\";\nvar NegativeVeryThinSpace = \"​\";\nvar nequiv = \"≢\";\nvar nesear = \"⤨\";\nvar nesim = \"≂̸\";\nvar NestedGreaterGreater = \"≫\";\nvar NestedLessLess = \"≪\";\nvar NewLine = \"\\n\";\nvar nexist = \"∄\";\nvar nexists = \"∄\";\nvar Nfr = \"𝔑\";\nvar nfr = \"𝔫\";\nvar ngE = \"≧̸\";\nvar nge = \"≱\";\nvar ngeq = \"≱\";\nvar ngeqq = \"≧̸\";\nvar ngeqslant = \"⩾̸\";\nvar nges = \"⩾̸\";\nvar nGg = \"⋙̸\";\nvar ngsim = \"≵\";\nvar nGt = \"≫⃒\";\nvar ngt = \"≯\";\nvar ngtr = \"≯\";\nvar nGtv = \"≫̸\";\nvar nharr = \"↮\";\nvar nhArr = \"⇎\";\nvar nhpar = \"⫲\";\nvar ni = \"∋\";\nvar nis = \"⋼\";\nvar nisd = \"⋺\";\nvar niv = \"∋\";\nvar NJcy = \"Њ\";\nvar njcy = \"њ\";\nvar nlarr = \"↚\";\nvar nlArr = \"⇍\";\nvar nldr = \"‥\";\nvar nlE = \"≦̸\";\nvar nle = \"≰\";\nvar nleftarrow = \"↚\";\nvar nLeftarrow = \"⇍\";\nvar nleftrightarrow = \"↮\";\nvar nLeftrightarrow = \"⇎\";\nvar nleq = \"≰\";\nvar nleqq = \"≦̸\";\nvar nleqslant = \"⩽̸\";\nvar nles = \"⩽̸\";\nvar nless = \"≮\";\nvar nLl = \"⋘̸\";\nvar nlsim = \"≴\";\nvar nLt = \"≪⃒\";\nvar nlt = \"≮\";\nvar nltri = \"⋪\";\nvar nltrie = \"⋬\";\nvar nLtv = \"≪̸\";\nvar nmid = \"∤\";\nvar NoBreak = \"⁠\";\nvar NonBreakingSpace = \" \";\nvar nopf = \"𝕟\";\nvar Nopf = \"ℕ\";\nvar Not = \"⫬\";\nvar not$1 = \"¬\";\nvar NotCongruent = \"≢\";\nvar NotCupCap = \"≭\";\nvar NotDoubleVerticalBar = \"∦\";\nvar NotElement = \"∉\";\nvar NotEqual = \"≠\";\nvar NotEqualTilde = \"≂̸\";\nvar NotExists = \"∄\";\nvar NotGreater = \"≯\";\nvar NotGreaterEqual = \"≱\";\nvar NotGreaterFullEqual = \"≧̸\";\nvar NotGreaterGreater = \"≫̸\";\nvar NotGreaterLess = \"≹\";\nvar NotGreaterSlantEqual = \"⩾̸\";\nvar NotGreaterTilde = \"≵\";\nvar NotHumpDownHump = \"≎̸\";\nvar NotHumpEqual = \"≏̸\";\nvar notin = \"∉\";\nvar notindot = \"⋵̸\";\nvar notinE = \"⋹̸\";\nvar notinva = \"∉\";\nvar notinvb = \"⋷\";\nvar notinvc = \"⋶\";\nvar NotLeftTriangleBar = \"⧏̸\";\nvar NotLeftTriangle = \"⋪\";\nvar NotLeftTriangleEqual = \"⋬\";\nvar NotLess = \"≮\";\nvar NotLessEqual = \"≰\";\nvar NotLessGreater = \"≸\";\nvar NotLessLess = \"≪̸\";\nvar NotLessSlantEqual = \"⩽̸\";\nvar NotLessTilde = \"≴\";\nvar NotNestedGreaterGreater = \"⪢̸\";\nvar NotNestedLessLess = \"⪡̸\";\nvar notni = \"∌\";\nvar notniva = \"∌\";\nvar notnivb = \"⋾\";\nvar notnivc = \"⋽\";\nvar NotPrecedes = \"⊀\";\nvar NotPrecedesEqual = \"⪯̸\";\nvar NotPrecedesSlantEqual = \"⋠\";\nvar NotReverseElement = \"∌\";\nvar NotRightTriangleBar = \"⧐̸\";\nvar NotRightTriangle = \"⋫\";\nvar NotRightTriangleEqual = \"⋭\";\nvar NotSquareSubset = \"⊏̸\";\nvar NotSquareSubsetEqual = \"⋢\";\nvar NotSquareSuperset = \"⊐̸\";\nvar NotSquareSupersetEqual = \"⋣\";\nvar NotSubset = \"⊂⃒\";\nvar NotSubsetEqual = \"⊈\";\nvar NotSucceeds = \"⊁\";\nvar NotSucceedsEqual = \"⪰̸\";\nvar NotSucceedsSlantEqual = \"⋡\";\nvar NotSucceedsTilde = \"≿̸\";\nvar NotSuperset = \"⊃⃒\";\nvar NotSupersetEqual = \"⊉\";\nvar NotTilde = \"≁\";\nvar NotTildeEqual = \"≄\";\nvar NotTildeFullEqual = \"≇\";\nvar NotTildeTilde = \"≉\";\nvar NotVerticalBar = \"∤\";\nvar nparallel = \"∦\";\nvar npar = \"∦\";\nvar nparsl = \"⫽⃥\";\nvar npart = \"∂̸\";\nvar npolint = \"⨔\";\nvar npr = \"⊀\";\nvar nprcue = \"⋠\";\nvar nprec = \"⊀\";\nvar npreceq = \"⪯̸\";\nvar npre = \"⪯̸\";\nvar nrarrc = \"⤳̸\";\nvar nrarr = \"↛\";\nvar nrArr = \"⇏\";\nvar nrarrw = \"↝̸\";\nvar nrightarrow = \"↛\";\nvar nRightarrow = \"⇏\";\nvar nrtri = \"⋫\";\nvar nrtrie = \"⋭\";\nvar nsc = \"⊁\";\nvar nsccue = \"⋡\";\nvar nsce = \"⪰̸\";\nvar Nscr = \"𝒩\";\nvar nscr = \"𝓃\";\nvar nshortmid = \"∤\";\nvar nshortparallel = \"∦\";\nvar nsim = \"≁\";\nvar nsime = \"≄\";\nvar nsimeq = \"≄\";\nvar nsmid = \"∤\";\nvar nspar = \"∦\";\nvar nsqsube = \"⋢\";\nvar nsqsupe = \"⋣\";\nvar nsub = \"⊄\";\nvar nsubE = \"⫅̸\";\nvar nsube = \"⊈\";\nvar nsubset = \"⊂⃒\";\nvar nsubseteq = \"⊈\";\nvar nsubseteqq = \"⫅̸\";\nvar nsucc = \"⊁\";\nvar nsucceq = \"⪰̸\";\nvar nsup = \"⊅\";\nvar nsupE = \"⫆̸\";\nvar nsupe = \"⊉\";\nvar nsupset = \"⊃⃒\";\nvar nsupseteq = \"⊉\";\nvar nsupseteqq = \"⫆̸\";\nvar ntgl = \"≹\";\nvar Ntilde$1 = \"Ñ\";\nvar ntilde$1 = \"ñ\";\nvar ntlg = \"≸\";\nvar ntriangleleft = \"⋪\";\nvar ntrianglelefteq = \"⋬\";\nvar ntriangleright = \"⋫\";\nvar ntrianglerighteq = \"⋭\";\nvar Nu = \"Ν\";\nvar nu = \"ν\";\nvar num = \"#\";\nvar numero = \"№\";\nvar numsp = \" \";\nvar nvap = \"≍⃒\";\nvar nvdash = \"⊬\";\nvar nvDash = \"⊭\";\nvar nVdash = \"⊮\";\nvar nVDash = \"⊯\";\nvar nvge = \"≥⃒\";\nvar nvgt = \">⃒\";\nvar nvHarr = \"⤄\";\nvar nvinfin = \"⧞\";\nvar nvlArr = \"⤂\";\nvar nvle = \"≤⃒\";\nvar nvlt = \"<⃒\";\nvar nvltrie = \"⊴⃒\";\nvar nvrArr = \"⤃\";\nvar nvrtrie = \"⊵⃒\";\nvar nvsim = \"∼⃒\";\nvar nwarhk = \"⤣\";\nvar nwarr = \"↖\";\nvar nwArr = \"⇖\";\nvar nwarrow = \"↖\";\nvar nwnear = \"⤧\";\nvar Oacute$1 = \"Ó\";\nvar oacute$1 = \"ó\";\nvar oast = \"⊛\";\nvar Ocirc$1 = \"Ô\";\nvar ocirc$1 = \"ô\";\nvar ocir = \"⊚\";\nvar Ocy = \"О\";\nvar ocy = \"о\";\nvar odash = \"⊝\";\nvar Odblac = \"Ő\";\nvar odblac = \"ő\";\nvar odiv = \"⨸\";\nvar odot = \"⊙\";\nvar odsold = \"⦼\";\nvar OElig = \"Œ\";\nvar oelig = \"œ\";\nvar ofcir = \"⦿\";\nvar Ofr = \"𝔒\";\nvar ofr = \"𝔬\";\nvar ogon = \"˛\";\nvar Ograve$1 = \"Ò\";\nvar ograve$1 = \"ò\";\nvar ogt = \"⧁\";\nvar ohbar = \"⦵\";\nvar ohm = \"Ω\";\nvar oint = \"∮\";\nvar olarr = \"↺\";\nvar olcir = \"⦾\";\nvar olcross = \"⦻\";\nvar oline = \"‾\";\nvar olt = \"⧀\";\nvar Omacr = \"Ō\";\nvar omacr = \"ō\";\nvar Omega = \"Ω\";\nvar omega = \"ω\";\nvar Omicron = \"Ο\";\nvar omicron = \"ο\";\nvar omid = \"⦶\";\nvar ominus = \"⊖\";\nvar Oopf = \"𝕆\";\nvar oopf = \"𝕠\";\nvar opar = \"⦷\";\nvar OpenCurlyDoubleQuote = \"“\";\nvar OpenCurlyQuote = \"‘\";\nvar operp = \"⦹\";\nvar oplus = \"⊕\";\nvar orarr = \"↻\";\nvar Or = \"⩔\";\nvar or = \"∨\";\nvar ord = \"⩝\";\nvar order = \"ℴ\";\nvar orderof = \"ℴ\";\nvar ordf$1 = \"ª\";\nvar ordm$1 = \"º\";\nvar origof = \"⊶\";\nvar oror = \"⩖\";\nvar orslope = \"⩗\";\nvar orv = \"⩛\";\nvar oS = \"Ⓢ\";\nvar Oscr = \"𝒪\";\nvar oscr = \"ℴ\";\nvar Oslash$1 = \"Ø\";\nvar oslash$1 = \"ø\";\nvar osol = \"⊘\";\nvar Otilde$1 = \"Õ\";\nvar otilde$1 = \"õ\";\nvar otimesas = \"⨶\";\nvar Otimes = \"⨷\";\nvar otimes = \"⊗\";\nvar Ouml$1 = \"Ö\";\nvar ouml$1 = \"ö\";\nvar ovbar = \"⌽\";\nvar OverBar = \"‾\";\nvar OverBrace = \"⏞\";\nvar OverBracket = \"⎴\";\nvar OverParenthesis = \"⏜\";\nvar para$1 = \"¶\";\nvar parallel = \"∥\";\nvar par = \"∥\";\nvar parsim = \"⫳\";\nvar parsl = \"⫽\";\nvar part = \"∂\";\nvar PartialD = \"∂\";\nvar Pcy = \"П\";\nvar pcy = \"п\";\nvar percnt = \"%\";\nvar period = \".\";\nvar permil = \"‰\";\nvar perp = \"⊥\";\nvar pertenk = \"‱\";\nvar Pfr = \"𝔓\";\nvar pfr = \"𝔭\";\nvar Phi = \"Φ\";\nvar phi = \"φ\";\nvar phiv = \"ϕ\";\nvar phmmat = \"ℳ\";\nvar phone = \"☎\";\nvar Pi = \"Π\";\nvar pi = \"π\";\nvar pitchfork = \"⋔\";\nvar piv = \"ϖ\";\nvar planck = \"ℏ\";\nvar planckh = \"ℎ\";\nvar plankv = \"ℏ\";\nvar plusacir = \"⨣\";\nvar plusb = \"⊞\";\nvar pluscir = \"⨢\";\nvar plus = \"+\";\nvar plusdo = \"∔\";\nvar plusdu = \"⨥\";\nvar pluse = \"⩲\";\nvar PlusMinus = \"±\";\nvar plusmn$1 = \"±\";\nvar plussim = \"⨦\";\nvar plustwo = \"⨧\";\nvar pm = \"±\";\nvar Poincareplane = \"ℌ\";\nvar pointint = \"⨕\";\nvar popf = \"𝕡\";\nvar Popf = \"ℙ\";\nvar pound$1 = \"£\";\nvar prap = \"⪷\";\nvar Pr = \"⪻\";\nvar pr = \"≺\";\nvar prcue = \"≼\";\nvar precapprox = \"⪷\";\nvar prec = \"≺\";\nvar preccurlyeq = \"≼\";\nvar Precedes = \"≺\";\nvar PrecedesEqual = \"⪯\";\nvar PrecedesSlantEqual = \"≼\";\nvar PrecedesTilde = \"≾\";\nvar preceq = \"⪯\";\nvar precnapprox = \"⪹\";\nvar precneqq = \"⪵\";\nvar precnsim = \"⋨\";\nvar pre = \"⪯\";\nvar prE = \"⪳\";\nvar precsim = \"≾\";\nvar prime = \"′\";\nvar Prime = \"″\";\nvar primes = \"ℙ\";\nvar prnap = \"⪹\";\nvar prnE = \"⪵\";\nvar prnsim = \"⋨\";\nvar prod = \"∏\";\nvar Product = \"∏\";\nvar profalar = \"⌮\";\nvar profline = \"⌒\";\nvar profsurf = \"⌓\";\nvar prop = \"∝\";\nvar Proportional = \"∝\";\nvar Proportion = \"∷\";\nvar propto = \"∝\";\nvar prsim = \"≾\";\nvar prurel = \"⊰\";\nvar Pscr = \"𝒫\";\nvar pscr = \"𝓅\";\nvar Psi = \"Ψ\";\nvar psi = \"ψ\";\nvar puncsp = \" \";\nvar Qfr = \"𝔔\";\nvar qfr = \"𝔮\";\nvar qint = \"⨌\";\nvar qopf = \"𝕢\";\nvar Qopf = \"ℚ\";\nvar qprime = \"⁗\";\nvar Qscr = \"𝒬\";\nvar qscr = \"𝓆\";\nvar quaternions = \"ℍ\";\nvar quatint = \"⨖\";\nvar quest = \"?\";\nvar questeq = \"≟\";\nvar quot$2 = \"\\\"\";\nvar QUOT$1 = \"\\\"\";\nvar rAarr = \"⇛\";\nvar race = \"∽̱\";\nvar Racute = \"Ŕ\";\nvar racute = \"ŕ\";\nvar radic = \"√\";\nvar raemptyv = \"⦳\";\nvar rang = \"⟩\";\nvar Rang = \"⟫\";\nvar rangd = \"⦒\";\nvar range = \"⦥\";\nvar rangle = \"⟩\";\nvar raquo$1 = \"»\";\nvar rarrap = \"⥵\";\nvar rarrb = \"⇥\";\nvar rarrbfs = \"⤠\";\nvar rarrc = \"⤳\";\nvar rarr = \"→\";\nvar Rarr = \"↠\";\nvar rArr = \"⇒\";\nvar rarrfs = \"⤞\";\nvar rarrhk = \"↪\";\nvar rarrlp = \"↬\";\nvar rarrpl = \"⥅\";\nvar rarrsim = \"⥴\";\nvar Rarrtl = \"⤖\";\nvar rarrtl = \"↣\";\nvar rarrw = \"↝\";\nvar ratail = \"⤚\";\nvar rAtail = \"⤜\";\nvar ratio = \"∶\";\nvar rationals = \"ℚ\";\nvar rbarr = \"⤍\";\nvar rBarr = \"⤏\";\nvar RBarr = \"⤐\";\nvar rbbrk = \"❳\";\nvar rbrace = \"}\";\nvar rbrack = \"]\";\nvar rbrke = \"⦌\";\nvar rbrksld = \"⦎\";\nvar rbrkslu = \"⦐\";\nvar Rcaron = \"Ř\";\nvar rcaron = \"ř\";\nvar Rcedil = \"Ŗ\";\nvar rcedil = \"ŗ\";\nvar rceil = \"⌉\";\nvar rcub = \"}\";\nvar Rcy = \"Р\";\nvar rcy = \"р\";\nvar rdca = \"⤷\";\nvar rdldhar = \"⥩\";\nvar rdquo = \"”\";\nvar rdquor = \"”\";\nvar rdsh = \"↳\";\nvar real = \"ℜ\";\nvar realine = \"ℛ\";\nvar realpart = \"ℜ\";\nvar reals = \"ℝ\";\nvar Re = \"ℜ\";\nvar rect = \"▭\";\nvar reg$1 = \"®\";\nvar REG$1 = \"®\";\nvar ReverseElement = \"∋\";\nvar ReverseEquilibrium = \"⇋\";\nvar ReverseUpEquilibrium = \"⥯\";\nvar rfisht = \"⥽\";\nvar rfloor = \"⌋\";\nvar rfr = \"𝔯\";\nvar Rfr = \"ℜ\";\nvar rHar = \"⥤\";\nvar rhard = \"⇁\";\nvar rharu = \"⇀\";\nvar rharul = \"⥬\";\nvar Rho = \"Ρ\";\nvar rho = \"ρ\";\nvar rhov = \"ϱ\";\nvar RightAngleBracket = \"⟩\";\nvar RightArrowBar = \"⇥\";\nvar rightarrow = \"→\";\nvar RightArrow = \"→\";\nvar Rightarrow = \"⇒\";\nvar RightArrowLeftArrow = \"⇄\";\nvar rightarrowtail = \"↣\";\nvar RightCeiling = \"⌉\";\nvar RightDoubleBracket = \"⟧\";\nvar RightDownTeeVector = \"⥝\";\nvar RightDownVectorBar = \"⥕\";\nvar RightDownVector = \"⇂\";\nvar RightFloor = \"⌋\";\nvar rightharpoondown = \"⇁\";\nvar rightharpoonup = \"⇀\";\nvar rightleftarrows = \"⇄\";\nvar rightleftharpoons = \"⇌\";\nvar rightrightarrows = \"⇉\";\nvar rightsquigarrow = \"↝\";\nvar RightTeeArrow = \"↦\";\nvar RightTee = \"⊢\";\nvar RightTeeVector = \"⥛\";\nvar rightthreetimes = \"⋌\";\nvar RightTriangleBar = \"⧐\";\nvar RightTriangle = \"⊳\";\nvar RightTriangleEqual = \"⊵\";\nvar RightUpDownVector = \"⥏\";\nvar RightUpTeeVector = \"⥜\";\nvar RightUpVectorBar = \"⥔\";\nvar RightUpVector = \"↾\";\nvar RightVectorBar = \"⥓\";\nvar RightVector = \"⇀\";\nvar ring = \"˚\";\nvar risingdotseq = \"≓\";\nvar rlarr = \"⇄\";\nvar rlhar = \"⇌\";\nvar rlm = \"‏\";\nvar rmoustache = \"⎱\";\nvar rmoust = \"⎱\";\nvar rnmid = \"⫮\";\nvar roang = \"⟭\";\nvar roarr = \"⇾\";\nvar robrk = \"⟧\";\nvar ropar = \"⦆\";\nvar ropf = \"𝕣\";\nvar Ropf = \"ℝ\";\nvar roplus = \"⨮\";\nvar rotimes = \"⨵\";\nvar RoundImplies = \"⥰\";\nvar rpar = \")\";\nvar rpargt = \"⦔\";\nvar rppolint = \"⨒\";\nvar rrarr = \"⇉\";\nvar Rrightarrow = \"⇛\";\nvar rsaquo = \"›\";\nvar rscr = \"𝓇\";\nvar Rscr = \"ℛ\";\nvar rsh = \"↱\";\nvar Rsh = \"↱\";\nvar rsqb = \"]\";\nvar rsquo = \"’\";\nvar rsquor = \"’\";\nvar rthree = \"⋌\";\nvar rtimes = \"⋊\";\nvar rtri = \"▹\";\nvar rtrie = \"⊵\";\nvar rtrif = \"▸\";\nvar rtriltri = \"⧎\";\nvar RuleDelayed = \"⧴\";\nvar ruluhar = \"⥨\";\nvar rx = \"℞\";\nvar Sacute = \"Ś\";\nvar sacute = \"ś\";\nvar sbquo = \"‚\";\nvar scap = \"⪸\";\nvar Scaron = \"Š\";\nvar scaron = \"š\";\nvar Sc = \"⪼\";\nvar sc = \"≻\";\nvar sccue = \"≽\";\nvar sce = \"⪰\";\nvar scE = \"⪴\";\nvar Scedil = \"Ş\";\nvar scedil = \"ş\";\nvar Scirc = \"Ŝ\";\nvar scirc = \"ŝ\";\nvar scnap = \"⪺\";\nvar scnE = \"⪶\";\nvar scnsim = \"⋩\";\nvar scpolint = \"⨓\";\nvar scsim = \"≿\";\nvar Scy = \"С\";\nvar scy = \"с\";\nvar sdotb = \"⊡\";\nvar sdot = \"⋅\";\nvar sdote = \"⩦\";\nvar searhk = \"⤥\";\nvar searr = \"↘\";\nvar seArr = \"⇘\";\nvar searrow = \"↘\";\nvar sect$1 = \"§\";\nvar semi = \";\";\nvar seswar = \"⤩\";\nvar setminus = \"∖\";\nvar setmn = \"∖\";\nvar sext = \"✶\";\nvar Sfr = \"𝔖\";\nvar sfr = \"𝔰\";\nvar sfrown = \"⌢\";\nvar sharp = \"♯\";\nvar SHCHcy = \"Щ\";\nvar shchcy = \"щ\";\nvar SHcy = \"Ш\";\nvar shcy = \"ш\";\nvar ShortDownArrow = \"↓\";\nvar ShortLeftArrow = \"←\";\nvar shortmid = \"∣\";\nvar shortparallel = \"∥\";\nvar ShortRightArrow = \"→\";\nvar ShortUpArrow = \"↑\";\nvar shy$1 = \"­\";\nvar Sigma = \"Σ\";\nvar sigma = \"σ\";\nvar sigmaf = \"ς\";\nvar sigmav = \"ς\";\nvar sim = \"∼\";\nvar simdot = \"⩪\";\nvar sime = \"≃\";\nvar simeq = \"≃\";\nvar simg = \"⪞\";\nvar simgE = \"⪠\";\nvar siml = \"⪝\";\nvar simlE = \"⪟\";\nvar simne = \"≆\";\nvar simplus = \"⨤\";\nvar simrarr = \"⥲\";\nvar slarr = \"←\";\nvar SmallCircle = \"∘\";\nvar smallsetminus = \"∖\";\nvar smashp = \"⨳\";\nvar smeparsl = \"⧤\";\nvar smid = \"∣\";\nvar smile = \"⌣\";\nvar smt = \"⪪\";\nvar smte = \"⪬\";\nvar smtes = \"⪬︀\";\nvar SOFTcy = \"Ь\";\nvar softcy = \"ь\";\nvar solbar = \"⌿\";\nvar solb = \"⧄\";\nvar sol = \"/\";\nvar Sopf = \"𝕊\";\nvar sopf = \"𝕤\";\nvar spades = \"♠\";\nvar spadesuit = \"♠\";\nvar spar = \"∥\";\nvar sqcap = \"⊓\";\nvar sqcaps = \"⊓︀\";\nvar sqcup = \"⊔\";\nvar sqcups = \"⊔︀\";\nvar Sqrt = \"√\";\nvar sqsub = \"⊏\";\nvar sqsube = \"⊑\";\nvar sqsubset = \"⊏\";\nvar sqsubseteq = \"⊑\";\nvar sqsup = \"⊐\";\nvar sqsupe = \"⊒\";\nvar sqsupset = \"⊐\";\nvar sqsupseteq = \"⊒\";\nvar square = \"□\";\nvar Square = \"□\";\nvar SquareIntersection = \"⊓\";\nvar SquareSubset = \"⊏\";\nvar SquareSubsetEqual = \"⊑\";\nvar SquareSuperset = \"⊐\";\nvar SquareSupersetEqual = \"⊒\";\nvar SquareUnion = \"⊔\";\nvar squarf = \"▪\";\nvar squ = \"□\";\nvar squf = \"▪\";\nvar srarr = \"→\";\nvar Sscr = \"𝒮\";\nvar sscr = \"𝓈\";\nvar ssetmn = \"∖\";\nvar ssmile = \"⌣\";\nvar sstarf = \"⋆\";\nvar Star = \"⋆\";\nvar star = \"☆\";\nvar starf = \"★\";\nvar straightepsilon = \"ϵ\";\nvar straightphi = \"ϕ\";\nvar strns = \"¯\";\nvar sub = \"⊂\";\nvar Sub = \"⋐\";\nvar subdot = \"⪽\";\nvar subE = \"⫅\";\nvar sube = \"⊆\";\nvar subedot = \"⫃\";\nvar submult = \"⫁\";\nvar subnE = \"⫋\";\nvar subne = \"⊊\";\nvar subplus = \"⪿\";\nvar subrarr = \"⥹\";\nvar subset = \"⊂\";\nvar Subset = \"⋐\";\nvar subseteq = \"⊆\";\nvar subseteqq = \"⫅\";\nvar SubsetEqual = \"⊆\";\nvar subsetneq = \"⊊\";\nvar subsetneqq = \"⫋\";\nvar subsim = \"⫇\";\nvar subsub = \"⫕\";\nvar subsup = \"⫓\";\nvar succapprox = \"⪸\";\nvar succ = \"≻\";\nvar succcurlyeq = \"≽\";\nvar Succeeds = \"≻\";\nvar SucceedsEqual = \"⪰\";\nvar SucceedsSlantEqual = \"≽\";\nvar SucceedsTilde = \"≿\";\nvar succeq = \"⪰\";\nvar succnapprox = \"⪺\";\nvar succneqq = \"⪶\";\nvar succnsim = \"⋩\";\nvar succsim = \"≿\";\nvar SuchThat = \"∋\";\nvar sum = \"∑\";\nvar Sum = \"∑\";\nvar sung = \"♪\";\nvar sup1$1 = \"¹\";\nvar sup2$1 = \"²\";\nvar sup3$1 = \"³\";\nvar sup = \"⊃\";\nvar Sup = \"⋑\";\nvar supdot = \"⪾\";\nvar supdsub = \"⫘\";\nvar supE = \"⫆\";\nvar supe = \"⊇\";\nvar supedot = \"⫄\";\nvar Superset = \"⊃\";\nvar SupersetEqual = \"⊇\";\nvar suphsol = \"⟉\";\nvar suphsub = \"⫗\";\nvar suplarr = \"⥻\";\nvar supmult = \"⫂\";\nvar supnE = \"⫌\";\nvar supne = \"⊋\";\nvar supplus = \"⫀\";\nvar supset = \"⊃\";\nvar Supset = \"⋑\";\nvar supseteq = \"⊇\";\nvar supseteqq = \"⫆\";\nvar supsetneq = \"⊋\";\nvar supsetneqq = \"⫌\";\nvar supsim = \"⫈\";\nvar supsub = \"⫔\";\nvar supsup = \"⫖\";\nvar swarhk = \"⤦\";\nvar swarr = \"↙\";\nvar swArr = \"⇙\";\nvar swarrow = \"↙\";\nvar swnwar = \"⤪\";\nvar szlig$1 = \"ß\";\nvar Tab = \"\\t\";\nvar target = \"⌖\";\nvar Tau = \"Τ\";\nvar tau = \"τ\";\nvar tbrk = \"⎴\";\nvar Tcaron = \"Ť\";\nvar tcaron = \"ť\";\nvar Tcedil = \"Ţ\";\nvar tcedil = \"ţ\";\nvar Tcy = \"Т\";\nvar tcy = \"т\";\nvar tdot = \"⃛\";\nvar telrec = \"⌕\";\nvar Tfr = \"𝔗\";\nvar tfr = \"𝔱\";\nvar there4 = \"∴\";\nvar therefore = \"∴\";\nvar Therefore = \"∴\";\nvar Theta = \"Θ\";\nvar theta = \"θ\";\nvar thetasym = \"ϑ\";\nvar thetav = \"ϑ\";\nvar thickapprox = \"≈\";\nvar thicksim = \"∼\";\nvar ThickSpace = \"  \";\nvar ThinSpace = \" \";\nvar thinsp = \" \";\nvar thkap = \"≈\";\nvar thksim = \"∼\";\nvar THORN$1 = \"Þ\";\nvar thorn$1 = \"þ\";\nvar tilde = \"˜\";\nvar Tilde = \"∼\";\nvar TildeEqual = \"≃\";\nvar TildeFullEqual = \"≅\";\nvar TildeTilde = \"≈\";\nvar timesbar = \"⨱\";\nvar timesb = \"⊠\";\nvar times$1 = \"×\";\nvar timesd = \"⨰\";\nvar tint = \"∭\";\nvar toea = \"⤨\";\nvar topbot = \"⌶\";\nvar topcir = \"⫱\";\nvar top = \"⊤\";\nvar Topf = \"𝕋\";\nvar topf = \"𝕥\";\nvar topfork = \"⫚\";\nvar tosa = \"⤩\";\nvar tprime = \"‴\";\nvar trade = \"™\";\nvar TRADE = \"™\";\nvar triangle = \"▵\";\nvar triangledown = \"▿\";\nvar triangleleft = \"◃\";\nvar trianglelefteq = \"⊴\";\nvar triangleq = \"≜\";\nvar triangleright = \"▹\";\nvar trianglerighteq = \"⊵\";\nvar tridot = \"◬\";\nvar trie = \"≜\";\nvar triminus = \"⨺\";\nvar TripleDot = \"⃛\";\nvar triplus = \"⨹\";\nvar trisb = \"⧍\";\nvar tritime = \"⨻\";\nvar trpezium = \"⏢\";\nvar Tscr = \"𝒯\";\nvar tscr = \"𝓉\";\nvar TScy = \"Ц\";\nvar tscy = \"ц\";\nvar TSHcy = \"Ћ\";\nvar tshcy = \"ћ\";\nvar Tstrok = \"Ŧ\";\nvar tstrok = \"ŧ\";\nvar twixt = \"≬\";\nvar twoheadleftarrow = \"↞\";\nvar twoheadrightarrow = \"↠\";\nvar Uacute$1 = \"Ú\";\nvar uacute$1 = \"ú\";\nvar uarr = \"↑\";\nvar Uarr = \"↟\";\nvar uArr = \"⇑\";\nvar Uarrocir = \"⥉\";\nvar Ubrcy = \"Ў\";\nvar ubrcy = \"ў\";\nvar Ubreve = \"Ŭ\";\nvar ubreve = \"ŭ\";\nvar Ucirc$1 = \"Û\";\nvar ucirc$1 = \"û\";\nvar Ucy = \"У\";\nvar ucy = \"у\";\nvar udarr = \"⇅\";\nvar Udblac = \"Ű\";\nvar udblac = \"ű\";\nvar udhar = \"⥮\";\nvar ufisht = \"⥾\";\nvar Ufr = \"𝔘\";\nvar ufr = \"𝔲\";\nvar Ugrave$1 = \"Ù\";\nvar ugrave$1 = \"ù\";\nvar uHar = \"⥣\";\nvar uharl = \"↿\";\nvar uharr = \"↾\";\nvar uhblk = \"▀\";\nvar ulcorn = \"⌜\";\nvar ulcorner = \"⌜\";\nvar ulcrop = \"⌏\";\nvar ultri = \"◸\";\nvar Umacr = \"Ū\";\nvar umacr = \"ū\";\nvar uml$1 = \"¨\";\nvar UnderBar = \"_\";\nvar UnderBrace = \"⏟\";\nvar UnderBracket = \"⎵\";\nvar UnderParenthesis = \"⏝\";\nvar Union = \"⋃\";\nvar UnionPlus = \"⊎\";\nvar Uogon = \"Ų\";\nvar uogon = \"ų\";\nvar Uopf = \"𝕌\";\nvar uopf = \"𝕦\";\nvar UpArrowBar = \"⤒\";\nvar uparrow = \"↑\";\nvar UpArrow = \"↑\";\nvar Uparrow = \"⇑\";\nvar UpArrowDownArrow = \"⇅\";\nvar updownarrow = \"↕\";\nvar UpDownArrow = \"↕\";\nvar Updownarrow = \"⇕\";\nvar UpEquilibrium = \"⥮\";\nvar upharpoonleft = \"↿\";\nvar upharpoonright = \"↾\";\nvar uplus = \"⊎\";\nvar UpperLeftArrow = \"↖\";\nvar UpperRightArrow = \"↗\";\nvar upsi = \"υ\";\nvar Upsi = \"ϒ\";\nvar upsih = \"ϒ\";\nvar Upsilon = \"Υ\";\nvar upsilon = \"υ\";\nvar UpTeeArrow = \"↥\";\nvar UpTee = \"⊥\";\nvar upuparrows = \"⇈\";\nvar urcorn = \"⌝\";\nvar urcorner = \"⌝\";\nvar urcrop = \"⌎\";\nvar Uring = \"Ů\";\nvar uring = \"ů\";\nvar urtri = \"◹\";\nvar Uscr = \"𝒰\";\nvar uscr = \"𝓊\";\nvar utdot = \"⋰\";\nvar Utilde = \"Ũ\";\nvar utilde = \"ũ\";\nvar utri = \"▵\";\nvar utrif = \"▴\";\nvar uuarr = \"⇈\";\nvar Uuml$1 = \"Ü\";\nvar uuml$1 = \"ü\";\nvar uwangle = \"⦧\";\nvar vangrt = \"⦜\";\nvar varepsilon = \"ϵ\";\nvar varkappa = \"ϰ\";\nvar varnothing = \"∅\";\nvar varphi = \"ϕ\";\nvar varpi = \"ϖ\";\nvar varpropto = \"∝\";\nvar varr = \"↕\";\nvar vArr = \"⇕\";\nvar varrho = \"ϱ\";\nvar varsigma = \"ς\";\nvar varsubsetneq = \"⊊︀\";\nvar varsubsetneqq = \"⫋︀\";\nvar varsupsetneq = \"⊋︀\";\nvar varsupsetneqq = \"⫌︀\";\nvar vartheta = \"ϑ\";\nvar vartriangleleft = \"⊲\";\nvar vartriangleright = \"⊳\";\nvar vBar = \"⫨\";\nvar Vbar = \"⫫\";\nvar vBarv = \"⫩\";\nvar Vcy = \"В\";\nvar vcy = \"в\";\nvar vdash = \"⊢\";\nvar vDash = \"⊨\";\nvar Vdash = \"⊩\";\nvar VDash = \"⊫\";\nvar Vdashl = \"⫦\";\nvar veebar = \"⊻\";\nvar vee = \"∨\";\nvar Vee = \"⋁\";\nvar veeeq = \"≚\";\nvar vellip = \"⋮\";\nvar verbar = \"|\";\nvar Verbar = \"‖\";\nvar vert = \"|\";\nvar Vert = \"‖\";\nvar VerticalBar = \"∣\";\nvar VerticalLine = \"|\";\nvar VerticalSeparator = \"❘\";\nvar VerticalTilde = \"≀\";\nvar VeryThinSpace = \" \";\nvar Vfr = \"𝔙\";\nvar vfr = \"𝔳\";\nvar vltri = \"⊲\";\nvar vnsub = \"⊂⃒\";\nvar vnsup = \"⊃⃒\";\nvar Vopf = \"𝕍\";\nvar vopf = \"𝕧\";\nvar vprop = \"∝\";\nvar vrtri = \"⊳\";\nvar Vscr = \"𝒱\";\nvar vscr = \"𝓋\";\nvar vsubnE = \"⫋︀\";\nvar vsubne = \"⊊︀\";\nvar vsupnE = \"⫌︀\";\nvar vsupne = \"⊋︀\";\nvar Vvdash = \"⊪\";\nvar vzigzag = \"⦚\";\nvar Wcirc = \"Ŵ\";\nvar wcirc = \"ŵ\";\nvar wedbar = \"⩟\";\nvar wedge = \"∧\";\nvar Wedge = \"⋀\";\nvar wedgeq = \"≙\";\nvar weierp = \"℘\";\nvar Wfr = \"𝔚\";\nvar wfr = \"𝔴\";\nvar Wopf = \"𝕎\";\nvar wopf = \"𝕨\";\nvar wp = \"℘\";\nvar wr = \"≀\";\nvar wreath = \"≀\";\nvar Wscr = \"𝒲\";\nvar wscr = \"𝓌\";\nvar xcap = \"⋂\";\nvar xcirc = \"◯\";\nvar xcup = \"⋃\";\nvar xdtri = \"▽\";\nvar Xfr = \"𝔛\";\nvar xfr = \"𝔵\";\nvar xharr = \"⟷\";\nvar xhArr = \"⟺\";\nvar Xi = \"Ξ\";\nvar xi = \"ξ\";\nvar xlarr = \"⟵\";\nvar xlArr = \"⟸\";\nvar xmap = \"⟼\";\nvar xnis = \"⋻\";\nvar xodot = \"⨀\";\nvar Xopf = \"𝕏\";\nvar xopf = \"𝕩\";\nvar xoplus = \"⨁\";\nvar xotime = \"⨂\";\nvar xrarr = \"⟶\";\nvar xrArr = \"⟹\";\nvar Xscr = \"𝒳\";\nvar xscr = \"𝓍\";\nvar xsqcup = \"⨆\";\nvar xuplus = \"⨄\";\nvar xutri = \"△\";\nvar xvee = \"⋁\";\nvar xwedge = \"⋀\";\nvar Yacute$1 = \"Ý\";\nvar yacute$1 = \"ý\";\nvar YAcy = \"Я\";\nvar yacy = \"я\";\nvar Ycirc = \"Ŷ\";\nvar ycirc = \"ŷ\";\nvar Ycy = \"Ы\";\nvar ycy = \"ы\";\nvar yen$1 = \"¥\";\nvar Yfr = \"𝔜\";\nvar yfr = \"𝔶\";\nvar YIcy = \"Ї\";\nvar yicy = \"ї\";\nvar Yopf = \"𝕐\";\nvar yopf = \"𝕪\";\nvar Yscr = \"𝒴\";\nvar yscr = \"𝓎\";\nvar YUcy = \"Ю\";\nvar yucy = \"ю\";\nvar yuml$1 = \"ÿ\";\nvar Yuml = \"Ÿ\";\nvar Zacute = \"Ź\";\nvar zacute = \"ź\";\nvar Zcaron = \"Ž\";\nvar zcaron = \"ž\";\nvar Zcy = \"З\";\nvar zcy = \"з\";\nvar Zdot = \"Ż\";\nvar zdot = \"ż\";\nvar zeetrf = \"ℨ\";\nvar ZeroWidthSpace = \"​\";\nvar Zeta = \"Ζ\";\nvar zeta = \"ζ\";\nvar zfr = \"𝔷\";\nvar Zfr = \"ℨ\";\nvar ZHcy = \"Ж\";\nvar zhcy = \"ж\";\nvar zigrarr = \"⇝\";\nvar zopf = \"𝕫\";\nvar Zopf = \"ℤ\";\nvar Zscr = \"𝒵\";\nvar zscr = \"𝓏\";\nvar zwj = \"‍\";\nvar zwnj = \"‌\";\nvar require$$1$1 = {\n\tAacute: Aacute$1,\n\taacute: aacute$1,\n\tAbreve: Abreve,\n\tabreve: abreve,\n\tac: ac,\n\tacd: acd,\n\tacE: acE,\n\tAcirc: Acirc$1,\n\tacirc: acirc$1,\n\tacute: acute$1,\n\tAcy: Acy,\n\tacy: acy,\n\tAElig: AElig$1,\n\taelig: aelig$1,\n\taf: af,\n\tAfr: Afr,\n\tafr: afr,\n\tAgrave: Agrave$1,\n\tagrave: agrave$1,\n\talefsym: alefsym,\n\taleph: aleph,\n\tAlpha: Alpha,\n\talpha: alpha,\n\tAmacr: Amacr,\n\tamacr: amacr,\n\tamalg: amalg,\n\tamp: amp$2,\n\tAMP: AMP$1,\n\tandand: andand,\n\tAnd: And,\n\tand: and,\n\tandd: andd,\n\tandslope: andslope,\n\tandv: andv,\n\tang: ang,\n\tange: ange,\n\tangle: angle,\n\tangmsdaa: angmsdaa,\n\tangmsdab: angmsdab,\n\tangmsdac: angmsdac,\n\tangmsdad: angmsdad,\n\tangmsdae: angmsdae,\n\tangmsdaf: angmsdaf,\n\tangmsdag: angmsdag,\n\tangmsdah: angmsdah,\n\tangmsd: angmsd,\n\tangrt: angrt,\n\tangrtvb: angrtvb,\n\tangrtvbd: angrtvbd,\n\tangsph: angsph,\n\tangst: angst,\n\tangzarr: angzarr,\n\tAogon: Aogon,\n\taogon: aogon,\n\tAopf: Aopf,\n\taopf: aopf,\n\tapacir: apacir,\n\tap: ap,\n\tapE: apE,\n\tape: ape,\n\tapid: apid,\n\tapos: apos$1,\n\tApplyFunction: ApplyFunction,\n\tapprox: approx,\n\tapproxeq: approxeq,\n\tAring: Aring$1,\n\taring: aring$1,\n\tAscr: Ascr,\n\tascr: ascr,\n\tAssign: Assign,\n\tast: ast,\n\tasymp: asymp,\n\tasympeq: asympeq,\n\tAtilde: Atilde$1,\n\tatilde: atilde$1,\n\tAuml: Auml$1,\n\tauml: auml$1,\n\tawconint: awconint,\n\tawint: awint,\n\tbackcong: backcong,\n\tbackepsilon: backepsilon,\n\tbackprime: backprime,\n\tbacksim: backsim,\n\tbacksimeq: backsimeq,\n\tBackslash: Backslash,\n\tBarv: Barv,\n\tbarvee: barvee,\n\tbarwed: barwed,\n\tBarwed: Barwed,\n\tbarwedge: barwedge,\n\tbbrk: bbrk,\n\tbbrktbrk: bbrktbrk,\n\tbcong: bcong,\n\tBcy: Bcy,\n\tbcy: bcy,\n\tbdquo: bdquo,\n\tbecaus: becaus,\n\tbecause: because,\n\tBecause: Because,\n\tbemptyv: bemptyv,\n\tbepsi: bepsi,\n\tbernou: bernou,\n\tBernoullis: Bernoullis,\n\tBeta: Beta,\n\tbeta: beta,\n\tbeth: beth,\n\tbetween: between,\n\tBfr: Bfr,\n\tbfr: bfr,\n\tbigcap: bigcap,\n\tbigcirc: bigcirc,\n\tbigcup: bigcup,\n\tbigodot: bigodot,\n\tbigoplus: bigoplus,\n\tbigotimes: bigotimes,\n\tbigsqcup: bigsqcup,\n\tbigstar: bigstar,\n\tbigtriangledown: bigtriangledown,\n\tbigtriangleup: bigtriangleup,\n\tbiguplus: biguplus,\n\tbigvee: bigvee,\n\tbigwedge: bigwedge,\n\tbkarow: bkarow,\n\tblacklozenge: blacklozenge,\n\tblacksquare: blacksquare,\n\tblacktriangle: blacktriangle,\n\tblacktriangledown: blacktriangledown,\n\tblacktriangleleft: blacktriangleleft,\n\tblacktriangleright: blacktriangleright,\n\tblank: blank,\n\tblk12: blk12,\n\tblk14: blk14,\n\tblk34: blk34,\n\tblock: block,\n\tbne: bne,\n\tbnequiv: bnequiv,\n\tbNot: bNot,\n\tbnot: bnot,\n\tBopf: Bopf,\n\tbopf: bopf,\n\tbot: bot,\n\tbottom: bottom,\n\tbowtie: bowtie,\n\tboxbox: boxbox,\n\tboxdl: boxdl,\n\tboxdL: boxdL,\n\tboxDl: boxDl,\n\tboxDL: boxDL,\n\tboxdr: boxdr,\n\tboxdR: boxdR,\n\tboxDr: boxDr,\n\tboxDR: boxDR,\n\tboxh: boxh,\n\tboxH: boxH,\n\tboxhd: boxhd,\n\tboxHd: boxHd,\n\tboxhD: boxhD,\n\tboxHD: boxHD,\n\tboxhu: boxhu,\n\tboxHu: boxHu,\n\tboxhU: boxhU,\n\tboxHU: boxHU,\n\tboxminus: boxminus,\n\tboxplus: boxplus,\n\tboxtimes: boxtimes,\n\tboxul: boxul,\n\tboxuL: boxuL,\n\tboxUl: boxUl,\n\tboxUL: boxUL,\n\tboxur: boxur,\n\tboxuR: boxuR,\n\tboxUr: boxUr,\n\tboxUR: boxUR,\n\tboxv: boxv,\n\tboxV: boxV,\n\tboxvh: boxvh,\n\tboxvH: boxvH,\n\tboxVh: boxVh,\n\tboxVH: boxVH,\n\tboxvl: boxvl,\n\tboxvL: boxvL,\n\tboxVl: boxVl,\n\tboxVL: boxVL,\n\tboxvr: boxvr,\n\tboxvR: boxvR,\n\tboxVr: boxVr,\n\tboxVR: boxVR,\n\tbprime: bprime,\n\tbreve: breve,\n\tBreve: Breve,\n\tbrvbar: brvbar$1,\n\tbscr: bscr,\n\tBscr: Bscr,\n\tbsemi: bsemi,\n\tbsim: bsim,\n\tbsime: bsime,\n\tbsolb: bsolb,\n\tbsol: bsol,\n\tbsolhsub: bsolhsub,\n\tbull: bull,\n\tbullet: bullet,\n\tbump: bump,\n\tbumpE: bumpE,\n\tbumpe: bumpe,\n\tBumpeq: Bumpeq,\n\tbumpeq: bumpeq,\n\tCacute: Cacute,\n\tcacute: cacute,\n\tcapand: capand,\n\tcapbrcup: capbrcup,\n\tcapcap: capcap,\n\tcap: cap,\n\tCap: Cap,\n\tcapcup: capcup,\n\tcapdot: capdot,\n\tCapitalDifferentialD: CapitalDifferentialD,\n\tcaps: caps,\n\tcaret: caret,\n\tcaron: caron,\n\tCayleys: Cayleys,\n\tccaps: ccaps,\n\tCcaron: Ccaron,\n\tccaron: ccaron,\n\tCcedil: Ccedil$1,\n\tccedil: ccedil$1,\n\tCcirc: Ccirc,\n\tccirc: ccirc,\n\tCconint: Cconint,\n\tccups: ccups,\n\tccupssm: ccupssm,\n\tCdot: Cdot,\n\tcdot: cdot,\n\tcedil: cedil$1,\n\tCedilla: Cedilla,\n\tcemptyv: cemptyv,\n\tcent: cent$1,\n\tcenterdot: centerdot,\n\tCenterDot: CenterDot,\n\tcfr: cfr,\n\tCfr: Cfr,\n\tCHcy: CHcy,\n\tchcy: chcy,\n\tcheck: check,\n\tcheckmark: checkmark,\n\tChi: Chi,\n\tchi: chi,\n\tcirc: circ,\n\tcirceq: circeq,\n\tcirclearrowleft: circlearrowleft,\n\tcirclearrowright: circlearrowright,\n\tcircledast: circledast,\n\tcircledcirc: circledcirc,\n\tcircleddash: circleddash,\n\tCircleDot: CircleDot,\n\tcircledR: circledR,\n\tcircledS: circledS,\n\tCircleMinus: CircleMinus,\n\tCirclePlus: CirclePlus,\n\tCircleTimes: CircleTimes,\n\tcir: cir,\n\tcirE: cirE,\n\tcire: cire,\n\tcirfnint: cirfnint,\n\tcirmid: cirmid,\n\tcirscir: cirscir,\n\tClockwiseContourIntegral: ClockwiseContourIntegral,\n\tCloseCurlyDoubleQuote: CloseCurlyDoubleQuote,\n\tCloseCurlyQuote: CloseCurlyQuote,\n\tclubs: clubs,\n\tclubsuit: clubsuit,\n\tcolon: colon,\n\tColon: Colon,\n\tColone: Colone,\n\tcolone: colone,\n\tcoloneq: coloneq,\n\tcomma: comma,\n\tcommat: commat,\n\tcomp: comp,\n\tcompfn: compfn,\n\tcomplement: complement,\n\tcomplexes: complexes,\n\tcong: cong,\n\tcongdot: congdot,\n\tCongruent: Congruent,\n\tconint: conint,\n\tConint: Conint,\n\tContourIntegral: ContourIntegral,\n\tcopf: copf,\n\tCopf: Copf,\n\tcoprod: coprod,\n\tCoproduct: Coproduct,\n\tcopy: copy$1,\n\tCOPY: COPY$1,\n\tcopysr: copysr,\n\tCounterClockwiseContourIntegral: CounterClockwiseContourIntegral,\n\tcrarr: crarr,\n\tcross: cross,\n\tCross: Cross,\n\tCscr: Cscr,\n\tcscr: cscr,\n\tcsub: csub,\n\tcsube: csube,\n\tcsup: csup,\n\tcsupe: csupe,\n\tctdot: ctdot,\n\tcudarrl: cudarrl,\n\tcudarrr: cudarrr,\n\tcuepr: cuepr,\n\tcuesc: cuesc,\n\tcularr: cularr,\n\tcularrp: cularrp,\n\tcupbrcap: cupbrcap,\n\tcupcap: cupcap,\n\tCupCap: CupCap,\n\tcup: cup,\n\tCup: Cup,\n\tcupcup: cupcup,\n\tcupdot: cupdot,\n\tcupor: cupor,\n\tcups: cups,\n\tcurarr: curarr,\n\tcurarrm: curarrm,\n\tcurlyeqprec: curlyeqprec,\n\tcurlyeqsucc: curlyeqsucc,\n\tcurlyvee: curlyvee,\n\tcurlywedge: curlywedge,\n\tcurren: curren$1,\n\tcurvearrowleft: curvearrowleft,\n\tcurvearrowright: curvearrowright,\n\tcuvee: cuvee,\n\tcuwed: cuwed,\n\tcwconint: cwconint,\n\tcwint: cwint,\n\tcylcty: cylcty,\n\tdagger: dagger,\n\tDagger: Dagger,\n\tdaleth: daleth,\n\tdarr: darr,\n\tDarr: Darr,\n\tdArr: dArr,\n\tdash: dash,\n\tDashv: Dashv,\n\tdashv: dashv,\n\tdbkarow: dbkarow,\n\tdblac: dblac,\n\tDcaron: Dcaron,\n\tdcaron: dcaron,\n\tDcy: Dcy,\n\tdcy: dcy,\n\tddagger: ddagger,\n\tddarr: ddarr,\n\tDD: DD,\n\tdd: dd,\n\tDDotrahd: DDotrahd,\n\tddotseq: ddotseq,\n\tdeg: deg$1,\n\tDel: Del,\n\tDelta: Delta,\n\tdelta: delta,\n\tdemptyv: demptyv,\n\tdfisht: dfisht,\n\tDfr: Dfr,\n\tdfr: dfr,\n\tdHar: dHar,\n\tdharl: dharl,\n\tdharr: dharr,\n\tDiacriticalAcute: DiacriticalAcute,\n\tDiacriticalDot: DiacriticalDot,\n\tDiacriticalDoubleAcute: DiacriticalDoubleAcute,\n\tDiacriticalGrave: DiacriticalGrave,\n\tDiacriticalTilde: DiacriticalTilde,\n\tdiam: diam,\n\tdiamond: diamond,\n\tDiamond: Diamond,\n\tdiamondsuit: diamondsuit,\n\tdiams: diams,\n\tdie: die,\n\tDifferentialD: DifferentialD,\n\tdigamma: digamma,\n\tdisin: disin,\n\tdiv: div,\n\tdivide: divide$1,\n\tdivideontimes: divideontimes,\n\tdivonx: divonx,\n\tDJcy: DJcy,\n\tdjcy: djcy,\n\tdlcorn: dlcorn,\n\tdlcrop: dlcrop,\n\tdollar: dollar,\n\tDopf: Dopf,\n\tdopf: dopf,\n\tDot: Dot,\n\tdot: dot,\n\tDotDot: DotDot,\n\tdoteq: doteq,\n\tdoteqdot: doteqdot,\n\tDotEqual: DotEqual,\n\tdotminus: dotminus,\n\tdotplus: dotplus,\n\tdotsquare: dotsquare,\n\tdoublebarwedge: doublebarwedge,\n\tDoubleContourIntegral: DoubleContourIntegral,\n\tDoubleDot: DoubleDot,\n\tDoubleDownArrow: DoubleDownArrow,\n\tDoubleLeftArrow: DoubleLeftArrow,\n\tDoubleLeftRightArrow: DoubleLeftRightArrow,\n\tDoubleLeftTee: DoubleLeftTee,\n\tDoubleLongLeftArrow: DoubleLongLeftArrow,\n\tDoubleLongLeftRightArrow: DoubleLongLeftRightArrow,\n\tDoubleLongRightArrow: DoubleLongRightArrow,\n\tDoubleRightArrow: DoubleRightArrow,\n\tDoubleRightTee: DoubleRightTee,\n\tDoubleUpArrow: DoubleUpArrow,\n\tDoubleUpDownArrow: DoubleUpDownArrow,\n\tDoubleVerticalBar: DoubleVerticalBar,\n\tDownArrowBar: DownArrowBar,\n\tdownarrow: downarrow,\n\tDownArrow: DownArrow,\n\tDownarrow: Downarrow,\n\tDownArrowUpArrow: DownArrowUpArrow,\n\tDownBreve: DownBreve,\n\tdowndownarrows: downdownarrows,\n\tdownharpoonleft: downharpoonleft,\n\tdownharpoonright: downharpoonright,\n\tDownLeftRightVector: DownLeftRightVector,\n\tDownLeftTeeVector: DownLeftTeeVector,\n\tDownLeftVectorBar: DownLeftVectorBar,\n\tDownLeftVector: DownLeftVector,\n\tDownRightTeeVector: DownRightTeeVector,\n\tDownRightVectorBar: DownRightVectorBar,\n\tDownRightVector: DownRightVector,\n\tDownTeeArrow: DownTeeArrow,\n\tDownTee: DownTee,\n\tdrbkarow: drbkarow,\n\tdrcorn: drcorn,\n\tdrcrop: drcrop,\n\tDscr: Dscr,\n\tdscr: dscr,\n\tDScy: DScy,\n\tdscy: dscy,\n\tdsol: dsol,\n\tDstrok: Dstrok,\n\tdstrok: dstrok,\n\tdtdot: dtdot,\n\tdtri: dtri,\n\tdtrif: dtrif,\n\tduarr: duarr,\n\tduhar: duhar,\n\tdwangle: dwangle,\n\tDZcy: DZcy,\n\tdzcy: dzcy,\n\tdzigrarr: dzigrarr,\n\tEacute: Eacute$1,\n\teacute: eacute$1,\n\teaster: easter,\n\tEcaron: Ecaron,\n\tecaron: ecaron,\n\tEcirc: Ecirc$1,\n\tecirc: ecirc$1,\n\tecir: ecir,\n\tecolon: ecolon,\n\tEcy: Ecy,\n\tecy: ecy,\n\teDDot: eDDot,\n\tEdot: Edot,\n\tedot: edot,\n\teDot: eDot,\n\tee: ee,\n\tefDot: efDot,\n\tEfr: Efr,\n\tefr: efr,\n\teg: eg,\n\tEgrave: Egrave$1,\n\tegrave: egrave$1,\n\tegs: egs,\n\tegsdot: egsdot,\n\tel: el,\n\tElement: Element$1,\n\telinters: elinters,\n\tell: ell,\n\tels: els,\n\telsdot: elsdot,\n\tEmacr: Emacr,\n\temacr: emacr,\n\tempty: empty,\n\temptyset: emptyset,\n\tEmptySmallSquare: EmptySmallSquare,\n\temptyv: emptyv,\n\tEmptyVerySmallSquare: EmptyVerySmallSquare,\n\temsp13: emsp13,\n\temsp14: emsp14,\n\temsp: emsp,\n\tENG: ENG,\n\teng: eng,\n\tensp: ensp,\n\tEogon: Eogon,\n\teogon: eogon,\n\tEopf: Eopf,\n\teopf: eopf,\n\tepar: epar,\n\teparsl: eparsl,\n\teplus: eplus,\n\tepsi: epsi,\n\tEpsilon: Epsilon,\n\tepsilon: epsilon,\n\tepsiv: epsiv,\n\teqcirc: eqcirc,\n\teqcolon: eqcolon,\n\teqsim: eqsim,\n\teqslantgtr: eqslantgtr,\n\teqslantless: eqslantless,\n\tEqual: Equal,\n\tequals: equals,\n\tEqualTilde: EqualTilde,\n\tequest: equest,\n\tEquilibrium: Equilibrium,\n\tequiv: equiv,\n\tequivDD: equivDD,\n\teqvparsl: eqvparsl,\n\terarr: erarr,\n\terDot: erDot,\n\tescr: escr,\n\tEscr: Escr,\n\tesdot: esdot,\n\tEsim: Esim,\n\tesim: esim,\n\tEta: Eta,\n\teta: eta,\n\tETH: ETH$1,\n\teth: eth$1,\n\tEuml: Euml$1,\n\teuml: euml$1,\n\teuro: euro,\n\texcl: excl,\n\texist: exist,\n\tExists: Exists,\n\texpectation: expectation,\n\texponentiale: exponentiale,\n\tExponentialE: ExponentialE,\n\tfallingdotseq: fallingdotseq,\n\tFcy: Fcy,\n\tfcy: fcy,\n\tfemale: female,\n\tffilig: ffilig,\n\tfflig: fflig,\n\tffllig: ffllig,\n\tFfr: Ffr,\n\tffr: ffr,\n\tfilig: filig,\n\tFilledSmallSquare: FilledSmallSquare,\n\tFilledVerySmallSquare: FilledVerySmallSquare,\n\tfjlig: fjlig,\n\tflat: flat,\n\tfllig: fllig,\n\tfltns: fltns,\n\tfnof: fnof,\n\tFopf: Fopf,\n\tfopf: fopf,\n\tforall: forall,\n\tForAll: ForAll,\n\tfork: fork,\n\tforkv: forkv,\n\tFouriertrf: Fouriertrf,\n\tfpartint: fpartint,\n\tfrac12: frac12$1,\n\tfrac13: frac13,\n\tfrac14: frac14$1,\n\tfrac15: frac15,\n\tfrac16: frac16,\n\tfrac18: frac18,\n\tfrac23: frac23,\n\tfrac25: frac25,\n\tfrac34: frac34$1,\n\tfrac35: frac35,\n\tfrac38: frac38,\n\tfrac45: frac45,\n\tfrac56: frac56,\n\tfrac58: frac58,\n\tfrac78: frac78,\n\tfrasl: frasl,\n\tfrown: frown,\n\tfscr: fscr,\n\tFscr: Fscr,\n\tgacute: gacute,\n\tGamma: Gamma,\n\tgamma: gamma,\n\tGammad: Gammad,\n\tgammad: gammad,\n\tgap: gap,\n\tGbreve: Gbreve,\n\tgbreve: gbreve,\n\tGcedil: Gcedil,\n\tGcirc: Gcirc,\n\tgcirc: gcirc,\n\tGcy: Gcy,\n\tgcy: gcy,\n\tGdot: Gdot,\n\tgdot: gdot,\n\tge: ge,\n\tgE: gE,\n\tgEl: gEl,\n\tgel: gel,\n\tgeq: geq,\n\tgeqq: geqq,\n\tgeqslant: geqslant,\n\tgescc: gescc,\n\tges: ges,\n\tgesdot: gesdot,\n\tgesdoto: gesdoto,\n\tgesdotol: gesdotol,\n\tgesl: gesl,\n\tgesles: gesles,\n\tGfr: Gfr,\n\tgfr: gfr,\n\tgg: gg,\n\tGg: Gg,\n\tggg: ggg,\n\tgimel: gimel,\n\tGJcy: GJcy,\n\tgjcy: gjcy,\n\tgla: gla,\n\tgl: gl,\n\tglE: glE,\n\tglj: glj,\n\tgnap: gnap,\n\tgnapprox: gnapprox,\n\tgne: gne,\n\tgnE: gnE,\n\tgneq: gneq,\n\tgneqq: gneqq,\n\tgnsim: gnsim,\n\tGopf: Gopf,\n\tgopf: gopf,\n\tgrave: grave,\n\tGreaterEqual: GreaterEqual,\n\tGreaterEqualLess: GreaterEqualLess,\n\tGreaterFullEqual: GreaterFullEqual,\n\tGreaterGreater: GreaterGreater,\n\tGreaterLess: GreaterLess,\n\tGreaterSlantEqual: GreaterSlantEqual,\n\tGreaterTilde: GreaterTilde,\n\tGscr: Gscr,\n\tgscr: gscr,\n\tgsim: gsim,\n\tgsime: gsime,\n\tgsiml: gsiml,\n\tgtcc: gtcc,\n\tgtcir: gtcir,\n\tgt: gt$2,\n\tGT: GT$1,\n\tGt: Gt,\n\tgtdot: gtdot,\n\tgtlPar: gtlPar,\n\tgtquest: gtquest,\n\tgtrapprox: gtrapprox,\n\tgtrarr: gtrarr,\n\tgtrdot: gtrdot,\n\tgtreqless: gtreqless,\n\tgtreqqless: gtreqqless,\n\tgtrless: gtrless,\n\tgtrsim: gtrsim,\n\tgvertneqq: gvertneqq,\n\tgvnE: gvnE,\n\tHacek: Hacek,\n\thairsp: hairsp,\n\thalf: half,\n\thamilt: hamilt,\n\tHARDcy: HARDcy,\n\thardcy: hardcy,\n\tharrcir: harrcir,\n\tharr: harr,\n\thArr: hArr,\n\tharrw: harrw,\n\tHat: Hat,\n\thbar: hbar,\n\tHcirc: Hcirc,\n\thcirc: hcirc,\n\thearts: hearts,\n\theartsuit: heartsuit,\n\thellip: hellip,\n\thercon: hercon,\n\thfr: hfr,\n\tHfr: Hfr,\n\tHilbertSpace: HilbertSpace,\n\thksearow: hksearow,\n\thkswarow: hkswarow,\n\thoarr: hoarr,\n\thomtht: homtht,\n\thookleftarrow: hookleftarrow,\n\thookrightarrow: hookrightarrow,\n\thopf: hopf,\n\tHopf: Hopf,\n\thorbar: horbar,\n\tHorizontalLine: HorizontalLine,\n\thscr: hscr,\n\tHscr: Hscr,\n\thslash: hslash,\n\tHstrok: Hstrok,\n\thstrok: hstrok,\n\tHumpDownHump: HumpDownHump,\n\tHumpEqual: HumpEqual,\n\thybull: hybull,\n\thyphen: hyphen,\n\tIacute: Iacute$1,\n\tiacute: iacute$1,\n\tic: ic,\n\tIcirc: Icirc$1,\n\ticirc: icirc$1,\n\tIcy: Icy,\n\ticy: icy,\n\tIdot: Idot,\n\tIEcy: IEcy,\n\tiecy: iecy,\n\tiexcl: iexcl$1,\n\tiff: iff,\n\tifr: ifr,\n\tIfr: Ifr,\n\tIgrave: Igrave$1,\n\tigrave: igrave$1,\n\tii: ii,\n\tiiiint: iiiint,\n\tiiint: iiint,\n\tiinfin: iinfin,\n\tiiota: iiota,\n\tIJlig: IJlig,\n\tijlig: ijlig,\n\tImacr: Imacr,\n\timacr: imacr,\n\timage: image,\n\tImaginaryI: ImaginaryI,\n\timagline: imagline,\n\timagpart: imagpart,\n\timath: imath,\n\tIm: Im,\n\timof: imof,\n\timped: imped,\n\tImplies: Implies,\n\tincare: incare,\n\t\"in\": \"∈\",\n\tinfin: infin,\n\tinfintie: infintie,\n\tinodot: inodot,\n\tintcal: intcal,\n\tint: int,\n\tInt: Int,\n\tintegers: integers,\n\tIntegral: Integral,\n\tintercal: intercal,\n\tIntersection: Intersection,\n\tintlarhk: intlarhk,\n\tintprod: intprod,\n\tInvisibleComma: InvisibleComma,\n\tInvisibleTimes: InvisibleTimes,\n\tIOcy: IOcy,\n\tiocy: iocy,\n\tIogon: Iogon,\n\tiogon: iogon,\n\tIopf: Iopf,\n\tiopf: iopf,\n\tIota: Iota,\n\tiota: iota,\n\tiprod: iprod,\n\tiquest: iquest$1,\n\tiscr: iscr,\n\tIscr: Iscr,\n\tisin: isin,\n\tisindot: isindot,\n\tisinE: isinE,\n\tisins: isins,\n\tisinsv: isinsv,\n\tisinv: isinv,\n\tit: it,\n\tItilde: Itilde,\n\titilde: itilde,\n\tIukcy: Iukcy,\n\tiukcy: iukcy,\n\tIuml: Iuml$1,\n\tiuml: iuml$1,\n\tJcirc: Jcirc,\n\tjcirc: jcirc,\n\tJcy: Jcy,\n\tjcy: jcy,\n\tJfr: Jfr,\n\tjfr: jfr,\n\tjmath: jmath,\n\tJopf: Jopf,\n\tjopf: jopf,\n\tJscr: Jscr,\n\tjscr: jscr,\n\tJsercy: Jsercy,\n\tjsercy: jsercy,\n\tJukcy: Jukcy,\n\tjukcy: jukcy,\n\tKappa: Kappa,\n\tkappa: kappa,\n\tkappav: kappav,\n\tKcedil: Kcedil,\n\tkcedil: kcedil,\n\tKcy: Kcy,\n\tkcy: kcy,\n\tKfr: Kfr,\n\tkfr: kfr,\n\tkgreen: kgreen,\n\tKHcy: KHcy,\n\tkhcy: khcy,\n\tKJcy: KJcy,\n\tkjcy: kjcy,\n\tKopf: Kopf,\n\tkopf: kopf,\n\tKscr: Kscr,\n\tkscr: kscr,\n\tlAarr: lAarr,\n\tLacute: Lacute,\n\tlacute: lacute,\n\tlaemptyv: laemptyv,\n\tlagran: lagran,\n\tLambda: Lambda,\n\tlambda: lambda,\n\tlang: lang,\n\tLang: Lang,\n\tlangd: langd,\n\tlangle: langle,\n\tlap: lap,\n\tLaplacetrf: Laplacetrf,\n\tlaquo: laquo$1,\n\tlarrb: larrb,\n\tlarrbfs: larrbfs,\n\tlarr: larr,\n\tLarr: Larr,\n\tlArr: lArr,\n\tlarrfs: larrfs,\n\tlarrhk: larrhk,\n\tlarrlp: larrlp,\n\tlarrpl: larrpl,\n\tlarrsim: larrsim,\n\tlarrtl: larrtl,\n\tlatail: latail,\n\tlAtail: lAtail,\n\tlat: lat,\n\tlate: late,\n\tlates: lates,\n\tlbarr: lbarr,\n\tlBarr: lBarr,\n\tlbbrk: lbbrk,\n\tlbrace: lbrace,\n\tlbrack: lbrack,\n\tlbrke: lbrke,\n\tlbrksld: lbrksld,\n\tlbrkslu: lbrkslu,\n\tLcaron: Lcaron,\n\tlcaron: lcaron,\n\tLcedil: Lcedil,\n\tlcedil: lcedil,\n\tlceil: lceil,\n\tlcub: lcub,\n\tLcy: Lcy,\n\tlcy: lcy,\n\tldca: ldca,\n\tldquo: ldquo,\n\tldquor: ldquor,\n\tldrdhar: ldrdhar,\n\tldrushar: ldrushar,\n\tldsh: ldsh,\n\tle: le,\n\tlE: lE,\n\tLeftAngleBracket: LeftAngleBracket,\n\tLeftArrowBar: LeftArrowBar,\n\tleftarrow: leftarrow,\n\tLeftArrow: LeftArrow,\n\tLeftarrow: Leftarrow,\n\tLeftArrowRightArrow: LeftArrowRightArrow,\n\tleftarrowtail: leftarrowtail,\n\tLeftCeiling: LeftCeiling,\n\tLeftDoubleBracket: LeftDoubleBracket,\n\tLeftDownTeeVector: LeftDownTeeVector,\n\tLeftDownVectorBar: LeftDownVectorBar,\n\tLeftDownVector: LeftDownVector,\n\tLeftFloor: LeftFloor,\n\tleftharpoondown: leftharpoondown,\n\tleftharpoonup: leftharpoonup,\n\tleftleftarrows: leftleftarrows,\n\tleftrightarrow: leftrightarrow,\n\tLeftRightArrow: LeftRightArrow,\n\tLeftrightarrow: Leftrightarrow,\n\tleftrightarrows: leftrightarrows,\n\tleftrightharpoons: leftrightharpoons,\n\tleftrightsquigarrow: leftrightsquigarrow,\n\tLeftRightVector: LeftRightVector,\n\tLeftTeeArrow: LeftTeeArrow,\n\tLeftTee: LeftTee,\n\tLeftTeeVector: LeftTeeVector,\n\tleftthreetimes: leftthreetimes,\n\tLeftTriangleBar: LeftTriangleBar,\n\tLeftTriangle: LeftTriangle,\n\tLeftTriangleEqual: LeftTriangleEqual,\n\tLeftUpDownVector: LeftUpDownVector,\n\tLeftUpTeeVector: LeftUpTeeVector,\n\tLeftUpVectorBar: LeftUpVectorBar,\n\tLeftUpVector: LeftUpVector,\n\tLeftVectorBar: LeftVectorBar,\n\tLeftVector: LeftVector,\n\tlEg: lEg,\n\tleg: leg,\n\tleq: leq,\n\tleqq: leqq,\n\tleqslant: leqslant,\n\tlescc: lescc,\n\tles: les,\n\tlesdot: lesdot,\n\tlesdoto: lesdoto,\n\tlesdotor: lesdotor,\n\tlesg: lesg,\n\tlesges: lesges,\n\tlessapprox: lessapprox,\n\tlessdot: lessdot,\n\tlesseqgtr: lesseqgtr,\n\tlesseqqgtr: lesseqqgtr,\n\tLessEqualGreater: LessEqualGreater,\n\tLessFullEqual: LessFullEqual,\n\tLessGreater: LessGreater,\n\tlessgtr: lessgtr,\n\tLessLess: LessLess,\n\tlesssim: lesssim,\n\tLessSlantEqual: LessSlantEqual,\n\tLessTilde: LessTilde,\n\tlfisht: lfisht,\n\tlfloor: lfloor,\n\tLfr: Lfr,\n\tlfr: lfr,\n\tlg: lg,\n\tlgE: lgE,\n\tlHar: lHar,\n\tlhard: lhard,\n\tlharu: lharu,\n\tlharul: lharul,\n\tlhblk: lhblk,\n\tLJcy: LJcy,\n\tljcy: ljcy,\n\tllarr: llarr,\n\tll: ll,\n\tLl: Ll,\n\tllcorner: llcorner,\n\tLleftarrow: Lleftarrow,\n\tllhard: llhard,\n\tlltri: lltri,\n\tLmidot: Lmidot,\n\tlmidot: lmidot,\n\tlmoustache: lmoustache,\n\tlmoust: lmoust,\n\tlnap: lnap,\n\tlnapprox: lnapprox,\n\tlne: lne,\n\tlnE: lnE,\n\tlneq: lneq,\n\tlneqq: lneqq,\n\tlnsim: lnsim,\n\tloang: loang,\n\tloarr: loarr,\n\tlobrk: lobrk,\n\tlongleftarrow: longleftarrow,\n\tLongLeftArrow: LongLeftArrow,\n\tLongleftarrow: Longleftarrow,\n\tlongleftrightarrow: longleftrightarrow,\n\tLongLeftRightArrow: LongLeftRightArrow,\n\tLongleftrightarrow: Longleftrightarrow,\n\tlongmapsto: longmapsto,\n\tlongrightarrow: longrightarrow,\n\tLongRightArrow: LongRightArrow,\n\tLongrightarrow: Longrightarrow,\n\tlooparrowleft: looparrowleft,\n\tlooparrowright: looparrowright,\n\tlopar: lopar,\n\tLopf: Lopf,\n\tlopf: lopf,\n\tloplus: loplus,\n\tlotimes: lotimes,\n\tlowast: lowast,\n\tlowbar: lowbar,\n\tLowerLeftArrow: LowerLeftArrow,\n\tLowerRightArrow: LowerRightArrow,\n\tloz: loz,\n\tlozenge: lozenge,\n\tlozf: lozf,\n\tlpar: lpar,\n\tlparlt: lparlt,\n\tlrarr: lrarr,\n\tlrcorner: lrcorner,\n\tlrhar: lrhar,\n\tlrhard: lrhard,\n\tlrm: lrm,\n\tlrtri: lrtri,\n\tlsaquo: lsaquo,\n\tlscr: lscr,\n\tLscr: Lscr,\n\tlsh: lsh,\n\tLsh: Lsh,\n\tlsim: lsim,\n\tlsime: lsime,\n\tlsimg: lsimg,\n\tlsqb: lsqb,\n\tlsquo: lsquo,\n\tlsquor: lsquor,\n\tLstrok: Lstrok,\n\tlstrok: lstrok,\n\tltcc: ltcc,\n\tltcir: ltcir,\n\tlt: lt$2,\n\tLT: LT$1,\n\tLt: Lt,\n\tltdot: ltdot,\n\tlthree: lthree,\n\tltimes: ltimes,\n\tltlarr: ltlarr,\n\tltquest: ltquest,\n\tltri: ltri,\n\tltrie: ltrie,\n\tltrif: ltrif,\n\tltrPar: ltrPar,\n\tlurdshar: lurdshar,\n\tluruhar: luruhar,\n\tlvertneqq: lvertneqq,\n\tlvnE: lvnE,\n\tmacr: macr$1,\n\tmale: male,\n\tmalt: malt,\n\tmaltese: maltese,\n\t\"Map\": \"⤅\",\n\tmap: map,\n\tmapsto: mapsto,\n\tmapstodown: mapstodown,\n\tmapstoleft: mapstoleft,\n\tmapstoup: mapstoup,\n\tmarker: marker,\n\tmcomma: mcomma,\n\tMcy: Mcy,\n\tmcy: mcy,\n\tmdash: mdash,\n\tmDDot: mDDot,\n\tmeasuredangle: measuredangle,\n\tMediumSpace: MediumSpace,\n\tMellintrf: Mellintrf,\n\tMfr: Mfr,\n\tmfr: mfr,\n\tmho: mho,\n\tmicro: micro$1,\n\tmidast: midast,\n\tmidcir: midcir,\n\tmid: mid,\n\tmiddot: middot$1,\n\tminusb: minusb,\n\tminus: minus,\n\tminusd: minusd,\n\tminusdu: minusdu,\n\tMinusPlus: MinusPlus,\n\tmlcp: mlcp,\n\tmldr: mldr,\n\tmnplus: mnplus,\n\tmodels: models,\n\tMopf: Mopf,\n\tmopf: mopf,\n\tmp: mp,\n\tmscr: mscr,\n\tMscr: Mscr,\n\tmstpos: mstpos,\n\tMu: Mu,\n\tmu: mu,\n\tmultimap: multimap,\n\tmumap: mumap,\n\tnabla: nabla,\n\tNacute: Nacute,\n\tnacute: nacute,\n\tnang: nang,\n\tnap: nap,\n\tnapE: napE,\n\tnapid: napid,\n\tnapos: napos,\n\tnapprox: napprox,\n\tnatural: natural,\n\tnaturals: naturals,\n\tnatur: natur,\n\tnbsp: nbsp$1,\n\tnbump: nbump,\n\tnbumpe: nbumpe,\n\tncap: ncap,\n\tNcaron: Ncaron,\n\tncaron: ncaron,\n\tNcedil: Ncedil,\n\tncedil: ncedil,\n\tncong: ncong,\n\tncongdot: ncongdot,\n\tncup: ncup,\n\tNcy: Ncy,\n\tncy: ncy,\n\tndash: ndash,\n\tnearhk: nearhk,\n\tnearr: nearr,\n\tneArr: neArr,\n\tnearrow: nearrow,\n\tne: ne,\n\tnedot: nedot,\n\tNegativeMediumSpace: NegativeMediumSpace,\n\tNegativeThickSpace: NegativeThickSpace,\n\tNegativeThinSpace: NegativeThinSpace,\n\tNegativeVeryThinSpace: NegativeVeryThinSpace,\n\tnequiv: nequiv,\n\tnesear: nesear,\n\tnesim: nesim,\n\tNestedGreaterGreater: NestedGreaterGreater,\n\tNestedLessLess: NestedLessLess,\n\tNewLine: NewLine,\n\tnexist: nexist,\n\tnexists: nexists,\n\tNfr: Nfr,\n\tnfr: nfr,\n\tngE: ngE,\n\tnge: nge,\n\tngeq: ngeq,\n\tngeqq: ngeqq,\n\tngeqslant: ngeqslant,\n\tnges: nges,\n\tnGg: nGg,\n\tngsim: ngsim,\n\tnGt: nGt,\n\tngt: ngt,\n\tngtr: ngtr,\n\tnGtv: nGtv,\n\tnharr: nharr,\n\tnhArr: nhArr,\n\tnhpar: nhpar,\n\tni: ni,\n\tnis: nis,\n\tnisd: nisd,\n\tniv: niv,\n\tNJcy: NJcy,\n\tnjcy: njcy,\n\tnlarr: nlarr,\n\tnlArr: nlArr,\n\tnldr: nldr,\n\tnlE: nlE,\n\tnle: nle,\n\tnleftarrow: nleftarrow,\n\tnLeftarrow: nLeftarrow,\n\tnleftrightarrow: nleftrightarrow,\n\tnLeftrightarrow: nLeftrightarrow,\n\tnleq: nleq,\n\tnleqq: nleqq,\n\tnleqslant: nleqslant,\n\tnles: nles,\n\tnless: nless,\n\tnLl: nLl,\n\tnlsim: nlsim,\n\tnLt: nLt,\n\tnlt: nlt,\n\tnltri: nltri,\n\tnltrie: nltrie,\n\tnLtv: nLtv,\n\tnmid: nmid,\n\tNoBreak: NoBreak,\n\tNonBreakingSpace: NonBreakingSpace,\n\tnopf: nopf,\n\tNopf: Nopf,\n\tNot: Not,\n\tnot: not$1,\n\tNotCongruent: NotCongruent,\n\tNotCupCap: NotCupCap,\n\tNotDoubleVerticalBar: NotDoubleVerticalBar,\n\tNotElement: NotElement,\n\tNotEqual: NotEqual,\n\tNotEqualTilde: NotEqualTilde,\n\tNotExists: NotExists,\n\tNotGreater: NotGreater,\n\tNotGreaterEqual: NotGreaterEqual,\n\tNotGreaterFullEqual: NotGreaterFullEqual,\n\tNotGreaterGreater: NotGreaterGreater,\n\tNotGreaterLess: NotGreaterLess,\n\tNotGreaterSlantEqual: NotGreaterSlantEqual,\n\tNotGreaterTilde: NotGreaterTilde,\n\tNotHumpDownHump: NotHumpDownHump,\n\tNotHumpEqual: NotHumpEqual,\n\tnotin: notin,\n\tnotindot: notindot,\n\tnotinE: notinE,\n\tnotinva: notinva,\n\tnotinvb: notinvb,\n\tnotinvc: notinvc,\n\tNotLeftTriangleBar: NotLeftTriangleBar,\n\tNotLeftTriangle: NotLeftTriangle,\n\tNotLeftTriangleEqual: NotLeftTriangleEqual,\n\tNotLess: NotLess,\n\tNotLessEqual: NotLessEqual,\n\tNotLessGreater: NotLessGreater,\n\tNotLessLess: NotLessLess,\n\tNotLessSlantEqual: NotLessSlantEqual,\n\tNotLessTilde: NotLessTilde,\n\tNotNestedGreaterGreater: NotNestedGreaterGreater,\n\tNotNestedLessLess: NotNestedLessLess,\n\tnotni: notni,\n\tnotniva: notniva,\n\tnotnivb: notnivb,\n\tnotnivc: notnivc,\n\tNotPrecedes: NotPrecedes,\n\tNotPrecedesEqual: NotPrecedesEqual,\n\tNotPrecedesSlantEqual: NotPrecedesSlantEqual,\n\tNotReverseElement: NotReverseElement,\n\tNotRightTriangleBar: NotRightTriangleBar,\n\tNotRightTriangle: NotRightTriangle,\n\tNotRightTriangleEqual: NotRightTriangleEqual,\n\tNotSquareSubset: NotSquareSubset,\n\tNotSquareSubsetEqual: NotSquareSubsetEqual,\n\tNotSquareSuperset: NotSquareSuperset,\n\tNotSquareSupersetEqual: NotSquareSupersetEqual,\n\tNotSubset: NotSubset,\n\tNotSubsetEqual: NotSubsetEqual,\n\tNotSucceeds: NotSucceeds,\n\tNotSucceedsEqual: NotSucceedsEqual,\n\tNotSucceedsSlantEqual: NotSucceedsSlantEqual,\n\tNotSucceedsTilde: NotSucceedsTilde,\n\tNotSuperset: NotSuperset,\n\tNotSupersetEqual: NotSupersetEqual,\n\tNotTilde: NotTilde,\n\tNotTildeEqual: NotTildeEqual,\n\tNotTildeFullEqual: NotTildeFullEqual,\n\tNotTildeTilde: NotTildeTilde,\n\tNotVerticalBar: NotVerticalBar,\n\tnparallel: nparallel,\n\tnpar: npar,\n\tnparsl: nparsl,\n\tnpart: npart,\n\tnpolint: npolint,\n\tnpr: npr,\n\tnprcue: nprcue,\n\tnprec: nprec,\n\tnpreceq: npreceq,\n\tnpre: npre,\n\tnrarrc: nrarrc,\n\tnrarr: nrarr,\n\tnrArr: nrArr,\n\tnrarrw: nrarrw,\n\tnrightarrow: nrightarrow,\n\tnRightarrow: nRightarrow,\n\tnrtri: nrtri,\n\tnrtrie: nrtrie,\n\tnsc: nsc,\n\tnsccue: nsccue,\n\tnsce: nsce,\n\tNscr: Nscr,\n\tnscr: nscr,\n\tnshortmid: nshortmid,\n\tnshortparallel: nshortparallel,\n\tnsim: nsim,\n\tnsime: nsime,\n\tnsimeq: nsimeq,\n\tnsmid: nsmid,\n\tnspar: nspar,\n\tnsqsube: nsqsube,\n\tnsqsupe: nsqsupe,\n\tnsub: nsub,\n\tnsubE: nsubE,\n\tnsube: nsube,\n\tnsubset: nsubset,\n\tnsubseteq: nsubseteq,\n\tnsubseteqq: nsubseteqq,\n\tnsucc: nsucc,\n\tnsucceq: nsucceq,\n\tnsup: nsup,\n\tnsupE: nsupE,\n\tnsupe: nsupe,\n\tnsupset: nsupset,\n\tnsupseteq: nsupseteq,\n\tnsupseteqq: nsupseteqq,\n\tntgl: ntgl,\n\tNtilde: Ntilde$1,\n\tntilde: ntilde$1,\n\tntlg: ntlg,\n\tntriangleleft: ntriangleleft,\n\tntrianglelefteq: ntrianglelefteq,\n\tntriangleright: ntriangleright,\n\tntrianglerighteq: ntrianglerighteq,\n\tNu: Nu,\n\tnu: nu,\n\tnum: num,\n\tnumero: numero,\n\tnumsp: numsp,\n\tnvap: nvap,\n\tnvdash: nvdash,\n\tnvDash: nvDash,\n\tnVdash: nVdash,\n\tnVDash: nVDash,\n\tnvge: nvge,\n\tnvgt: nvgt,\n\tnvHarr: nvHarr,\n\tnvinfin: nvinfin,\n\tnvlArr: nvlArr,\n\tnvle: nvle,\n\tnvlt: nvlt,\n\tnvltrie: nvltrie,\n\tnvrArr: nvrArr,\n\tnvrtrie: nvrtrie,\n\tnvsim: nvsim,\n\tnwarhk: nwarhk,\n\tnwarr: nwarr,\n\tnwArr: nwArr,\n\tnwarrow: nwarrow,\n\tnwnear: nwnear,\n\tOacute: Oacute$1,\n\toacute: oacute$1,\n\toast: oast,\n\tOcirc: Ocirc$1,\n\tocirc: ocirc$1,\n\tocir: ocir,\n\tOcy: Ocy,\n\tocy: ocy,\n\todash: odash,\n\tOdblac: Odblac,\n\todblac: odblac,\n\todiv: odiv,\n\todot: odot,\n\todsold: odsold,\n\tOElig: OElig,\n\toelig: oelig,\n\tofcir: ofcir,\n\tOfr: Ofr,\n\tofr: ofr,\n\togon: ogon,\n\tOgrave: Ograve$1,\n\tograve: ograve$1,\n\togt: ogt,\n\tohbar: ohbar,\n\tohm: ohm,\n\toint: oint,\n\tolarr: olarr,\n\tolcir: olcir,\n\tolcross: olcross,\n\toline: oline,\n\tolt: olt,\n\tOmacr: Omacr,\n\tomacr: omacr,\n\tOmega: Omega,\n\tomega: omega,\n\tOmicron: Omicron,\n\tomicron: omicron,\n\tomid: omid,\n\tominus: ominus,\n\tOopf: Oopf,\n\toopf: oopf,\n\topar: opar,\n\tOpenCurlyDoubleQuote: OpenCurlyDoubleQuote,\n\tOpenCurlyQuote: OpenCurlyQuote,\n\toperp: operp,\n\toplus: oplus,\n\torarr: orarr,\n\tOr: Or,\n\tor: or,\n\tord: ord,\n\torder: order,\n\torderof: orderof,\n\tordf: ordf$1,\n\tordm: ordm$1,\n\torigof: origof,\n\toror: oror,\n\torslope: orslope,\n\torv: orv,\n\toS: oS,\n\tOscr: Oscr,\n\toscr: oscr,\n\tOslash: Oslash$1,\n\toslash: oslash$1,\n\tosol: osol,\n\tOtilde: Otilde$1,\n\totilde: otilde$1,\n\totimesas: otimesas,\n\tOtimes: Otimes,\n\totimes: otimes,\n\tOuml: Ouml$1,\n\touml: ouml$1,\n\tovbar: ovbar,\n\tOverBar: OverBar,\n\tOverBrace: OverBrace,\n\tOverBracket: OverBracket,\n\tOverParenthesis: OverParenthesis,\n\tpara: para$1,\n\tparallel: parallel,\n\tpar: par,\n\tparsim: parsim,\n\tparsl: parsl,\n\tpart: part,\n\tPartialD: PartialD,\n\tPcy: Pcy,\n\tpcy: pcy,\n\tpercnt: percnt,\n\tperiod: period,\n\tpermil: permil,\n\tperp: perp,\n\tpertenk: pertenk,\n\tPfr: Pfr,\n\tpfr: pfr,\n\tPhi: Phi,\n\tphi: phi,\n\tphiv: phiv,\n\tphmmat: phmmat,\n\tphone: phone,\n\tPi: Pi,\n\tpi: pi,\n\tpitchfork: pitchfork,\n\tpiv: piv,\n\tplanck: planck,\n\tplanckh: planckh,\n\tplankv: plankv,\n\tplusacir: plusacir,\n\tplusb: plusb,\n\tpluscir: pluscir,\n\tplus: plus,\n\tplusdo: plusdo,\n\tplusdu: plusdu,\n\tpluse: pluse,\n\tPlusMinus: PlusMinus,\n\tplusmn: plusmn$1,\n\tplussim: plussim,\n\tplustwo: plustwo,\n\tpm: pm,\n\tPoincareplane: Poincareplane,\n\tpointint: pointint,\n\tpopf: popf,\n\tPopf: Popf,\n\tpound: pound$1,\n\tprap: prap,\n\tPr: Pr,\n\tpr: pr,\n\tprcue: prcue,\n\tprecapprox: precapprox,\n\tprec: prec,\n\tpreccurlyeq: preccurlyeq,\n\tPrecedes: Precedes,\n\tPrecedesEqual: PrecedesEqual,\n\tPrecedesSlantEqual: PrecedesSlantEqual,\n\tPrecedesTilde: PrecedesTilde,\n\tpreceq: preceq,\n\tprecnapprox: precnapprox,\n\tprecneqq: precneqq,\n\tprecnsim: precnsim,\n\tpre: pre,\n\tprE: prE,\n\tprecsim: precsim,\n\tprime: prime,\n\tPrime: Prime,\n\tprimes: primes,\n\tprnap: prnap,\n\tprnE: prnE,\n\tprnsim: prnsim,\n\tprod: prod,\n\tProduct: Product,\n\tprofalar: profalar,\n\tprofline: profline,\n\tprofsurf: profsurf,\n\tprop: prop,\n\tProportional: Proportional,\n\tProportion: Proportion,\n\tpropto: propto,\n\tprsim: prsim,\n\tprurel: prurel,\n\tPscr: Pscr,\n\tpscr: pscr,\n\tPsi: Psi,\n\tpsi: psi,\n\tpuncsp: puncsp,\n\tQfr: Qfr,\n\tqfr: qfr,\n\tqint: qint,\n\tqopf: qopf,\n\tQopf: Qopf,\n\tqprime: qprime,\n\tQscr: Qscr,\n\tqscr: qscr,\n\tquaternions: quaternions,\n\tquatint: quatint,\n\tquest: quest,\n\tquesteq: questeq,\n\tquot: quot$2,\n\tQUOT: QUOT$1,\n\trAarr: rAarr,\n\trace: race,\n\tRacute: Racute,\n\tracute: racute,\n\tradic: radic,\n\traemptyv: raemptyv,\n\trang: rang,\n\tRang: Rang,\n\trangd: rangd,\n\trange: range,\n\trangle: rangle,\n\traquo: raquo$1,\n\trarrap: rarrap,\n\trarrb: rarrb,\n\trarrbfs: rarrbfs,\n\trarrc: rarrc,\n\trarr: rarr,\n\tRarr: Rarr,\n\trArr: rArr,\n\trarrfs: rarrfs,\n\trarrhk: rarrhk,\n\trarrlp: rarrlp,\n\trarrpl: rarrpl,\n\trarrsim: rarrsim,\n\tRarrtl: Rarrtl,\n\trarrtl: rarrtl,\n\trarrw: rarrw,\n\tratail: ratail,\n\trAtail: rAtail,\n\tratio: ratio,\n\trationals: rationals,\n\trbarr: rbarr,\n\trBarr: rBarr,\n\tRBarr: RBarr,\n\trbbrk: rbbrk,\n\trbrace: rbrace,\n\trbrack: rbrack,\n\trbrke: rbrke,\n\trbrksld: rbrksld,\n\trbrkslu: rbrkslu,\n\tRcaron: Rcaron,\n\trcaron: rcaron,\n\tRcedil: Rcedil,\n\trcedil: rcedil,\n\trceil: rceil,\n\trcub: rcub,\n\tRcy: Rcy,\n\trcy: rcy,\n\trdca: rdca,\n\trdldhar: rdldhar,\n\trdquo: rdquo,\n\trdquor: rdquor,\n\trdsh: rdsh,\n\treal: real,\n\trealine: realine,\n\trealpart: realpart,\n\treals: reals,\n\tRe: Re,\n\trect: rect,\n\treg: reg$1,\n\tREG: REG$1,\n\tReverseElement: ReverseElement,\n\tReverseEquilibrium: ReverseEquilibrium,\n\tReverseUpEquilibrium: ReverseUpEquilibrium,\n\trfisht: rfisht,\n\trfloor: rfloor,\n\trfr: rfr,\n\tRfr: Rfr,\n\trHar: rHar,\n\trhard: rhard,\n\trharu: rharu,\n\trharul: rharul,\n\tRho: Rho,\n\trho: rho,\n\trhov: rhov,\n\tRightAngleBracket: RightAngleBracket,\n\tRightArrowBar: RightArrowBar,\n\trightarrow: rightarrow,\n\tRightArrow: RightArrow,\n\tRightarrow: Rightarrow,\n\tRightArrowLeftArrow: RightArrowLeftArrow,\n\trightarrowtail: rightarrowtail,\n\tRightCeiling: RightCeiling,\n\tRightDoubleBracket: RightDoubleBracket,\n\tRightDownTeeVector: RightDownTeeVector,\n\tRightDownVectorBar: RightDownVectorBar,\n\tRightDownVector: RightDownVector,\n\tRightFloor: RightFloor,\n\trightharpoondown: rightharpoondown,\n\trightharpoonup: rightharpoonup,\n\trightleftarrows: rightleftarrows,\n\trightleftharpoons: rightleftharpoons,\n\trightrightarrows: rightrightarrows,\n\trightsquigarrow: rightsquigarrow,\n\tRightTeeArrow: RightTeeArrow,\n\tRightTee: RightTee,\n\tRightTeeVector: RightTeeVector,\n\trightthreetimes: rightthreetimes,\n\tRightTriangleBar: RightTriangleBar,\n\tRightTriangle: RightTriangle,\n\tRightTriangleEqual: RightTriangleEqual,\n\tRightUpDownVector: RightUpDownVector,\n\tRightUpTeeVector: RightUpTeeVector,\n\tRightUpVectorBar: RightUpVectorBar,\n\tRightUpVector: RightUpVector,\n\tRightVectorBar: RightVectorBar,\n\tRightVector: RightVector,\n\tring: ring,\n\trisingdotseq: risingdotseq,\n\trlarr: rlarr,\n\trlhar: rlhar,\n\trlm: rlm,\n\trmoustache: rmoustache,\n\trmoust: rmoust,\n\trnmid: rnmid,\n\troang: roang,\n\troarr: roarr,\n\trobrk: robrk,\n\tropar: ropar,\n\tropf: ropf,\n\tRopf: Ropf,\n\troplus: roplus,\n\trotimes: rotimes,\n\tRoundImplies: RoundImplies,\n\trpar: rpar,\n\trpargt: rpargt,\n\trppolint: rppolint,\n\trrarr: rrarr,\n\tRrightarrow: Rrightarrow,\n\trsaquo: rsaquo,\n\trscr: rscr,\n\tRscr: Rscr,\n\trsh: rsh,\n\tRsh: Rsh,\n\trsqb: rsqb,\n\trsquo: rsquo,\n\trsquor: rsquor,\n\trthree: rthree,\n\trtimes: rtimes,\n\trtri: rtri,\n\trtrie: rtrie,\n\trtrif: rtrif,\n\trtriltri: rtriltri,\n\tRuleDelayed: RuleDelayed,\n\truluhar: ruluhar,\n\trx: rx,\n\tSacute: Sacute,\n\tsacute: sacute,\n\tsbquo: sbquo,\n\tscap: scap,\n\tScaron: Scaron,\n\tscaron: scaron,\n\tSc: Sc,\n\tsc: sc,\n\tsccue: sccue,\n\tsce: sce,\n\tscE: scE,\n\tScedil: Scedil,\n\tscedil: scedil,\n\tScirc: Scirc,\n\tscirc: scirc,\n\tscnap: scnap,\n\tscnE: scnE,\n\tscnsim: scnsim,\n\tscpolint: scpolint,\n\tscsim: scsim,\n\tScy: Scy,\n\tscy: scy,\n\tsdotb: sdotb,\n\tsdot: sdot,\n\tsdote: sdote,\n\tsearhk: searhk,\n\tsearr: searr,\n\tseArr: seArr,\n\tsearrow: searrow,\n\tsect: sect$1,\n\tsemi: semi,\n\tseswar: seswar,\n\tsetminus: setminus,\n\tsetmn: setmn,\n\tsext: sext,\n\tSfr: Sfr,\n\tsfr: sfr,\n\tsfrown: sfrown,\n\tsharp: sharp,\n\tSHCHcy: SHCHcy,\n\tshchcy: shchcy,\n\tSHcy: SHcy,\n\tshcy: shcy,\n\tShortDownArrow: ShortDownArrow,\n\tShortLeftArrow: ShortLeftArrow,\n\tshortmid: shortmid,\n\tshortparallel: shortparallel,\n\tShortRightArrow: ShortRightArrow,\n\tShortUpArrow: ShortUpArrow,\n\tshy: shy$1,\n\tSigma: Sigma,\n\tsigma: sigma,\n\tsigmaf: sigmaf,\n\tsigmav: sigmav,\n\tsim: sim,\n\tsimdot: simdot,\n\tsime: sime,\n\tsimeq: simeq,\n\tsimg: simg,\n\tsimgE: simgE,\n\tsiml: siml,\n\tsimlE: simlE,\n\tsimne: simne,\n\tsimplus: simplus,\n\tsimrarr: simrarr,\n\tslarr: slarr,\n\tSmallCircle: SmallCircle,\n\tsmallsetminus: smallsetminus,\n\tsmashp: smashp,\n\tsmeparsl: smeparsl,\n\tsmid: smid,\n\tsmile: smile,\n\tsmt: smt,\n\tsmte: smte,\n\tsmtes: smtes,\n\tSOFTcy: SOFTcy,\n\tsoftcy: softcy,\n\tsolbar: solbar,\n\tsolb: solb,\n\tsol: sol,\n\tSopf: Sopf,\n\tsopf: sopf,\n\tspades: spades,\n\tspadesuit: spadesuit,\n\tspar: spar,\n\tsqcap: sqcap,\n\tsqcaps: sqcaps,\n\tsqcup: sqcup,\n\tsqcups: sqcups,\n\tSqrt: Sqrt,\n\tsqsub: sqsub,\n\tsqsube: sqsube,\n\tsqsubset: sqsubset,\n\tsqsubseteq: sqsubseteq,\n\tsqsup: sqsup,\n\tsqsupe: sqsupe,\n\tsqsupset: sqsupset,\n\tsqsupseteq: sqsupseteq,\n\tsquare: square,\n\tSquare: Square,\n\tSquareIntersection: SquareIntersection,\n\tSquareSubset: SquareSubset,\n\tSquareSubsetEqual: SquareSubsetEqual,\n\tSquareSuperset: SquareSuperset,\n\tSquareSupersetEqual: SquareSupersetEqual,\n\tSquareUnion: SquareUnion,\n\tsquarf: squarf,\n\tsqu: squ,\n\tsquf: squf,\n\tsrarr: srarr,\n\tSscr: Sscr,\n\tsscr: sscr,\n\tssetmn: ssetmn,\n\tssmile: ssmile,\n\tsstarf: sstarf,\n\tStar: Star,\n\tstar: star,\n\tstarf: starf,\n\tstraightepsilon: straightepsilon,\n\tstraightphi: straightphi,\n\tstrns: strns,\n\tsub: sub,\n\tSub: Sub,\n\tsubdot: subdot,\n\tsubE: subE,\n\tsube: sube,\n\tsubedot: subedot,\n\tsubmult: submult,\n\tsubnE: subnE,\n\tsubne: subne,\n\tsubplus: subplus,\n\tsubrarr: subrarr,\n\tsubset: subset,\n\tSubset: Subset,\n\tsubseteq: subseteq,\n\tsubseteqq: subseteqq,\n\tSubsetEqual: SubsetEqual,\n\tsubsetneq: subsetneq,\n\tsubsetneqq: subsetneqq,\n\tsubsim: subsim,\n\tsubsub: subsub,\n\tsubsup: subsup,\n\tsuccapprox: succapprox,\n\tsucc: succ,\n\tsucccurlyeq: succcurlyeq,\n\tSucceeds: Succeeds,\n\tSucceedsEqual: SucceedsEqual,\n\tSucceedsSlantEqual: SucceedsSlantEqual,\n\tSucceedsTilde: SucceedsTilde,\n\tsucceq: succeq,\n\tsuccnapprox: succnapprox,\n\tsuccneqq: succneqq,\n\tsuccnsim: succnsim,\n\tsuccsim: succsim,\n\tSuchThat: SuchThat,\n\tsum: sum,\n\tSum: Sum,\n\tsung: sung,\n\tsup1: sup1$1,\n\tsup2: sup2$1,\n\tsup3: sup3$1,\n\tsup: sup,\n\tSup: Sup,\n\tsupdot: supdot,\n\tsupdsub: supdsub,\n\tsupE: supE,\n\tsupe: supe,\n\tsupedot: supedot,\n\tSuperset: Superset,\n\tSupersetEqual: SupersetEqual,\n\tsuphsol: suphsol,\n\tsuphsub: suphsub,\n\tsuplarr: suplarr,\n\tsupmult: supmult,\n\tsupnE: supnE,\n\tsupne: supne,\n\tsupplus: supplus,\n\tsupset: supset,\n\tSupset: Supset,\n\tsupseteq: supseteq,\n\tsupseteqq: supseteqq,\n\tsupsetneq: supsetneq,\n\tsupsetneqq: supsetneqq,\n\tsupsim: supsim,\n\tsupsub: supsub,\n\tsupsup: supsup,\n\tswarhk: swarhk,\n\tswarr: swarr,\n\tswArr: swArr,\n\tswarrow: swarrow,\n\tswnwar: swnwar,\n\tszlig: szlig$1,\n\tTab: Tab,\n\ttarget: target,\n\tTau: Tau,\n\ttau: tau,\n\ttbrk: tbrk,\n\tTcaron: Tcaron,\n\ttcaron: tcaron,\n\tTcedil: Tcedil,\n\ttcedil: tcedil,\n\tTcy: Tcy,\n\ttcy: tcy,\n\ttdot: tdot,\n\ttelrec: telrec,\n\tTfr: Tfr,\n\ttfr: tfr,\n\tthere4: there4,\n\ttherefore: therefore,\n\tTherefore: Therefore,\n\tTheta: Theta,\n\ttheta: theta,\n\tthetasym: thetasym,\n\tthetav: thetav,\n\tthickapprox: thickapprox,\n\tthicksim: thicksim,\n\tThickSpace: ThickSpace,\n\tThinSpace: ThinSpace,\n\tthinsp: thinsp,\n\tthkap: thkap,\n\tthksim: thksim,\n\tTHORN: THORN$1,\n\tthorn: thorn$1,\n\ttilde: tilde,\n\tTilde: Tilde,\n\tTildeEqual: TildeEqual,\n\tTildeFullEqual: TildeFullEqual,\n\tTildeTilde: TildeTilde,\n\ttimesbar: timesbar,\n\ttimesb: timesb,\n\ttimes: times$1,\n\ttimesd: timesd,\n\ttint: tint,\n\ttoea: toea,\n\ttopbot: topbot,\n\ttopcir: topcir,\n\ttop: top,\n\tTopf: Topf,\n\ttopf: topf,\n\ttopfork: topfork,\n\ttosa: tosa,\n\ttprime: tprime,\n\ttrade: trade,\n\tTRADE: TRADE,\n\ttriangle: triangle,\n\ttriangledown: triangledown,\n\ttriangleleft: triangleleft,\n\ttrianglelefteq: trianglelefteq,\n\ttriangleq: triangleq,\n\ttriangleright: triangleright,\n\ttrianglerighteq: trianglerighteq,\n\ttridot: tridot,\n\ttrie: trie,\n\ttriminus: triminus,\n\tTripleDot: TripleDot,\n\ttriplus: triplus,\n\ttrisb: trisb,\n\ttritime: tritime,\n\ttrpezium: trpezium,\n\tTscr: Tscr,\n\ttscr: tscr,\n\tTScy: TScy,\n\ttscy: tscy,\n\tTSHcy: TSHcy,\n\ttshcy: tshcy,\n\tTstrok: Tstrok,\n\ttstrok: tstrok,\n\ttwixt: twixt,\n\ttwoheadleftarrow: twoheadleftarrow,\n\ttwoheadrightarrow: twoheadrightarrow,\n\tUacute: Uacute$1,\n\tuacute: uacute$1,\n\tuarr: uarr,\n\tUarr: Uarr,\n\tuArr: uArr,\n\tUarrocir: Uarrocir,\n\tUbrcy: Ubrcy,\n\tubrcy: ubrcy,\n\tUbreve: Ubreve,\n\tubreve: ubreve,\n\tUcirc: Ucirc$1,\n\tucirc: ucirc$1,\n\tUcy: Ucy,\n\tucy: ucy,\n\tudarr: udarr,\n\tUdblac: Udblac,\n\tudblac: udblac,\n\tudhar: udhar,\n\tufisht: ufisht,\n\tUfr: Ufr,\n\tufr: ufr,\n\tUgrave: Ugrave$1,\n\tugrave: ugrave$1,\n\tuHar: uHar,\n\tuharl: uharl,\n\tuharr: uharr,\n\tuhblk: uhblk,\n\tulcorn: ulcorn,\n\tulcorner: ulcorner,\n\tulcrop: ulcrop,\n\tultri: ultri,\n\tUmacr: Umacr,\n\tumacr: umacr,\n\tuml: uml$1,\n\tUnderBar: UnderBar,\n\tUnderBrace: UnderBrace,\n\tUnderBracket: UnderBracket,\n\tUnderParenthesis: UnderParenthesis,\n\tUnion: Union,\n\tUnionPlus: UnionPlus,\n\tUogon: Uogon,\n\tuogon: uogon,\n\tUopf: Uopf,\n\tuopf: uopf,\n\tUpArrowBar: UpArrowBar,\n\tuparrow: uparrow,\n\tUpArrow: UpArrow,\n\tUparrow: Uparrow,\n\tUpArrowDownArrow: UpArrowDownArrow,\n\tupdownarrow: updownarrow,\n\tUpDownArrow: UpDownArrow,\n\tUpdownarrow: Updownarrow,\n\tUpEquilibrium: UpEquilibrium,\n\tupharpoonleft: upharpoonleft,\n\tupharpoonright: upharpoonright,\n\tuplus: uplus,\n\tUpperLeftArrow: UpperLeftArrow,\n\tUpperRightArrow: UpperRightArrow,\n\tupsi: upsi,\n\tUpsi: Upsi,\n\tupsih: upsih,\n\tUpsilon: Upsilon,\n\tupsilon: upsilon,\n\tUpTeeArrow: UpTeeArrow,\n\tUpTee: UpTee,\n\tupuparrows: upuparrows,\n\turcorn: urcorn,\n\turcorner: urcorner,\n\turcrop: urcrop,\n\tUring: Uring,\n\turing: uring,\n\turtri: urtri,\n\tUscr: Uscr,\n\tuscr: uscr,\n\tutdot: utdot,\n\tUtilde: Utilde,\n\tutilde: utilde,\n\tutri: utri,\n\tutrif: utrif,\n\tuuarr: uuarr,\n\tUuml: Uuml$1,\n\tuuml: uuml$1,\n\tuwangle: uwangle,\n\tvangrt: vangrt,\n\tvarepsilon: varepsilon,\n\tvarkappa: varkappa,\n\tvarnothing: varnothing,\n\tvarphi: varphi,\n\tvarpi: varpi,\n\tvarpropto: varpropto,\n\tvarr: varr,\n\tvArr: vArr,\n\tvarrho: varrho,\n\tvarsigma: varsigma,\n\tvarsubsetneq: varsubsetneq,\n\tvarsubsetneqq: varsubsetneqq,\n\tvarsupsetneq: varsupsetneq,\n\tvarsupsetneqq: varsupsetneqq,\n\tvartheta: vartheta,\n\tvartriangleleft: vartriangleleft,\n\tvartriangleright: vartriangleright,\n\tvBar: vBar,\n\tVbar: Vbar,\n\tvBarv: vBarv,\n\tVcy: Vcy,\n\tvcy: vcy,\n\tvdash: vdash,\n\tvDash: vDash,\n\tVdash: Vdash,\n\tVDash: VDash,\n\tVdashl: Vdashl,\n\tveebar: veebar,\n\tvee: vee,\n\tVee: Vee,\n\tveeeq: veeeq,\n\tvellip: vellip,\n\tverbar: verbar,\n\tVerbar: Verbar,\n\tvert: vert,\n\tVert: Vert,\n\tVerticalBar: VerticalBar,\n\tVerticalLine: VerticalLine,\n\tVerticalSeparator: VerticalSeparator,\n\tVerticalTilde: VerticalTilde,\n\tVeryThinSpace: VeryThinSpace,\n\tVfr: Vfr,\n\tvfr: vfr,\n\tvltri: vltri,\n\tvnsub: vnsub,\n\tvnsup: vnsup,\n\tVopf: Vopf,\n\tvopf: vopf,\n\tvprop: vprop,\n\tvrtri: vrtri,\n\tVscr: Vscr,\n\tvscr: vscr,\n\tvsubnE: vsubnE,\n\tvsubne: vsubne,\n\tvsupnE: vsupnE,\n\tvsupne: vsupne,\n\tVvdash: Vvdash,\n\tvzigzag: vzigzag,\n\tWcirc: Wcirc,\n\twcirc: wcirc,\n\twedbar: wedbar,\n\twedge: wedge,\n\tWedge: Wedge,\n\twedgeq: wedgeq,\n\tweierp: weierp,\n\tWfr: Wfr,\n\twfr: wfr,\n\tWopf: Wopf,\n\twopf: wopf,\n\twp: wp,\n\twr: wr,\n\twreath: wreath,\n\tWscr: Wscr,\n\twscr: wscr,\n\txcap: xcap,\n\txcirc: xcirc,\n\txcup: xcup,\n\txdtri: xdtri,\n\tXfr: Xfr,\n\txfr: xfr,\n\txharr: xharr,\n\txhArr: xhArr,\n\tXi: Xi,\n\txi: xi,\n\txlarr: xlarr,\n\txlArr: xlArr,\n\txmap: xmap,\n\txnis: xnis,\n\txodot: xodot,\n\tXopf: Xopf,\n\txopf: xopf,\n\txoplus: xoplus,\n\txotime: xotime,\n\txrarr: xrarr,\n\txrArr: xrArr,\n\tXscr: Xscr,\n\txscr: xscr,\n\txsqcup: xsqcup,\n\txuplus: xuplus,\n\txutri: xutri,\n\txvee: xvee,\n\txwedge: xwedge,\n\tYacute: Yacute$1,\n\tyacute: yacute$1,\n\tYAcy: YAcy,\n\tyacy: yacy,\n\tYcirc: Ycirc,\n\tycirc: ycirc,\n\tYcy: Ycy,\n\tycy: ycy,\n\tyen: yen$1,\n\tYfr: Yfr,\n\tyfr: yfr,\n\tYIcy: YIcy,\n\tyicy: yicy,\n\tYopf: Yopf,\n\tyopf: yopf,\n\tYscr: Yscr,\n\tyscr: yscr,\n\tYUcy: YUcy,\n\tyucy: yucy,\n\tyuml: yuml$1,\n\tYuml: Yuml,\n\tZacute: Zacute,\n\tzacute: zacute,\n\tZcaron: Zcaron,\n\tzcaron: zcaron,\n\tZcy: Zcy,\n\tzcy: zcy,\n\tZdot: Zdot,\n\tzdot: zdot,\n\tzeetrf: zeetrf,\n\tZeroWidthSpace: ZeroWidthSpace,\n\tZeta: Zeta,\n\tzeta: zeta,\n\tzfr: zfr,\n\tZfr: Zfr,\n\tZHcy: ZHcy,\n\tzhcy: zhcy,\n\tzigrarr: zigrarr,\n\tzopf: zopf,\n\tZopf: Zopf,\n\tZscr: Zscr,\n\tzscr: zscr,\n\tzwj: zwj,\n\tzwnj: zwnj\n};\n\nvar Aacute = \"Á\";\nvar aacute = \"á\";\nvar Acirc = \"Â\";\nvar acirc = \"â\";\nvar acute = \"´\";\nvar AElig = \"Æ\";\nvar aelig = \"æ\";\nvar Agrave = \"À\";\nvar agrave = \"à\";\nvar amp$1 = \"&\";\nvar AMP = \"&\";\nvar Aring = \"Å\";\nvar aring = \"å\";\nvar Atilde = \"Ã\";\nvar atilde = \"ã\";\nvar Auml = \"Ä\";\nvar auml = \"ä\";\nvar brvbar = \"¦\";\nvar Ccedil = \"Ç\";\nvar ccedil = \"ç\";\nvar cedil = \"¸\";\nvar cent = \"¢\";\nvar copy = \"©\";\nvar COPY = \"©\";\nvar curren = \"¤\";\nvar deg = \"°\";\nvar divide = \"÷\";\nvar Eacute = \"É\";\nvar eacute = \"é\";\nvar Ecirc = \"Ê\";\nvar ecirc = \"ê\";\nvar Egrave = \"È\";\nvar egrave = \"è\";\nvar ETH = \"Ð\";\nvar eth = \"ð\";\nvar Euml = \"Ë\";\nvar euml = \"ë\";\nvar frac12 = \"½\";\nvar frac14 = \"¼\";\nvar frac34 = \"¾\";\nvar gt$1 = \">\";\nvar GT = \">\";\nvar Iacute = \"Í\";\nvar iacute = \"í\";\nvar Icirc = \"Î\";\nvar icirc = \"î\";\nvar iexcl = \"¡\";\nvar Igrave = \"Ì\";\nvar igrave = \"ì\";\nvar iquest = \"¿\";\nvar Iuml = \"Ï\";\nvar iuml = \"ï\";\nvar laquo = \"«\";\nvar lt$1 = \"<\";\nvar LT = \"<\";\nvar macr = \"¯\";\nvar micro = \"µ\";\nvar middot = \"·\";\nvar nbsp = \" \";\nvar not = \"¬\";\nvar Ntilde = \"Ñ\";\nvar ntilde = \"ñ\";\nvar Oacute = \"Ó\";\nvar oacute = \"ó\";\nvar Ocirc = \"Ô\";\nvar ocirc = \"ô\";\nvar Ograve = \"Ò\";\nvar ograve = \"ò\";\nvar ordf = \"ª\";\nvar ordm = \"º\";\nvar Oslash = \"Ø\";\nvar oslash = \"ø\";\nvar Otilde = \"Õ\";\nvar otilde = \"õ\";\nvar Ouml = \"Ö\";\nvar ouml = \"ö\";\nvar para = \"¶\";\nvar plusmn = \"±\";\nvar pound = \"£\";\nvar quot$1 = \"\\\"\";\nvar QUOT = \"\\\"\";\nvar raquo = \"»\";\nvar reg = \"®\";\nvar REG = \"®\";\nvar sect = \"§\";\nvar shy = \"­\";\nvar sup1 = \"¹\";\nvar sup2 = \"²\";\nvar sup3 = \"³\";\nvar szlig = \"ß\";\nvar THORN = \"Þ\";\nvar thorn = \"þ\";\nvar times = \"×\";\nvar Uacute = \"Ú\";\nvar uacute = \"ú\";\nvar Ucirc = \"Û\";\nvar ucirc = \"û\";\nvar Ugrave = \"Ù\";\nvar ugrave = \"ù\";\nvar uml = \"¨\";\nvar Uuml = \"Ü\";\nvar uuml = \"ü\";\nvar Yacute = \"Ý\";\nvar yacute = \"ý\";\nvar yen = \"¥\";\nvar yuml = \"ÿ\";\nvar require$$1 = {\n\tAacute: Aacute,\n\taacute: aacute,\n\tAcirc: Acirc,\n\tacirc: acirc,\n\tacute: acute,\n\tAElig: AElig,\n\taelig: aelig,\n\tAgrave: Agrave,\n\tagrave: agrave,\n\tamp: amp$1,\n\tAMP: AMP,\n\tAring: Aring,\n\taring: aring,\n\tAtilde: Atilde,\n\tatilde: atilde,\n\tAuml: Auml,\n\tauml: auml,\n\tbrvbar: brvbar,\n\tCcedil: Ccedil,\n\tccedil: ccedil,\n\tcedil: cedil,\n\tcent: cent,\n\tcopy: copy,\n\tCOPY: COPY,\n\tcurren: curren,\n\tdeg: deg,\n\tdivide: divide,\n\tEacute: Eacute,\n\teacute: eacute,\n\tEcirc: Ecirc,\n\tecirc: ecirc,\n\tEgrave: Egrave,\n\tegrave: egrave,\n\tETH: ETH,\n\teth: eth,\n\tEuml: Euml,\n\teuml: euml,\n\tfrac12: frac12,\n\tfrac14: frac14,\n\tfrac34: frac34,\n\tgt: gt$1,\n\tGT: GT,\n\tIacute: Iacute,\n\tiacute: iacute,\n\tIcirc: Icirc,\n\ticirc: icirc,\n\tiexcl: iexcl,\n\tIgrave: Igrave,\n\tigrave: igrave,\n\tiquest: iquest,\n\tIuml: Iuml,\n\tiuml: iuml,\n\tlaquo: laquo,\n\tlt: lt$1,\n\tLT: LT,\n\tmacr: macr,\n\tmicro: micro,\n\tmiddot: middot,\n\tnbsp: nbsp,\n\tnot: not,\n\tNtilde: Ntilde,\n\tntilde: ntilde,\n\tOacute: Oacute,\n\toacute: oacute,\n\tOcirc: Ocirc,\n\tocirc: ocirc,\n\tOgrave: Ograve,\n\tograve: ograve,\n\tordf: ordf,\n\tordm: ordm,\n\tOslash: Oslash,\n\toslash: oslash,\n\tOtilde: Otilde,\n\totilde: otilde,\n\tOuml: Ouml,\n\touml: ouml,\n\tpara: para,\n\tplusmn: plusmn,\n\tpound: pound,\n\tquot: quot$1,\n\tQUOT: QUOT,\n\traquo: raquo,\n\treg: reg,\n\tREG: REG,\n\tsect: sect,\n\tshy: shy,\n\tsup1: sup1,\n\tsup2: sup2,\n\tsup3: sup3,\n\tszlig: szlig,\n\tTHORN: THORN,\n\tthorn: thorn,\n\ttimes: times,\n\tUacute: Uacute,\n\tuacute: uacute,\n\tUcirc: Ucirc,\n\tucirc: ucirc,\n\tUgrave: Ugrave,\n\tugrave: ugrave,\n\tuml: uml,\n\tUuml: Uuml,\n\tuuml: uuml,\n\tYacute: Yacute,\n\tyacute: yacute,\n\tyen: yen,\n\tyuml: yuml\n};\n\nvar amp = \"&\";\nvar apos = \"'\";\nvar gt = \">\";\nvar lt = \"<\";\nvar quot = \"\\\"\";\nvar require$$0$1 = {\n\tamp: amp,\n\tapos: apos,\n\tgt: gt,\n\tlt: lt,\n\tquot: quot\n};\n\nvar decode_codepoint = {};\n\nvar require$$0 = {\n\t\"0\": 65533,\n\t\"128\": 8364,\n\t\"130\": 8218,\n\t\"131\": 402,\n\t\"132\": 8222,\n\t\"133\": 8230,\n\t\"134\": 8224,\n\t\"135\": 8225,\n\t\"136\": 710,\n\t\"137\": 8240,\n\t\"138\": 352,\n\t\"139\": 8249,\n\t\"140\": 338,\n\t\"142\": 381,\n\t\"145\": 8216,\n\t\"146\": 8217,\n\t\"147\": 8220,\n\t\"148\": 8221,\n\t\"149\": 8226,\n\t\"150\": 8211,\n\t\"151\": 8212,\n\t\"152\": 732,\n\t\"153\": 8482,\n\t\"154\": 353,\n\t\"155\": 8250,\n\t\"156\": 339,\n\t\"158\": 382,\n\t\"159\": 376\n};\n\nvar __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode_codepoint, \"__esModule\", { value: true });\nvar decode_json_1 = __importDefault$2(require$$0);\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint$2 = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = \"\";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint$2(codePoint);\n}\ndecode_codepoint.default = decodeCodePoint;\n\nvar __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode, \"__esModule\", { value: true });\ndecode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;\nvar entities_json_1$1 = __importDefault$1(require$$1$1);\nvar legacy_json_1 = __importDefault$1(require$$1);\nvar xml_json_1$1 = __importDefault$1(require$$0$1);\nvar decode_codepoint_1 = __importDefault$1(decode_codepoint);\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\ndecode.decodeXML = getStrictDecoder(xml_json_1$1.default);\ndecode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\ndecode.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1$1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += \";?\";\n            j++;\n        }\n        else {\n            keys[i] += \";\";\n        }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1$1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== \";\")\n            str += \";\";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === \"#\") {\n            var secondChar = str.charAt(2);\n            if (secondChar === \"X\" || secondChar === \"x\") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\n\nvar encode = {};\n\nvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(encode, \"__esModule\", { value: true });\nencode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;\nvar xml_json_1 = __importDefault(require$$0$1);\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = __importDefault(require$$1$1);\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nencode.escape = escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nencode.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n\n(function (exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\nvar decode_1 = decode;\nvar encode_1 = encode;\n/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeXML` or `decodeHTML` directly.\n */\nfunction decode$1(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n}\nexports.decode = decode$1;\n/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n */\nfunction decodeStrict(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n}\nexports.decodeStrict = decodeStrict;\n/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n */\nfunction encode$1(data, level) {\n    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n}\nexports.encode = encode$1;\nvar encode_2 = encode;\nObject.defineProperty(exports, \"encodeXML\", { enumerable: true, get: function () { return encode_2.encodeXML; } });\nObject.defineProperty(exports, \"encodeHTML\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeNonAsciiHTML\", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });\nObject.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return encode_2.escape; } });\nObject.defineProperty(exports, \"escapeUTF8\", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"encodeHTML4\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeHTML5\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nvar decode_2 = decode;\nObject.defineProperty(exports, \"decodeXML\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\nObject.defineProperty(exports, \"decodeHTML\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTMLStrict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"decodeHTML4\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML5\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML4Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeHTML5Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeXMLStrict\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n}(lib));\n\nvar ENTITY = '&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});';\nvar C_BACKSLASH$1 = 92;\nvar reBackslashOrAmp = /[\\\\&]/;\nvar ESCAPABLE = '[!\"#$%&\\'()*+,./:;<=>?@[\\\\\\\\\\\\]^_`{|}~-]';\nvar reEntityOrEscapedChar = new RegExp(\"\\\\\\\\\" + ESCAPABLE + \"|\" + ENTITY, 'gi');\nvar XMLSPECIAL = '[&<>\"]';\nvar reXmlSpecial = new RegExp(XMLSPECIAL, 'g');\nvar unescapeChar = function (s) {\n    if (s.charCodeAt(0) === C_BACKSLASH$1) {\n        return s.charAt(1);\n    }\n    return lib.decodeHTML(s);\n};\n// Replace entities and backslash escapes with literal characters.\nfunction unescapeString(s) {\n    if (reBackslashOrAmp.test(s)) {\n        return s.replace(reEntityOrEscapedChar, unescapeChar);\n    }\n    return s;\n}\nfunction normalizeURI(uri) {\n    try {\n        return encode_1(uri);\n    }\n    catch (err) {\n        return uri;\n    }\n}\nfunction replaceUnsafeChar(s) {\n    switch (s) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return s;\n    }\n}\nfunction escapeXml(s) {\n    if (reXmlSpecial.test(s)) {\n        return s.replace(reXmlSpecial, replaceUnsafeChar);\n    }\n    return s;\n}\nfunction repeat(str, count) {\n    var arr = [];\n    for (var i = 0; i < count; i++) {\n        arr.push(str);\n    }\n    return arr.join('');\n}\nfunction isEmpty(str) {\n    if (!str) {\n        return true;\n    }\n    return !/[^ \\t]+/.test(str);\n}\n\nvar NodeWalker = /** @class */ (function () {\n    function NodeWalker(root) {\n        this.current = root;\n        this.root = root;\n        this.entering = true;\n    }\n    NodeWalker.prototype.next = function () {\n        var cur = this.current;\n        var entering = this.entering;\n        if (cur === null) {\n            return null;\n        }\n        var container = isContainer$1(cur);\n        if (entering && container) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                // stay on node but exit\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next === null) {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        else {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        return { entering: entering, node: cur };\n    };\n    NodeWalker.prototype.resumeAt = function (node, entering) {\n        this.current = node;\n        this.entering = entering === true;\n    };\n    return NodeWalker;\n}());\n\nfunction isContainer$1(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nvar lastNodeId = 1;\nvar nodeMap = {};\nfunction getNodeById(id) {\n    return nodeMap[id];\n}\nfunction removeNodeById(id) {\n    delete nodeMap[id];\n}\nfunction removeAllNode() {\n    nodeMap = {};\n}\nvar Node$1 = /** @class */ (function () {\n    function Node(nodeType, sourcepos) {\n        this.parent = null;\n        this.prev = null;\n        this.next = null;\n        // only for container node\n        this.firstChild = null;\n        this.lastChild = null;\n        // only for leaf node\n        this.literal = null;\n        if (nodeType === 'document') {\n            this.id = -1;\n        }\n        else {\n            this.id = lastNodeId++;\n        }\n        this.type = nodeType;\n        this.sourcepos = sourcepos;\n        nodeMap[this.id] = this;\n    }\n    Node.prototype.isContainer = function () {\n        return isContainer$1(this);\n    };\n    Node.prototype.unlink = function () {\n        if (this.prev) {\n            this.prev.next = this.next;\n        }\n        else if (this.parent) {\n            this.parent.firstChild = this.next;\n        }\n        if (this.next) {\n            this.next.prev = this.prev;\n        }\n        else if (this.parent) {\n            this.parent.lastChild = this.prev;\n        }\n        this.parent = null;\n        this.next = null;\n        this.prev = null;\n    };\n    Node.prototype.replaceWith = function (node) {\n        this.insertBefore(node);\n        this.unlink();\n    };\n    Node.prototype.insertAfter = function (sibling) {\n        sibling.unlink();\n        sibling.next = this.next;\n        if (sibling.next) {\n            sibling.next.prev = sibling;\n        }\n        sibling.prev = this;\n        this.next = sibling;\n        if (this.parent) {\n            sibling.parent = this.parent;\n            if (!sibling.next) {\n                sibling.parent.lastChild = sibling;\n            }\n        }\n    };\n    Node.prototype.insertBefore = function (sibling) {\n        sibling.unlink();\n        sibling.prev = this.prev;\n        if (sibling.prev) {\n            sibling.prev.next = sibling;\n        }\n        sibling.next = this;\n        this.prev = sibling;\n        sibling.parent = this.parent;\n        if (!sibling.prev) {\n            sibling.parent.firstChild = sibling;\n        }\n    };\n    Node.prototype.appendChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.lastChild) {\n            this.lastChild.next = child;\n            child.prev = this.lastChild;\n            this.lastChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.prependChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.firstChild) {\n            this.firstChild.prev = child;\n            child.next = this.firstChild;\n            this.firstChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.walker = function () {\n        return new NodeWalker(this);\n    };\n    return Node;\n}());\nvar BlockNode = /** @class */ (function (_super) {\n    __extends(BlockNode, _super);\n    function BlockNode(nodeType, sourcepos) {\n        var _this = _super.call(this, nodeType, sourcepos) || this;\n        // temporal data (for parsing)\n        _this.open = true;\n        _this.lineOffsets = null;\n        _this.stringContent = null;\n        _this.lastLineBlank = false;\n        _this.lastLineChecked = false;\n        _this.type = nodeType;\n        return _this;\n    }\n    return BlockNode;\n}(Node$1));\nvar ListNode = /** @class */ (function (_super) {\n    __extends(ListNode, _super);\n    function ListNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.listData = null;\n        return _this;\n    }\n    return ListNode;\n}(BlockNode));\nvar HeadingNode = /** @class */ (function (_super) {\n    __extends(HeadingNode, _super);\n    function HeadingNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.level = 0;\n        _this.headingType = 'atx';\n        return _this;\n    }\n    return HeadingNode;\n}(BlockNode));\nvar CodeBlockNode = /** @class */ (function (_super) {\n    __extends(CodeBlockNode, _super);\n    function CodeBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isFenced = false;\n        _this.fenceChar = null;\n        _this.fenceLength = 0;\n        _this.fenceOffset = -1;\n        _this.info = null;\n        _this.infoPadding = 0;\n        return _this;\n    }\n    return CodeBlockNode;\n}(BlockNode));\nvar TableNode = /** @class */ (function (_super) {\n    __extends(TableNode, _super);\n    function TableNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.columns = [];\n        return _this;\n    }\n    return TableNode;\n}(BlockNode));\nvar TableCellNode = /** @class */ (function (_super) {\n    __extends(TableCellNode, _super);\n    function TableCellNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.startIdx = 0;\n        _this.endIdx = 0;\n        _this.paddingLeft = 0;\n        _this.paddingRight = 0;\n        _this.ignored = false;\n        return _this;\n    }\n    return TableCellNode;\n}(BlockNode));\nvar RefDefNode = /** @class */ (function (_super) {\n    __extends(RefDefNode, _super);\n    function RefDefNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.title = '';\n        _this.dest = '';\n        _this.label = '';\n        return _this;\n    }\n    return RefDefNode;\n}(BlockNode));\nvar CustomBlockNode = /** @class */ (function (_super) {\n    __extends(CustomBlockNode, _super);\n    function CustomBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.syntaxLength = 0;\n        _this.offset = -1;\n        _this.info = '';\n        return _this;\n    }\n    return CustomBlockNode;\n}(BlockNode));\nvar HtmlBlockNode = /** @class */ (function (_super) {\n    __extends(HtmlBlockNode, _super);\n    function HtmlBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.htmlBlockType = -1;\n        return _this;\n    }\n    return HtmlBlockNode;\n}(BlockNode));\nvar LinkNode = /** @class */ (function (_super) {\n    __extends(LinkNode, _super);\n    function LinkNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destination = null;\n        _this.title = null;\n        _this.extendedAutolink = false;\n        return _this;\n    }\n    return LinkNode;\n}(Node$1));\nvar CodeNode = /** @class */ (function (_super) {\n    __extends(CodeNode, _super);\n    function CodeNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.tickCount = 0;\n        return _this;\n    }\n    return CodeNode;\n}(Node$1));\nvar CustomInlineNode = /** @class */ (function (_super) {\n    __extends(CustomInlineNode, _super);\n    function CustomInlineNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.info = '';\n        return _this;\n    }\n    return CustomInlineNode;\n}(Node$1));\nfunction createNode$1(type, sourcepos) {\n    switch (type) {\n        case 'heading':\n            return new HeadingNode(type, sourcepos);\n        case 'list':\n        case 'item':\n            return new ListNode(type, sourcepos);\n        case 'link':\n        case 'image':\n            return new LinkNode(type, sourcepos);\n        case 'codeBlock':\n            return new CodeBlockNode(type, sourcepos);\n        case 'htmlBlock':\n            return new HtmlBlockNode(type, sourcepos);\n        case 'table':\n            return new TableNode(type, sourcepos);\n        case 'tableCell':\n            return new TableCellNode(type, sourcepos);\n        case 'document':\n        case 'paragraph':\n        case 'blockQuote':\n        case 'thematicBreak':\n        case 'tableRow':\n        case 'tableBody':\n        case 'tableHead':\n        case 'frontMatter':\n            return new BlockNode(type, sourcepos);\n        case 'code':\n            return new CodeNode(type, sourcepos);\n        case 'refDef':\n            return new RefDefNode(type, sourcepos);\n        case 'customBlock':\n            return new CustomBlockNode(type, sourcepos);\n        case 'customInline':\n            return new CustomInlineNode(type, sourcepos);\n        default:\n            return new Node$1(type, sourcepos);\n    }\n}\nfunction isCodeBlock(node) {\n    return node.type === 'codeBlock';\n}\nfunction isHtmlBlock(node) {\n    return node.type === 'htmlBlock';\n}\nfunction isHeading(node) {\n    return node.type === 'heading';\n}\nfunction isList(node) {\n    return node.type === 'list';\n}\nfunction isTable(node) {\n    return node.type === 'table';\n}\nfunction isRefDef(node) {\n    return node.type === 'refDef';\n}\nfunction isCustomBlock(node) {\n    return node.type === 'customBlock';\n}\nfunction isCustomInline(node) {\n    return node.type === 'customInline';\n}\nfunction text$1(s, sourcepos) {\n    var node = createNode$1('text', sourcepos);\n    node.literal = s;\n    return node;\n}\n\nvar TAGNAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTEDVALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLEQUOTEDVALUE = \"'[^']*'\";\nvar DOUBLEQUOTEDVALUE = '\"[^\"]*\"';\nvar ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE + \"|\" + DOUBLEQUOTEDVALUE + \")\";\nvar ATTRIBUTEVALUESPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTEVALUE + \")\";\nvar ATTRIBUTE = \"\" + '(?:\\\\s+' + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + \"?)\";\nvar OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\\\\s*/?>\";\nvar CLOSETAG = \"</\" + TAGNAME + \"\\\\s*[>]\";\nvar HTMLCOMMENT = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar PROCESSINGINSTRUCTION = '[<][?].*?[?][>]';\nvar DECLARATION = '<![A-Z]+\\\\s+[^>]*>';\nvar CDATA = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\nvar HTMLTAG = \"(?:\" + OPENTAG + \"|\" + CLOSETAG + \"|\" + HTMLCOMMENT + \"|\" + PROCESSINGINSTRUCTION + \"|\" + DECLARATION + \"|\" + CDATA + \")\";\nvar reHtmlTag = new RegExp(\"^\" + HTMLTAG, 'i');\n\n// derived from https://github.com/mathiasbynens/String.fromCodePoint\n/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nvar fromCodePoint;\nif (String.fromCodePoint) {\n    fromCodePoint = function (_) {\n        try {\n            return String.fromCodePoint(_);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                return String.fromCharCode(0xfffd);\n            }\n            throw e;\n        }\n    };\n}\nelse {\n    var stringFromCharCode_1 = String.fromCharCode;\n    var floor_1 = Math.floor;\n    fromCodePoint = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = args.length;\n        if (!length) {\n            return '';\n        }\n        var result = '';\n        while (++index < length) {\n            var codePoint = Number(args[index]);\n            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                codePoint < 0 || // not a valid Unicode code point\n                codePoint > 0x10ffff || // not a valid Unicode code point\n                floor_1(codePoint) !== codePoint // not an integer\n            ) {\n                return String.fromCharCode(0xfffd);\n            }\n            if (codePoint <= 0xffff) {\n                // BMP code point\n                codeUnits.push(codePoint);\n            }\n            else {\n                // Astral code point; split in surrogate halves\n                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint -= 0x10000;\n                highSurrogate = (codePoint >> 10) + 0xd800;\n                lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                codeUnits.push(highSurrogate, lowSurrogate);\n            }\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += stringFromCharCode_1.apply(void 0, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    };\n}\nvar fromCodePoint$1 = fromCodePoint;\n\nvar DOMAIN = '(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+';\nvar PATH = '[^<\\\\s]*[^<?!.,:*_?~\\\\s]';\nvar EMAIL = '[\\\\w.+-]+@(?:[\\\\w-]+\\\\.)+[\\\\w-]+';\nfunction trimUnmatchedTrailingParens(source) {\n    var trailingParen = /\\)+$/.exec(source);\n    if (trailingParen) {\n        var count = 0;\n        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {\n            var ch = source_1[_i];\n            if (ch === '(') {\n                if (count < 0) {\n                    count = 1;\n                }\n                else {\n                    count += 1;\n                }\n            }\n            else if (ch === ')') {\n                count -= 1;\n            }\n        }\n        if (count < 0) {\n            var trimCount = Math.min(-count, trailingParen[0].length);\n            return source.substring(0, source.length - trimCount);\n        }\n    }\n    return source;\n}\nfunction trimTrailingEntity(source) {\n    return source.replace(/&[A-Za-z0-9]+;$/, '');\n}\nfunction parseEmailLink(source) {\n    var reEmailLink = new RegExp(EMAIL, 'g');\n    var result = [];\n    var m;\n    while ((m = reEmailLink.exec(source))) {\n        var text_1 = m[0];\n        if (!/[_-]+$/.test(text_1)) {\n            result.push({\n                text: text_1,\n                range: [m.index, m.index + text_1.length - 1],\n                url: \"mailto:\" + text_1,\n            });\n        }\n    }\n    return result;\n}\nfunction parseUrlLink(source) {\n    var reWwwAutolink = new RegExp(\"(www|https?://).\" + DOMAIN + PATH, 'g');\n    var result = [];\n    var m;\n    while ((m = reWwwAutolink.exec(source))) {\n        var text_2 = trimTrailingEntity(trimUnmatchedTrailingParens(m[0]));\n        var scheme = m[1] === 'www' ? 'http://' : '';\n        result.push({\n            text: text_2,\n            range: [m.index, m.index + text_2.length - 1],\n            url: \"\" + scheme + text_2,\n        });\n    }\n    return result;\n}\nfunction baseAutolinkParser(source) {\n    return __spreadArray(__spreadArray([], parseUrlLink(source)), parseEmailLink(source)).sort(function (a, b) { return a.range[0] - b.range[0]; });\n}\nfunction convertExtAutoLinks(walker, autolinkParser) {\n    if (typeof autolinkParser === 'boolean') {\n        autolinkParser = baseAutolinkParser;\n    }\n    var event;\n    var _loop_1 = function () {\n        var entering = event.entering, node = event.node;\n        if (entering && node.type === 'text' && node.parent.type !== 'link') {\n            var literal = node.literal;\n            var linkInfos = autolinkParser(literal);\n            if (!linkInfos || !linkInfos.length) {\n                return \"continue\";\n            }\n            var lastIdx = 0;\n            var _a = node.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];\n            var sourcepos = function (startIdx, endIdx) { return [\n                [lineNum_1, chPos_1 + startIdx],\n                [lineNum_1, chPos_1 + endIdx],\n            ]; };\n            var newNodes = [];\n            for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {\n                var _b = linkInfos_1[_i], range = _b.range, url = _b.url, linkText = _b.text;\n                if (range[0] > lastIdx) {\n                    newNodes.push(text$1(literal.substring(lastIdx, range[0]), sourcepos(lastIdx, range[0] - 1)));\n                }\n                var linkNode = createNode$1('link', sourcepos.apply(void 0, range));\n                linkNode.appendChild(text$1(linkText, sourcepos.apply(void 0, range)));\n                linkNode.destination = url;\n                linkNode.extendedAutolink = true;\n                newNodes.push(linkNode);\n                lastIdx = range[1] + 1;\n            }\n            if (lastIdx < literal.length) {\n                newNodes.push(text$1(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));\n            }\n            for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {\n                var newNode = newNodes_1[_c];\n                node.insertBefore(newNode);\n            }\n            node.unlink();\n        }\n    };\n    while ((event = walker.next())) {\n        _loop_1();\n    }\n}\n\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n// normalize a reference in reference link (remove []s, trim,\n// collapse internal space, unicode case fold.\n// See commonmark/commonmark.js#168.\nfunction normalizeReference(str) {\n    return str\n        .slice(1, str.length - 1)\n        .trim()\n        .replace(/[ \\t\\r\\n]+/, ' ')\n        .toLowerCase()\n        .toUpperCase();\n}\nfunction iterateObject(obj, iteratee) {\n    Object.keys(obj).forEach(function (key) {\n        iteratee(key, obj[key]);\n    });\n}\nfunction omit(obj) {\n    var propNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        propNames[_i - 1] = arguments[_i];\n    }\n    var resultMap = __assign({}, obj);\n    propNames.forEach(function (key) {\n        delete resultMap[key];\n    });\n    return resultMap;\n}\nfunction isEmptyObj(obj) {\n    return !Object.keys(obj).length;\n}\nfunction clearObj(obj) {\n    Object.keys(obj).forEach(function (key) {\n        delete obj[key];\n    });\n}\n\nvar C_NEWLINE = 10;\nvar C_ASTERISK = 42;\nvar C_UNDERSCORE = 95;\nvar C_BACKTICK = 96;\nvar C_OPEN_BRACKET$1 = 91;\nvar C_CLOSE_BRACKET = 93;\nvar C_TILDE = 126;\nvar C_LESSTHAN$1 = 60;\nvar C_BANG = 33;\nvar C_BACKSLASH = 92;\nvar C_AMPERSAND = 38;\nvar C_OPEN_PAREN = 40;\nvar C_CLOSE_PAREN = 41;\nvar C_COLON = 58;\nvar C_SINGLEQUOTE = 39;\nvar C_DOUBLEQUOTE = 34;\nvar C_DOLLAR = 36;\n// Some regexps used in inline parser:\nvar ESCAPED_CHAR = \"\\\\\\\\\" + ESCAPABLE;\nvar rePunctuation = new RegExp(/[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/);\nvar reLinkTitle = new RegExp(\"^(?:\\\"(\" + ESCAPED_CHAR + \"|[^\\\"\\\\x00])*\\\"\" +\n    \"|\" +\n    (\"'(\" + ESCAPED_CHAR + \"|[^'\\\\x00])*'\") +\n    \"|\" +\n    (\"\\\\((\" + ESCAPED_CHAR + \"|[^()\\\\x00])*\\\\))\"));\nvar reLinkDestinationBraces = /^(?:<(?:[^<>\\n\\\\\\x00]|\\\\.)*>)/;\nvar reEscapable = new RegExp(\"^\" + ESCAPABLE);\nvar reEntityHere = new RegExp(\"^\" + ENTITY, 'i');\nvar reTicks = /`+/;\nvar reTicksHere = /^`+/;\nvar reEllipses = /\\.\\.\\./g;\nvar reDash = /--+/g;\nvar reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\\x00-\\x20]*>/i;\nvar reSpnl = /^ *(?:\\n *)?/;\nvar reWhitespaceChar = /^[ \\t\\n\\x0b\\x0c\\x0d]/;\nvar reUnicodeWhitespaceChar = /^\\s/;\nvar reFinalSpace = / *$/;\nvar reInitialSpace = /^ */;\nvar reSpaceAtEndOfLine = /^ *(?:\\n|$)/;\nvar reLinkLabel = /^\\[(?:[^\\\\\\[\\]]|\\\\.){0,1000}\\]/;\n// Matches a string of non-special characters.\nvar reMain = /^[^\\n`\\[\\]\\\\!<&*_'\"~$]+/m;\nvar InlineParser = /** @class */ (function () {\n    function InlineParser(options) {\n        // An InlineParser keeps track of a subject (a string to be parsed)\n        // and a position in that subject.\n        this.subject = '';\n        this.delimiters = null; // used by handleDelim method\n        this.brackets = null;\n        this.pos = 0;\n        this.lineStartNum = 0;\n        this.lineIdx = 0;\n        this.lineOffsets = [0];\n        this.linePosOffset = 0;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.options = options;\n    }\n    InlineParser.prototype.sourcepos = function (start, end) {\n        var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];\n        var lineNum = this.lineStartNum + this.lineIdx;\n        var startpos = [lineNum, start + linePosOffset];\n        if (typeof end === 'number') {\n            return [startpos, [lineNum, end + linePosOffset]];\n        }\n        return startpos;\n    };\n    InlineParser.prototype.nextLine = function () {\n        this.lineIdx += 1;\n        this.linePosOffset = -this.pos;\n    };\n    // If re matches at current position in the subject, advance\n    // position in subject and return the match; otherwise return null.\n    InlineParser.prototype.match = function (re) {\n        var m = re.exec(this.subject.slice(this.pos));\n        if (m === null) {\n            return null;\n        }\n        this.pos += m.index + m[0].length;\n        return m[0];\n    };\n    // Returns the code for the character at the current subject position, or -1\n    // there are no more characters.\n    InlineParser.prototype.peek = function () {\n        if (this.pos < this.subject.length) {\n            return this.subject.charCodeAt(this.pos);\n        }\n        return -1;\n    };\n    // Parse zero or more space characters, including at most one newline\n    InlineParser.prototype.spnl = function () {\n        this.match(reSpnl);\n        return true;\n    };\n    // All of the parsers below try to match something at the current position\n    // in the subject.  If they succeed in matching anything, they\n    // return the inline matched, advancing the subject.\n    // Attempt to parse backticks, adding either a backtick code span or a\n    // literal sequence of backticks.\n    InlineParser.prototype.parseBackticks = function (block) {\n        var startpos = this.pos + 1;\n        var ticks = this.match(reTicksHere);\n        if (ticks === null) {\n            return false;\n        }\n        var afterOpenTicks = this.pos;\n        var matched;\n        while ((matched = this.match(reTicks)) !== null) {\n            if (matched === ticks) {\n                var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);\n                var sourcepos = this.sourcepos(startpos, this.pos);\n                var lines = contents.split('\\n');\n                if (lines.length > 1) {\n                    var lastLine = last(lines);\n                    this.lineIdx += lines.length - 1;\n                    this.linePosOffset = -(this.pos - lastLine.length - ticks.length);\n                    sourcepos[1] = this.sourcepos(this.pos);\n                    contents = lines.join(' ');\n                }\n                var node = createNode$1('code', sourcepos);\n                if (contents.length > 0 &&\n                    contents.match(/[^ ]/) !== null &&\n                    contents[0] == ' ' &&\n                    contents[contents.length - 1] == ' ') {\n                    node.literal = contents.slice(1, contents.length - 1);\n                }\n                else {\n                    node.literal = contents;\n                }\n                node.tickCount = ticks.length;\n                block.appendChild(node);\n                return true;\n            }\n        }\n        // If we got here, we didn't match a closing backtick sequence.\n        this.pos = afterOpenTicks;\n        block.appendChild(text$1(ticks, this.sourcepos(startpos, this.pos - 1)));\n        return true;\n    };\n    // Parse a backslash-escaped special character, adding either the escaped\n    // character, a hard line break (if the backslash is followed by a newline),\n    // or a literal backslash to the block's children.  Assumes current character\n    // is a backslash.\n    InlineParser.prototype.parseBackslash = function (block) {\n        var subj = this.subject;\n        var node;\n        this.pos += 1;\n        var startpos = this.pos;\n        if (this.peek() === C_NEWLINE) {\n            this.pos += 1;\n            node = createNode$1('linebreak', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            this.nextLine();\n        }\n        else if (reEscapable.test(subj.charAt(this.pos))) {\n            block.appendChild(text$1(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));\n            this.pos += 1;\n        }\n        else {\n            block.appendChild(text$1('\\\\', this.sourcepos(startpos, startpos)));\n        }\n        return true;\n    };\n    // Attempt to parse an autolink (URL or email in pointy brackets).\n    InlineParser.prototype.parseAutolink = function (block) {\n        var m;\n        var dest;\n        var node;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEmailAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode$1('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(\"mailto:\" + dest);\n            node.title = '';\n            node.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        if ((m = this.match(reAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode$1('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(dest);\n            node.title = '';\n            node.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        return false;\n    };\n    // Attempt to parse a raw HTML tag.\n    InlineParser.prototype.parseHtmlTag = function (block) {\n        var startpos = this.pos + 1;\n        var m = this.match(reHtmlTag);\n        if (m === null) {\n            return false;\n        }\n        var node = createNode$1('htmlInline', this.sourcepos(startpos, this.pos));\n        node.literal = m;\n        block.appendChild(node);\n        return true;\n    };\n    // Scan a sequence of characters with code cc, and return information about\n    // the number of delimiters and whether they are positioned such that\n    // they can open and/or close emphasis or strong emphasis.  A utility\n    // function for strong/emph parsing.\n    InlineParser.prototype.scanDelims = function (cc) {\n        var numdelims = 0;\n        var startpos = this.pos;\n        if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            numdelims++;\n            this.pos++;\n        }\n        else {\n            while (this.peek() === cc) {\n                numdelims++;\n                this.pos++;\n            }\n        }\n        if (numdelims === 0 || (numdelims < 2 && (cc === C_TILDE || cc === C_DOLLAR))) {\n            this.pos = startpos;\n            return null;\n        }\n        var charBefore = startpos === 0 ? '\\n' : this.subject.charAt(startpos - 1);\n        var ccAfter = this.peek();\n        var charAfter;\n        if (ccAfter === -1) {\n            charAfter = '\\n';\n        }\n        else {\n            charAfter = fromCodePoint$1(ccAfter);\n        }\n        var afterIsWhitespace = reUnicodeWhitespaceChar.test(charAfter);\n        var afterIsPunctuation = rePunctuation.test(charAfter);\n        var beforeIsWhitespace = reUnicodeWhitespaceChar.test(charBefore);\n        var beforeIsPunctuation = rePunctuation.test(charBefore);\n        var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);\n        var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);\n        var canOpen;\n        var canClose;\n        if (cc === C_UNDERSCORE) {\n            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);\n            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);\n        }\n        else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            canOpen = leftFlanking && !rightFlanking;\n            canClose = rightFlanking;\n        }\n        else if (cc === C_DOLLAR) {\n            canOpen = !afterIsWhitespace;\n            canClose = !beforeIsWhitespace;\n        }\n        else {\n            canOpen = leftFlanking;\n            canClose = rightFlanking;\n        }\n        this.pos = startpos;\n        return { numdelims: numdelims, canOpen: canOpen, canClose: canClose };\n    };\n    // Handle a delimiter marker for emphasis or a quote.\n    InlineParser.prototype.handleDelim = function (cc, block) {\n        var res = this.scanDelims(cc);\n        if (!res) {\n            return false;\n        }\n        var numdelims = res.numdelims;\n        var startpos = this.pos + 1;\n        var contents;\n        this.pos += numdelims;\n        if (cc === C_SINGLEQUOTE) {\n            contents = '\\u2019';\n        }\n        else if (cc === C_DOUBLEQUOTE) {\n            contents = '\\u201C';\n        }\n        else {\n            contents = this.subject.slice(startpos - 1, this.pos);\n        }\n        var node = text$1(contents, this.sourcepos(startpos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        if ((res.canOpen || res.canClose) &&\n            (this.options.smart || (cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE))) {\n            this.delimiters = {\n                cc: cc,\n                numdelims: numdelims,\n                origdelims: numdelims,\n                node: node,\n                previous: this.delimiters,\n                next: null,\n                canOpen: res.canOpen,\n                canClose: res.canClose,\n            };\n            if (this.delimiters.previous) {\n                this.delimiters.previous.next = this.delimiters;\n            }\n        }\n        return true;\n    };\n    InlineParser.prototype.removeDelimiter = function (delim) {\n        if (delim.previous !== null) {\n            delim.previous.next = delim.next;\n        }\n        if (delim.next === null) {\n            // top of stack\n            this.delimiters = delim.previous;\n        }\n        else {\n            delim.next.previous = delim.previous;\n        }\n    };\n    InlineParser.prototype.removeDelimitersBetween = function (bottom, top) {\n        if (bottom.next !== top) {\n            bottom.next = top;\n            top.previous = bottom;\n        }\n    };\n    /**\n     * Process all delimiters - emphasis, strong emphasis, strikethrough(gfm)\n     * If the smart punctuation options is true,\n     * convert single/double quotes to corresponding unicode characters.\n     **/\n    InlineParser.prototype.processEmphasis = function (stackBottom) {\n        var _a;\n        var opener;\n        var closer;\n        var oldCloser;\n        var openerInl, closerInl;\n        var openerFound;\n        var oddMatch = false;\n        var openersBottom = (_a = {},\n            _a[C_UNDERSCORE] = [stackBottom, stackBottom, stackBottom],\n            _a[C_ASTERISK] = [stackBottom, stackBottom, stackBottom],\n            _a[C_SINGLEQUOTE] = [stackBottom],\n            _a[C_DOUBLEQUOTE] = [stackBottom],\n            _a[C_TILDE] = [stackBottom],\n            _a[C_DOLLAR] = [stackBottom],\n            _a);\n        // find first closer above stackBottom:\n        closer = this.delimiters;\n        while (closer !== null && closer.previous !== stackBottom) {\n            closer = closer.previous;\n        }\n        // move forward, looking for closers, and handling each\n        while (closer !== null) {\n            var closercc = closer.cc;\n            var closerEmph = closercc === C_UNDERSCORE || closercc === C_ASTERISK;\n            if (!closer.canClose) {\n                closer = closer.next;\n            }\n            else {\n                // found emphasis closer. now look back for first matching opener:\n                opener = closer.previous;\n                openerFound = false;\n                while (opener !== null &&\n                    opener !== stackBottom &&\n                    opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {\n                    oddMatch =\n                        closerEmph &&\n                            (closer.canOpen || opener.canClose) &&\n                            closer.origdelims % 3 !== 0 &&\n                            (opener.origdelims + closer.origdelims) % 3 === 0;\n                    if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {\n                        openerFound = true;\n                        break;\n                    }\n                    opener = opener.previous;\n                }\n                oldCloser = closer;\n                if (closerEmph || closercc === C_TILDE || closercc === C_DOLLAR) {\n                    if (!openerFound) {\n                        closer = closer.next;\n                    }\n                    else if (opener) {\n                        // (null opener check for type narrowing)\n                        // calculate actual number of delimiters used from closer\n                        var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;\n                        var emptyDelims = closerEmph ? 0 : 1;\n                        openerInl = opener.node;\n                        closerInl = closer.node;\n                        // build contents for new emph element\n                        var nodeType = closerEmph\n                            ? useDelims === 1\n                                ? 'emph'\n                                : 'strong'\n                            : 'strike';\n                        if (closercc === C_DOLLAR) {\n                            nodeType = 'customInline';\n                        }\n                        var newNode = createNode$1(nodeType);\n                        var openerEndPos = openerInl.sourcepos[1];\n                        var closerStartPos = closerInl.sourcepos[0];\n                        newNode.sourcepos = [\n                            [openerEndPos[0], openerEndPos[1] - useDelims + 1],\n                            [closerStartPos[0], closerStartPos[1] + useDelims - 1],\n                        ];\n                        openerInl.sourcepos[1][1] -= useDelims;\n                        closerInl.sourcepos[0][1] += useDelims;\n                        openerInl.literal = openerInl.literal.slice(useDelims);\n                        closerInl.literal = closerInl.literal.slice(useDelims);\n                        opener.numdelims -= useDelims;\n                        closer.numdelims -= useDelims;\n                        // remove used delimiters from stack elts and inlines\n                        var tmp = openerInl.next;\n                        var next = void 0;\n                        while (tmp && tmp !== closerInl) {\n                            next = tmp.next;\n                            tmp.unlink();\n                            newNode.appendChild(tmp);\n                            tmp = next;\n                        }\n                        // build custom inline node\n                        if (closercc === C_DOLLAR) {\n                            var textNode = newNode.firstChild;\n                            var literal = textNode.literal || '';\n                            var info = literal.split(/\\s/)[0];\n                            newNode.info = info;\n                            if (literal.length <= info.length) {\n                                textNode.unlink();\n                            }\n                            else {\n                                textNode.sourcepos[0][1] += info.length;\n                                textNode.literal = literal.replace(info + \" \", '');\n                            }\n                        }\n                        openerInl.insertAfter(newNode);\n                        // remove elts between opener and closer in delimiters stack\n                        this.removeDelimitersBetween(opener, closer);\n                        // if opener has 0 delims, remove it and the inline\n                        // if opener has 1 delims and character is tilde, remove delimiter only\n                        if (opener.numdelims <= emptyDelims) {\n                            if (opener.numdelims === 0) {\n                                openerInl.unlink();\n                            }\n                            this.removeDelimiter(opener);\n                        }\n                        // if closer has 0 delims, remove it and the inline\n                        // if closer has 1 delims and character is tilde, remove delimiter only\n                        if (closer.numdelims <= emptyDelims) {\n                            if (closer.numdelims === 0) {\n                                closerInl.unlink();\n                            }\n                            var tempstack = closer.next;\n                            this.removeDelimiter(closer);\n                            closer = tempstack;\n                        }\n                    }\n                }\n                else if (closercc === C_SINGLEQUOTE) {\n                    closer.node.literal = '\\u2019';\n                    if (openerFound) {\n                        opener.node.literal = '\\u2018';\n                    }\n                    closer = closer.next;\n                }\n                else if (closercc === C_DOUBLEQUOTE) {\n                    closer.node.literal = '\\u201D';\n                    if (openerFound) {\n                        opener.node.literal = '\\u201C';\n                    }\n                    closer = closer.next;\n                }\n                if (!openerFound) {\n                    // Set lower bound for future searches for openers:\n                    openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;\n                    if (!oldCloser.canOpen) {\n                        // We can remove a closer that can't be an opener,\n                        // once we've seen there's no matching opener:\n                        this.removeDelimiter(oldCloser);\n                    }\n                }\n            }\n        }\n        // remove all delimiters\n        while (this.delimiters !== null && this.delimiters !== stackBottom) {\n            this.removeDelimiter(this.delimiters);\n        }\n    };\n    // Attempt to parse link title (sans quotes), returning the string\n    // or null if no match.\n    InlineParser.prototype.parseLinkTitle = function () {\n        var title = this.match(reLinkTitle);\n        if (title === null) {\n            return null;\n        }\n        // chop off quotes from title and unescape:\n        return unescapeString(title.substr(1, title.length - 2));\n    };\n    // Attempt to parse link destination, returning the string or null if no match.\n    InlineParser.prototype.parseLinkDestination = function () {\n        var res = this.match(reLinkDestinationBraces);\n        if (res === null) {\n            if (this.peek() === C_LESSTHAN$1) {\n                return null;\n            }\n            // @TODO handrolled parser; res should be null or the string\n            var savepos = this.pos;\n            var openparens = 0;\n            var c = void 0;\n            while ((c = this.peek()) !== -1) {\n                if (c === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1))) {\n                    this.pos += 1;\n                    if (this.peek() !== -1) {\n                        this.pos += 1;\n                    }\n                }\n                else if (c === C_OPEN_PAREN) {\n                    this.pos += 1;\n                    openparens += 1;\n                }\n                else if (c === C_CLOSE_PAREN) {\n                    if (openparens < 1) {\n                        break;\n                    }\n                    else {\n                        this.pos += 1;\n                        openparens -= 1;\n                    }\n                }\n                else if (reWhitespaceChar.exec(fromCodePoint$1(c)) !== null) {\n                    break;\n                }\n                else {\n                    this.pos += 1;\n                }\n            }\n            if (this.pos === savepos && c !== C_CLOSE_PAREN) {\n                return null;\n            }\n            if (openparens !== 0) {\n                return null;\n            }\n            res = this.subject.substr(savepos, this.pos - savepos);\n            return normalizeURI(unescapeString(res));\n        } // chop off surrounding <..>:\n        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));\n    };\n    // Attempt to parse a link label, returning number of characters parsed.\n    InlineParser.prototype.parseLinkLabel = function () {\n        var m = this.match(reLinkLabel);\n        if (m === null || m.length > 1001) {\n            return 0;\n        }\n        return m.length;\n    };\n    // Add open bracket to delimiter stack and add a text node to block's children.\n    InlineParser.prototype.parseOpenBracket = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        var node = text$1('[', this.sourcepos(this.pos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        this.addBracket(node, startpos, false);\n        return true;\n    };\n    // IF next character is [, and ! delimiter to delimiter stack and\n    // add a text node to block's children.  Otherwise just add a text node.\n    InlineParser.prototype.parseBang = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        if (this.peek() === C_OPEN_BRACKET$1) {\n            this.pos += 1;\n            var node = text$1('![', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            // Add entry to stack for this opener\n            this.addBracket(node, startpos + 1, true);\n        }\n        else {\n            var node = text$1('!', this.sourcepos(this.pos, this.pos));\n            block.appendChild(node);\n        }\n        return true;\n    };\n    // Try to match close bracket against an opening in the delimiter\n    // stack.  Add either a link or image, or a plain [ character,\n    // to block's children.  If there is a matching delimiter,\n    // remove it from the delimiter stack.\n    InlineParser.prototype.parseCloseBracket = function (block) {\n        var dest = null;\n        var title = null;\n        var matched = false;\n        this.pos += 1;\n        var startpos = this.pos;\n        // get last [ or ![\n        var opener = this.brackets;\n        if (opener === null) {\n            // no matched opener, just return a literal\n            block.appendChild(text$1(']', this.sourcepos(startpos, startpos)));\n            return true;\n        }\n        if (!opener.active) {\n            // no matched opener, just return a literal\n            block.appendChild(text$1(']', this.sourcepos(startpos, startpos)));\n            // take opener off brackets stack\n            this.removeBracket();\n            return true;\n        }\n        // If we got here, open is a potential opener\n        var isImage = opener.image;\n        // Check to see if we have a link/image\n        var savepos = this.pos;\n        // Inline link?\n        if (this.peek() === C_OPEN_PAREN) {\n            this.pos++;\n            if (this.spnl() &&\n                (dest = this.parseLinkDestination()) !== null &&\n                this.spnl() &&\n                // make sure there's a space before the title:\n                ((reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&\n                    (title = this.parseLinkTitle())) ||\n                    true) &&\n                this.spnl() &&\n                this.peek() === C_CLOSE_PAREN) {\n                this.pos += 1;\n                matched = true;\n            }\n            else {\n                this.pos = savepos;\n            }\n        }\n        var refLabel = '';\n        if (!matched) {\n            // Next, see if there's a link label\n            var beforelabel = this.pos;\n            var n = this.parseLinkLabel();\n            if (n > 2) {\n                refLabel = this.subject.slice(beforelabel, beforelabel + n);\n            }\n            else if (!opener.bracketAfter) {\n                // Empty or missing second label means to use the first label as the reference.\n                // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.\n                refLabel = this.subject.slice(opener.index, startpos);\n            }\n            if (n === 0) {\n                // If shortcut reference link, rewind before spaces we skipped.\n                this.pos = savepos;\n            }\n            if (refLabel) {\n                refLabel = normalizeReference(refLabel);\n                // lookup rawlabel in refMap\n                var link = this.refMap[refLabel];\n                if (link) {\n                    dest = link.destination;\n                    title = link.title;\n                    matched = true;\n                }\n            }\n        }\n        if (matched) {\n            var node = createNode$1(isImage ? 'image' : 'link');\n            node.destination = dest;\n            node.title = title || '';\n            node.sourcepos = [opener.startpos, this.sourcepos(this.pos)];\n            var tmp = opener.node.next;\n            var next = void 0;\n            while (tmp) {\n                next = tmp.next;\n                tmp.unlink();\n                node.appendChild(tmp);\n                tmp = next;\n            }\n            block.appendChild(node);\n            this.processEmphasis(opener.previousDelimiter);\n            this.removeBracket();\n            opener.node.unlink();\n            // We remove this bracket and processEmphasis will remove later delimiters.\n            // Now, for a link, we also deactivate earlier link openers.\n            // (no links in links)\n            if (!isImage) {\n                opener = this.brackets;\n                while (opener !== null) {\n                    if (!opener.image) {\n                        opener.active = false; // deactivate this opener\n                    }\n                    opener = opener.previous;\n                }\n            }\n            if (this.options.referenceDefinition) {\n                this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n            }\n            return true;\n        } // no match\n        this.removeBracket(); // remove this opener from stack\n        this.pos = startpos;\n        block.appendChild(text$1(']', this.sourcepos(startpos, startpos)));\n        if (this.options.referenceDefinition) {\n            this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n        }\n        return true;\n    };\n    InlineParser.prototype.addBracket = function (node, index, image) {\n        if (this.brackets !== null) {\n            this.brackets.bracketAfter = true;\n        }\n        this.brackets = {\n            node: node,\n            startpos: this.sourcepos(index + (image ? 0 : 1)),\n            previous: this.brackets,\n            previousDelimiter: this.delimiters,\n            index: index,\n            image: image,\n            active: true,\n        };\n    };\n    InlineParser.prototype.removeBracket = function () {\n        if (this.brackets) {\n            this.brackets = this.brackets.previous;\n        }\n    };\n    // Attempt to parse an entity.\n    InlineParser.prototype.parseEntity = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEntityHere))) {\n            block.appendChild(text$1(lib.decodeHTML(m), this.sourcepos(startpos, this.pos)));\n            return true;\n        }\n        return false;\n    };\n    // Parse a run of ordinary characters, or a single character with\n    // a special meaning in markdown, as a plain string.\n    InlineParser.prototype.parseString = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reMain))) {\n            if (this.options.smart) {\n                var lit = m.replace(reEllipses, '\\u2026').replace(reDash, function (chars) {\n                    var enCount = 0;\n                    var emCount = 0;\n                    if (chars.length % 3 === 0) {\n                        // If divisible by 3, use all em dashes\n                        emCount = chars.length / 3;\n                    }\n                    else if (chars.length % 2 === 0) {\n                        // If divisible by 2, use all en dashes\n                        enCount = chars.length / 2;\n                    }\n                    else if (chars.length % 3 === 2) {\n                        // If 2 extra dashes, use en dash for last 2; em dashes for rest\n                        enCount = 1;\n                        emCount = (chars.length - 2) / 3;\n                    }\n                    else {\n                        // Use en dashes for last 4 hyphens; em dashes for rest\n                        enCount = 2;\n                        emCount = (chars.length - 4) / 3;\n                    }\n                    return repeat('\\u2014', emCount) + repeat('\\u2013', enCount);\n                });\n                block.appendChild(text$1(lit, this.sourcepos(startpos, this.pos)));\n            }\n            else {\n                var node = text$1(m, this.sourcepos(startpos, this.pos));\n                block.appendChild(node);\n            }\n            return true;\n        }\n        return false;\n    };\n    // Parse a newline.  If it was preceded by two spaces, return a hard\n    // line break; otherwise a soft line break.\n    InlineParser.prototype.parseNewline = function (block) {\n        this.pos += 1; // assume we're at a \\n\n        // check previous node for trailing spaces\n        var lastc = block.lastChild;\n        if (lastc && lastc.type === 'text' && lastc.literal[lastc.literal.length - 1] === ' ') {\n            var hardbreak = lastc.literal[lastc.literal.length - 2] === ' ';\n            var litLen = lastc.literal.length;\n            lastc.literal = lastc.literal.replace(reFinalSpace, '');\n            var finalSpaceLen = litLen - lastc.literal.length;\n            lastc.sourcepos[1][1] -= finalSpaceLen;\n            block.appendChild(createNode$1(hardbreak ? 'linebreak' : 'softbreak', this.sourcepos(this.pos - finalSpaceLen, this.pos)));\n        }\n        else {\n            block.appendChild(createNode$1('softbreak', this.sourcepos(this.pos, this.pos)));\n        }\n        this.nextLine();\n        this.match(reInitialSpace); // gobble leading spaces in next line\n        return true;\n    };\n    // Attempt to parse a link reference, modifying refmap.\n    InlineParser.prototype.parseReference = function (block, refMap) {\n        if (!this.options.referenceDefinition) {\n            return 0;\n        }\n        this.subject = block.stringContent;\n        this.pos = 0;\n        var title = null;\n        var startpos = this.pos;\n        // label:\n        var matchChars = this.parseLinkLabel();\n        if (matchChars === 0) {\n            return 0;\n        }\n        var rawlabel = this.subject.substr(0, matchChars);\n        // colon:\n        if (this.peek() === C_COLON) {\n            this.pos++;\n        }\n        else {\n            this.pos = startpos;\n            return 0;\n        }\n        //  link url\n        this.spnl();\n        var dest = this.parseLinkDestination();\n        if (dest === null) {\n            this.pos = startpos;\n            return 0;\n        }\n        var beforetitle = this.pos;\n        this.spnl();\n        if (this.pos !== beforetitle) {\n            title = this.parseLinkTitle();\n        }\n        if (title === null) {\n            title = '';\n            // rewind before spaces\n            this.pos = beforetitle;\n        }\n        // make sure we're at line end:\n        var atLineEnd = true;\n        if (this.match(reSpaceAtEndOfLine) === null) {\n            if (title === '') {\n                atLineEnd = false;\n            }\n            else {\n                // the potential title we found is not at the line end,\n                // but it could still be a legal link reference if we\n                // discard the title\n                title = '';\n                // rewind before spaces\n                this.pos = beforetitle;\n                // and instead check if the link URL is at the line end\n                atLineEnd = this.match(reSpaceAtEndOfLine) !== null;\n            }\n        }\n        if (!atLineEnd) {\n            this.pos = startpos;\n            return 0;\n        }\n        var normalLabel = normalizeReference(rawlabel);\n        if (normalLabel === '') {\n            // label must contain non-whitespace characters\n            this.pos = startpos;\n            return 0;\n        }\n        var sourcepos = this.getReferenceDefSourcepos(block);\n        block.sourcepos[0][0] = sourcepos[1][0] + 1;\n        var node = createNode$1('refDef', sourcepos);\n        node.title = title;\n        node.dest = dest;\n        node.label = normalLabel;\n        block.insertBefore(node);\n        if (!refMap[normalLabel]) {\n            refMap[normalLabel] = createRefDefState(node);\n        }\n        else {\n            this.refDefCandidateMap[node.id] = node;\n        }\n        return this.pos - startpos;\n    };\n    InlineParser.prototype.mergeTextNodes = function (walker) {\n        var event;\n        var textNodes = [];\n        while ((event = walker.next())) {\n            var entering = event.entering, node = event.node;\n            if (entering && node.type === 'text') {\n                textNodes.push(node);\n            }\n            else if (textNodes.length === 1) {\n                textNodes = [];\n            }\n            else if (textNodes.length > 1) {\n                var firstNode = textNodes[0];\n                var lastNode = textNodes[textNodes.length - 1];\n                if (firstNode.sourcepos && lastNode.sourcepos) {\n                    firstNode.sourcepos[1] = lastNode.sourcepos[1];\n                }\n                firstNode.next = lastNode.next;\n                if (firstNode.next) {\n                    firstNode.next.prev = firstNode;\n                }\n                for (var i = 1; i < textNodes.length; i += 1) {\n                    firstNode.literal += textNodes[i].literal;\n                    textNodes[i].unlink();\n                }\n                textNodes = [];\n            }\n        }\n    };\n    InlineParser.prototype.getReferenceDefSourcepos = function (block) {\n        var lines = block.stringContent.split(/\\n|\\r\\n/);\n        var passedUrlLine = false;\n        var quotationCount = 0;\n        var lastLineOffset = { line: 0, ch: 0 };\n        for (var i = 0; i < lines.length; i += 1) {\n            var line = lines[i];\n            if (reWhitespaceChar.test(line)) {\n                break;\n            }\n            if (/\\:/.test(line) && quotationCount === 0) {\n                if (passedUrlLine) {\n                    break;\n                }\n                var lineOffset = line.indexOf(':') === line.length - 1 ? i + 1 : i;\n                lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };\n                passedUrlLine = true;\n            }\n            // should consider extendable title\n            var matched = line.match(/'|\"/g);\n            if (matched) {\n                quotationCount += matched.length;\n            }\n            if (quotationCount === 2) {\n                lastLineOffset = { line: i, ch: line.length };\n                break;\n            }\n        }\n        return [\n            [block.sourcepos[0][0], block.sourcepos[0][1]],\n            [block.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch],\n        ];\n    };\n    // Parse the next inline element in subject, advancing subject position.\n    // On success, add the result to block's children and return true.\n    // On failure, return false.\n    InlineParser.prototype.parseInline = function (block) {\n        var _a;\n        var res = false;\n        var c = this.peek();\n        if (c === -1) {\n            return false;\n        }\n        switch (c) {\n            case C_NEWLINE:\n                res = this.parseNewline(block);\n                break;\n            case C_BACKSLASH:\n                res = this.parseBackslash(block);\n                break;\n            case C_BACKTICK:\n                res = this.parseBackticks(block);\n                break;\n            case C_ASTERISK:\n            case C_UNDERSCORE:\n            case C_TILDE:\n            case C_DOLLAR:\n                res = this.handleDelim(c, block);\n                break;\n            case C_SINGLEQUOTE:\n            case C_DOUBLEQUOTE:\n                res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block);\n                break;\n            case C_OPEN_BRACKET$1:\n                res = this.parseOpenBracket(block);\n                break;\n            case C_BANG:\n                res = this.parseBang(block);\n                break;\n            case C_CLOSE_BRACKET:\n                res = this.parseCloseBracket(block);\n                break;\n            case C_LESSTHAN$1:\n                res = this.parseAutolink(block) || this.parseHtmlTag(block);\n                break;\n            case C_AMPERSAND:\n                if (!block.disabledEntityParse) {\n                    res = this.parseEntity(block);\n                }\n                break;\n            default:\n                res = this.parseString(block);\n                break;\n        }\n        if (!res) {\n            this.pos += 1;\n            block.appendChild(text$1(fromCodePoint$1(c), this.sourcepos(this.pos, this.pos + 1)));\n        }\n        return true;\n    };\n    // Parse string content in block into inline children,\n    // using refmap to resolve references.\n    InlineParser.prototype.parse = function (block) {\n        this.subject = block.stringContent.trim();\n        this.pos = 0;\n        this.delimiters = null;\n        this.brackets = null;\n        this.lineOffsets = block.lineOffsets || [0];\n        this.lineIdx = 0;\n        this.linePosOffset = 0;\n        this.lineStartNum = block.sourcepos[0][0];\n        if (isHeading(block)) {\n            this.lineOffsets[0] += block.level + 1;\n        }\n        while (this.parseInline(block)) { }\n        block.stringContent = null; // allow raw string to be garbage collected\n        this.processEmphasis(null);\n        this.mergeTextNodes(block.walker());\n        var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;\n        if (extendedAutolinks) {\n            convertExtAutoLinks(block.walker(), extendedAutolinks);\n        }\n        if (customParser && block.firstChild) {\n            var event_1;\n            var walker = block.firstChild.walker();\n            while ((event_1 = walker.next())) {\n                var node = event_1.node, entering = event_1.entering;\n                if (customParser[node.type]) {\n                    customParser[node.type](node, { entering: entering, options: this.options });\n                }\n            }\n        }\n    };\n    return InlineParser;\n}());\n\nvar reTaskListItemMarker = /^\\[([ \\txX])\\][ \\t]+/;\n// finalize for block handler\nfunction taskListItemFinalize(_, block) {\n    if (block.firstChild && block.firstChild.type === 'paragraph') {\n        var p = block.firstChild;\n        var m = p.stringContent.match(reTaskListItemMarker);\n        if (m) {\n            var mLen = m[0].length;\n            p.stringContent = p.stringContent.substring(mLen - 1);\n            p.sourcepos[0][1] += mLen;\n            p.lineOffsets[0] += mLen;\n            block.listData.task = true;\n            block.listData.checked = /[xX]/.test(m[1]);\n        }\n    }\n}\n\nvar table = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableHead' || t === 'tableBody';\n    },\n    acceptsLines: false,\n};\nvar tableBody$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow';\n    },\n    acceptsLines: false,\n};\nvar tableHead$1 = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow' || t === 'tableDelimRow';\n    },\n    acceptsLines: false,\n};\nvar tableDelimRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableDelimCell';\n    },\n    acceptsLines: false,\n};\nvar tableDelimCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar tableRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableCell';\n    },\n    acceptsLines: false,\n};\nvar tableCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\n\nvar CODE_INDENT = 4;\nvar C_TAB = 9;\nvar C_GREATERTHAN = 62;\nvar C_LESSTHAN = 60;\nvar C_SPACE = 32;\nvar C_OPEN_BRACKET = 91;\nvar reNonSpace = /[^ \\t\\f\\v\\r\\n]/;\nvar reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;\n// Returns true if block ends with a blank line, descending if needed\n// into lists and sublists.\nfunction endsWithBlankLine(block) {\n    var curBlock = block;\n    while (curBlock) {\n        if (curBlock.lastLineBlank) {\n            return true;\n        }\n        var t = curBlock.type;\n        if (!curBlock.lastLineChecked && (t === 'list' || t === 'item')) {\n            curBlock.lastLineChecked = true;\n            curBlock = curBlock.lastChild;\n        }\n        else {\n            curBlock.lastLineChecked = true;\n            break;\n        }\n    }\n    return false;\n}\nfunction peek(ln, pos) {\n    if (pos < ln.length) {\n        return ln.charCodeAt(pos);\n    }\n    return -1;\n}\n// Returns true if string contains only space characters.\nfunction isBlank(s) {\n    return !reNonSpace.test(s);\n}\nfunction isSpaceOrTab(c) {\n    return c === C_SPACE || c === C_TAB;\n}\n\nvar reClosingCustomBlock = /^\\$\\$$/;\nvar customBlock$1 = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reClosingCustomBlock);\n        if (match) {\n            // closing custom block\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        // skip optional spaces of custom block offset\n        var i = container.offset;\n        while (i > 0 && isSpaceOrTab(peek(line, parser.offset))) {\n            parser.advanceOffset(1, true);\n            i--;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        // first line becomes info string\n        var content = block.stringContent;\n        var newlinePos = content.indexOf('\\n');\n        var firstLine = content.slice(0, newlinePos);\n        var rest = content.slice(newlinePos + 1);\n        var infoString = firstLine.match(/^(\\s*)(.*)/);\n        block.info = unescapeString(infoString[2].trim());\n        block.literal = rest;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\n\nvar noop = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar document$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar list = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var item = block.firstChild;\n        while (item) {\n            // check for non-final list item ending with blank line:\n            if (endsWithBlankLine(item) && item.next) {\n                block.listData.tight = false;\n                break;\n            }\n            // recurse into children of list item, to see if there are\n            // spaces between any of them:\n            var subitem = item.firstChild;\n            while (subitem) {\n                if (endsWithBlankLine(subitem) && (item.next || subitem.next)) {\n                    block.listData.tight = false;\n                    break;\n                }\n                subitem = subitem.next;\n            }\n            item = item.next;\n        }\n    },\n    canContain: function (t) {\n        return t === 'item';\n    },\n    acceptsLines: false,\n};\nvar blockQuote$1 = {\n    continue: function (parser) {\n        var ln = parser.currentLine;\n        if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {\n            parser.advanceNextNonspace();\n            parser.advanceOffset(1, false);\n            if (isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n            }\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar item = {\n    continue: function (parser, container) {\n        if (parser.blank) {\n            if (container.firstChild === null) {\n                // Blank line after empty list item\n                return 1 /* Stop */;\n            }\n            parser.advanceNextNonspace();\n        }\n        else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {\n            parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: taskListItemFinalize,\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar heading = {\n    continue: function () {\n        // a heading can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar thematicBreak$1 = {\n    continue: function () {\n        // a thematic break can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar codeBlock = {\n    continue: function (parser, container) {\n        var ln = parser.currentLine;\n        var indent = parser.indent;\n        if (container.isFenced) {\n            // fenced\n            var match = indent <= 3 &&\n                ln.charAt(parser.nextNonspace) === container.fenceChar &&\n                ln.slice(parser.nextNonspace).match(reClosingCodeFence);\n            if (match && match[0].length >= container.fenceLength) {\n                // closing fence - we're at end of line, so we can return\n                parser.lastLineLength = parser.offset + indent + match[0].length;\n                parser.finalize(container, parser.lineNumber);\n                return 2 /* Finished */;\n            }\n            // skip optional spaces of fence offset\n            var i = container.fenceOffset;\n            while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n                i--;\n            }\n        }\n        else {\n            // indented\n            if (indent >= CODE_INDENT) {\n                parser.advanceOffset(CODE_INDENT, true);\n            }\n            else if (parser.blank) {\n                parser.advanceNextNonspace();\n            }\n            else {\n                return 1 /* Stop */;\n            }\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        if (block.stringContent === null) {\n            return;\n        }\n        if (block.isFenced) {\n            // fenced\n            // first line becomes info string\n            var content = block.stringContent;\n            var newlinePos = content.indexOf('\\n');\n            var firstLine = content.slice(0, newlinePos);\n            var rest = content.slice(newlinePos + 1);\n            var infoString = firstLine.match(/^(\\s*)(.*)/);\n            block.infoPadding = infoString[1].length;\n            block.info = unescapeString(infoString[2].trim());\n            block.literal = rest;\n        }\n        else {\n            // indented\n            block.literal = (_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '\\n');\n        }\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar htmlBlock$1 = {\n    continue: function (parser, container) {\n        return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7)\n            ? 1 /* Stop */\n            : 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        block.literal = ((_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '')) || null;\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar paragraph = {\n    continue: function (parser) {\n        return parser.blank ? 1 /* Stop */ : 0 /* Go */;\n    },\n    finalize: function (parser, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        var pos;\n        var hasReferenceDefs = false;\n        // try parsing the beginning as link reference definitions:\n        while (peek(block.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(block, parser.refMap))) {\n            block.stringContent = block.stringContent.slice(pos);\n            hasReferenceDefs = true;\n        }\n        if (hasReferenceDefs && isBlank(block.stringContent)) {\n            block.unlink();\n        }\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar refDef = noop;\nvar frontMatter$2 = noop;\nvar blockHandlers = {\n    document: document$1,\n    list: list,\n    blockQuote: blockQuote$1,\n    item: item,\n    heading: heading,\n    thematicBreak: thematicBreak$1,\n    codeBlock: codeBlock,\n    htmlBlock: htmlBlock$1,\n    paragraph: paragraph,\n    table: table,\n    tableBody: tableBody$1,\n    tableHead: tableHead$1,\n    tableRow: tableRow,\n    tableCell: tableCell,\n    tableDelimRow: tableDelimRow,\n    tableDelimCell: tableDelimCell,\n    refDef: refDef,\n    customBlock: customBlock$1,\n    frontMatter: frontMatter$2,\n};\n\nfunction parseRowContent(content) {\n    var startIdx = 0;\n    var offset = 0;\n    var cells = [];\n    for (var i = 0; i < content.length; i += 1) {\n        if (content[i] === '|' && content[i - 1] !== '\\\\') {\n            var cell = content.substring(startIdx, i);\n            if (startIdx === 0 && isEmpty(cell)) {\n                offset = i + 1;\n            }\n            else {\n                cells.push(cell);\n            }\n            startIdx = i + 1;\n        }\n    }\n    if (startIdx < content.length) {\n        var cell = content.substring(startIdx, content.length);\n        if (!isEmpty(cell)) {\n            cells.push(cell);\n        }\n    }\n    return [offset, cells];\n}\nfunction generateTableCells(cellType, contents, lineNum, chPos) {\n    var cells = [];\n    for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {\n        var content = contents_1[_i];\n        var preSpaces = content.match(/^[ \\t]+/);\n        var paddingLeft = preSpaces ? preSpaces[0].length : 0;\n        var paddingRight = void 0, trimmed = void 0;\n        if (paddingLeft === content.length) {\n            paddingLeft = 0;\n            paddingRight = 0;\n            trimmed = '';\n        }\n        else {\n            var postSpaces = content.match(/[ \\t]+$/);\n            paddingRight = postSpaces ? postSpaces[0].length : 0;\n            trimmed = content.slice(paddingLeft, content.length - paddingRight);\n        }\n        var chPosStart = chPos + paddingLeft;\n        var tableCell = createNode$1(cellType, [\n            [lineNum, chPos],\n            [lineNum, chPos + content.length - 1],\n        ]);\n        tableCell.stringContent = trimmed.replace(/\\\\\\|/g, '|'); // replace esacped pipe(\\|)\n        tableCell.startIdx = cells.length;\n        tableCell.endIdx = cells.length;\n        tableCell.lineOffsets = [chPosStart - 1];\n        tableCell.paddingLeft = paddingLeft;\n        tableCell.paddingRight = paddingRight;\n        cells.push(tableCell);\n        chPos += content.length + 1;\n    }\n    return cells;\n}\nfunction getColumnFromDelimCell(cellNode) {\n    var align = null;\n    var content = cellNode.stringContent;\n    var firstCh = content[0];\n    var lastCh = content[content.length - 1];\n    if (lastCh === ':') {\n        align = firstCh === ':' ? 'center' : 'right';\n    }\n    else if (firstCh === ':') {\n        align = 'left';\n    }\n    return { align: align };\n}\nvar tableHead = function (parser, container) {\n    var stringContent = container.stringContent;\n    if (container.type === 'paragraph' && !parser.indented && !parser.blank) {\n        var lastNewLineIdx = stringContent.length - 1;\n        var lastLineStartIdx = stringContent.lastIndexOf('\\n', lastNewLineIdx - 1) + 1;\n        var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);\n        var delimContent = parser.currentLine.slice(parser.nextNonspace);\n        var _a = parseRowContent(headerContent), headerOffset = _a[0], headerCells = _a[1];\n        var _b = parseRowContent(delimContent), delimOffset = _b[0], delimCells = _b[1];\n        var reValidDelimCell_1 = /^[ \\t]*:?-+:?[ \\t]*$/;\n        if (\n        // not checking if the number of header cells and delimiter cells are the same\n        // to consider the case of merged-column (via plugin)\n        !headerCells.length ||\n            !delimCells.length ||\n            delimCells.some(function (cell) { return !reValidDelimCell_1.test(cell); }) ||\n            // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option\n            (delimCells.length === 1 && delimContent.indexOf('|') !== 0)) {\n            return 0 /* None */;\n        }\n        var lineOffsets = container.lineOffsets;\n        var firstLineNum = parser.lineNumber - 1;\n        var firstLineStart = last(lineOffsets) + 1;\n        var table = createNode$1('table', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        // eslint-disable-next-line arrow-body-style\n        table.columns = delimCells.map(function () { return ({ align: null }); });\n        container.insertAfter(table);\n        if (lineOffsets.length === 1) {\n            container.unlink();\n        }\n        else {\n            container.stringContent = stringContent.slice(0, lastLineStartIdx);\n            var paraLastLineStartIdx = stringContent.lastIndexOf('\\n', lastLineStartIdx - 2) + 1;\n            var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;\n            parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;\n            parser.finalize(container, firstLineNum - 1);\n        }\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        var tableHead_1 = createNode$1('tableHead', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        table.appendChild(tableHead_1);\n        var tableHeadRow_1 = createNode$1('tableRow', [\n            [firstLineNum, firstLineStart],\n            [firstLineNum, firstLineStart + headerContent.length - 1],\n        ]);\n        var tableDelimRow_1 = createNode$1('tableDelimRow', [\n            [parser.lineNumber, parser.nextNonspace + 1],\n            [parser.lineNumber, parser.offset],\n        ]);\n        tableHead_1.appendChild(tableHeadRow_1);\n        tableHead_1.appendChild(tableDelimRow_1);\n        generateTableCells('tableCell', headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function (cellNode) {\n            tableHeadRow_1.appendChild(cellNode);\n        });\n        var delimCellNodes = generateTableCells('tableDelimCell', delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);\n        delimCellNodes.forEach(function (cellNode) {\n            tableDelimRow_1.appendChild(cellNode);\n        });\n        table.columns = delimCellNodes.map(getColumnFromDelimCell);\n        parser.tip = table;\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar tableBody = function (parser, container) {\n    if ((container.type !== 'table' && container.type !== 'tableBody') ||\n        (!parser.blank && parser.currentLine.indexOf('|') === -1)) {\n        return 0 /* None */;\n    }\n    parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n    if (parser.blank) {\n        var table_1 = container;\n        if (container.type === 'tableBody') {\n            table_1 = container.parent;\n            parser.finalize(container, parser.lineNumber - 1);\n        }\n        parser.finalize(table_1, parser.lineNumber - 1);\n        return 0 /* None */;\n    }\n    var tableBody = container;\n    if (container.type === 'table') {\n        tableBody = parser.addChild('tableBody', parser.nextNonspace);\n        tableBody.stringContent = null;\n    }\n    var tableRow = createNode$1('tableRow', [\n        [parser.lineNumber, parser.nextNonspace + 1],\n        [parser.lineNumber, parser.currentLine.length],\n    ]);\n    tableBody.appendChild(tableRow);\n    var table = tableBody.parent;\n    var content = parser.currentLine.slice(parser.nextNonspace);\n    var _a = parseRowContent(content), offset = _a[0], cellContents = _a[1];\n    generateTableCells('tableCell', cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset).forEach(function (cellNode, idx) {\n        if (idx >= table.columns.length) {\n            cellNode.ignored = true;\n        }\n        tableRow.appendChild(cellNode);\n    });\n    return 2 /* Leaf */;\n};\n\nvar reCustomBlock = /^(\\$\\$)(\\s*[a-zA-Z])+/;\nvar reCanBeCustomInline = /^(\\$\\$)(\\s*[a-zA-Z])+.*(\\$\\$)/;\nvar customBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        !reCanBeCustomInline.test(parser.currentLine) &&\n        (match = parser.currentLine.match(reCustomBlock))) {\n        var syntaxLength = match[1].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('customBlock', parser.nextNonspace);\n        container.syntaxLength = syntaxLength;\n        container.offset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(syntaxLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\n\nvar reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;\nvar reHtmlBlockOpen = [\n    /./,\n    /^<(?:script|pre|style)(?:\\s|>|$)/i,\n    /^<!--/,\n    /^<[?]/,\n    /^<![A-Z]/,\n    /^<!\\[CDATA\\[/,\n    /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|[/]?[>]|$)/i,\n    new RegExp(\"^(?:\" + OPENTAG + \"|\" + CLOSETAG + \")\\\\s*$\", 'i'),\n];\nvar reSetextHeadingLine = /^(?:=+|-+)[ \\t]*$/;\nvar reATXHeadingMarker = /^#{1,6}(?:[ \\t]+|$)/;\nvar reThematicBreak = /^(?:(?:\\*[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:-[ \\t]*){3,})[ \\t]*$/;\nvar reBulletListMarker = /^[*+-]/;\nvar reOrderedListMarker = /^(\\d{1,9})([.)])/;\n// Parse a list marker and return data on the marker (type,\n// start, delimiter, bullet character, padding) or null.\nfunction parseListMarker(parser, container) {\n    var rest = parser.currentLine.slice(parser.nextNonspace);\n    var match;\n    var nextc;\n    var data = {\n        type: 'bullet',\n        tight: true,\n        bulletChar: '',\n        start: 0,\n        delimiter: '',\n        padding: 0,\n        markerOffset: parser.indent,\n        // GFM: Task List Item\n        task: false,\n        checked: false,\n    };\n    if (parser.indent >= 4) {\n        return null;\n    }\n    if ((match = rest.match(reBulletListMarker))) {\n        data.type = 'bullet';\n        data.bulletChar = match[0][0];\n    }\n    else if ((match = rest.match(reOrderedListMarker)) &&\n        (container.type !== 'paragraph' || match[1] === '1')) {\n        data.type = 'ordered';\n        data.start = parseInt(match[1], 10);\n        data.delimiter = match[2];\n    }\n    else {\n        return null;\n    }\n    // make sure we have spaces after\n    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);\n    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {\n        return null;\n    }\n    // if it interrupts paragraph, make sure first line isn't blank\n    if (container.type === 'paragraph' &&\n        !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {\n        return null;\n    }\n    // we've got a match! advance offset and calculate padding\n    parser.advanceNextNonspace(); // to start of marker\n    parser.advanceOffset(match[0].length, true); // to end of marker\n    var spacesStartCol = parser.column;\n    var spacesStartOffset = parser.offset;\n    do {\n        parser.advanceOffset(1, true);\n        nextc = peek(parser.currentLine, parser.offset);\n    } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));\n    var blankItem = peek(parser.currentLine, parser.offset) === -1;\n    var spacesAfterMarker = parser.column - spacesStartCol;\n    if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {\n        data.padding = match[0].length + 1;\n        parser.column = spacesStartCol;\n        parser.offset = spacesStartOffset;\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n    }\n    else {\n        data.padding = match[0].length + spacesAfterMarker;\n    }\n    return data;\n}\n// Returns true if the two list items are of the same type,\n// with the same delimiter and bullet character.  This is used\n// in agglomerating list items into lists.\nfunction listsMatch(listData, itemData) {\n    return (listData.type === itemData.type &&\n        listData.delimiter === itemData.delimiter &&\n        listData.bulletChar === itemData.bulletChar);\n}\nfunction isDisallowedDeepHeading(parser, node) {\n    return parser.options.disallowDeepHeading && (node.type === 'blockQuote' || node.type === 'item');\n}\nvar blockQuote = function (parser) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(1, false);\n        // optional following space\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n        parser.closeUnmatchedBlocks();\n        parser.addChild('blockQuote', parser.nextNonspace);\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\nvar atxHeading = function (parser, container) {\n    var match;\n    if (!parser.indented &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(match[0].length, false);\n        parser.closeUnmatchedBlocks();\n        var heading = parser.addChild('heading', parser.nextNonspace);\n        heading.level = match[0].trim().length; // number of #s\n        heading.headingType = 'atx';\n        // remove trailing ###s:\n        heading.stringContent = parser.currentLine\n            .slice(parser.offset)\n            .replace(/^[ \\t]*#+[ \\t]*$/, '')\n            .replace(/[ \\t]+#+[ \\t]*$/, '');\n        parser.advanceOffset(parser.currentLine.length - parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar fencedCodeBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {\n        var fenceLength = match[0].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('codeBlock', parser.nextNonspace);\n        container.isFenced = true;\n        container.fenceLength = fenceLength;\n        container.fenceChar = match[0][0];\n        container.fenceOffset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(fenceLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar htmlBlock = function (parser, container) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {\n        var s = parser.currentLine.slice(parser.nextNonspace);\n        var disallowedTags = parser.options.disallowedHtmlBlockTags;\n        var blockType = void 0;\n        for (blockType = 1; blockType <= 7; blockType++) {\n            var matched = s.match(reHtmlBlockOpen[blockType]);\n            if (matched) {\n                if (blockType === 7) {\n                    if (container.type === 'paragraph') {\n                        return 0 /* None */;\n                    }\n                    if (disallowedTags.length > 0) {\n                        var reDisallowedTags = new RegExp(\"</?(?:\" + disallowedTags.join('|') + \")\", 'i');\n                        if (reDisallowedTags.test(matched[0])) {\n                            return 0 /* None */;\n                        }\n                    }\n                }\n                parser.closeUnmatchedBlocks();\n                // We don't adjust parser.offset;\n                // spaces are part of the HTML block:\n                var b = parser.addChild('htmlBlock', parser.offset);\n                b.htmlBlockType = blockType;\n                return 2 /* Leaf */;\n            }\n        }\n    }\n    return 0 /* None */;\n};\nvar seTextHeading = function (parser, container) {\n    var match;\n    if (container.stringContent !== null &&\n        !parser.indented &&\n        container.type === 'paragraph' &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container.parent) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {\n        parser.closeUnmatchedBlocks();\n        // resolve reference link definitions\n        var pos = void 0;\n        while (peek(container.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(container, parser.refMap))) {\n            container.stringContent = container.stringContent.slice(pos);\n        }\n        if (container.stringContent.length > 0) {\n            var heading = createNode$1('heading', container.sourcepos);\n            heading.level = match[0][0] === '=' ? 1 : 2;\n            heading.headingType = 'setext';\n            heading.stringContent = container.stringContent;\n            container.insertAfter(heading);\n            container.unlink();\n            parser.tip = heading;\n            parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n            return 2 /* Leaf */;\n        }\n        return 0 /* None */;\n    }\n    return 0 /* None */;\n};\nvar thematicBreak = function (parser) {\n    if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {\n        parser.closeUnmatchedBlocks();\n        parser.addChild('thematicBreak', parser.nextNonspace);\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar listItem = function (parser, container) {\n    var data;\n    var currNode = container;\n    if ((!parser.indented || container.type === 'list') &&\n        (data = parseListMarker(parser, currNode))) {\n        parser.closeUnmatchedBlocks();\n        // add the list if needed\n        if (parser.tip.type !== 'list' || !listsMatch(currNode.listData, data)) {\n            currNode = parser.addChild('list', parser.nextNonspace);\n            currNode.listData = data;\n        }\n        // add the list item\n        currNode = parser.addChild('item', parser.nextNonspace);\n        currNode.listData = data;\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\n// indented code block\nvar indentedCodeBlock = function (parser) {\n    if (parser.indented && parser.tip.type !== 'paragraph' && !parser.blank) {\n        // indented code\n        parser.advanceOffset(CODE_INDENT, true);\n        parser.closeUnmatchedBlocks();\n        parser.addChild('codeBlock', parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar blockStarts = [\n    blockQuote,\n    atxHeading,\n    fencedCodeBlock,\n    htmlBlock,\n    seTextHeading,\n    thematicBreak,\n    listItem,\n    indentedCodeBlock,\n    tableHead,\n    tableBody,\n    customBlock,\n];\n\n// `---` for YAML, `+++` for TOML, `;;;` for JSON\nvar reFrontMatter = /^(-{3}|\\+{3}|;{3})$/;\nvar frontMatter$1 = function (parser, container) {\n    var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;\n    if (lineNumber === 1 &&\n        !indented &&\n        container.type === 'document' &&\n        reFrontMatter.test(currentLine)) {\n        parser.closeUnmatchedBlocks();\n        var frontMatter_1 = parser.addChild('frontMatter', parser.nextNonspace);\n        frontMatter_1.stringContent = currentLine;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(currentLine.length, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\n\nvar frontMatter = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reFrontMatter);\n        if (container.type === 'frontMatter' && match) {\n            container.stringContent += line;\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        block.literal = block.stringContent;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\n\nvar reHtmlBlockClose = [\n    /./,\n    /<\\/(?:script|pre|style)>/i,\n    /-->/,\n    /\\?>/,\n    />/,\n    /\\]\\]>/,\n];\nvar reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/;\nvar reLineEnding$1 = /\\r\\n|\\n|\\r/;\nfunction document$2() {\n    return createNode$1('document', [\n        [1, 1],\n        [0, 0],\n    ]);\n}\nvar defaultOptions$1 = {\n    smart: false,\n    tagFilter: false,\n    extendedAutolinks: false,\n    disallowedHtmlBlockTags: [],\n    referenceDefinition: false,\n    disallowDeepHeading: false,\n    customParser: null,\n    frontMatter: false,\n};\nvar Parser = /** @class */ (function () {\n    function Parser(options) {\n        this.options = __assign(__assign({}, defaultOptions$1), options);\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.oldtip = this.doc;\n        this.lineNumber = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.nextNonspace = 0;\n        this.nextNonspaceColumn = 0;\n        this.indent = 0;\n        this.currentLine = '';\n        this.indented = false;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.allClosed = true;\n        this.lastMatchedContainer = this.doc;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.lastLineLength = 0;\n        this.lines = [];\n        if (this.options.frontMatter) {\n            blockHandlers.frontMatter = frontMatter;\n            blockStarts.unshift(frontMatter$1);\n        }\n        this.inlineParser = new InlineParser(this.options);\n    }\n    Parser.prototype.advanceOffset = function (count, columns) {\n        if (columns === void 0) { columns = false; }\n        var currentLine = this.currentLine;\n        var charsToTab, charsToAdvance;\n        var c;\n        while (count > 0 && (c = currentLine[this.offset])) {\n            if (c === '\\t') {\n                charsToTab = 4 - (this.column % 4);\n                if (columns) {\n                    this.partiallyConsumedTab = charsToTab > count;\n                    charsToAdvance = charsToTab > count ? count : charsToTab;\n                    this.column += charsToAdvance;\n                    this.offset += this.partiallyConsumedTab ? 0 : 1;\n                    count -= charsToAdvance;\n                }\n                else {\n                    this.partiallyConsumedTab = false;\n                    this.column += charsToTab;\n                    this.offset += 1;\n                    count -= 1;\n                }\n            }\n            else {\n                this.partiallyConsumedTab = false;\n                this.offset += 1;\n                this.column += 1; // assume ascii; block starts are ascii\n                count -= 1;\n            }\n        }\n    };\n    Parser.prototype.advanceNextNonspace = function () {\n        this.offset = this.nextNonspace;\n        this.column = this.nextNonspaceColumn;\n        this.partiallyConsumedTab = false;\n    };\n    Parser.prototype.findNextNonspace = function () {\n        var currentLine = this.currentLine;\n        var i = this.offset;\n        var cols = this.column;\n        var c;\n        while ((c = currentLine.charAt(i)) !== '') {\n            if (c === ' ') {\n                i++;\n                cols++;\n            }\n            else if (c === '\\t') {\n                i++;\n                cols += 4 - (cols % 4);\n            }\n            else {\n                break;\n            }\n        }\n        this.blank = c === '\\n' || c === '\\r' || c === '';\n        this.nextNonspace = i;\n        this.nextNonspaceColumn = cols;\n        this.indent = this.nextNonspaceColumn - this.column;\n        this.indented = this.indent >= CODE_INDENT;\n    };\n    // Add a line to the block at the tip.  We assume the tip\n    // can accept lines -- that check should be done before calling this.\n    Parser.prototype.addLine = function () {\n        if (this.partiallyConsumedTab) {\n            this.offset += 1; // skip over tab\n            // add space characters:\n            var charsToTab = 4 - (this.column % 4);\n            this.tip.stringContent += repeat(' ', charsToTab);\n        }\n        if (this.tip.lineOffsets) {\n            this.tip.lineOffsets.push(this.offset);\n        }\n        else {\n            this.tip.lineOffsets = [this.offset];\n        }\n        this.tip.stringContent += this.currentLine.slice(this.offset) + \"\\n\";\n    };\n    // Add block of type tag as a child of the tip.  If the tip can't\n    // accept children, close and finalize it and try its parent,\n    // and so on til we find a block that can accept children.\n    Parser.prototype.addChild = function (tag, offset) {\n        while (!blockHandlers[this.tip.type].canContain(tag)) {\n            this.finalize(this.tip, this.lineNumber - 1);\n        }\n        var columnNumber = offset + 1; // offset 0 = column 1\n        var newBlock = createNode$1(tag, [\n            [this.lineNumber, columnNumber],\n            [0, 0],\n        ]);\n        newBlock.stringContent = '';\n        this.tip.appendChild(newBlock);\n        this.tip = newBlock;\n        return newBlock;\n    };\n    // Finalize and close any unmatched blocks.\n    Parser.prototype.closeUnmatchedBlocks = function () {\n        if (!this.allClosed) {\n            // finalize any blocks not matched\n            while (this.oldtip !== this.lastMatchedContainer) {\n                var parent_1 = this.oldtip.parent;\n                this.finalize(this.oldtip, this.lineNumber - 1);\n                this.oldtip = parent_1;\n            }\n            this.allClosed = true;\n        }\n    };\n    // Finalize a block.  Close it and do any necessary postprocessing,\n    // e.g. creating stringContent from strings, setting the 'tight'\n    // or 'loose' status of a list, and parsing the beginnings\n    // of paragraphs for reference definitions.  Reset the tip to the\n    // parent of the closed block.\n    Parser.prototype.finalize = function (block, lineNumber) {\n        var above = block.parent;\n        block.open = false;\n        block.sourcepos[1] = [lineNumber, this.lastLineLength];\n        blockHandlers[block.type].finalize(this, block);\n        this.tip = above;\n    };\n    // Walk through a block & children recursively, parsing string content\n    // into inline content where appropriate.\n    Parser.prototype.processInlines = function (block) {\n        var event;\n        var customParser = this.options.customParser;\n        var walker = block.walker();\n        this.inlineParser.refMap = this.refMap;\n        this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;\n        this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;\n        this.inlineParser.options = this.options;\n        while ((event = walker.next())) {\n            var node = event.node, entering = event.entering;\n            var t = node.type;\n            if (customParser && customParser[t]) {\n                customParser[t](node, { entering: entering, options: this.options });\n            }\n            if (!entering &&\n                (t === 'paragraph' ||\n                    t === 'heading' ||\n                    (t === 'tableCell' && !node.ignored))) {\n                this.inlineParser.parse(node);\n            }\n        }\n    };\n    // Analyze a line of text and update the document appropriately.\n    // We parse markdown text by calling this on each line of input,\n    // then finalizing the document.\n    Parser.prototype.incorporateLine = function (ln) {\n        var container = this.doc;\n        this.oldtip = this.tip;\n        this.offset = 0;\n        this.column = 0;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.lineNumber += 1;\n        // replace NUL characters for security\n        if (ln.indexOf('\\u0000') !== -1) {\n            ln = ln.replace(/\\0/g, '\\uFFFD');\n        }\n        this.currentLine = ln;\n        // For each containing block, try to parse the associated line start.\n        // Bail out on failure: container will point to the last matching block.\n        // Set allMatched to false if not all containers match.\n        var allMatched = true;\n        var lastChild;\n        while ((lastChild = container.lastChild) && lastChild.open) {\n            container = lastChild;\n            this.findNextNonspace();\n            switch (blockHandlers[container.type]['continue'](this, container)) {\n                case 0 /* Go */: // we've matched, keep going\n                    break;\n                case 1 /* Stop */: // we've failed to match a block\n                    allMatched = false;\n                    break;\n                case 2 /* Finished */: // we've hit end of line for fenced code close and can return\n                    this.lastLineLength = ln.length;\n                    return;\n                default:\n                    throw new Error('continue returned illegal value, must be 0, 1, or 2');\n            }\n            if (!allMatched) {\n                container = container.parent; // back up to last matching block\n                break;\n            }\n        }\n        this.allClosed = container === this.oldtip;\n        this.lastMatchedContainer = container;\n        var matchedLeaf = container.type !== 'paragraph' && blockHandlers[container.type].acceptsLines;\n        var blockStartsLen = blockStarts.length;\n        // Unless last matched container is a code block, try new container starts,\n        // adding children to the last matched container:\n        while (!matchedLeaf) {\n            this.findNextNonspace();\n            // this is a little performance optimization:\n            if (container.type !== 'table' &&\n                container.type !== 'tableBody' &&\n                container.type !== 'paragraph' &&\n                !this.indented &&\n                !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {\n                this.advanceNextNonspace();\n                break;\n            }\n            var i = 0;\n            while (i < blockStartsLen) {\n                var res = blockStarts[i](this, container);\n                if (res === 1 /* Container */) {\n                    container = this.tip;\n                    break;\n                }\n                else if (res === 2 /* Leaf */) {\n                    container = this.tip;\n                    matchedLeaf = true;\n                    break;\n                }\n                else {\n                    i++;\n                }\n            }\n            if (i === blockStartsLen) {\n                // nothing matched\n                this.advanceNextNonspace();\n                break;\n            }\n        }\n        // What remains at the offset is a text line.  Add the text to the\n        // appropriate container.\n        // First check for a lazy paragraph continuation:\n        if (!this.allClosed && !this.blank && this.tip.type === 'paragraph') {\n            // lazy paragraph continuation\n            this.addLine();\n        }\n        else {\n            // not a lazy continuation\n            // finalize any blocks not matched\n            this.closeUnmatchedBlocks();\n            if (this.blank && container.lastChild) {\n                container.lastChild.lastLineBlank = true;\n            }\n            var t = container.type;\n            // Block quote lines are never blank as they start with >\n            // and we don't count blanks in fenced code for purposes of tight/loose\n            // lists or breaking out of lists. We also don't set _lastLineBlank\n            // on an empty list item, or if we just closed a fenced block.\n            var lastLineBlank = this.blank &&\n                !(t === 'blockQuote' ||\n                    (isCodeBlock(container) && container.isFenced) ||\n                    (t === 'item' && !container.firstChild && container.sourcepos[0][0] === this.lineNumber));\n            // propagate lastLineBlank up through parents:\n            var cont = container;\n            while (cont) {\n                cont.lastLineBlank = lastLineBlank;\n                cont = cont.parent;\n            }\n            if (blockHandlers[t].acceptsLines) {\n                this.addLine();\n                // if HtmlBlock, check for end condition\n                if (isHtmlBlock(container) &&\n                    container.htmlBlockType >= 1 &&\n                    container.htmlBlockType <= 5 &&\n                    reHtmlBlockClose[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {\n                    this.lastLineLength = ln.length;\n                    this.finalize(container, this.lineNumber);\n                }\n            }\n            else if (this.offset < ln.length && !this.blank) {\n                // create paragraph container for line\n                container = this.addChild('paragraph', this.offset);\n                this.advanceNextNonspace();\n                this.addLine();\n            }\n        }\n        this.lastLineLength = ln.length;\n    };\n    // The main parsing function.  Returns a parsed document AST.\n    Parser.prototype.parse = function (input, lineTexts) {\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.lineNumber = 0;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var lines = input.split(reLineEnding$1);\n        var len = lines.length;\n        this.lines = lineTexts ? lineTexts : lines;\n        if (this.options.referenceDefinition) {\n            this.clearRefMaps();\n        }\n        if (input.charCodeAt(input.length - 1) === C_NEWLINE) {\n            // ignore last blank line created by final newline\n            len -= 1;\n        }\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        while (this.tip) {\n            this.finalize(this.tip, len);\n        }\n        this.processInlines(this.doc);\n        return this.doc;\n    };\n    Parser.prototype.partialParseStart = function (lineNumber, lines) {\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.lineNumber = lineNumber - 1;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var len = lines.length;\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        return this.doc;\n    };\n    Parser.prototype.partialParseExtends = function (lines) {\n        for (var i = 0; i < lines.length; i++) {\n            this.incorporateLine(lines[i]);\n        }\n    };\n    Parser.prototype.partialParseFinish = function () {\n        while (this.tip) {\n            this.finalize(this.tip, this.lineNumber);\n        }\n        this.processInlines(this.doc);\n    };\n    Parser.prototype.setRefMaps = function (refMap, refLinkCandidateMap, refDefCandidateMap) {\n        this.refMap = refMap;\n        this.refLinkCandidateMap = refLinkCandidateMap;\n        this.refDefCandidateMap = refDefCandidateMap;\n    };\n    Parser.prototype.clearRefMaps = function () {\n        [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (map) {\n            clearObj(map);\n        });\n    };\n    return Parser;\n}());\n\nfunction comparePos(p1, p2) {\n    if (p1[0] < p2[0]) {\n        return 1 /* LT */;\n    }\n    if (p1[0] > p2[0]) {\n        return -1 /* GT */;\n    }\n    if (p1[1] < p2[1]) {\n        return 1 /* LT */;\n    }\n    if (p1[1] > p2[1]) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction compareRangeAndPos(_a, pos) {\n    var startPos = _a[0], endPos = _a[1];\n    if (comparePos(endPos, pos) === 1 /* LT */) {\n        return 1 /* LT */;\n    }\n    if (comparePos(startPos, pos) === -1 /* GT */) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction removeNextUntil(node, last) {\n    if (node.parent !== last.parent || node === last) {\n        return;\n    }\n    var next = node.next;\n    while (next && next !== last) {\n        var temp = next.next;\n        for (var _i = 0, _a = ['parent', 'prev', 'next']; _i < _a.length; _i++) {\n            var type = _a[_i];\n            if (next[type]) {\n                removeNodeById(next[type].id);\n                next[type] = null;\n            }\n        }\n        next = temp;\n    }\n    node.next = last.next;\n    if (last.next) {\n        last.next.prev = node;\n    }\n    else {\n        node.parent.lastChild = node;\n    }\n}\nfunction getChildNodes(parent) {\n    var nodes = [];\n    var curr = parent.firstChild;\n    while (curr) {\n        nodes.push(curr);\n        curr = curr.next;\n    }\n    return nodes;\n}\nfunction insertNodesBefore(target, nodes) {\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n        target.insertBefore(node);\n    }\n}\nfunction prependChildNodes(parent, nodes) {\n    for (var i = nodes.length - 1; i >= 0; i -= 1) {\n        parent.prependChild(nodes[i]);\n    }\n}\nfunction updateNextLineNumbers(base, diff) {\n    if (!base || !base.parent || diff === 0) {\n        return;\n    }\n    var walker = base.parent.walker();\n    walker.resumeAt(base, true);\n    var event;\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            node.sourcepos[0][0] += diff;\n            node.sourcepos[1][0] += diff;\n        }\n    }\n}\nfunction compareRangeAndLine(_a, line) {\n    var startPos = _a[0], endPos = _a[1];\n    if (endPos[0] < line) {\n        return 1 /* LT */;\n    }\n    if (startPos[0] > line) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction findChildNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            return node;\n        }\n        if (comp === -1 /* GT */) {\n            // To consider that top line is blank line\n            return node.prev || node;\n        }\n        node = node.next;\n    }\n    return parent.lastChild;\n}\nfunction lastLeafNode(node) {\n    while (node.lastChild) {\n        node = node.lastChild;\n    }\n    return node;\n}\nfunction sameLineTopAncestor(node) {\n    while (node.parent &&\n        node.parent.type !== 'document' &&\n        node.parent.sourcepos[0][0] === node.sourcepos[0][0]) {\n        node = node.parent;\n    }\n    return node;\n}\nfunction findFirstNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            if (node.sourcepos[0][0] === line || !node.firstChild) {\n                return node;\n            }\n            prev = node;\n            node = node.firstChild;\n        }\n        else if (comp === -1 /* GT */) {\n            break;\n        }\n        else {\n            prev = node;\n            node = node.next;\n        }\n    }\n    if (prev) {\n        return sameLineTopAncestor(lastLeafNode(prev));\n    }\n    return null;\n}\nfunction findNodeAtPosition(parent, pos) {\n    var node = parent;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndPos(node.sourcepos, pos);\n        if (comp === 0 /* EQ */) {\n            if (node.firstChild) {\n                prev = node;\n                node = node.firstChild;\n            }\n            else {\n                return node;\n            }\n        }\n        else if (comp === -1 /* GT */) {\n            return prev;\n        }\n        else if (node.next) {\n            node = node.next;\n        }\n        else {\n            return prev;\n        }\n    }\n    return node;\n}\nfunction findNodeById(id) {\n    return getNodeById(id) || null;\n}\nfunction invokeNextUntil(callback, start, end) {\n    if (end === void 0) { end = null; }\n    if (start) {\n        var walker = start.walker();\n        while (start && start !== end) {\n            callback(start);\n            var next = walker.next();\n            if (next) {\n                start = next.node;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\nfunction isUnlinked(id) {\n    var node = findNodeById(id);\n    if (!node) {\n        return true;\n    }\n    while (node && node.type !== 'document') {\n        // eslint-disable-next-line no-loop-func\n        if (!node.parent && !node.prev && !node.next) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\n\nvar reLineEnding = /\\r\\n|\\n|\\r/;\nfunction canBeContinuedListItem(lineText) {\n    var spaceMatch = lineText.match(/^[ \\t]+/);\n    if (spaceMatch && (spaceMatch[0].length >= 2 || /\\t/.test(spaceMatch[0]))) {\n        return true;\n    }\n    var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;\n    return reBulletListMarker.test(leftTrimmed) || reOrderedListMarker.test(leftTrimmed);\n}\nfunction canBeContinuedTableBody(lineText) {\n    return !isBlank(lineText) && lineText.indexOf('|') !== -1;\n}\nfunction createRefDefState(node) {\n    var id = node.id, title = node.title, sourcepos = node.sourcepos, dest = node.dest;\n    return {\n        id: id,\n        title: title,\n        sourcepos: sourcepos,\n        unlinked: false,\n        destination: dest,\n    };\n}\nvar ToastMark = /** @class */ (function () {\n    function ToastMark(contents, options) {\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);\n        this.parser = new Parser(options);\n        this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);\n        this.eventHandlerMap = { change: [] };\n        contents = contents || '';\n        this.lineTexts = contents.split(reLineEnding);\n        this.root = this.parser.parse(contents, this.lineTexts);\n    }\n    ToastMark.prototype.updateLineTexts = function (startPos, endPos, newText) {\n        var _a;\n        var startLine = startPos[0], startCol = startPos[1];\n        var endLine = endPos[0], endCol = endPos[1];\n        var newLines = newText.split(reLineEnding);\n        var newLineLen = newLines.length;\n        var startLineText = this.lineTexts[startLine - 1];\n        var endLineText = this.lineTexts[endLine - 1];\n        newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];\n        newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);\n        var removedLineLen = endLine - startLine + 1;\n        (_a = this.lineTexts).splice.apply(_a, __spreadArray([startLine - 1, removedLineLen], newLines));\n        return newLineLen - removedLineLen;\n    };\n    ToastMark.prototype.updateRootNodeState = function () {\n        if (this.lineTexts.length === 1 && this.lineTexts[0] === '') {\n            this.root.lastLineBlank = true;\n            this.root.sourcepos = [\n                [1, 1],\n                [1, 0],\n            ];\n            return;\n        }\n        if (this.root.lastChild) {\n            this.root.lastLineBlank = this.root.lastChild.lastLineBlank;\n        }\n        var lineTexts = this.lineTexts;\n        var idx = lineTexts.length - 1;\n        while (lineTexts[idx] === '') {\n            idx -= 1;\n        }\n        if (lineTexts.length - 2 > idx) {\n            idx += 1;\n        }\n        this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];\n    };\n    ToastMark.prototype.replaceRangeNodes = function (startNode, endNode, newNodes) {\n        if (!startNode) {\n            if (endNode) {\n                insertNodesBefore(endNode, newNodes);\n                removeNodeById(endNode.id);\n                endNode.unlink();\n            }\n            else {\n                prependChildNodes(this.root, newNodes);\n            }\n        }\n        else {\n            insertNodesBefore(startNode, newNodes);\n            removeNextUntil(startNode, endNode);\n            [startNode.id, endNode.id].forEach(function (id) { return removeNodeById(id); });\n            startNode.unlink();\n        }\n    };\n    ToastMark.prototype.getNodeRange = function (startPos, endPos) {\n        var startNode = findChildNodeAtLine(this.root, startPos[0]);\n        var endNode = findChildNodeAtLine(this.root, endPos[0]);\n        // extend node range to include a following block which doesn't have preceding blank line\n        if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {\n            endNode = endNode.next;\n        }\n        return [startNode, endNode];\n    };\n    ToastMark.prototype.trigger = function (eventName, param) {\n        this.eventHandlerMap[eventName].forEach(function (handler) {\n            handler(param);\n        });\n    };\n    ToastMark.prototype.extendEndLine = function (line) {\n        while (this.lineTexts[line] === '') {\n            line += 1;\n        }\n        return line;\n    };\n    ToastMark.prototype.parseRange = function (startNode, endNode, startLine, endLine) {\n        // extends starting range if the first node can be a continued list item\n        if (startNode &&\n            startNode.prev &&\n            ((isList(startNode.prev) && canBeContinuedListItem(this.lineTexts[startLine - 1])) ||\n                (isTable(startNode.prev) && canBeContinuedTableBody(this.lineTexts[startLine - 1])))) {\n            startNode = startNode.prev;\n            startLine = startNode.sourcepos[0][0];\n        }\n        var editedLines = this.lineTexts.slice(startLine - 1, endLine);\n        var root = this.parser.partialParseStart(startLine, editedLines);\n        // extends ending range if the following node can be a fenced code block or a continued list item\n        var nextNode = endNode ? endNode.next : this.root.firstChild;\n        var lastChild = root.lastChild;\n        var isOpenedLastChildCodeBlock = lastChild && isCodeBlock(lastChild) && lastChild.open;\n        var isOpenedLastChildCustomBlock = lastChild && isCustomBlock(lastChild) && lastChild.open;\n        var isLastChildList = lastChild && isList(lastChild);\n        while (((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode) ||\n            (isLastChildList && nextNode && (nextNode.type === 'list' || nextNode.sourcepos[0][1] >= 2))) {\n            var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);\n            this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));\n            if (!startNode) {\n                startNode = endNode;\n            }\n            endNode = nextNode;\n            endLine = newEndLine;\n            nextNode = nextNode.next;\n        }\n        this.parser.partialParseFinish();\n        var newNodes = getChildNodes(root);\n        return { newNodes: newNodes, extStartNode: startNode, extEndNode: endNode };\n    };\n    ToastMark.prototype.getRemovedNodeRange = function (extStartNode, extEndNode) {\n        if (!extStartNode ||\n            (extStartNode && isRefDef(extStartNode)) ||\n            (extEndNode && isRefDef(extEndNode))) {\n            return null;\n        }\n        return {\n            id: [extStartNode.id, extEndNode.id],\n            line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1],\n        };\n    };\n    ToastMark.prototype.markDeletedRefMap = function (extStartNode, extEndNode) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var markDeleted = function (node) {\n                if (isRefDef(node)) {\n                    var refDefState = _this.refMap[node.label];\n                    if (refDefState && node.id === refDefState.id) {\n                        refDefState.unlinked = true;\n                    }\n                }\n            };\n            if (extStartNode) {\n                invokeNextUntil(markDeleted, extStartNode.parent, extEndNode);\n            }\n            if (extEndNode) {\n                invokeNextUntil(markDeleted, extEndNode);\n            }\n        }\n    };\n    ToastMark.prototype.replaceWithNewRefDefState = function (nodes) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var replaceWith_1 = function (node) {\n                if (isRefDef(node)) {\n                    var label = node.label;\n                    var refDefState = _this.refMap[label];\n                    if (!refDefState || refDefState.unlinked) {\n                        _this.refMap[label] = createRefDefState(node);\n                    }\n                }\n            };\n            nodes.forEach(function (node) {\n                invokeNextUntil(replaceWith_1, node);\n            });\n        }\n    };\n    ToastMark.prototype.replaceWithRefDefCandidate = function () {\n        var _this = this;\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            iterateObject(this.refDefCandidateMap, function (_, candidate) {\n                var label = candidate.label, sourcepos = candidate.sourcepos;\n                var refDefState = _this.refMap[label];\n                if (!refDefState ||\n                    refDefState.unlinked ||\n                    refDefState.sourcepos[0][0] > sourcepos[0][0]) {\n                    _this.refMap[label] = createRefDefState(candidate);\n                }\n            });\n        }\n    };\n    ToastMark.prototype.getRangeWithRefDef = function (startLine, endLine, startNode, endNode, lineDiff) {\n        if (this.referenceDefinition && !isEmptyObj(this.refMap)) {\n            var prevNode = findChildNodeAtLine(this.root, startLine - 1);\n            var nextNode = findChildNodeAtLine(this.root, endLine + 1);\n            if (prevNode && isRefDef(prevNode) && prevNode !== startNode && prevNode !== endNode) {\n                startNode = prevNode;\n                startLine = startNode.sourcepos[0][0];\n            }\n            if (nextNode && isRefDef(nextNode) && nextNode !== startNode && nextNode !== endNode) {\n                endNode = nextNode;\n                endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);\n            }\n        }\n        return [startNode, endNode, startLine, endLine];\n    };\n    ToastMark.prototype.parse = function (startPos, endPos, lineDiff) {\n        if (lineDiff === void 0) { lineDiff = 0; }\n        var range = this.getNodeRange(startPos, endPos);\n        var startNode = range[0], endNode = range[1];\n        var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];\n        var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);\n        var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));\n        var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;\n        var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);\n        var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;\n        if (this.referenceDefinition) {\n            this.markDeletedRefMap(extStartNode, extEndNode);\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n            this.replaceWithNewRefDefState(newNodes);\n        }\n        else {\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n        }\n        return { nodes: newNodes, removedNodeRange: removedNodeRange, nextNode: nextNode };\n    };\n    ToastMark.prototype.parseRefLink = function () {\n        var _this = this;\n        var result = [];\n        if (!isEmptyObj(this.refMap)) {\n            iterateObject(this.refMap, function (label, value) {\n                if (value.unlinked) {\n                    delete _this.refMap[label];\n                }\n                iterateObject(_this.refLinkCandidateMap, function (_, candidate) {\n                    var node = candidate.node, refLabel = candidate.refLabel;\n                    if (refLabel === label) {\n                        result.push(_this.parse(node.sourcepos[0], node.sourcepos[1]));\n                    }\n                });\n            });\n        }\n        return result;\n    };\n    ToastMark.prototype.removeUnlinkedCandidate = function () {\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (candidateMap) {\n                iterateObject(candidateMap, function (id) {\n                    if (isUnlinked(id)) {\n                        delete candidateMap[id];\n                    }\n                });\n            });\n        }\n    };\n    ToastMark.prototype.editMarkdown = function (startPos, endPos, newText) {\n        var lineDiff = this.updateLineTexts(startPos, endPos, newText);\n        var parseResult = this.parse(startPos, endPos, lineDiff);\n        var editResult = omit(parseResult, 'nextNode');\n        updateNextLineNumbers(parseResult.nextNode, lineDiff);\n        this.updateRootNodeState();\n        var result = [editResult];\n        if (this.referenceDefinition) {\n            this.removeUnlinkedCandidate();\n            this.replaceWithRefDefCandidate();\n            result = result.concat(this.parseRefLink());\n        }\n        this.trigger('change', result);\n        return result;\n    };\n    ToastMark.prototype.getLineTexts = function () {\n        return this.lineTexts;\n    };\n    ToastMark.prototype.getRootNode = function () {\n        return this.root;\n    };\n    ToastMark.prototype.findNodeAtPosition = function (pos) {\n        var node = findNodeAtPosition(this.root, pos);\n        if (!node || node === this.root) {\n            return null;\n        }\n        return node;\n    };\n    ToastMark.prototype.findFirstNodeAtLine = function (line) {\n        return findFirstNodeAtLine(this.root, line);\n    };\n    ToastMark.prototype.on = function (eventName, callback) {\n        this.eventHandlerMap[eventName].push(callback);\n    };\n    ToastMark.prototype.off = function (eventName, callback) {\n        var handlers = this.eventHandlerMap[eventName];\n        var idx = handlers.indexOf(callback);\n        handlers.splice(idx, 1);\n    };\n    ToastMark.prototype.findNodeById = function (id) {\n        return findNodeById(id);\n    };\n    ToastMark.prototype.removeAllNode = function () {\n        removeAllNode();\n    };\n    return ToastMark;\n}());\n\nvar disallowedTags = [\n    'title',\n    'textarea',\n    'style',\n    'xmp',\n    'iframe',\n    'noembed',\n    'noframes',\n    'script',\n    'plaintext',\n];\nvar reDisallowedTag = new RegExp(\"<(/?(?:\" + disallowedTags.join('|') + \")[^>]*>)\", 'ig');\nfunction filterDisallowedTags(str) {\n    if (reDisallowedTag.test(str)) {\n        return str.replace(reDisallowedTag, function (_, group) { return \"&lt;\" + group; });\n    }\n    return str;\n}\n\nvar baseConvertors$1 = {\n    heading: function (node, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: \"h\" + node.level,\n            outerNewLine: true,\n        };\n    },\n    text: function (node) {\n        return {\n            type: 'text',\n            content: node.literal,\n        };\n    },\n    softbreak: function (_, _a) {\n        var options = _a.options;\n        return {\n            type: 'html',\n            content: options.softbreak,\n        };\n    },\n    linebreak: function () {\n        return {\n            type: 'html',\n            content: '<br />\\n',\n        };\n    },\n    emph: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'em',\n        };\n    },\n    strong: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'strong',\n        };\n    },\n    paragraph: function (node, _a) {\n        var _b;\n        var entering = _a.entering;\n        var grandparent = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent;\n        if (grandparent && grandparent.type === 'list') {\n            if (grandparent.listData.tight) {\n                return null;\n            }\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'p',\n            outerNewLine: true,\n        };\n    },\n    thematicBreak: function () {\n        return {\n            type: 'openTag',\n            tagName: 'hr',\n            outerNewLine: true,\n            selfClose: true,\n        };\n    },\n    blockQuote: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'blockquote',\n            outerNewLine: true,\n            innerNewLine: true,\n        };\n    },\n    list: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, type = _b.type, start = _b.start;\n        var tagName = type === 'bullet' ? 'ul' : 'ol';\n        var attributes = {};\n        if (tagName === 'ol' && start !== null && start !== 1) {\n            attributes.start = start.toString();\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: tagName,\n            attributes: attributes,\n            outerNewLine: true,\n        };\n    },\n    item: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    htmlInline: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        return { type: 'html', content: content };\n    },\n    htmlBlock: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        if (options.nodeId) {\n            return [\n                { type: 'openTag', tagName: 'div', outerNewLine: true },\n                { type: 'html', content: content },\n                { type: 'closeTag', tagName: 'div', outerNewLine: true },\n            ];\n        }\n        return { type: 'html', content: content, outerNewLine: true };\n    },\n    code: function (node) {\n        return [\n            { type: 'openTag', tagName: 'code' },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var infoStr = node.info;\n        var infoWords = infoStr ? infoStr.split(/\\s+/) : [];\n        var codeClassNames = [];\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            codeClassNames.push(\"language-\" + escapeXml(infoWords[0]));\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', outerNewLine: true },\n            { type: 'openTag', tagName: 'code', classNames: codeClassNames },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre', outerNewLine: true },\n        ];\n    },\n    link: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, title = _b.title, destination = _b.destination;\n            return {\n                type: 'openTag',\n                tagName: 'a',\n                attributes: __assign({ href: escapeXml(destination) }, (title && { title: escapeXml(title) })),\n            };\n        }\n        return { type: 'closeTag', tagName: 'a' };\n    },\n    image: function (node, _a) {\n        var getChildrenText = _a.getChildrenText, skipChildren = _a.skipChildren;\n        var _b = node, title = _b.title, destination = _b.destination;\n        skipChildren();\n        return {\n            type: 'openTag',\n            tagName: 'img',\n            selfClose: true,\n            attributes: __assign({ src: escapeXml(destination), alt: getChildrenText(node) }, (title && { title: escapeXml(title) })),\n        };\n    },\n    customBlock: function (node, context, convertors) {\n        var info = node.info.trim().toLowerCase();\n        var customConvertor = convertors[info];\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + info + \" block node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return [\n            { type: 'openTag', tagName: 'div', outerNewLine: true },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    frontMatter: function (node) {\n        return [\n            {\n                type: 'openTag',\n                tagName: 'div',\n                outerNewLine: true,\n                // Because front matter is metadata, it should not be render.\n                attributes: { style: 'white-space: pre; display: none;' },\n            },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    customInline: function (node, context, convertors) {\n        var _a = node, info = _a.info, firstChild = _a.firstChild;\n        var nomalizedInfo = info.trim().toLowerCase();\n        var customConvertor = convertors[nomalizedInfo];\n        var entering = context.entering;\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + nomalizedInfo + \" inline node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return entering\n            ? [\n                { type: 'openTag', tagName: 'span' },\n                { type: 'text', content: \"$$\" + info + (firstChild ? ' ' : '') },\n            ]\n            : [\n                { type: 'text', content: '$$' },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n    },\n};\n\nvar gfmConvertors = {\n    strike: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'del',\n        };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, checked = _b.checked, task = _b.task;\n        if (entering) {\n            var itemTag = {\n                type: 'openTag',\n                tagName: 'li',\n                outerNewLine: true,\n            };\n            if (task) {\n                return [\n                    itemTag,\n                    {\n                        type: 'openTag',\n                        tagName: 'input',\n                        selfClose: true,\n                        attributes: __assign(__assign({}, (checked && { checked: '' })), { disabled: '', type: 'checkbox' }),\n                    },\n                    {\n                        type: 'text',\n                        content: ' ',\n                    },\n                ];\n            }\n            return itemTag;\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    table: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'table',\n            outerNewLine: true,\n        };\n    },\n    tableHead: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'thead',\n            outerNewLine: true,\n        };\n    },\n    tableBody: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'tbody',\n            outerNewLine: true,\n        };\n    },\n    tableRow: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            return {\n                type: 'openTag',\n                tagName: 'tr',\n                outerNewLine: true,\n            };\n        }\n        var result = [];\n        if (node.lastChild) {\n            var columnLen = node.parent.parent.columns.length;\n            var lastColIdx = node.lastChild.endIdx;\n            for (var i = lastColIdx + 1; i < columnLen; i += 1) {\n                result.push({\n                    type: 'openTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                }, {\n                    type: 'closeTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                });\n            }\n        }\n        result.push({\n            type: 'closeTag',\n            tagName: 'tr',\n            outerNewLine: true,\n        });\n        return result;\n    },\n    tableCell: function (node, _a) {\n        var entering = _a.entering;\n        if (node.ignored) {\n            return {\n                type: 'text',\n                content: '',\n            };\n        }\n        var tablePart = node.parent.parent;\n        var tagName = tablePart.type === 'tableHead' ? 'th' : 'td';\n        var table = tablePart.parent;\n        var columnInfo = table.columns[node.startIdx];\n        var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;\n        if (entering) {\n            return __assign({ type: 'openTag', tagName: tagName, outerNewLine: true }, (attributes && { attributes: attributes }));\n        }\n        return {\n            type: 'closeTag',\n            tagName: tagName,\n            outerNewLine: true,\n        };\n    },\n};\n\nvar defaultOptions = {\n    softbreak: '\\n',\n    gfm: false,\n    tagFilter: false,\n    nodeId: false,\n};\nfunction getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var node_1 = event.node;\n        if (node_1.type === 'text') {\n            buffer.push(node_1.literal);\n        }\n    }\n    return buffer.join('');\n}\nvar Renderer = /** @class */ (function () {\n    function Renderer(customOptions) {\n        this.buffer = [];\n        this.options = __assign(__assign({}, defaultOptions), customOptions);\n        this.convertors = this.createConvertors();\n        delete this.options.convertors;\n    }\n    Renderer.prototype.createConvertors = function () {\n        var convertors = __assign({}, baseConvertors$1);\n        if (this.options.gfm) {\n            convertors = __assign(__assign({}, convertors), gfmConvertors);\n        }\n        if (this.options.convertors) {\n            var customConvertors_1 = this.options.convertors;\n            var nodeTypes = Object.keys(customConvertors_1);\n            var defaultConvertors_1 = __assign(__assign({}, baseConvertors$1), gfmConvertors);\n            nodeTypes.forEach(function (nodeType) {\n                var orgConvertor = convertors[nodeType];\n                var convertor = customConvertors_1[nodeType];\n                var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType) === -1\n                    ? nodeType.toLowerCase()\n                    : nodeType;\n                if (orgConvertor) {\n                    convertors[convertorType] = function (node, context, convertors) {\n                        context.origin = function () { return orgConvertor(node, context, convertors); };\n                        return convertor(node, context);\n                    };\n                }\n                else {\n                    convertors[convertorType] = convertor;\n                }\n            });\n        }\n        return convertors;\n    };\n    Renderer.prototype.getConvertors = function () {\n        return this.convertors;\n    };\n    Renderer.prototype.getOptions = function () {\n        return this.options;\n    };\n    Renderer.prototype.render = function (rootNode) {\n        var _this = this;\n        this.buffer = [];\n        var walker = rootNode.walker();\n        var event = null;\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            if (!convertor) {\n                return \"continue\";\n            }\n            var skipped = false;\n            var context = {\n                entering: entering,\n                leaf: !isContainer$1(node),\n                options: this_1.options,\n                getChildrenText: getChildrenText,\n                skipChildren: function () {\n                    skipped = true;\n                },\n            };\n            var converted = isCustomBlock(node) || isCustomInline(node)\n                ? convertor(node, context, this_1.convertors)\n                : convertor(node, context);\n            if (converted) {\n                var htmlNodes = Array.isArray(converted) ? converted : [converted];\n                htmlNodes.forEach(function (htmlNode, index) {\n                    if (htmlNode.type === 'openTag' && _this.options.nodeId && index === 0) {\n                        if (!htmlNode.attributes) {\n                            htmlNode.attributes = {};\n                        }\n                        htmlNode.attributes['data-nodeid'] = String(node.id);\n                    }\n                    _this.renderHTMLNode(htmlNode);\n                });\n                if (skipped) {\n                    walker.resumeAt(node, false);\n                    walker.next();\n                }\n            }\n        };\n        var this_1 = this;\n        while ((event = walker.next())) {\n            _loop_1();\n        }\n        this.addNewLine();\n        return this.buffer.join('');\n    };\n    Renderer.prototype.renderHTMLNode = function (node) {\n        switch (node.type) {\n            case 'openTag':\n            case 'closeTag':\n                this.renderElementNode(node);\n                break;\n            case 'text':\n                this.renderTextNode(node);\n                break;\n            case 'html':\n                this.renderRawHtmlNode(node);\n                break;\n            // no-default-case\n        }\n    };\n    Renderer.prototype.generateOpenTagString = function (node) {\n        var _this = this;\n        var tagName = node.tagName, classNames = node.classNames, attributes = node.attributes;\n        this.buffer.push(\"<\" + tagName);\n        if (classNames && classNames.length > 0) {\n            this.buffer.push(\" class=\\\"\" + classNames.join(' ') + \"\\\"\");\n        }\n        if (attributes) {\n            Object.keys(attributes).forEach(function (attrName) {\n                var attrValue = attributes[attrName];\n                _this.buffer.push(\" \" + attrName + \"=\\\"\" + attrValue + \"\\\"\");\n            });\n        }\n        if (node.selfClose) {\n            this.buffer.push(' /');\n        }\n        this.buffer.push('>');\n    };\n    Renderer.prototype.generateCloseTagString = function (_a) {\n        var tagName = _a.tagName;\n        this.buffer.push(\"</\" + tagName + \">\");\n    };\n    Renderer.prototype.addNewLine = function () {\n        if (this.buffer.length && last(last(this.buffer)) !== '\\n') {\n            this.buffer.push('\\n');\n        }\n    };\n    Renderer.prototype.addOuterNewLine = function (node) {\n        if (node.outerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.addInnerNewLine = function (node) {\n        if (node.innerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.renderTextNode = function (node) {\n        this.buffer.push(escapeXml(node.content));\n    };\n    Renderer.prototype.renderRawHtmlNode = function (node) {\n        this.addOuterNewLine(node);\n        this.buffer.push(node.content);\n        this.addOuterNewLine(node);\n    };\n    Renderer.prototype.renderElementNode = function (node) {\n        if (node.type === 'openTag') {\n            this.addOuterNewLine(node);\n            this.generateOpenTagString(node);\n            if (node.selfClose) {\n                this.addOuterNewLine(node);\n            }\n            else {\n                this.addInnerNewLine(node);\n            }\n        }\n        else {\n            this.addInnerNewLine(node);\n            this.generateCloseTagString(node);\n            this.addOuterNewLine(node);\n        }\n    };\n    return Renderer;\n}());\n\n/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar hasOwnProperty = Object.hasOwnProperty,\n    setPrototypeOf = Object.setPrototypeOf,\n    isFrozen = Object.isFrozen,\n    getPrototypeOf = Object.getPrototypeOf,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar freeze = Object.freeze,\n    seal = Object.seal,\n    create = Object.create; // eslint-disable-line import/no-mutable-exports\n\nvar _ref = typeof Reflect !== 'undefined' && Reflect,\n    apply = _ref.apply,\n    construct = _ref.construct;\n\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\nif (!freeze) {\n  freeze = function freeze(x) {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function seal(x) {\n    return x;\n  };\n}\n\nif (!construct) {\n  construct = function construct(Func, args) {\n    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n  };\n}\n\nvar arrayForEach = unapply(Array.prototype.forEach);\nvar arrayPop = unapply(Array.prototype.pop);\nvar arrayPush = unapply(Array.prototype.push);\n\nvar stringToLowerCase = unapply(String.prototype.toLowerCase);\nvar stringMatch = unapply(String.prototype.match);\nvar stringReplace = unapply(String.prototype.replace);\nvar stringIndexOf = unapply(String.prototype.indexOf);\nvar stringTrim = unapply(String.prototype.trim);\n\nvar regExpTest = unapply(RegExp.prototype.test);\n\nvar typeErrorCreate = unconstruct(TypeError);\n\nfunction unapply(func) {\n  return function (thisArg) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\nfunction unconstruct(func) {\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return construct(func, args);\n  };\n}\n\n/* Add properties to a lookup table */\nfunction addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  var l = array.length;\n  while (l--) {\n    var element = array[l];\n    if (typeof element === 'string') {\n      var lcElement = stringToLowerCase(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/* Shallow clone an object */\nfunction clone(object) {\n  var newObject = create(null);\n\n  var property = void 0;\n  for (property in object) {\n    if (apply(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n\n/* IE10 doesn't support __lookupGetter__ so lets'\n * simulate it. It also automatically checks\n * if the prop is function or getter and behaves\n * accordingly. */\nfunction lookupGetter(object, prop) {\n  while (object !== null) {\n    var desc = getOwnPropertyDescriptor(object, prop);\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n\n    object = getPrototypeOf(object);\n  }\n\n  function fallbackValue(element) {\n    console.warn('fallback value for', element);\n    return null;\n  }\n\n  return fallbackValue;\n}\n\nvar html$2 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n// SVG\nvar svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\nvar svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nvar svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\nvar mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nvar mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\nvar text = freeze(['#text']);\n\nvar html$1$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n\nvar svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\nvar mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\nvar xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n// eslint-disable-next-line unicorn/better-regex\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  var suffix = null;\n  var ATTR_NAME = 'data-tt-policy-suffix';\n  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\n\nfunction createDOMPurify() {\n  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n  var DOMPurify = function DOMPurify(root) {\n    return createDOMPurify(root);\n  };\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = '2.3.3';\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  var originalDocument = window.document;\n\n  var document = window.document;\n  var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      Element = window.Element,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      Text = window.Text,\n      Comment = window.Comment,\n      DOMParser = window.DOMParser,\n      trustedTypes = window.trustedTypes;\n\n\n  var ElementPrototype = Element.prototype;\n\n  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    var template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n  var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      createDocumentFragment = _document.createDocumentFragment,\n      getElementsByTagName = _document.getElementsByTagName;\n  var importNode = originalDocument.importNode;\n\n\n  var documentMode = {};\n  try {\n    documentMode = clone(document).documentMode ? document.documentMode : {};\n  } catch (_) {}\n\n  var hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n      ERB_EXPR$$1 = ERB_EXPR,\n      DATA_ATTR$$1 = DATA_ATTR,\n      ARIA_ATTR$$1 = ARIA_ATTR,\n      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html$2), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n  /* Allowed attribute names */\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  var FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  var FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  var ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  var ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  var SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  var WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  var SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  var FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  var RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  var RETURN_DOM_FRAGMENT = false;\n\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify.\n   *\n   * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n   * might cause XSS from attacks hidden in closed shadowroots in case the browser\n   * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n   */\n  var RETURN_DOM_IMPORT = true;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  var RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks? */\n  var SANITIZE_DOM = true;\n\n  /* Keep element content when removing element? */\n  var KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  var IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  var USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  var FORBID_CONTENTS = null;\n  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n  /* Tags that are safe for data: URIs */\n  var DATA_URI_TAGS = null;\n  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n  /* Attributes safe for values like \"javascript:\" */\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  var NAMESPACE = HTML_NAMESPACE;\n  var IS_EMPTY_INPUT = false;\n\n  /* Parsing of strict XHTML documents */\n  var PARSER_MEDIA_TYPE = void 0;\n  var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n  var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n  var transformCaseFunc = void 0;\n\n  /* Keep a reference to config to pass to hooks */\n  var CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  var formElement = document.createElement('form');\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  var _parseConfig = function _parseConfig(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n\n    PARSER_MEDIA_TYPE =\n    // eslint-disable-next-line unicorn/prefer-includes\n    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\n      return x;\n    } : stringToLowerCase;\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html$2);\n        addToSet(ALLOWED_ATTR, html$1$1);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  var ALL_SVG_TAGS = addToSet({}, svg);\n  addToSet(ALL_SVG_TAGS, svgFilters);\n  addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n  var ALL_MATHML_TAGS = addToSet({}, mathMl);\n  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n  /**\n   *\n   *\n   * @param  {Element} element a DOM element whose namespace is being checked\n   * @returns {boolean} Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  var _checkValidNamespace = function _checkValidNamespace(element) {\n    var parent = getParentNode(element);\n\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: HTML_NAMESPACE,\n        tagName: 'template'\n      };\n    }\n\n    var tagName = stringToLowerCase(element.tagName);\n    var parentTagName = stringToLowerCase(parent.tagName);\n\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n\n      // The only way to switch from MathML to SVG is via\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      // Certain elements are allowed in both SVG and HTML\n      // namespace. We need to specify them explicitly\n      // so that they don't get erronously deleted from\n      // HTML namespace.\n      var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG or MathML). Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  var _forceRemove = function _forceRemove(node) {\n    arrayPush(DOMPurify.removed, { element: node });\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      node.parentNode.removeChild(node);\n    } catch (_) {\n      try {\n        node.outerHTML = emptyHTML;\n      } catch (_) {\n        node.remove();\n      }\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  var _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node\n      });\n    }\n\n    node.removeAttribute(name);\n\n    // We void attribute values for unremovable \"is\"\" attributes\n    if (name === 'is' && !ALLOWED_ATTR[name]) {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(node);\n        } catch (_) {}\n      } else {\n        try {\n          node.setAttribute(name, '');\n        } catch (_) {}\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  var _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n    }\n\n    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) {}\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n\n    var body = doc.body || doc.documentElement;\n\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n    }\n\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n  var _createIterator = function _createIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  var _isClobbered = function _isClobbered(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  var _isNode = function _isNode(object) {\n    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    arrayForEach(hooks[entryPoint], function (hook) {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  var _sanitizeElements = function _sanitizeElements(currentNode) {\n    var content = void 0;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check if tagname contains Unicode */\n    if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    var tagName = transformCaseFunc(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName: tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Mitigate a problem with templates inside select */\n    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n        if (childNodes && parentNode) {\n          var childCount = childNodes.length;\n\n          for (var i = childCount - 1; i >= 0; --i) {\n            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n          }\n        }\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n      content = stringReplace(content, ERB_EXPR$$1, ' ');\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n      return false;\n    }\n\n    return true;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var l = void 0;\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    var attributes = currentNode.attributes;\n\n    /* Check if we have attributes; if not we might have a text node */\n\n    if (!attributes) {\n      return;\n    }\n\n    var hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      attr = attributes[l];\n      var _attr = attr,\n          name = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n\n      value = stringTrim(attr.value);\n      lcName = transformCaseFunc(name);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Remove attribute */\n      _removeAttribute(name, currentNode);\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n        value = stringReplace(value, ERB_EXPR$$1, ' ');\n      }\n\n      /* Is `value` valid for this attribute? */\n      var lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        arrayPop(DOMPurify.removed);\n      } catch (_) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    var shadowNode = void 0;\n    var shadowIterator = _createIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== 'function') {\n        throw typeErrorCreate('toString is not a function');\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      }\n    }\n\n    /* Check we can run. Otherwise fall back or ignore */\n    if (!DOMPurify.isSupported) {\n      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n        if (typeof dirty === 'string') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) ; else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n      // eslint-disable-next-line unicorn/prefer-includes\n      dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Fix IE's strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function (cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    var lcTag = transformCaseFunc(tag);\n    var lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      arrayPop(hooks[entryPoint]);\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nvar purify = createDOMPurify();\n\nvar CAN_BE_WHITE_TAG_LIST = ['iframe', 'embed'];\nvar whiteTagList = [];\nfunction registerTagWhitelistIfPossible(tagName) {\n    if (includes(CAN_BE_WHITE_TAG_LIST, tagName)) {\n        whiteTagList.push(tagName.toLowerCase());\n    }\n}\nfunction sanitizeHTML(html, options) {\n    return purify.sanitize(html, __assign$1({ ADD_TAGS: whiteTagList, ADD_ATTR: ['rel', 'target', 'hreflang', 'type'], FORBID_TAGS: [\n            'input',\n            'script',\n            'textarea',\n            'form',\n            'button',\n            'select',\n            'meta',\n            'style',\n            'link',\n            'title',\n            'object',\n            'base',\n        ] }, options));\n}\n\nfunction getChildrenHTML(node, typeName) {\n    return node\n        .literal.replace(new RegExp(\"(<\\\\s*\" + typeName + \"[^>]*>)|(</\" + typeName + \"\\\\s*[>])\", 'ig'), '')\n        .trim();\n}\nfunction getHTMLAttrsByHTMLString(html) {\n    html = html.match(reHTMLTag)[0];\n    var attrs = html.match(new RegExp(ATTRIBUTE$1, 'g'));\n    return attrs\n        ? attrs.reduce(function (acc, attr) {\n            var _a = attr.trim().split('='), name = _a[0], values = _a.slice(1);\n            if (values.length) {\n                acc[name] = values.join('=').replace(/'|\"/g, '').trim();\n            }\n            return acc;\n        }, {})\n        : {};\n}\nfunction getHTMLAttrs(dom) {\n    return toArray_1(dom.attributes).reduce(function (acc, attr) {\n        acc[attr.nodeName] = attr.nodeValue;\n        return acc;\n    }, {});\n}\nfunction sanitizeDOM(node, typeName, sanitizer, wwToDOMAdaptor) {\n    var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node);\n    var html = sanitizer(dom.outerHTML);\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    dom = container.firstChild;\n    var htmlAttrs = getHTMLAttrs(dom);\n    return { dom: dom, htmlAttrs: htmlAttrs };\n}\nvar schemaFactory = {\n    htmlBlock: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            atom: true,\n            content: 'block+',\n            group: 'block',\n            attrs: {\n                htmlAttrs: { default: {} },\n                childrenHTML: { default: '' },\n                htmlBlock: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                            childrenHTML: dom.innerHTML,\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var _a = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;\n                htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + \" html-block\" : 'html-block';\n                return __spreadArray$1([typeName, htmlAttrs], toArray_1(dom.childNodes));\n            },\n        };\n    },\n    htmlInline: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            attrs: {\n                htmlAttrs: { default: {} },\n                htmlInline: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var htmlAttrs = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor).htmlAttrs;\n                return [typeName, htmlAttrs, 0];\n            },\n        };\n    },\n};\nfunction createHTMLSchemaMap(convertorMap, sanitizeHTML, wwToDOMAdaptor) {\n    var htmlSchemaMap = { nodes: {}, marks: {} };\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            Object.keys(convertorMap[htmlType]).forEach(function (type) {\n                var targetType = htmlType === 'htmlBlock' ? 'nodes' : 'marks';\n                // register tag white list for preventing to remove the html in sanitizer\n                registerTagWhitelistIfPossible(type);\n                htmlSchemaMap[targetType][type] = schemaFactory[htmlType](type, sanitizeHTML, wwToDOMAdaptor);\n            });\n        }\n    });\n    return htmlSchemaMap;\n}\n\nvar reCloseTag = /^\\s*<\\s*\\//;\nvar baseConvertors = {\n    paragraph: function (_, _a) {\n        var entering = _a.entering, origin = _a.origin, options = _a.options;\n        if (options.nodeId) {\n            return {\n                type: entering ? 'openTag' : 'closeTag',\n                outerNewLine: true,\n                tagName: 'p',\n            };\n        }\n        return origin();\n    },\n    softbreak: function (node) {\n        var isPrevNodeHTML = node.prev && node.prev.type === 'htmlInline';\n        var isPrevBR = isPrevNodeHTML && /<br ?\\/?>/.test(node.prev.literal);\n        var content = isPrevBR ? '\\n' : '<br>\\n';\n        return { type: 'html', content: content };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var attributes = {};\n            var classNames = [];\n            if (node.listData.task) {\n                attributes['data-task'] = '';\n                classNames.push('task-list-item');\n                if (node.listData.checked) {\n                    classNames.push('checked');\n                    attributes['data-task-checked'] = '';\n                }\n            }\n            return {\n                type: 'openTag',\n                tagName: 'li',\n                classNames: classNames,\n                attributes: attributes,\n                outerNewLine: true,\n            };\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    code: function (node) {\n        var attributes = { 'data-backticks': String(node.tickCount) };\n        return [\n            { type: 'openTag', tagName: 'code', attributes: attributes },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var _a = node, fenceLength = _a.fenceLength, info = _a.info;\n        var infoWords = info ? info.split(/\\s+/) : [];\n        var preClasses = [];\n        var codeAttrs = {};\n        if (fenceLength > 3) {\n            codeAttrs['data-backticks'] = fenceLength;\n        }\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            var lang = infoWords[0];\n            preClasses.push(\"lang-\" + lang);\n            codeAttrs['data-language'] = lang;\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', classNames: preClasses },\n            { type: 'openTag', tagName: 'code', attributes: codeAttrs },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre' },\n        ];\n    },\n    customInline: function (node, _a) {\n        var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;\n        var info = node.info;\n        if (info.indexOf('widget') !== -1 && entering) {\n            skipChildren();\n            var content = getWidgetContent(node);\n            var htmlInline = widgetToDOM(info, content).outerHTML;\n            return [\n                { type: 'openTag', tagName: 'span', classNames: ['tui-widget'] },\n                { type: 'html', content: htmlInline },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n        }\n        return origin();\n    },\n};\nfunction getHTMLRenderConvertors(linkAttributes, customConvertors) {\n    var convertors = __assign$1({}, baseConvertors);\n    if (linkAttributes) {\n        convertors.link = function (_, _a) {\n            var entering = _a.entering, origin = _a.origin;\n            var result = origin();\n            if (entering) {\n                result.attributes = __assign$1(__assign$1({}, result.attributes), linkAttributes);\n            }\n            return result;\n        };\n    }\n    if (customConvertors) {\n        Object.keys(customConvertors).forEach(function (nodeType) {\n            var orgConvertor = convertors[nodeType];\n            var customConvertor = customConvertors[nodeType];\n            if (orgConvertor && isFunction_1(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var newContext = __assign$1({}, context);\n                    newContext.origin = function () { return orgConvertor(node, context); };\n                    return customConvertor(node, newContext);\n                };\n            }\n            else if (includes(['htmlBlock', 'htmlInline'], nodeType) && !isFunction_1(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var matched = node.literal.match(reHTMLTag);\n                    if (matched) {\n                        var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];\n                        var typeName = (openTagName || closeTagName).toLowerCase();\n                        var htmlConvertor = customConvertor[typeName];\n                        var childrenHTML = getChildrenHTML(node, typeName);\n                        if (htmlConvertor) {\n                            // copy for preventing to overwrite the originial property\n                            var newNode = __assign$1({}, node);\n                            newNode.attrs = getHTMLAttrsByHTMLString(rootHTML);\n                            newNode.childrenHTML = childrenHTML;\n                            newNode.type = typeName;\n                            context.entering = !reCloseTag.test(node.literal);\n                            return htmlConvertor(newNode, context);\n                        }\n                    }\n                    return context.origin();\n                };\n            }\n            else {\n                convertors[nodeType] = customConvertor;\n            }\n        });\n    }\n    return convertors;\n}\n\nvar nestableTypes = ['list', 'item', 'blockQuote'];\nvar nestableTagNames = ['UL', 'OL', 'BLOCKQUOTE'];\nfunction isBlankLine(doc, index) {\n    var _a;\n    var pmNode = doc.child(index);\n    return !pmNode.childCount || (pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim()));\n}\nfunction getEditorRangeHeightInfo(doc, mdNode, children) {\n    var start = getMdStartLine(mdNode) - 1;\n    var end = getMdEndLine(mdNode) - 1;\n    var rect = children[start].getBoundingClientRect();\n    var height = children[end].offsetTop -\n        children[start].offsetTop +\n        children[end].clientHeight;\n    return {\n        height: height <= 0\n            ? children[start].clientHeight\n            : height + getBlankLinesHeight(doc, children, Math.min(end + 1, doc.childCount - 1)),\n        rect: rect,\n    };\n}\nfunction getBlankLinesHeight(doc, children, start) {\n    var end = doc.childCount - 1;\n    var height = 0;\n    while (start <= end && isBlankLine(doc, start)) {\n        height += children[start].clientHeight;\n        start += 1;\n    }\n    return height;\n}\nfunction findAncestorHavingId(el, root) {\n    while (!el.getAttribute('data-nodeid') && el.parentElement !== root) {\n        el = el.parentElement;\n    }\n    return el;\n}\nfunction getTotalOffsetTop(el, root) {\n    var offsetTop = 0;\n    while (el && el !== root) {\n        if (!includes(nestableTagNames, el.tagName)) {\n            offsetTop += el.offsetTop;\n        }\n        if (el.offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.parentElement;\n    }\n    return offsetTop;\n}\nfunction findAdjacentElementToScrollTop(scrollTop, root) {\n    var el = root;\n    var prev = null;\n    while (el) {\n        var firstElementChild = el.firstElementChild;\n        if (!firstElementChild) {\n            break;\n        }\n        var lastSibling = findLastSiblingElementToScrollTop(firstElementChild, scrollTop, getTotalOffsetTop(el, root));\n        prev = el;\n        el = lastSibling;\n    }\n    var adjacentEl = el || prev;\n    return adjacentEl === root ? null : adjacentEl;\n}\nfunction findLastSiblingElementToScrollTop(el, scrollTop, offsetTop) {\n    if (el && scrollTop > offsetTop + el.offsetTop) {\n        return (findLastSiblingElementToScrollTop(el.nextElementSibling, scrollTop, offsetTop) || el);\n    }\n    return null;\n}\nfunction getAdditionalPos(scrollTop, offsetTop, height, targetNodeHeight) {\n    var ratio = Math.min((scrollTop - offsetTop) / height, 1);\n    return ratio * targetNodeHeight;\n}\nfunction getParentNodeObj(previewContent, mdNode) {\n    var el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    while (!el || isStyledInlineNode(mdNode)) {\n        mdNode = mdNode.parent;\n        el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    }\n    return getNonNestableNodeObj({ mdNode: mdNode, el: el });\n}\nfunction getNonNestableNodeObj(_a) {\n    var mdNode = _a.mdNode, el = _a.el;\n    while ((includes(nestableTypes, mdNode.type) || mdNode.type === 'table') && mdNode.firstChild) {\n        mdNode = mdNode.firstChild;\n        el = el.firstElementChild;\n    }\n    return { mdNode: mdNode, el: el };\n}\n\nvar offsetInfoMap = {};\nfunction setHeight(id, height) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].height = height;\n}\nfunction setOffsetTop(id, offsetTop) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].offsetTop = offsetTop;\n}\nfunction getHeight(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].height;\n}\nfunction getOffsetTop(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].offsetTop;\n}\nfunction removeOffsetInfoByNode(node) {\n    if (node) {\n        delete offsetInfoMap[Number(node.getAttribute('data-nodeid'))];\n        toArray_1(node.children).forEach(function (child) {\n            removeOffsetInfoByNode(child);\n        });\n    }\n}\nfunction getAndSaveOffsetInfo(node, root, mdNodeId) {\n    var cachedHeight = getHeight(mdNodeId);\n    var cachedTop = getOffsetTop(mdNodeId);\n    var nodeHeight = cachedHeight || node.clientHeight;\n    var offsetTop = cachedTop || getTotalOffsetTop(node, root) || node.offsetTop;\n    if (!cachedHeight) {\n        setHeight(mdNodeId, nodeHeight);\n    }\n    if (!cachedTop) {\n        setOffsetTop(mdNodeId, offsetTop);\n    }\n    return { nodeHeight: nodeHeight, offsetTop: offsetTop };\n}\n\nvar CLASS_HIGHLIGHT = cls('md-preview-highlight');\nfunction findTableCell(tableRow, chOffset) {\n    var cell = tableRow.firstChild;\n    while (cell && cell.next) {\n        if (getMdStartCh(cell.next) > chOffset + 1) {\n            break;\n        }\n        cell = cell.next;\n    }\n    return cell;\n}\n/**\n * Class Markdown Preview\n * @param {HTMLElement} el - base element\n * @param {eventEmitter} eventEmitter - event manager\n * @param {object} options\n * @param {boolean} options.isViewer - true for view-only mode\n * @param {boolean} options.highlight - true for using live-highlight feature\n * @param {object} opitons.linkAttributes - attributes for link element\n * @param {object} opitons.customHTMLRenderer - map of custom HTML render functions\n *\n * @ignore\n */\nvar MarkdownPreview = /** @class */ (function () {\n    function MarkdownPreview(eventEmitter, options) {\n        var el = document.createElement('div');\n        this.el = el;\n        this.eventEmitter = eventEmitter;\n        this.isViewer = !!options.isViewer;\n        this.el.className = cls('md-preview');\n        var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;\n        this.renderer = new Renderer({\n            gfm: true,\n            nodeId: true,\n            convertors: getHTMLRenderConvertors(linkAttributes, customHTMLRenderer),\n        });\n        this.cursorNodeId = null;\n        this.sanitizer = sanitizer;\n        this.initEvent(highlight);\n        this.initContentSection();\n        // To prevent overflowing contents in the viewer\n        if (this.isViewer) {\n            this.previewContent.style.overflowWrap = 'break-word';\n        }\n    }\n    MarkdownPreview.prototype.initContentSection = function () {\n        this.previewContent = createElementWith(\"<div class=\\\"\" + cls('contents') + \"\\\"></div>\");\n        if (!this.isViewer) {\n            this.el.appendChild(this.previewContent);\n        }\n    };\n    MarkdownPreview.prototype.toggleActive = function (active) {\n        toggleClass(this.el, 'active', active);\n    };\n    MarkdownPreview.prototype.initEvent = function (highlight) {\n        var _this = this;\n        this.eventEmitter.listen('updatePreview', this.update.bind(this));\n        if (this.isViewer) {\n            return;\n        }\n        if (highlight) {\n            this.eventEmitter.listen('changeToolbarState', function (_a) {\n                var mdNode = _a.mdNode, cursorPos = _a.cursorPos;\n                _this.updateCursorNode(mdNode, cursorPos);\n            });\n            this.eventEmitter.listen('blur', function () {\n                _this.removeHighlight();\n            });\n        }\n        on_1(this.el, 'scroll', function (event) {\n            _this.eventEmitter.emit('scroll', 'preview', findAdjacentElementToScrollTop(event.target.scrollTop, _this.previewContent));\n        });\n        this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(true); });\n        this.eventEmitter.listen('changePreviewTabWrite', function () { return _this.toggleActive(false); });\n    };\n    MarkdownPreview.prototype.removeHighlight = function () {\n        if (this.cursorNodeId) {\n            var currentEl = this.getElementByNodeId(this.cursorNodeId);\n            if (currentEl) {\n                removeClass_1(currentEl, CLASS_HIGHLIGHT);\n            }\n        }\n    };\n    MarkdownPreview.prototype.updateCursorNode = function (cursorNode, cursorPos) {\n        if (cursorNode) {\n            cursorNode = findClosestNode(cursorNode, function (mdNode) { return !isInlineNode$1(mdNode); });\n            if (cursorNode.type === 'tableRow') {\n                cursorNode = findTableCell(cursorNode, cursorPos[1]);\n            }\n            else if (cursorNode.type === 'tableBody') {\n                // empty line next to table\n                cursorNode = null;\n            }\n        }\n        var cursorNodeId = cursorNode ? cursorNode.id : null;\n        if (this.cursorNodeId === cursorNodeId) {\n            return;\n        }\n        var oldEL = this.getElementByNodeId(this.cursorNodeId);\n        var newEL = this.getElementByNodeId(cursorNodeId);\n        if (oldEL) {\n            removeClass_1(oldEL, CLASS_HIGHLIGHT);\n        }\n        if (newEL) {\n            addClass_1(newEL, CLASS_HIGHLIGHT);\n        }\n        this.cursorNodeId = cursorNodeId;\n    };\n    MarkdownPreview.prototype.getElementByNodeId = function (nodeId) {\n        return nodeId\n            ? this.previewContent.querySelector(\"[data-nodeid=\\\"\" + nodeId + \"\\\"]\")\n            : null;\n    };\n    MarkdownPreview.prototype.update = function (changed) {\n        var _this = this;\n        changed.forEach(function (editResult) { return _this.replaceRangeNodes(editResult); });\n        this.eventEmitter.emit('afterPreviewRender', this);\n    };\n    MarkdownPreview.prototype.replaceRangeNodes = function (editResult) {\n        var _this = this;\n        var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;\n        var contentEl = this.previewContent;\n        var newHtml = this.eventEmitter.emitReduce('beforePreviewRender', this.sanitizer(nodes.map(function (node) { return _this.renderer.render(node); }).join('')));\n        if (!removedNodeRange) {\n            contentEl.insertAdjacentHTML('afterbegin', newHtml);\n        }\n        else {\n            var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];\n            var startEl = this.getElementByNodeId(startNodeId);\n            var endEl = this.getElementByNodeId(endNodeId);\n            if (startEl) {\n                startEl.insertAdjacentHTML('beforebegin', newHtml);\n                var el = startEl;\n                while (el && el !== endEl) {\n                    var nextEl = el.nextElementSibling;\n                    removeNode$1(el);\n                    removeOffsetInfoByNode(el);\n                    el = nextEl;\n                }\n                if (el === null || el === void 0 ? void 0 : el.parentNode) {\n                    removeNode$1(el);\n                    removeOffsetInfoByNode(el);\n                }\n            }\n        }\n    };\n    MarkdownPreview.prototype.getRenderer = function () {\n        return this.renderer;\n    };\n    MarkdownPreview.prototype.destroy = function () {\n        off_1(this.el, 'scroll');\n        this.el = null;\n    };\n    MarkdownPreview.prototype.getElement = function () {\n        return this.el;\n    };\n    MarkdownPreview.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.previewContent.innerHTML);\n    };\n    MarkdownPreview.prototype.setHTML = function (html) {\n        this.previewContent.innerHTML = html;\n    };\n    MarkdownPreview.prototype.setHeight = function (height) {\n        css_1(this.el, { height: height + \"px\" });\n    };\n    MarkdownPreview.prototype.setMinHeight = function (minHeight) {\n        css_1(this.el, { minHeight: minHeight + \"px\" });\n    };\n    return MarkdownPreview;\n}());\n\nfunction findNodeBy(pos, condition) {\n    var depth = pos.depth;\n    while (depth) {\n        var node = pos.node(depth);\n        if (condition(node, depth)) {\n            return {\n                node: node,\n                depth: depth,\n                offset: depth > 0 ? pos.before(depth) : 0,\n            };\n        }\n        depth -= 1;\n    }\n    return null;\n}\nfunction isInListNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem' || type.name === 'bulletList' || type.name === 'orderedList';\n    });\n}\nfunction isInTableNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n    });\n}\nfunction findListItem(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem';\n    });\n}\nfunction createDOMInfoParsedRawHTML(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            var rawHTML = dom.getAttribute('data-raw-html');\n            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n        },\n    };\n}\nfunction createCellAttrs(attrs) {\n    return Object.keys(attrs).reduce(function (acc, attrName) {\n        if (attrName !== 'rawHTML' && attrs[attrName]) {\n            attrName = attrName === 'className' ? 'class' : attrName;\n            acc[attrName] = attrs[attrName];\n        }\n        return acc;\n    }, {});\n}\nfunction createParsedCellDOM(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            return ['rawHTML', 'colspan', 'rowspan', 'extended'].reduce(function (acc, attrName) {\n                var attrNameInDOM = attrName === 'rawHTML' ? 'data-raw-html' : attrName;\n                var attrValue = dom.getAttribute(attrNameInDOM);\n                if (attrValue) {\n                    acc[attrName] = includes(['rawHTML', 'extended'], attrName)\n                        ? attrValue\n                        : Number(attrValue);\n                }\n                return acc;\n            }, {});\n        },\n    };\n}\nfunction getDefaultCustomAttrs() {\n    return {\n        htmlAttrs: { default: null },\n        classNames: { default: null },\n    };\n}\nfunction getCustomAttrs(attrs) {\n    var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;\n    return __assign$1(__assign$1({}, htmlAttrs), { class: classNames ? classNames.join(' ') : null });\n}\n\nfunction findWrappingOutside(range, type) {\n    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;\n    var around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (around) {\n        var outer = around.length ? around[0] : type;\n        return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n    }\n    return null;\n}\nfunction findWrappingInside(range, type) {\n    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;\n    var inner = parent.child(startIndex);\n    var inside = type.contentMatch.findWrapping(inner.type);\n    if (inside) {\n        var lastType = inside.length ? inside[inside.length - 1] : type;\n        var innerMatch = lastType.contentMatch;\n        for (var i = startIndex; innerMatch && i < endIndex; i += 1) {\n            innerMatch = innerMatch.matchType(parent.child(i).type);\n        }\n        if (innerMatch && innerMatch.validEnd) {\n            return inside;\n        }\n    }\n    return null;\n}\nfunction findWrappers(range, innerRange, nodeType, attrs) {\n    var around = findWrappingOutside(range, nodeType);\n    var inner = findWrappingInside(innerRange, nodeType);\n    if (around && inner) {\n        var aroundNodes = around.map(function (type) {\n            return { type: type };\n        });\n        var innerNodes = inner.map(function (type) {\n            return { type: type, attrs: attrs };\n        });\n        return aroundNodes.concat({ type: nodeType }).concat(innerNodes);\n    }\n    return null;\n}\nfunction wrapInList(tr, _a, wrappers, joinBefore, list) {\n    var start = _a.start, end = _a.end, startIndex = _a.startIndex, endIndex = _a.endIndex, parent = _a.parent;\n    var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for (var i = wrappers.length - 1; i >= 0; i -= 1) {\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(start - (joinBefore ? 2 : 0), end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, 0, 0), wrappers.length, true));\n    var foundListIndex = 0;\n    for (var i = 0; i < wrappers.length; i += 1) {\n        if (wrappers[i].type === list) {\n            foundListIndex = i + 1;\n            break;\n        }\n    }\n    var splitDepth = wrappers.length - foundListIndex;\n    var splitPos = start + wrappers.length - (joinBefore ? 2 : 0);\n    for (var i = startIndex, len = endIndex; i < len; i += 1) {\n        var first = i === startIndex;\n        if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.canSplit)(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += splitDepth * 2;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\nfunction changeToList(tr, range, list, attrs) {\n    var $from = range.$from, $to = range.$to, depth = range.depth;\n    var outerRange = range;\n    var joinBefore = false;\n    if (depth >= 2 &&\n        $from.node(depth - 1).type.compatibleContent(list) &&\n        range.startIndex === 0 &&\n        $from.index(depth - 1)) {\n        var start = tr.doc.resolve(range.start - 2);\n        outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(start, start, depth);\n        if (range.endIndex < range.parent.childCount) {\n            range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange($from, tr.doc.resolve($to.end(depth)), depth);\n        }\n        joinBefore = true;\n    }\n    var wrappers = findWrappers(outerRange, range, list, attrs);\n    if (wrappers) {\n        return wrapInList(tr, range, wrappers, joinBefore, list);\n    }\n    return tr;\n}\nfunction getBeforeLineListItem(doc, offset) {\n    var endListItemPos = doc.resolve(offset);\n    while (endListItemPos.node().type.name !== 'paragraph') {\n        offset -= 2; // The position value of </li></ul>\n        endListItemPos = doc.resolve(offset);\n    }\n    return findListItem(endListItemPos);\n}\nfunction toggleTaskListItems(tr, _a) {\n    var $from = _a.$from, $to = _a.$to;\n    var startListItem = findListItem($from);\n    var endListItem = findListItem($to);\n    if (startListItem && endListItem) {\n        while (endListItem) {\n            var offset = endListItem.offset, node = endListItem.node;\n            var attrs = { task: !node.attrs.task, checked: false };\n            tr.setNodeMarkup(offset, null, attrs);\n            if (offset === startListItem.offset) {\n                break;\n            }\n            endListItem = getBeforeLineListItem(tr.doc, offset);\n        }\n    }\n    return tr;\n}\nfunction changeListType(tr, _a, list) {\n    var $from = _a.$from, $to = _a.$to;\n    var startListItem = findListItem($from);\n    var endListItem = findListItem($to);\n    if (startListItem && endListItem) {\n        while (endListItem) {\n            var offset = endListItem.offset, node = endListItem.node, depth = endListItem.depth;\n            if (node.attrs.task) {\n                tr.setNodeMarkup(offset, null, { task: false, checked: false });\n            }\n            var resolvedPos = tr.doc.resolve(offset);\n            if (resolvedPos.parent.type !== list) {\n                var parentOffset = resolvedPos.before(depth - 1);\n                tr.setNodeMarkup(parentOffset, list);\n            }\n            if (offset === startListItem.offset) {\n                break;\n            }\n            endListItem = getBeforeLineListItem(tr.doc, offset);\n        }\n    }\n    return tr;\n}\nfunction changeList(list) {\n    return function (_a, dispatch) {\n        var selection = _a.selection, tr = _a.tr;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range) {\n            var newTr = isInListNode($from)\n                ? changeListType(tr, range, list)\n                : changeToList(tr, range, list);\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction toggleTask() {\n    return function (_a, dispatch) {\n        var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range) {\n            var newTr = isInListNode($from)\n                ? toggleTaskListItems(tr, range)\n                : changeToList(tr, range, schema.nodes.bulletList, { task: true });\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction sinkListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to, function (_a) {\n            var childCount = _a.childCount, firstChild = _a.firstChild;\n            return !!childCount && firstChild.type === listItem;\n        });\n        if (range && range.startIndex > 0) {\n            var parent_1 = range.parent;\n            var nodeBefore = parent_1.child(range.startIndex - 1);\n            if (nodeBefore.type !== listItem) {\n                return false;\n            }\n            var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type === parent_1.type;\n            var inner = nestedBefore ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create()) : null;\n            var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(parent_1.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            var before = range.start;\n            var after = range.end;\n            tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true));\n            dispatch(tr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction liftToOuterList(tr, range, listItem) {\n    var $from = range.$from, $to = range.$to, end = range.end, depth = range.depth, parent = range.parent;\n    var endOfList = $to.end(depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create(null, parent.copy())), 1, 0), 1, true));\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), depth);\n    }\n    tr.lift(range, (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.liftTarget)(range));\n    return tr;\n}\nfunction liftOutOfList(tr, range) {\n    var list = range.parent;\n    var pos = range.end;\n    // Merge the list items into a single big item\n    for (var i = range.endIndex - 1, len = range.startIndex; i > len; i -= 1) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    var startPos = tr.doc.resolve(range.start);\n    var listItem = startPos.nodeAfter;\n    var atStart = range.startIndex === 0;\n    var atEnd = range.endIndex === list.childCount;\n    var parent = startPos.node(-1);\n    var indexBefore = startPos.index(-1);\n    var canReplaceParent = parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, listItem === null || listItem === void 0 ? void 0 : listItem.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list)));\n    if (listItem && canReplaceParent) {\n        var start = startPos.pos;\n        var end = start + listItem.nodeSize;\n        // Strip off the surrounding list. At the sides where we're not at\n        // the end of the list, the existing list is closed. At sides where\n        // this is the end, it is overwritten to its end.\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))).append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    }\n    return tr;\n}\nfunction liftListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to, function (_a) {\n            var childCount = _a.childCount, firstChild = _a.firstChild;\n            return !!childCount && firstChild.type === listItem;\n        });\n        if (range) {\n            var topListItem = $from.node(range.depth - 1).type === listItem;\n            var newTr = topListItem ? liftToOuterList(tr, range, listItem) : liftOutOfList(tr, range);\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction splitListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        if ($from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        var grandParent = $from.node(-1);\n        if (grandParent.type !== listItem) {\n            return false;\n        }\n        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth === 2 ||\n                $from.node(-3).type !== listItem ||\n                $from.index(-2) !== $from.node(-2).childCount - 1) {\n                return false;\n            }\n            var keepItem = $from.index(-1) > 0;\n            var wrapper = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n            // Build a fragment containing empty versions of the structure\n            // from the outer list item to the parent node of the cursor\n            for (var depth = $from.depth - (keepItem ? 1 : 2); depth >= $from.depth - 3; depth -= 1) {\n                wrapper = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from($from.node(depth).copy(wrapper));\n            }\n            // Add a second list item with an empty default start node\n            wrapper = wrapper.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.createAndFill()));\n            tr.replace(keepItem ? $from.before() : $from.before(-1), $from.after(-3), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(wrapper, keepItem ? 3 : 2, 2));\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n            dispatch(tr);\n            return true;\n        }\n        var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        var types = nextType && [null, { type: nextType }];\n        tr.delete($from.pos, $to.pos);\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.canSplit)(tr.doc, $from.pos, 2, types)) {\n            tr.split($from.pos, 2, types);\n            dispatch(tr);\n            return true;\n        }\n        return false;\n    };\n}\n\nfunction indent() {\n    return function () { return function (state, dispatch) {\n        var selection = state.selection, schema = state.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range && isInListNode($from)) {\n            return sinkListItem(schema.nodes.listItem)(state, dispatch);\n        }\n        return false;\n    }; };\n}\nfunction outdent() {\n    return function () { return function (state, dispatch) {\n        var selection = state.selection, schema = state.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range && isInListNode($from)) {\n            return liftListItem(schema.nodes.listItem)(state, dispatch);\n        }\n        return false;\n    }; };\n}\nfunction getWwCommands() {\n    return {\n        indent: indent(),\n        outdent: outdent(),\n    };\n}\n\nvar cache = new Map();\n/* eslint-disable @typescript-eslint/no-unused-vars */\nvar TableOffsetMap = /** @class */ (function () {\n    function TableOffsetMap(table, tableRows, tableStartPos, rowInfo) {\n        this.table = table;\n        this.tableRows = tableRows;\n        this.tableStartPos = tableStartPos;\n        this.rowInfo = rowInfo;\n    }\n    TableOffsetMap.create = function (cellPos) {\n        var table = findNodeBy(cellPos, function (_a) {\n            var type = _a.type;\n            return type.name === 'table';\n        });\n        if (table) {\n            var node = table.node, depth = table.depth, offset = table.offset;\n            var cached = cache.get(node);\n            if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset + 1) {\n                return cached;\n            }\n            var rows_1 = [];\n            var tablePos = cellPos.start(depth);\n            var thead = node.child(0);\n            var tbody = node.child(1);\n            var theadCellInfo = createOffsetMap(thead, tablePos);\n            var tbodyCellInfo = createOffsetMap(tbody, tablePos + thead.nodeSize);\n            thead.forEach(function (row) { return rows_1.push(row); });\n            tbody.forEach(function (row) { return rows_1.push(row); });\n            var map = new TableOffsetMap(node, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));\n            cache.set(node, map);\n            return map;\n        }\n        return null;\n    };\n    Object.defineProperty(TableOffsetMap.prototype, \"totalRowCount\", {\n        get: function () {\n            return this.rowInfo.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"totalColumnCount\", {\n        get: function () {\n            return this.rowInfo[0].length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableStartOffset\", {\n        get: function () {\n            return this.tableStartPos;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableEndOffset\", {\n        get: function () {\n            return this.tableStartPos + this.table.nodeSize - 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TableOffsetMap.prototype.getCellInfo = function (rowIdx, colIdx) {\n        return this.rowInfo[rowIdx][colIdx];\n    };\n    TableOffsetMap.prototype.posAt = function (rowIdx, colIdx) {\n        for (var i = 0, rowStart = this.tableStartPos;; i += 1) {\n            var rowEnd = rowStart + this.tableRows[i].nodeSize;\n            if (i === rowIdx) {\n                var index = colIdx;\n                // Skip the cells from previous row(via rowspan)\n                while (index < this.totalColumnCount && this.rowInfo[i][index].offset < rowStart) {\n                    index += 1;\n                }\n                return index === this.totalColumnCount ? rowEnd : this.rowInfo[i][index].offset;\n            }\n            rowStart = rowEnd;\n        }\n    };\n    TableOffsetMap.prototype.getNodeAndPos = function (rowIdx, colIdx) {\n        var cellInfo = this.rowInfo[rowIdx][colIdx];\n        return {\n            node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),\n            pos: cellInfo.offset,\n        };\n    };\n    TableOffsetMap.prototype.extendedRowspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.extendedColspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.getRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getRowspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getCellStartOffset = function (rowIdx, colIdx) {\n        var offset = this.rowInfo[rowIdx][colIdx].offset;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset;\n    };\n    TableOffsetMap.prototype.getCellEndOffset = function (rowIdx, colIdx) {\n        var _a = this.rowInfo[rowIdx][colIdx], offset = _a.offset, nodeSize = _a.nodeSize;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset + nodeSize;\n    };\n    TableOffsetMap.prototype.getCellIndex = function (cellPos) {\n        for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {\n            var rowInfo = this.rowInfo[rowIdx];\n            for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {\n                if (rowInfo[colIdx].offset + 1 > cellPos.pos) {\n                    return [rowIdx, colIdx];\n                }\n            }\n        }\n        return [0, 0];\n    };\n    TableOffsetMap.prototype.getRectOffsets = function (startCellPos, endCellPos) {\n        var _a, _b, _c;\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        if (startCellPos.pos > endCellPos.pos) {\n            _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];\n        }\n        var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];\n        var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];\n        _b = getSortedNumPair(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];\n        _c = getSortedNumPair(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];\n        return this.getSpannedOffsets({ startRowIdx: startRowIdx, startColIdx: startColIdx, endRowIdx: endRowIdx, endColIdx: endColIdx });\n    };\n    TableOffsetMap.prototype.getSpannedOffsets = function (selectionInfo) {\n        return selectionInfo;\n    };\n    return TableOffsetMap;\n}());\n/* eslint-enable @typescript-eslint/no-unused-vars */\nvar createOffsetMap = function (headOrBody, startOffset) {\n    var cellInfoMatrix = [];\n    headOrBody.forEach(function (row, rowOffset) {\n        // get row index based on table(not table head or table body)\n        var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };\n        row.forEach(function (_a, cellOffset) {\n            var nodeSize = _a.nodeSize;\n            var colIdx = 0;\n            while (rowInfo[colIdx]) {\n                colIdx += 1;\n            }\n            rowInfo[colIdx] = {\n                // 2 is the sum of the front and back positions of the tag\n                offset: startOffset + rowOffset + cellOffset + 2,\n                nodeSize: nodeSize,\n            };\n            rowInfo.length += 1;\n        });\n        cellInfoMatrix.push(rowInfo);\n    });\n    return cellInfoMatrix;\n};\nfunction mixinTableOffsetMapPrototype(offsetMapMixin, createOffsetMapMixin) {\n    assign(TableOffsetMap.prototype, offsetMapMixin);\n    createOffsetMap = createOffsetMapMixin;\n    return TableOffsetMap;\n}\n\nfunction getSelectionRanges(doc, map, _a) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;\n    var ranges = [];\n    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n            var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n            ranges.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange(doc.resolve(offset + 1), doc.resolve(offset + nodeSize - 1)));\n        }\n    }\n    return ranges;\n}\nfunction createTableFragment(tableHead, tableBody) {\n    var fragment = [];\n    if (tableHead.childCount) {\n        fragment.push(tableHead);\n    }\n    if (tableBody.childCount) {\n        fragment.push(tableBody);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fragment);\n}\nvar CellSelection = /** @class */ (function (_super) {\n    __extends$1(CellSelection, _super);\n    function CellSelection(startCellPos, endCellPos) {\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        var _this = this;\n        var doc = startCellPos.node(0);\n        var map = TableOffsetMap.create(startCellPos);\n        var selectionInfo = map.getRectOffsets(startCellPos, endCellPos);\n        var ranges = getSelectionRanges(doc, map, selectionInfo);\n        _this = _super.call(this, ranges[0].$from, ranges[0].$to, ranges) || this;\n        _this.startCell = startCellPos;\n        _this.endCell = endCellPos;\n        _this.offsetMap = map;\n        _this.isCellSelection = true;\n        // This property is the api of the 'Selection' in prosemirror,\n        // and is used to disable the text selection.\n        _this.visible = false;\n        return _this;\n    }\n    CellSelection.prototype.map = function (doc, mapping) {\n        var startPos = this.startCell.pos;\n        var endPos = this.endCell.pos;\n        var startCell = doc.resolve(mapping.map(startPos));\n        var endCell = doc.resolve(mapping.map(endPos));\n        var map = TableOffsetMap.create(startCell);\n        // text selection when rows or columns are deleted\n        if (this.offsetMap.totalColumnCount > map.totalColumnCount ||\n            this.offsetMap.totalRowCount > map.totalRowCount) {\n            var depthMap = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 };\n            var depthFromTable = depthMap[endCell.parent.type.name];\n            var tableEndPos = endCell.end(endCell.depth - depthFromTable);\n            // subtract 4(</td></tr></tbody></table> tag length)\n            var from = Math.min(tableEndPos - 4, endCell.pos);\n            return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, from);\n        }\n        return new CellSelection(startCell, endCell);\n    };\n    CellSelection.prototype.eq = function (cell) {\n        return (cell instanceof CellSelection &&\n            cell.startCell.pos === this.startCell.pos &&\n            cell.endCell.pos === this.endCell.pos);\n    };\n    CellSelection.prototype.content = function () {\n        var table = this.startCell.node(-2);\n        var tableOffset = this.startCell.start(-2);\n        var row = table.child(1).firstChild;\n        var tableHead = table.child(0).type.create();\n        var tableBody = table.child(1).type.create();\n        var map = TableOffsetMap.create(this.startCell);\n        var selectionInfo = map.getRectOffsets(this.startCell, this.endCell);\n        var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;\n        var isTableHeadCell = false;\n        for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n            var cells = [];\n            for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                var offset = map.getCellInfo(rowIdx, colIdx).offset;\n                var cell = table.nodeAt(offset - tableOffset);\n                if (cell) {\n                    isTableHeadCell = cell.type.name === 'tableHeadCell';\n                    // mark the extended cell for pasting\n                    if (map.extendedRowspan(rowIdx, colIdx) || map.extendedColspan(rowIdx, colIdx)) {\n                        cells.push(cell.type.create({ extended: true }));\n                    }\n                    else {\n                        cells.push(cell.copy(cell.content));\n                    }\n                }\n            }\n            var copiedRow = row.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n            var targetNode = isTableHeadCell ? tableHead : tableBody;\n            // @ts-ignore\n            targetNode.content = targetNode.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(copiedRow));\n        }\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(createTableFragment(tableHead, tableBody), 1, 1);\n    };\n    CellSelection.prototype.toJSON = function () {\n        return JSON.stringify(this);\n    };\n    return CellSelection;\n}(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection));\n\nfunction createTableHeadRow(columnCount, schema, data) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell, paragraph = _a.paragraph;\n    var cells = [];\n    for (var index = 0; index < columnCount; index += 1) {\n        var text = data && data[index];\n        var para = paragraph.create(null, text ? schema.text(text) : []);\n        cells.push(tableHeadCell.create(null, para));\n    }\n    return [tableRow.create(null, cells)];\n}\nfunction createTableBodyRows(rowCount, columnCount, schema, data) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;\n    var tableRows = [];\n    for (var rowIdx = 0; rowIdx < rowCount; rowIdx += 1) {\n        var cells = [];\n        for (var colIdx = 0; colIdx < columnCount; colIdx += 1) {\n            var text = data && data[rowIdx * columnCount + colIdx];\n            var para = paragraph.create(null, text ? schema.text(text) : []);\n            cells.push(tableBodyCell.create(null, para));\n        }\n        tableRows.push(tableRow.create(null, cells));\n    }\n    return tableRows;\n}\nfunction createDummyCells(columnCount, rowIdx, schema, attrs) {\n    if (attrs === void 0) { attrs = null; }\n    var _a = schema.nodes, tableHeadCell = _a.tableHeadCell, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;\n    var cell = rowIdx === 0 ? tableHeadCell : tableBodyCell;\n    var cells = [];\n    for (var index = 0; index < columnCount; index += 1) {\n        cells.push(cell.create(attrs, paragraph.create()));\n    }\n    return cells;\n}\nfunction findCellElement(node, root) {\n    while (node && node !== root) {\n        if (node.nodeName === 'TD' || node.nodeName === 'TH') {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction findCell(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n    });\n}\nfunction getResolvedSelection(selection) {\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n        var $anchor = selection.$anchor;\n        var foundCell = findCell($anchor);\n        if (foundCell) {\n            var anchor = $anchor.node(0).resolve($anchor.before(foundCell.depth));\n            return { anchor: anchor, head: anchor };\n        }\n    }\n    var _a = selection, startCell = _a.startCell, endCell = _a.endCell;\n    return { anchor: startCell, head: endCell };\n}\nfunction getTableContentFromSlice(slice) {\n    var _a;\n    if (slice.size) {\n        var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;\n        if (content.childCount !== 1) {\n            return null;\n        }\n        while (content.childCount === 1 &&\n            ((openStart > 0 && openEnd > 0) || ((_a = content.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) === 'table')) {\n            openStart -= 1;\n            openEnd -= 1;\n            content = content.firstChild.content;\n        }\n        if (content.firstChild.type.name === 'tableHead' ||\n            content.firstChild.type.name === 'tableBody') {\n            return content;\n        }\n    }\n    return null;\n}\nfunction getRowAndColumnCount(_a) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;\n    var rowCount = endRowIdx - startRowIdx + 1;\n    var columnCount = endColIdx - startColIdx + 1;\n    return { rowCount: rowCount, columnCount: columnCount };\n}\nfunction setAttrs(cell, attrs) {\n    return __assign$1(__assign$1({}, cell.attrs), attrs);\n}\n\nvar pluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('cellSelection');\nvar MOUSE_RIGHT_BUTTON = 2;\nvar TableSelection = /** @class */ (function () {\n    function TableSelection(view) {\n        this.view = view;\n        this.handlers = {\n            mousedown: this.handleMousedown.bind(this),\n            mousemove: this.handleMousemove.bind(this),\n            mouseup: this.handleMouseup.bind(this),\n        };\n        this.startCellPos = null;\n        this.init();\n    }\n    TableSelection.prototype.init = function () {\n        this.view.dom.addEventListener('mousedown', this.handlers.mousedown);\n    };\n    TableSelection.prototype.handleMousedown = function (ev) {\n        var foundCell = findCellElement(ev.target, this.view.dom);\n        if (ev.button === MOUSE_RIGHT_BUTTON) {\n            ev.preventDefault();\n            return;\n        }\n        if (foundCell) {\n            var startCellPos = this.getCellPos(ev);\n            if (startCellPos) {\n                this.startCellPos = startCellPos;\n            }\n            this.bindEvent();\n        }\n    };\n    TableSelection.prototype.handleMousemove = function (ev) {\n        var prevEndCellOffset = pluginKey.getState(this.view.state);\n        var endCellPos = this.getCellPos(ev);\n        var startCellPos = this.startCellPos;\n        var prevEndCellPos;\n        if (prevEndCellOffset) {\n            prevEndCellPos = this.view.state.doc.resolve(prevEndCellOffset);\n        }\n        else if (startCellPos !== endCellPos) {\n            prevEndCellPos = startCellPos;\n        }\n        if (prevEndCellPos && startCellPos && endCellPos) {\n            this.setCellSelection(startCellPos, endCellPos);\n        }\n    };\n    TableSelection.prototype.handleMouseup = function () {\n        this.startCellPos = null;\n        this.unbindEvent();\n        if (pluginKey.getState(this.view.state) !== null) {\n            this.view.dispatch(this.view.state.tr.setMeta(pluginKey, -1));\n        }\n    };\n    TableSelection.prototype.bindEvent = function () {\n        var dom = this.view.dom;\n        dom.addEventListener('mousemove', this.handlers.mousemove);\n        dom.addEventListener('mouseup', this.handlers.mouseup);\n    };\n    TableSelection.prototype.unbindEvent = function () {\n        var dom = this.view.dom;\n        dom.removeEventListener('mousemove', this.handlers.mousemove);\n        dom.removeEventListener('mouseup', this.handlers.mouseup);\n    };\n    TableSelection.prototype.getCellPos = function (_a) {\n        var clientX = _a.clientX, clientY = _a.clientY;\n        var mousePos = this.view.posAtCoords({ left: clientX, top: clientY });\n        if (mousePos) {\n            var doc = this.view.state.doc;\n            var currentPos = doc.resolve(mousePos.pos);\n            var foundCell = findCell(currentPos);\n            if (foundCell) {\n                var cellOffset = currentPos.before(foundCell.depth);\n                return doc.resolve(cellOffset);\n            }\n        }\n        return null;\n    };\n    TableSelection.prototype.setCellSelection = function (startCellPos, endCellPos) {\n        var _a = this.view.state, selection = _a.selection, tr = _a.tr;\n        var starting = pluginKey.getState(this.view.state) === null;\n        var cellSelection = new CellSelection(startCellPos, endCellPos);\n        if (starting || !selection.eq(cellSelection)) {\n            var newTr = tr.setSelection(cellSelection);\n            if (starting) {\n                newTr.setMeta(pluginKey, endCellPos.pos);\n            }\n            this.view.dispatch(newTr);\n        }\n    };\n    TableSelection.prototype.destroy = function () {\n        this.view.dom.removeEventListener('mousedown', this.handlers.mousedown);\n    };\n    return TableSelection;\n}());\n\nvar SELECTED_CELL_CLASS_NAME = cls('cell-selected');\nfunction drawCellSelection(_a) {\n    var selection = _a.selection, doc = _a.doc;\n    if (selection instanceof CellSelection) {\n        var cells_1 = [];\n        var ranges = selection.ranges;\n        ranges.forEach(function (_a) {\n            var $from = _a.$from, $to = _a.$to;\n            cells_1.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.node($from.pos - 1, $to.pos + 1, { class: SELECTED_CELL_CLASS_NAME }));\n        });\n        return prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet.create(doc, cells_1);\n    }\n    return null;\n}\nfunction tableSelection() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey,\n        state: {\n            init: function () {\n                return null;\n            },\n            apply: function (tr, value) {\n                var cellOffset = tr.getMeta(pluginKey);\n                if (cellOffset) {\n                    return cellOffset === -1 ? null : cellOffset;\n                }\n                if (isNull_1(value) || !tr.docChanged) {\n                    return value;\n                }\n                var _a = tr.mapping.mapResult(value), deleted = _a.deleted, pos = _a.pos;\n                return deleted ? null : pos;\n            },\n        },\n        props: {\n            decorations: drawCellSelection,\n            createSelectionBetween: function (_a) {\n                var state = _a.state;\n                if (!isNull_1(pluginKey.getState(state))) {\n                    return state.selection;\n                }\n                return null;\n            },\n        },\n        view: function (editorView) {\n            return new TableSelection(editorView);\n        },\n    });\n}\n\n/**\n * @class\n * @ignore\n * @classdesc ES6 Map\n */\nvar Map$1 = /** @class */ (function () {\n    function Map() {\n        this.keys = [];\n        this.values = [];\n    }\n    Map.prototype.getKeyIndex = function (key) {\n        return inArray_1(key, this.keys);\n    };\n    Map.prototype.get = function (key) {\n        return this.values[this.getKeyIndex(key)];\n    };\n    Map.prototype.set = function (key, value) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.values[keyIndex] = value;\n        }\n        else {\n            this.keys.push(key);\n            this.values.push(value);\n        }\n        return this;\n    };\n    Map.prototype.has = function (key) {\n        return this.getKeyIndex(key) > -1;\n    };\n    Map.prototype.delete = function (key) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.keys.splice(keyIndex, 1);\n            this.values.splice(keyIndex, 1);\n            return true;\n        }\n        return false;\n    };\n    Map.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        if (thisArg === void 0) { thisArg = this; }\n        this.values.forEach(function (value, index) {\n            if (value && _this.keys[index]) {\n                callback.call(thisArg, value, _this.keys[index], _this);\n            }\n        });\n    };\n    Map.prototype.clear = function () {\n        this.keys = [];\n        this.values = [];\n    };\n    return Map;\n}());\n\n/**\n * @fileoverview Implements i18n\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\nvar DEFAULT_CODE = 'en-US';\n/**\n * Class I18n\n * @ignore\n */\nvar I18n = /** @class */ (function () {\n    function I18n() {\n        this.code = DEFAULT_CODE;\n        this.langs = new Map$1();\n    }\n    I18n.prototype.setCode = function (code) {\n        this.code = code || DEFAULT_CODE;\n    };\n    /**\n     * Set language set\n     * @param {string|string[]} codes locale code\n     * @param {object} data language set\n     */\n    I18n.prototype.setLanguage = function (codes, data) {\n        var _this = this;\n        codes = [].concat(codes);\n        codes.forEach(function (code) {\n            if (!_this.langs.has(code)) {\n                _this.langs.set(code, data);\n            }\n            else {\n                var langData = _this.langs.get(code);\n                _this.langs.set(code, extend_1(langData, data));\n            }\n        });\n    };\n    I18n.prototype.get = function (key, code) {\n        if (!code) {\n            code = this.code;\n        }\n        var langSet = this.langs.get(code);\n        if (!langSet) {\n            langSet = this.langs.get(DEFAULT_CODE);\n        }\n        var text = langSet[key];\n        if (!text) {\n            throw new Error(\"There is no text key \\\"\" + key + \"\\\" in \" + code);\n        }\n        return text;\n    };\n    return I18n;\n}());\nvar i18n = new I18n();\n\nvar contextMenuGroups = [\n    [\n        {\n            action: 'Add row to up',\n            command: 'addRowToUp',\n            disableInThead: true,\n            className: 'add-row-up',\n        },\n        {\n            action: 'Add row to down',\n            command: 'addRowToDown',\n            disableInThead: true,\n            className: 'add-row-down',\n        },\n        { action: 'Remove row', command: 'removeRow', disableInThead: true, className: 'remove-row' },\n    ],\n    [\n        { action: 'Add column to left', command: 'addColumnToLeft', className: 'add-column-left' },\n        { action: 'Add column to right', command: 'addColumnToRight', className: 'add-column-right' },\n        { action: 'Remove column', command: 'removeColumn', className: 'remove-column' },\n    ],\n    [\n        {\n            action: 'Align column to left',\n            command: 'alignColumn',\n            payload: { align: 'left' },\n            className: 'align-column-left',\n        },\n        {\n            action: 'Align column to center',\n            command: 'alignColumn',\n            payload: { align: 'center' },\n            className: 'align-column-center',\n        },\n        {\n            action: 'Align column to right',\n            command: 'alignColumn',\n            payload: { align: 'right' },\n            className: 'align-column-right',\n        },\n    ],\n    [{ action: 'Remove table', command: 'removeTable', className: 'remove-table' }],\n];\nfunction getContextMenuGroups(eventEmitter, inTableHead) {\n    return contextMenuGroups\n        .map(function (contextMenuGroup) {\n        return contextMenuGroup.map(function (_a) {\n            var action = _a.action, command = _a.command, payload = _a.payload, disableInThead = _a.disableInThead, className = _a.className;\n            return {\n                label: i18n.get(action),\n                onClick: function () {\n                    eventEmitter.emit('command', command, payload);\n                },\n                disabled: inTableHead && !!disableInThead,\n                className: className,\n            };\n        });\n    })\n        .concat();\n}\nfunction tableContextMenu(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                contextmenu: function (view, ev) {\n                    var tableCell = findCellElement(ev.target, view.dom);\n                    if (tableCell) {\n                        ev.preventDefault();\n                        var _a = ev, clientX = _a.clientX, clientY = _a.clientY;\n                        var _b = view.dom.parentNode.getBoundingClientRect(), left = _b.left, top_1 = _b.top;\n                        var inTableHead = tableCell.nodeName === 'TH';\n                        eventEmitter.emit('contextmenu', {\n                            pos: { left: clientX - left + 10 + \"px\", top: clientY - top_1 + 30 + \"px\" },\n                            menuGroups: getContextMenuGroups(eventEmitter, inTableHead),\n                            tableCell: tableCell,\n                        });\n                        return true;\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nfunction task() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                mousedown: function (view, ev) {\n                    var _a = ev, clientX = _a.clientX, clientY = _a.clientY;\n                    var mousePos = view.posAtCoords({ left: clientX, top: clientY });\n                    if (mousePos) {\n                        var _b = view.state, doc = _b.doc, tr = _b.tr;\n                        var currentPos = doc.resolve(mousePos.pos);\n                        var listItem = findListItem(currentPos);\n                        var target = ev.target;\n                        var style = getComputedStyle(target, ':before');\n                        var _c = ev, offsetX = _c.offsetX, offsetY = _c.offsetY;\n                        if (!listItem || !isPositionInBox(style, offsetX, offsetY)) {\n                            return false;\n                        }\n                        ev.preventDefault();\n                        var offset = currentPos.before(listItem.depth);\n                        var attrs = listItem.node.attrs;\n                        tr.setNodeMarkup(offset, null, __assign$1(__assign$1({}, attrs), { checked: !attrs.checked }));\n                        view.dispatch(tr);\n                        return true;\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nvar EXCEPT_TYPES = ['image', 'link', 'customBlock', 'frontMatter'];\nvar MARK_TYPES = ['strong', 'strike', 'emph', 'code'];\nvar LIST_TYPES = ['bulletList', 'orderedList', 'taskList'];\nfunction getToolbarStateType(node, parentNode) {\n    var type = node.type.name;\n    if (type === 'listItem') {\n        return node.attrs.task ? 'taskList' : parentNode.type.name;\n    }\n    if (type.indexOf('table') !== -1) {\n        return 'table';\n    }\n    return type;\n}\nfunction setListNodeToolbarState(type, nodeTypeState) {\n    nodeTypeState[type] = { active: true };\n    LIST_TYPES.filter(function (listName) { return listName !== type; }).forEach(function (listType) {\n        if (nodeTypeState[listType]) {\n            delete nodeTypeState[listType];\n        }\n    });\n}\nfunction setMarkTypeStates(from, to, schema, toolbarState) {\n    MARK_TYPES.forEach(function (type) {\n        var mark = schema.marks[type];\n        var marksAtPos = from.marksAcross(to) || [];\n        var foundMark = !!mark.isInSet(marksAtPos);\n        if (foundMark) {\n            toolbarState[type] = { active: true };\n        }\n    });\n}\nfunction getToolbarState(selection, doc, schema) {\n    var $from = selection.$from, $to = selection.$to, from = selection.from, to = selection.to;\n    var toolbarState = {\n        indent: { active: false, disabled: true },\n        outdent: { active: false, disabled: true },\n    };\n    doc.nodesBetween(from, to, function (node, _, parentNode) {\n        var type = getToolbarStateType(node, parentNode);\n        if (includes(EXCEPT_TYPES, type)) {\n            return;\n        }\n        if (includes(LIST_TYPES, type)) {\n            setListNodeToolbarState(type, toolbarState);\n            toolbarState.indent.disabled = false;\n            toolbarState.outdent.disabled = false;\n        }\n        else if (type === 'paragraph' || type === 'text') {\n            setMarkTypeStates($from, $to, schema, toolbarState);\n        }\n        else {\n            toolbarState[type] = { active: true };\n        }\n    });\n    return toolbarState;\n}\nfunction toolbarStateHighlight(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view: function () {\n            return {\n                update: function (view) {\n                    var _a = view.state, selection = _a.selection, doc = _a.doc, schema = _a.schema;\n                    eventEmitter.emit('changeToolbarState', {\n                        toolbarState: getToolbarState(selection, doc, schema),\n                    });\n                },\n            };\n        },\n    });\n}\n\nvar CustomBlockView = /** @class */ (function () {\n    function CustomBlockView(node, view, getPos, toDOMAdaptor) {\n        var _this = this;\n        this.openEditor = function () {\n            if (_this.innerEditorView) {\n                throw new Error('The editor is already opened.');\n            }\n            _this.dom.draggable = false;\n            _this.wrapper.style.display = 'none';\n            _this.innerViewContainer.style.display = 'block';\n            _this.innerEditorView = new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(_this.innerViewContainer, {\n                state: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n                    doc: _this.node,\n                    plugins: [\n                        (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)({\n                            'Mod-z': function () { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },\n                            'Shift-Mod-z': function () { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.redo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },\n                            Tab: function (state, dispatch) {\n                                dispatch(state.tr.insertText('\\t'));\n                                return true;\n                            },\n                            Enter: prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.newlineInCode,\n                            Escape: function () {\n                                _this.cancelEditing();\n                                return true;\n                            },\n                            'Ctrl-Enter': function () {\n                                _this.saveAndFinishEditing();\n                                return true;\n                            },\n                        }),\n                        (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.history)(),\n                    ],\n                }),\n                dispatchTransaction: function (tr) { return _this.dispatchInner(tr); },\n                handleDOMEvents: {\n                    mousedown: function () {\n                        if (_this.editorView.hasFocus()) {\n                            _this.innerEditorView.focus();\n                        }\n                        return true;\n                    },\n                    blur: function () {\n                        _this.saveAndFinishEditing();\n                        return true;\n                    },\n                },\n            });\n            _this.innerEditorView.focus();\n        };\n        this.node = node;\n        this.editorView = view;\n        this.getPos = getPos;\n        this.toDOMAdaptor = toDOMAdaptor;\n        this.innerEditorView = null;\n        this.canceled = false;\n        this.dom = document.createElement('div');\n        this.dom.className = cls('custom-block');\n        this.wrapper = document.createElement('div');\n        this.wrapper.className = cls('custom-block-view');\n        this.createInnerViewContainer();\n        this.renderCustomBlock();\n        this.dom.appendChild(this.innerViewContainer);\n        this.dom.appendChild(this.wrapper);\n    }\n    CustomBlockView.prototype.renderToolArea = function () {\n        var _this = this;\n        var tool = document.createElement('div');\n        var span = document.createElement('span');\n        var button = document.createElement('button');\n        tool.className = 'tool';\n        span.textContent = this.node.attrs.info;\n        span.className = 'info';\n        button.type = 'button';\n        button.addEventListener('click', function () { return _this.openEditor(); });\n        tool.appendChild(span);\n        tool.appendChild(button);\n        this.wrapper.appendChild(tool);\n    };\n    CustomBlockView.prototype.renderCustomBlock = function () {\n        var toDOMNode = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);\n        if (toDOMNode) {\n            var node = toDOMNode(this.node);\n            while (this.wrapper.hasChildNodes()) {\n                this.wrapper.removeChild(this.wrapper.lastChild);\n            }\n            if (node) {\n                this.wrapper.appendChild(node);\n            }\n            this.renderToolArea();\n        }\n    };\n    CustomBlockView.prototype.createInnerViewContainer = function () {\n        this.innerViewContainer = document.createElement('div');\n        this.innerViewContainer.className = cls('custom-block-editor');\n        this.innerViewContainer.style.display = 'none';\n    };\n    CustomBlockView.prototype.closeEditor = function () {\n        if (this.innerEditorView) {\n            this.innerEditorView.destroy();\n            this.innerEditorView = null;\n            this.innerViewContainer.style.display = 'none';\n        }\n        this.wrapper.style.display = 'block';\n    };\n    CustomBlockView.prototype.saveAndFinishEditing = function () {\n        var to = this.editorView.state.selection.to;\n        var outerState = this.editorView.state;\n        this.editorView.dispatch(outerState.tr.setSelection(createTextSelection(outerState.tr, to)));\n        this.editorView.focus();\n        this.renderCustomBlock();\n        this.closeEditor();\n    };\n    CustomBlockView.prototype.cancelEditing = function () {\n        var undoableCount = (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undoDepth)(this.innerEditorView.state);\n        this.canceled = true;\n        // should undo editing result\n        // eslint-disable-next-line no-plusplus\n        while (undoableCount--) {\n            (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(this.innerEditorView.state, this.innerEditorView.dispatch);\n            (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(this.editorView.state, this.editorView.dispatch);\n        }\n        this.canceled = false;\n        var to = this.editorView.state.selection.to;\n        var outerState = this.editorView.state;\n        this.editorView.dispatch(outerState.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(outerState.doc, to)));\n        this.editorView.focus();\n        this.closeEditor();\n    };\n    CustomBlockView.prototype.dispatchInner = function (tr) {\n        var _a = this.innerEditorView.state.applyTransaction(tr), state = _a.state, transactions = _a.transactions;\n        this.innerEditorView.updateState(state);\n        if (!this.canceled && isFunction_1(this.getPos)) {\n            var outerTr = this.editorView.state.tr;\n            var offsetMap = prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.StepMap.offset(this.getPos() + 1);\n            for (var i = 0; i < transactions.length; i += 1) {\n                var steps = transactions[i].steps;\n                for (var j = 0; j < steps.length; j += 1) {\n                    outerTr.step(steps[j].map(offsetMap));\n                }\n            }\n            if (outerTr.docChanged) {\n                this.editorView.dispatch(outerTr);\n            }\n        }\n    };\n    CustomBlockView.prototype.update = function (node) {\n        if (!node.sameMarkup(this.node)) {\n            return false;\n        }\n        this.node = node;\n        if (!this.innerEditorView) {\n            this.renderCustomBlock();\n        }\n        return true;\n    };\n    CustomBlockView.prototype.stopEvent = function (event) {\n        return (!!this.innerEditorView &&\n            !!event.target &&\n            this.innerEditorView.dom.contains(event.target));\n    };\n    CustomBlockView.prototype.ignoreMutation = function () {\n        return true;\n    };\n    CustomBlockView.prototype.destroy = function () {\n        this.dom.removeEventListener('dblclick', this.openEditor);\n        this.closeEditor();\n    };\n    return CustomBlockView;\n}());\n\nvar IMAGE_LINK_CLASS_NAME = 'image-link';\nvar ImageView = /** @class */ (function () {\n    function ImageView(node, view, getPos, eventEmitter) {\n        var _this = this;\n        var _a;\n        this.handleMousedown = function (ev) {\n            ev.preventDefault();\n            var target = ev.target, offsetX = ev.offsetX, offsetY = ev.offsetY;\n            if (_this.imageLink &&\n                isFunction_1(_this.getPos) &&\n                hasClass_1(target, IMAGE_LINK_CLASS_NAME)) {\n                var style = getComputedStyle(target, ':before');\n                ev.stopPropagation();\n                if (isPositionInBox(style, offsetX, offsetY)) {\n                    var tr = _this.view.state.tr;\n                    var pos = _this.getPos();\n                    tr.setSelection(createTextSelection(tr, pos, pos + 1));\n                    _this.view.dispatch(tr);\n                    _this.eventEmitter.emit('openPopup', 'link', _this.imageLink.attrs);\n                }\n            }\n        };\n        this.node = node;\n        this.view = view;\n        this.getPos = getPos;\n        this.eventEmitter = eventEmitter;\n        this.imageLink = (_a = node.marks.filter(function (_a) {\n            var type = _a.type;\n            return type.name === 'link';\n        })[0]) !== null && _a !== void 0 ? _a : null;\n        this.dom = this.createElement();\n        this.bindEvent();\n    }\n    ImageView.prototype.createElement = function () {\n        var image = this.createImageElement(this.node);\n        if (this.imageLink) {\n            var wrapper = document.createElement('span');\n            wrapper.className = IMAGE_LINK_CLASS_NAME;\n            wrapper.appendChild(image);\n            return wrapper;\n        }\n        return image;\n    };\n    ImageView.prototype.createImageElement = function (node) {\n        var image = document.createElement('img');\n        var _a = node.attrs, imageUrl = _a.imageUrl, altText = _a.altText;\n        var attrs = getCustomAttrs(node.attrs);\n        image.src = imageUrl;\n        if (altText) {\n            image.alt = altText;\n        }\n        setAttributes(attrs, image);\n        return image;\n    };\n    ImageView.prototype.bindEvent = function () {\n        if (this.imageLink) {\n            this.dom.addEventListener('mousedown', this.handleMousedown);\n        }\n    };\n    ImageView.prototype.stopEvent = function () {\n        return true;\n    };\n    ImageView.prototype.destroy = function () {\n        if (this.imageLink) {\n            this.dom.removeEventListener('mousedown', this.handleMousedown);\n        }\n    };\n    return ImageView;\n}());\n\nvar WRAPPER_CLASS_NAME = 'toastui-editor-ww-code-block';\nvar CODE_BLOCK_LANG_CLASS_NAME = 'toastui-editor-ww-code-block-language';\nvar CodeBlockView = /** @class */ (function () {\n    function CodeBlockView(node, view, getPos, eventEmitter) {\n        var _this = this;\n        this.contentDOM = null;\n        this.input = null;\n        this.timer = null;\n        this.handleMousedown = function (ev) {\n            var target = ev.target;\n            var style = getComputedStyle(target, ':after');\n            // judge to click pseudo element with background image for IE11\n            if (style.backgroundImage !== 'none' && isFunction_1(_this.getPos)) {\n                var _a = _this.view.coordsAtPos(_this.getPos()), top_1 = _a.top, right = _a.right;\n                _this.createLanguageEditor({ top: top_1, right: right });\n            }\n        };\n        this.handleKeydown = function (ev) {\n            if (ev.key === 'Enter' && _this.input) {\n                ev.preventDefault();\n                _this.changeLanguage();\n            }\n        };\n        this.node = node;\n        this.view = view;\n        this.getPos = getPos;\n        this.eventEmitter = eventEmitter;\n        this.createElement();\n        this.bindDOMEvent();\n        this.bindEvent();\n    }\n    CodeBlockView.prototype.createElement = function () {\n        var language = this.node.attrs.language;\n        var wrapper = document.createElement('div');\n        wrapper.setAttribute('data-language', language || 'text');\n        wrapper.className = WRAPPER_CLASS_NAME;\n        var pre = this.createCodeBlockElement();\n        var code = pre.firstChild;\n        wrapper.appendChild(pre);\n        this.dom = wrapper;\n        this.contentDOM = code;\n    };\n    CodeBlockView.prototype.createCodeBlockElement = function () {\n        var pre = document.createElement('pre');\n        var code = document.createElement('code');\n        var language = this.node.attrs.language;\n        var attrs = getCustomAttrs(this.node.attrs);\n        if (language) {\n            code.setAttribute('data-language', language);\n        }\n        setAttributes(attrs, pre);\n        pre.appendChild(code);\n        return pre;\n    };\n    CodeBlockView.prototype.createLanguageEditor = function (_a) {\n        var _this = this;\n        var top = _a.top, right = _a.right;\n        var wrapper = document.createElement('span');\n        wrapper.className = CODE_BLOCK_LANG_CLASS_NAME;\n        var input = document.createElement('input');\n        input.type = 'text';\n        input.value = this.node.attrs.language;\n        wrapper.appendChild(input);\n        this.view.dom.parentElement.appendChild(wrapper);\n        var wrpperWidth = wrapper.clientWidth;\n        css_1(wrapper, {\n            top: top + 10 + \"px\",\n            left: right - wrpperWidth - 10 + \"px\",\n            width: wrpperWidth + \"px\",\n        });\n        this.input = input;\n        this.input.addEventListener('blur', function () { return _this.changeLanguage(); });\n        this.input.addEventListener('keydown', this.handleKeydown);\n        this.clearTimer();\n        this.timer = setTimeout(function () {\n            _this.input.focus();\n        });\n    };\n    CodeBlockView.prototype.bindDOMEvent = function () {\n        if (this.dom) {\n            this.dom.addEventListener('click', this.handleMousedown);\n        }\n    };\n    CodeBlockView.prototype.bindEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen('scroll', function () {\n            if (_this.input) {\n                _this.reset();\n            }\n        });\n    };\n    CodeBlockView.prototype.changeLanguage = function () {\n        if (this.input && isFunction_1(this.getPos)) {\n            var value = this.input.value;\n            this.reset();\n            var pos = this.getPos();\n            var tr = this.view.state.tr;\n            tr.setNodeMarkup(pos, null, { language: value });\n            this.view.dispatch(tr);\n        }\n    };\n    CodeBlockView.prototype.reset = function () {\n        var _a;\n        if ((_a = this.input) === null || _a === void 0 ? void 0 : _a.parentElement) {\n            var parent_1 = this.input.parentElement;\n            this.input = null;\n            removeNode$1(parent_1);\n        }\n    };\n    CodeBlockView.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    CodeBlockView.prototype.stopEvent = function () {\n        return true;\n    };\n    CodeBlockView.prototype.update = function (node) {\n        if (!node.sameMarkup(this.node)) {\n            return false;\n        }\n        this.node = node;\n        return true;\n    };\n    CodeBlockView.prototype.destroy = function () {\n        this.reset();\n        this.clearTimer();\n        if (this.dom) {\n            this.dom.removeEventListener('click', this.handleMousedown);\n        }\n    };\n    return CodeBlockView;\n}());\n\nvar reMSOListClassName = /MsoListParagraph/;\nvar reMSOStylePrefix = /style=(.|\\n)*mso-/;\nvar reMSOListStyle = /mso-list:(.*)/;\nvar reMSOTagName = /O:P/;\nvar reMSOListBullet = /^(n|u|l)/;\nvar MSO_CLASS_NAME_LIST_PARA = 'p.MsoListParagraph';\nfunction isFromMso(html) {\n    return reMSOStylePrefix.test(html);\n}\nfunction getListItemContents(para) {\n    var removedNodes = [];\n    var walker = document.createTreeWalker(para, 1, null, false);\n    while (walker.nextNode()) {\n        var node = walker.currentNode;\n        if (isElemNode(node)) {\n            var _a = node, outerHTML = _a.outerHTML, textContent = _a.textContent;\n            var msoSpan = reMSOStylePrefix.test(outerHTML);\n            var bulletSpan = reMSOListStyle.test(outerHTML);\n            if (msoSpan && !bulletSpan && textContent) {\n                removedNodes.push([node, true]);\n            }\n            else if (reMSOTagName.test(node.nodeName) || (msoSpan && !textContent) || bulletSpan) {\n                removedNodes.push([node, false]);\n            }\n        }\n    }\n    removedNodes.forEach(function (_a) {\n        var node = _a[0], isUnwrap = _a[1];\n        if (isUnwrap) {\n            unwrapNode(node);\n        }\n        else {\n            removeNode$1(node);\n        }\n    });\n    return para.innerHTML.trim();\n}\nfunction createListItemDataFromParagraph(para, index) {\n    var styleAttr = para.getAttribute('style');\n    if (styleAttr) {\n        var _a = styleAttr.match(reMSOListStyle), listItemInfo = _a[1];\n        var _b = listItemInfo.trim().split(' '), levelStr = _b[1];\n        var level = parseInt(levelStr.replace('level', ''), 10);\n        var unordered = reMSOListBullet.test(para.textContent || '');\n        return {\n            id: index,\n            level: level,\n            prev: null,\n            parent: null,\n            children: [],\n            unordered: unordered,\n            contents: getListItemContents(para),\n        };\n    }\n    return null;\n}\nfunction addListItemDetailData(data, prevData) {\n    if (prevData.level < data.level) {\n        prevData.children.push(data);\n        data.parent = prevData;\n    }\n    else {\n        while (prevData) {\n            if (prevData.level === data.level) {\n                break;\n            }\n            prevData = prevData.parent;\n        }\n        if (prevData) {\n            data.prev = prevData;\n            data.parent = prevData.parent;\n            if (data.parent) {\n                data.parent.children.push(data);\n            }\n        }\n    }\n}\nfunction createListData(paras) {\n    var listData = [];\n    paras.forEach(function (para, index) {\n        var prevListItemData = listData[index - 1];\n        var listItemData = createListItemDataFromParagraph(para, index);\n        if (listItemData) {\n            if (prevListItemData) {\n                addListItemDetailData(listItemData, prevListItemData);\n            }\n            listData.push(listItemData);\n        }\n    });\n    return listData;\n}\nfunction makeList(listData) {\n    var listTagName = listData[0].unordered ? 'ul' : 'ol';\n    var list = document.createElement(listTagName);\n    listData.forEach(function (data) {\n        var children = data.children, contents = data.contents;\n        var listItem = document.createElement('li');\n        listItem.innerHTML = contents;\n        list.appendChild(listItem);\n        if (children.length) {\n            list.appendChild(makeList(children));\n        }\n    });\n    return list;\n}\nfunction makeListFromParagraphs(paras) {\n    var listData = createListData(paras);\n    var rootChildren = listData.filter(function (_a) {\n        var parent = _a.parent;\n        return !parent;\n    });\n    return makeList(rootChildren);\n}\nfunction isMsoListParagraphEnd(node) {\n    while (node) {\n        if (isElemNode(node)) {\n            break;\n        }\n        node = node.nextSibling;\n    }\n    return node ? !reMSOListClassName.test(node.className) : true;\n}\nfunction convertMsoParagraphsToList(html) {\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    var paras = [];\n    var foundParas = findNodes(container, MSO_CLASS_NAME_LIST_PARA);\n    foundParas.forEach(function (para) {\n        var msoListParaEnd = isMsoListParagraphEnd(para.nextSibling);\n        paras.push(para);\n        if (msoListParaEnd) {\n            var list = makeListFromParagraphs(paras);\n            var nextSibling = para.nextSibling;\n            if (nextSibling) {\n                insertBeforeNode(list, nextSibling);\n            }\n            else {\n                appendNodes(container, list);\n            }\n            paras = [];\n        }\n        removeNode$1(para);\n    });\n    // without `<p></p>`, the list string was parsed as a paragraph node and added\n    var extraHTML = foundParas.length ? '<p></p>' : '';\n    return \"\" + extraHTML + container.innerHTML;\n}\n\nvar START_FRAGMENT_COMMENT = '<!--StartFragment-->';\nvar END_FRAGMENT_COMMENT = '<!--EndFragment-->';\nfunction getContentBetweenFragmentComments(html) {\n    var startFragmentIndex = html.indexOf(START_FRAGMENT_COMMENT);\n    var endFragmentIndex = html.lastIndexOf(END_FRAGMENT_COMMENT);\n    if (startFragmentIndex > -1 && endFragmentIndex > -1) {\n        html = html.slice(startFragmentIndex + START_FRAGMENT_COMMENT.length, endFragmentIndex);\n    }\n    return html.replace(/<br[^>]*>/g, ALTERNATIVE_TAG_FOR_BR);\n}\nfunction convertMsoTableToCompletedTable(html) {\n    // wrap with <tr> if html contains dangling <td> tags\n    // dangling <td> tag is that tag does not have <tr> as parent node\n    if (/<\\/td>((?!<\\/tr>)[\\s\\S])*$/i.test(html)) {\n        html = \"<tr>\" + html + \"</tr>\";\n    }\n    // wrap with <table> if html contains dangling <tr> tags\n    // dangling <tr> tag is that tag does not have <table> as parent node\n    if (/<\\/tr>((?!<\\/table>)[\\s\\S])*$/i.test(html)) {\n        html = \"<table>\" + html + \"</table>\";\n    }\n    return html;\n}\nfunction changePastedHTML(html) {\n    html = getContentBetweenFragmentComments(html);\n    html = convertMsoTableToCompletedTable(html);\n    if (isFromMso(html)) {\n        html = convertMsoParagraphsToList(html);\n    }\n    return html;\n}\nfunction getMaxColumnCount(rows) {\n    var row = rows.reduce(function (prevRow, currentRow) {\n        return prevRow.childCount > currentRow.childCount ? prevRow : currentRow;\n    });\n    return row.childCount;\n}\nfunction createCells(orgRow, maxColumnCount, cell) {\n    var cells = [];\n    var cellCount = orgRow.childCount;\n    for (var colIdx = 0; colIdx < cellCount; colIdx += 1) {\n        if (!orgRow.child(colIdx).attrs.extended) {\n            var copiedCell = colIdx < cellCount\n                ? cell.create(orgRow.child(colIdx).attrs, orgRow.child(colIdx).content)\n                : cell.createAndFill();\n            cells.push(copiedCell);\n        }\n    }\n    return cells;\n}\nfunction copyTableHeadRow(orgRow, maxColumnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell;\n    var cells = createCells(orgRow, maxColumnCount, tableHeadCell);\n    return tableRow.create(null, cells);\n}\nfunction copyTableBodyRow(orgRow, maxColumnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;\n    var cells = createCells(orgRow, maxColumnCount, tableBodyCell);\n    return tableRow.create(null, cells);\n}\nfunction creatTableBodyDummyRow(columnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;\n    var cells = [];\n    for (var columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {\n        var dummyCell = tableBodyCell.createAndFill();\n        cells.push(dummyCell);\n    }\n    return tableRow.create({ dummyRowForPasting: true }, cells);\n}\nfunction createRowsFromPastingTable(tableContent) {\n    var tableHeadRows = [];\n    var tableBodyRows = [];\n    if (tableContent.firstChild.type.name === 'tableHead') {\n        var tableHead = tableContent.firstChild;\n        tableHead.forEach(function (row) { return tableHeadRows.push(row); });\n    }\n    if (tableContent.lastChild.type.name === 'tableBody') {\n        var tableBody = tableContent.lastChild;\n        tableBody.forEach(function (row) { return tableBodyRows.push(row); });\n    }\n    return __spreadArray$1(__spreadArray$1([], tableHeadRows), tableBodyRows);\n}\nfunction createTableHead(tableHeadRow, maxColumnCount, schema) {\n    var copiedRow = copyTableHeadRow(tableHeadRow, maxColumnCount, schema);\n    return schema.nodes.tableHead.create(null, copiedRow);\n}\nfunction createTableBody(tableBodyRows, maxColumnCount, schema) {\n    var copiedRows = tableBodyRows.map(function (tableBodyRow) {\n        return copyTableBodyRow(tableBodyRow, maxColumnCount, schema);\n    });\n    if (!tableBodyRows.length) {\n        var dummyTableRow = creatTableBodyDummyRow(maxColumnCount, schema);\n        copiedRows.push(dummyTableRow);\n    }\n    return schema.nodes.tableBody.create(null, copiedRows);\n}\nfunction createTableFromPastingTable(rows, schema, startFromBody, isInTable) {\n    var columnCount = getMaxColumnCount(rows);\n    if (startFromBody && isInTable) {\n        return schema.nodes.table.create(null, [createTableBody(rows, columnCount, schema)]);\n    }\n    var tableHeadRow = rows[0];\n    var tableBodyRows = rows.slice(1);\n    var nodes = [createTableHead(tableHeadRow, columnCount, schema)];\n    if (tableBodyRows.length) {\n        nodes.push(createTableBody(tableBodyRows, columnCount, schema));\n    }\n    return schema.nodes.table.create(null, nodes);\n}\nfunction changePastedSlice(slice, schema, isInTable) {\n    var nodes = [];\n    var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;\n    content.forEach(function (node) {\n        if (node.type.name === 'table') {\n            var tableContent = getTableContentFromSlice(new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), 0, 0));\n            if (tableContent) {\n                var rows = createRowsFromPastingTable(tableContent);\n                var startFromBody = tableContent.firstChild.type.name === 'tableBody';\n                var table = createTableFromPastingTable(rows, schema, startFromBody, isInTable);\n                nodes.push(table);\n            }\n        }\n        else {\n            nodes.push(node);\n        }\n    });\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nodes), openStart, openEnd);\n}\n\nvar DUMMY_CELL_SIZE = 4;\nvar TR_NODES_SIZE = 2;\nfunction getDummyCellSize(dummyCellCount) {\n    return dummyCellCount * DUMMY_CELL_SIZE;\n}\nfunction createPastingCells(tableContent, curSelectionInfo, schema) {\n    var pastingRows = [];\n    var pastingTableRows = createRowsFromPastingTable(tableContent);\n    var columnCount = pastingTableRows[0].childCount;\n    var rowCount = pastingTableRows.length;\n    var startToTableHead = curSelectionInfo.startRowIdx === 0;\n    var slicedRows = pastingTableRows.slice(0, rowCount);\n    if (startToTableHead) {\n        var tableHeadRow = slicedRows.shift();\n        if (tableHeadRow) {\n            var content = copyTableHeadRow(tableHeadRow, columnCount, schema).content;\n            pastingRows.push(content);\n        }\n    }\n    slicedRows.forEach(function (tableBodyRow) {\n        if (!tableBodyRow.attrs.dummyRowForPasting) {\n            var content = copyTableBodyRow(tableBodyRow, columnCount, schema).content;\n            pastingRows.push(content);\n        }\n    });\n    return pastingRows;\n}\nfunction getPastingRangeInfo(map, _a, pastingCells) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx;\n    var pastingRowCount = pastingCells.length;\n    var pastingColumnCount = 0;\n    var _loop_1 = function (i) {\n        var columnCount = pastingCells[i].childCount;\n        pastingCells[i].forEach(function (_a) {\n            var attrs = _a.attrs;\n            var colspan = attrs.colspan;\n            if (colspan > 1) {\n                columnCount += colspan - 1;\n            }\n        });\n        pastingColumnCount = Math.max(pastingColumnCount, columnCount);\n    };\n    for (var i = 0; i < pastingRowCount; i += 1) {\n        _loop_1(i);\n    }\n    var endRowIdx = startRowIdx + pastingRowCount - 1;\n    var endColIdx = startColIdx + pastingColumnCount - 1;\n    var addedRowCount = Math.max(endRowIdx + 1 - map.totalRowCount, 0);\n    var addedColumnCount = Math.max(endColIdx + 1 - map.totalColumnCount, 0);\n    return {\n        startRowIdx: startRowIdx,\n        startColIdx: startColIdx,\n        endRowIdx: endRowIdx,\n        endColIdx: endColIdx,\n        addedRowCount: addedRowCount,\n        addedColumnCount: addedColumnCount,\n    };\n}\nfunction addReplacedOffsets(_a, cellsOffsets) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;\n    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx - addedRowCount; rowIdx += 1) {\n        cellsOffsets.push({\n            rowIdx: rowIdx,\n            startColIdx: startColIdx,\n            endColIdx: endColIdx - addedColumnCount,\n        });\n    }\n}\nfunction expandColumns(tr, schema, map, _a, cellsOffsets) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;\n    var totalRowCount = map.totalRowCount;\n    var index = 0;\n    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n        var _b = map.getCellInfo(rowIdx, endColIdx - addedColumnCount), offset = _b.offset, nodeSize = _b.nodeSize;\n        var insertOffset = tr.mapping.map(offset + nodeSize);\n        var cells = createDummyCells(addedColumnCount, rowIdx, schema);\n        tr.insert(insertOffset, cells);\n        if (rowIdx >= startRowIdx && rowIdx <= endRowIdx - addedRowCount) {\n            var cellInfo = map.getCellInfo(rowIdx, endColIdx - addedColumnCount);\n            var startCellOffset = tr.mapping.map(cellInfo.offset);\n            var endCellOffset = insertOffset + getDummyCellSize(addedColumnCount);\n            cellsOffsets[index] = {\n                rowIdx: rowIdx,\n                startColIdx: startColIdx,\n                endColIdx: endColIdx,\n                dummyOffsets: [startCellOffset, endCellOffset],\n            };\n            index += 1;\n        }\n    }\n}\nfunction expandRows(tr, schema, map, _a, cellsOffsets) {\n    var addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount, startColIdx = _a.startColIdx, endColIdx = _a.endColIdx;\n    var mapStart = tr.mapping.maps.length;\n    var tableEndPos = map.tableEndOffset - 2;\n    var rows = createTableBodyRows(addedRowCount, map.totalColumnCount + addedColumnCount, schema);\n    var startOffset = tableEndPos;\n    tr.insert(tr.mapping.slice(mapStart).map(startOffset), rows);\n    for (var rowIndex = 0; rowIndex < addedRowCount; rowIndex += 1) {\n        var startCellOffset = startOffset + getDummyCellSize(startColIdx) + 1;\n        var endCellOffset = startOffset + getDummyCellSize(endColIdx + 1) + 1;\n        var nextCellOffset = startOffset + getDummyCellSize(map.totalColumnCount + addedColumnCount) + TR_NODES_SIZE;\n        cellsOffsets.push({\n            rowIdx: rowIndex + map.totalRowCount,\n            startColIdx: startColIdx,\n            endColIdx: endColIdx,\n            dummyOffsets: [startCellOffset, endCellOffset],\n        });\n        startOffset = nextCellOffset;\n    }\n}\nfunction replaceCells(tr, pastingRows, cellsOffsets, map) {\n    var mapStart = tr.mapping.maps.length;\n    cellsOffsets.forEach(function (offsets, index) {\n        var rowIdx = offsets.rowIdx, startColIdx = offsets.startColIdx, endColIdx = offsets.endColIdx, dummyOffsets = offsets.dummyOffsets;\n        var mapping = tr.mapping.slice(mapStart);\n        var cells = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(pastingRows[index], 0, 0);\n        var from = dummyOffsets ? dummyOffsets[0] : map.getCellStartOffset(rowIdx, startColIdx);\n        var to = dummyOffsets ? dummyOffsets[1] : map.getCellEndOffset(rowIdx, endColIdx);\n        tr.replace(mapping.map(from), mapping.map(to), cells);\n    });\n}\nfunction pasteToTable(view, slice) {\n    var _a = view.state, selection = _a.selection, schema = _a.schema, tr = _a.tr;\n    var _b = getResolvedSelection(selection), anchor = _b.anchor, head = _b.head;\n    if (anchor && head) {\n        var tableContent = getTableContentFromSlice(slice);\n        if (!tableContent) {\n            return false;\n        }\n        var map = TableOffsetMap.create(anchor);\n        var curSelectionInfo = map.getRectOffsets(anchor, head);\n        var pastingCells = createPastingCells(tableContent, curSelectionInfo, schema);\n        var pastingInfo = getPastingRangeInfo(map, curSelectionInfo, pastingCells);\n        var cellsOffsets = [];\n        // @TODO: unmerge the span and paste the cell\n        if (canMerge(map, pastingInfo)) {\n            addReplacedOffsets(pastingInfo, cellsOffsets);\n            if (pastingInfo.addedColumnCount) {\n                expandColumns(tr, schema, map, pastingInfo, cellsOffsets);\n            }\n            if (pastingInfo.addedRowCount) {\n                expandRows(tr, schema, map, pastingInfo, cellsOffsets);\n            }\n            replaceCells(tr, pastingCells, cellsOffsets, map);\n            view.dispatch(tr);\n            setSelection(view, cellsOffsets, map.getCellInfo(0, 0).offset);\n        }\n        return true;\n    }\n    return false;\n}\nfunction setSelection(view, cellsOffsets, pos) {\n    var _a = view.state, tr = _a.tr, doc = _a.doc;\n    // get changed cell offsets\n    var map = TableOffsetMap.create(doc.resolve(pos));\n    // eslint-disable-next-line prefer-destructuring\n    var _b = cellsOffsets[0], startRowIdx = _b.rowIdx, startColIdx = _b.startColIdx;\n    var _c = last$1(cellsOffsets), endRowIdx = _c.rowIdx, endColIdx = _c.endColIdx;\n    var startOffset = map.getCellInfo(startRowIdx, startColIdx).offset;\n    var endOffset = map.getCellInfo(endRowIdx, endColIdx).offset;\n    view.dispatch(tr.setSelection(new CellSelection(doc.resolve(startOffset), doc.resolve(endOffset))));\n}\nfunction canMerge(map, pastingInfo) {\n    var ranges = map.getSpannedOffsets(pastingInfo);\n    var _a = getRowAndColumnCount(ranges), rowCount = _a.rowCount, columnCount = _a.columnCount;\n    var _b = getRowAndColumnCount(pastingInfo), pastingRowCount = _b.rowCount, pastingColumnCount = _b.columnCount;\n    return rowCount === pastingRowCount && columnCount === pastingColumnCount;\n}\n\nvar Doc = /** @class */ (function (_super) {\n    __extends$1(Doc, _super);\n    function Doc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Doc.prototype, \"name\", {\n        get: function () {\n            return 'doc';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Doc.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'block+',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Doc;\n}(Node$2));\n\nvar Paragraph = /** @class */ (function (_super) {\n    __extends$1(Paragraph, _super);\n    function Paragraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Paragraph.prototype, \"name\", {\n        get: function () {\n            return 'paragraph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Paragraph.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'inline*',\n                group: 'block',\n                attrs: __assign$1({}, getDefaultCustomAttrs()),\n                parseDOM: [{ tag: 'p' }],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['p', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Paragraph;\n}(Node$2));\n\nvar reSoftTabLen = /\\s{1,4}$/;\nvar Text = /** @class */ (function (_super) {\n    __extends$1(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Text.prototype, \"name\", {\n        get: function () {\n            return 'text';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"schema\", {\n        get: function () {\n            return {\n                group: 'inline',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Text.prototype.addSpaces = function () {\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var $from = selection.$from, $to = selection.$to;\n            var range = $from.blockRange($to);\n            if (range && !isInListNode($from) && !isInTableNode($from)) {\n                dispatch(tr.insertText('    ', $from.pos, $to.pos));\n                return true;\n            }\n            return false;\n        };\n    };\n    Text.prototype.removeSpaces = function () {\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var $from = selection.$from, $to = selection.$to, from = selection.from;\n            var range = $from.blockRange($to);\n            if (range && !isInListNode($from) && !isInTableNode($from)) {\n                var nodeBefore = $from.nodeBefore;\n                if (nodeBefore && nodeBefore.isText) {\n                    var text = nodeBefore.text;\n                    var removedSpaceText = text.replace(reSoftTabLen, '');\n                    var spaces = text.length - removedSpaceText.length;\n                    dispatch(tr.delete(from - spaces, from));\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Text.prototype.keymaps = function () {\n        return {\n            Tab: this.addSpaces(),\n            'Shift-Tab': this.removeSpaces(),\n        };\n    };\n    return Text;\n}(Node$2));\n\nvar Heading = /** @class */ (function (_super) {\n    __extends$1(Heading, _super);\n    function Heading() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Heading.prototype, \"name\", {\n        get: function () {\n            return 'heading';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, \"levels\", {\n        get: function () {\n            return [1, 2, 3, 4, 5, 6];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = this.levels.map(function (level) {\n                return {\n                    tag: \"h\" + level,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({ level: level }, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ level: { default: 1 }, headingType: { default: 'atx' }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                content: 'inline*',\n                group: 'block',\n                defining: true,\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\"h\" + attrs.level, getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Heading.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            var nodeType = state.schema.nodes[payload.level ? 'heading' : 'paragraph'];\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(nodeType, payload)(state, dispatch);\n        }; };\n    };\n    return Heading;\n}(Node$2));\n\nvar CodeBlock = /** @class */ (function (_super) {\n    __extends$1(CodeBlock, _super);\n    function CodeBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CodeBlock.prototype, \"name\", {\n        get: function () {\n            return 'codeBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CodeBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                attrs: __assign$1({ language: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                code: true,\n                defining: true,\n                marks: '',\n                parseDOM: [\n                    {\n                        tag: 'pre',\n                        preserveWhitespace: 'full',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            var child = dom.firstElementChild;\n                            return __assign$1({ language: (child === null || child === void 0 ? void 0 : child.getAttribute('data-language')) || null }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'pre',\n                        ['code', __assign$1({ 'data-language': attrs.language }, getCustomAttrs(attrs)), 0],\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CodeBlock.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(state.schema.nodes.codeBlock)(state, dispatch); }; };\n    };\n    CodeBlock.prototype.moveCursor = function (direction) {\n        var _this = this;\n        return function (state, dispatch) {\n            var tr = state.tr, doc = state.doc, schema = state.schema;\n            var $from = state.selection.$from;\n            var view = _this.context.view;\n            if (view.endOfTextblock(direction) && $from.node().type.name === 'codeBlock') {\n                var lines = $from.parent.textContent.split('\\n');\n                var offset = direction === 'up' ? $from.start() : $from.end();\n                var range = direction === 'up'\n                    ? [offset, lines[0].length + offset]\n                    : [offset - last$1(lines).length, offset];\n                var pos = doc.resolve(direction === 'up' ? $from.before() : $from.after());\n                var node = direction === 'up' ? pos.nodeBefore : pos.nodeAfter;\n                if (between$1($from.pos, range[0], range[1]) && !node) {\n                    var newTr = addParagraph(tr, pos, schema);\n                    if (newTr) {\n                        dispatch(newTr);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n    };\n    CodeBlock.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return {\n            'Shift-Mod-p': codeCommand,\n            'Shift-Mod-P': codeCommand,\n            ArrowUp: this.moveCursor('up'),\n            ArrowDown: this.moveCursor('down'),\n        };\n    };\n    return CodeBlock;\n}(Node$2));\n\nvar BulletList = /** @class */ (function (_super) {\n    __extends$1(BulletList, _super);\n    function BulletList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BulletList.prototype, \"name\", {\n        get: function () {\n            return 'bulletList';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BulletList.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'listItem+',\n                group: 'block',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML('ul')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['ul', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BulletList.prototype.changeList = function () {\n        return function (state, dispatch) { return changeList(state.schema.nodes.bulletList)(state, dispatch); };\n    };\n    BulletList.prototype.commands = function () {\n        return {\n            bulletList: this.changeList,\n            taskList: toggleTask,\n        };\n    };\n    BulletList.prototype.keymaps = function () {\n        var bulletListCommand = this.changeList();\n        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;\n        return {\n            'Mod-u': bulletListCommand,\n            'Mod-U': bulletListCommand,\n            Tab: indent(),\n            'Shift-Tab': outdent(),\n        };\n    };\n    return BulletList;\n}(Node$2));\n\nvar OrderedList = /** @class */ (function (_super) {\n    __extends$1(OrderedList, _super);\n    function OrderedList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(OrderedList.prototype, \"name\", {\n        get: function () {\n            return 'orderedList';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OrderedList.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'listItem+',\n                group: 'block',\n                attrs: __assign$1({ order: { default: 1 }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'ol',\n                        getAttrs: function (dom) {\n                            var start = dom.getAttribute('start');\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            return __assign$1({ order: dom.hasAttribute('start') ? Number(start) : 1 }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'ol',\n                        __assign$1({ start: attrs.order === 1 ? null : attrs.order }, getCustomAttrs(attrs)),\n                        0,\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    OrderedList.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return changeList(state.schema.nodes.orderedList)(state, dispatch); }; };\n    };\n    OrderedList.prototype.keymaps = function () {\n        var orderedListCommand = this.commands()();\n        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;\n        return {\n            'Mod-o': orderedListCommand,\n            'Mod-O': orderedListCommand,\n            Tab: indent(),\n            'Shift-Tab': outdent(),\n        };\n    };\n    return OrderedList;\n}(Node$2));\n\nvar ListItem = /** @class */ (function (_super) {\n    __extends$1(ListItem, _super);\n    function ListItem() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ListItem.prototype, \"name\", {\n        get: function () {\n            return 'listItem';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ListItem.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'paragraph block*',\n                selectable: false,\n                attrs: {\n                    task: { default: false },\n                    checked: { default: false },\n                    rawHTML: { default: null },\n                },\n                defining: true,\n                parseDOM: [\n                    {\n                        tag: 'li',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            return __assign$1({ task: dom.hasAttribute('data-task'), checked: dom.hasAttribute('data-task-checked') }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var task = attrs.task, checked = attrs.checked;\n                    if (!task) {\n                        return [attrs.rawHTML || 'li', 0];\n                    }\n                    var classNames = ['task-list-item'];\n                    if (checked) {\n                        classNames.push('checked');\n                    }\n                    return [\n                        attrs.rawHTML || 'li',\n                        __assign$1({ class: classNames.join(' '), 'data-task': task }, (checked && { 'data-task-checked': checked })),\n                        0,\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ListItem.prototype.liftToPrevListItem = function () {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var $from = selection.$from, empty = selection.empty;\n            var listItem = schema.nodes.listItem;\n            var parent = $from.parent;\n            var listItemParent = $from.node(-1);\n            if (empty && !parent.childCount && listItemParent.type === listItem) {\n                // move to previous sibling list item when the current list item is not top list item\n                if ($from.index(-2) >= 1) {\n                    // should subtract '1' for considering tag length(<li>)\n                    tr.delete($from.start(-1) - 1, $from.end(-1));\n                    dispatch(tr);\n                    return true;\n                }\n                var grandParentListItem = $from.node(-3);\n                // move to parent list item when the current list item is top list item\n                if (grandParentListItem.type === listItem) {\n                    // should subtract '1' for considering tag length(<ul>)\n                    tr.delete($from.start(-2) - 1, $from.end(-1));\n                    dispatch(tr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    ListItem.prototype.keymaps = function () {\n        var split = function (state, dispatch) {\n            return splitListItem(state.schema.nodes.listItem)(state, dispatch);\n        };\n        return {\n            Backspace: this.liftToPrevListItem(),\n            Enter: split,\n        };\n    };\n    return ListItem;\n}(Node$2));\n\nvar BlockQuote = /** @class */ (function (_super) {\n    __extends$1(BlockQuote, _super);\n    function BlockQuote() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BlockQuote.prototype, \"name\", {\n        get: function () {\n            return 'blockQuote';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BlockQuote.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                content: 'block+',\n                group: 'block',\n                parseDOM: [createDOMInfoParsedRawHTML('blockquote')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['blockquote', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BlockQuote.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.wrapIn)(state.schema.nodes.blockQuote)(state, dispatch); }; };\n    };\n    BlockQuote.prototype.keymaps = function () {\n        var blockQutoeCommand = this.commands()();\n        return {\n            'Alt-q': blockQutoeCommand,\n            'Alt-Q': blockQutoeCommand,\n        };\n    };\n    return BlockQuote;\n}(Node$2));\n\nvar cellOffsetFnMap = {\n    left: getLeftCellOffset,\n    right: getRightCellOffset,\n    up: getUpCellOffset,\n    down: getDownCellOffset,\n};\nfunction isInFirstListItem(pos, doc, _a) {\n    var paraDepth = _a[0], listDepth = _a[1];\n    var listItemNode = doc.resolve(pos.before(paraDepth - 1));\n    return listDepth === paraDepth && !listItemNode.nodeBefore;\n}\nfunction isInLastListItem(pos) {\n    var _a;\n    var depth = pos.depth;\n    var parentNode;\n    while (depth) {\n        parentNode = pos.node(depth);\n        if (parentNode.type.name === 'tableBodyCell') {\n            break;\n        }\n        if (parentNode.type.name === 'listItem') {\n            var grandParent = pos.node(depth - 1);\n            var lastListItem = grandParent.lastChild === parentNode;\n            var hasChildren = ((_a = parentNode.lastChild) === null || _a === void 0 ? void 0 : _a.type.name) !== 'paragraph';\n            if (!lastListItem) {\n                return false;\n            }\n            return !hasChildren;\n        }\n        depth -= 1;\n    }\n    return false;\n}\nfunction canMoveToBeforeCell(direction, _a, from, doc, inList) {\n    var paraDepth = _a[0], listDepth = _a[1], curDepth = _a[2];\n    if (direction === \"left\" /* LEFT */ || direction === \"up\" /* UP */) {\n        if (inList && !isInFirstListItem(from, doc, [paraDepth, listDepth])) {\n            return false;\n        }\n        var endOffset = from.before(curDepth);\n        var nodeBefore = doc.resolve(endOffset).nodeBefore;\n        if (nodeBefore) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canMoveToAfterCell(direction, curDepth, from, doc, inList) {\n    if (direction === \"right\" /* RIGHT */ || direction === \"down\" /* DOWN */) {\n        if (inList && !isInLastListItem(from)) {\n            return false;\n        }\n        var endOffset = from.after(curDepth);\n        var nodeAfter = doc.resolve(endOffset).nodeAfter;\n        if (nodeAfter) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canMoveBetweenCells(direction, _a, from, doc) {\n    var cellDepth = _a[0], paraDepth = _a[1];\n    var listDepth = cellDepth + 3; // 3 is position of <ul><li><p>\n    var inList = paraDepth >= listDepth;\n    var curDepth = inList ? cellDepth + 1 : paraDepth;\n    var moveBeforeCell = canMoveToBeforeCell(direction, [paraDepth, listDepth, curDepth], from, doc, inList);\n    var moveAfterCell = canMoveToAfterCell(direction, curDepth, from, doc, inList);\n    return moveBeforeCell && moveAfterCell;\n}\nfunction canBeOutOfTable(direction, map, _a) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);\n    var inFirstRow = direction === \"up\" /* UP */ && rowIdx === 0;\n    var inLastRow = direction === \"down\" /* DOWN */ &&\n        ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1 ? rowIdx + rowspanInfo.count - 1 : rowIdx) === map.totalRowCount - 1;\n    return inFirstRow || inLastRow;\n}\nfunction addParagraphBeforeTable(tr, map, schema) {\n    var tableStartPos = tr.doc.resolve(map.tableStartOffset - 1);\n    if (!tableStartPos.nodeBefore) {\n        return addParagraph(tr, tableStartPos, schema);\n    }\n    return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tableStartPos, -1));\n}\nfunction addParagraphAfterTable(tr, map, schema, forcedAddtion) {\n    if (forcedAddtion === void 0) { forcedAddtion = false; }\n    var tableEndPos = tr.doc.resolve(map.tableEndOffset);\n    if (forcedAddtion || !tableEndPos.nodeAfter) {\n        return addParagraph(tr, tableEndPos, schema);\n    }\n    return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tableEndPos, 1));\n}\nfunction getRightCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;\n    var lastCellInRow = colIdx === totalColumnCount - 1;\n    var lastCellInTable = rowIdx === totalRowCount - 1 && lastCellInRow;\n    if (!lastCellInTable) {\n        var nextColIdx = colIdx + 1;\n        var colspanInfo = map.getColspanStartInfo(rowIdx, colIdx);\n        if ((colspanInfo === null || colspanInfo === void 0 ? void 0 : colspanInfo.count) > 1) {\n            nextColIdx += colspanInfo.count - 1;\n        }\n        if (lastCellInRow || nextColIdx === totalColumnCount) {\n            rowIdx += 1;\n            nextColIdx = 0;\n        }\n        var offset = map.getCellInfo(rowIdx, nextColIdx).offset;\n        return offset + 2;\n    }\n    return null;\n}\nfunction getLeftCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalColumnCount = map.totalColumnCount;\n    var firstCellInRow = colIdx === 0;\n    var firstCellInTable = rowIdx === 0 && firstCellInRow;\n    if (!firstCellInTable) {\n        colIdx -= 1;\n        if (firstCellInRow) {\n            rowIdx -= 1;\n            colIdx = totalColumnCount - 1;\n        }\n        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n        return offset + nodeSize - 2;\n    }\n    return null;\n}\nfunction getUpCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    if (rowIdx > 0) {\n        var _b = map.getCellInfo(rowIdx - 1, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n        return offset + nodeSize - 2;\n    }\n    return null;\n}\nfunction getDownCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalRowCount = map.totalRowCount;\n    if (rowIdx < totalRowCount - 1) {\n        var nextRowIdx = rowIdx + 1;\n        var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);\n        if ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1) {\n            nextRowIdx += rowspanInfo.count - 1;\n        }\n        var offset = map.getCellInfo(nextRowIdx, colIdx).offset;\n        return offset + 2;\n    }\n    return null;\n}\nfunction moveToCell(direction, tr, cellIndex, map) {\n    var cellOffsetFn = cellOffsetFnMap[direction];\n    var offset = cellOffsetFn(cellIndex, map);\n    if (offset) {\n        var dir = direction === \"right\" /* RIGHT */ || direction === \"down\" /* DOWN */ ? 1 : -1;\n        return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(offset), dir));\n    }\n    return null;\n}\nfunction canSelectTableNode(direction, map, _a) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    if (direction === \"up\" /* UP */ || direction === \"down\" /* DOWN */) {\n        return false;\n    }\n    var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;\n    var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n    var pos = direction === \"left\" /* LEFT */ ? tableStartOffset : tableEndOffset;\n    var curPos = direction === \"left\" /* LEFT */ ? offset - 2 : offset + nodeSize + 3;\n    return pos === curPos;\n}\nfunction selectNode(tr, pos, depth) {\n    var tablePos = tr.doc.resolve(pos.before(depth - 3));\n    return tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(tablePos));\n}\n\nfunction getTargetRowInfo(direction, map, selectionInfo) {\n    var targetRowIdx;\n    var insertColIdx;\n    var nodeSize;\n    if (direction === \"up\" /* UP */) {\n        targetRowIdx = selectionInfo.startRowIdx;\n        insertColIdx = 0;\n        nodeSize = -1;\n    }\n    else {\n        targetRowIdx = selectionInfo.endRowIdx;\n        insertColIdx = map.totalColumnCount - 1;\n        nodeSize = map.getCellInfo(targetRowIdx, insertColIdx).nodeSize + 1;\n    }\n    return { targetRowIdx: targetRowIdx, insertColIdx: insertColIdx, nodeSize: nodeSize };\n}\nfunction getRowRanges(map, rowIdx, totalColumnCount) {\n    var startOffset = map.getCellInfo(rowIdx, 0).offset;\n    var _a = map.getCellInfo(rowIdx, totalColumnCount - 1), offset = _a.offset, nodeSize = _a.nodeSize;\n    return { from: startOffset, to: offset + nodeSize };\n}\nvar Table = /** @class */ (function (_super) {\n    __extends$1(Table, _super);\n    function Table() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Table.prototype, \"name\", {\n        get: function () {\n            return 'table';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Table.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'tableHead{1} tableBody{1}',\n                group: 'block',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML('table')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['table', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Table.prototype.addTable = function () {\n        return function (payload) {\n            if (payload === void 0) { payload = { rowCount: 2, columnCount: 1, data: [] }; }\n            return function (state, dispatch) {\n                var rowCount = payload.rowCount, columnCount = payload.columnCount, data = payload.data;\n                var schema = state.schema, selection = state.selection, tr = state.tr;\n                var from = selection.from, to = selection.to, $from = selection.$from;\n                var collapsed = from === to;\n                if (collapsed && !isInTableNode($from)) {\n                    var _a = schema.nodes, tableHead = _a.tableHead, tableBody = _a.tableBody;\n                    var theadData = data === null || data === void 0 ? void 0 : data.slice(0, columnCount);\n                    var tbodyData = data === null || data === void 0 ? void 0 : data.slice(columnCount, data.length);\n                    var tableHeadRow = createTableHeadRow(columnCount, schema, theadData);\n                    var tableBodyRows = createTableBodyRows(rowCount - 1, columnCount, schema, tbodyData);\n                    var table = schema.nodes.table.create(null, [\n                        tableHead.create(null, tableHeadRow),\n                        tableBody.create(null, tableBodyRows),\n                    ]);\n                    dispatch(tr.replaceSelectionWith(table));\n                    return true;\n                }\n                return false;\n            };\n        };\n    };\n    Table.prototype.removeTable = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var map = TableOffsetMap.create(selection.$anchor);\n            if (map) {\n                var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;\n                var startOffset = tableStartOffset - 1;\n                var cursorPos = createTextSelection(tr.delete(startOffset, tableEndOffset), startOffset);\n                dispatch(tr.setSelection(cursorPos));\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.addColumn = function (direction) {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var targetColIdx = direction === \"left\" /* LEFT */ ? selectionInfo.startColIdx : selectionInfo.endColIdx + 1;\n                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;\n                var totalRowCount = map.totalRowCount;\n                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                    var cells = createDummyCells(columnCount, rowIdx, schema);\n                    tr.insert(tr.mapping.map(map.posAt(rowIdx, targetColIdx)), cells);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.removeColumn = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var totalColumnCount = map.totalColumnCount, totalRowCount = map.totalRowCount;\n                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;\n                var selectedAllColumn = columnCount === totalColumnCount;\n                if (selectedAllColumn) {\n                    return false;\n                }\n                var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;\n                var mapStart = tr.mapping.maps.length;\n                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                    for (var colIdx = endColIdx; colIdx >= startColIdx; colIdx -= 1) {\n                        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n                        var from = tr.mapping.slice(mapStart).map(offset);\n                        var to = from + nodeSize;\n                        tr.delete(from, to);\n                    }\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.addRow = function (direction) {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var totalColumnCount = map.totalColumnCount;\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;\n                var _b = getTargetRowInfo(direction, map, selectionInfo), targetRowIdx = _b.targetRowIdx, insertColIdx = _b.insertColIdx, nodeSize = _b.nodeSize;\n                var selectedThead = targetRowIdx === 0;\n                if (!selectedThead) {\n                    var rows = [];\n                    var from = tr.mapping.map(map.posAt(targetRowIdx, insertColIdx)) + nodeSize;\n                    var cells = [];\n                    for (var colIdx = 0; colIdx < totalColumnCount; colIdx += 1) {\n                        cells = cells.concat(createDummyCells(1, targetRowIdx, schema));\n                    }\n                    for (var i = 0; i < rowCount; i += 1) {\n                        rows.push(schema.nodes.tableRow.create(null, cells));\n                    }\n                    dispatch(tr.insert(from, rows));\n                    return true;\n                }\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.removeRow = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;\n                var startRowIdx = selectionInfo.startRowIdx, endRowIdx = selectionInfo.endRowIdx;\n                var selectedThead = startRowIdx === 0;\n                var selectedAllTbodyRow = rowCount === totalRowCount - 1;\n                if (selectedAllTbodyRow || selectedThead) {\n                    return false;\n                }\n                for (var rowIdx = endRowIdx; rowIdx >= startRowIdx; rowIdx -= 1) {\n                    var _b = getRowRanges(map, rowIdx, totalColumnCount), from = _b.from, to = _b.to;\n                    // delete table row\n                    tr.delete(from - 1, to + 1);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.alignColumn = function () {\n        return function (payload) {\n            if (payload === void 0) { payload = { align: 'center' }; }\n            return function (state, dispatch) {\n                var align = payload.align;\n                var selection = state.selection, tr = state.tr;\n                var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n                if (anchor && head) {\n                    var map = TableOffsetMap.create(anchor);\n                    var totalRowCount = map.totalRowCount;\n                    var selectionInfo = map.getRectOffsets(anchor, head);\n                    var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;\n                    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                            if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {\n                                var _b = map.getNodeAndPos(rowIdx, colIdx), node = _b.node, pos = _b.pos;\n                                var attrs = setAttrs(node, { align: align });\n                                tr.setNodeMarkup(pos, null, attrs);\n                            }\n                        }\n                    }\n                    dispatch(tr);\n                    return true;\n                }\n                return false;\n            };\n        };\n    };\n    Table.prototype.moveToCell = function (direction) {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var cellIndex = map.getCellIndex(anchor);\n                var newTr = void 0;\n                if (canBeOutOfTable(direction, map, cellIndex)) {\n                    // When there is no content before or after the table,\n                    // an empty line('paragraph') is created by pressing the arrow keys.\n                    newTr = addParagraphAfterTable(tr, map, schema);\n                }\n                else {\n                    newTr = moveToCell(direction, tr, cellIndex, map);\n                }\n                if (newTr) {\n                    dispatch(newTr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.moveInCell = function (direction) {\n        var _this = this;\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, doc = state.doc, schema = state.schema;\n            var $from = selection.$from;\n            var view = _this.context.view;\n            if (!view.endOfTextblock(direction)) {\n                return false;\n            }\n            var cell = findNodeBy($from, function (_a) {\n                var type = _a.type;\n                return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n            });\n            if (cell) {\n                var para = findNodeBy($from, function (_a) {\n                    var type = _a.type;\n                    return type.name === 'paragraph';\n                });\n                var cellDepth = cell.depth;\n                if (para && canMoveBetweenCells(direction, [cellDepth, para.depth], $from, doc)) {\n                    var anchor = getResolvedSelection(selection).anchor;\n                    var map = TableOffsetMap.create(anchor);\n                    var cellIndex = map.getCellIndex(anchor);\n                    var newTr = void 0;\n                    if (canSelectTableNode(direction, map, cellIndex)) {\n                        // When the cursor position is at the end of the cell,\n                        // the table is selected when the left / right arrow keys are pressed.\n                        newTr = selectNode(tr, $from, cellDepth);\n                    }\n                    else if (canBeOutOfTable(direction, map, cellIndex)) {\n                        // When there is no content before or after the table,\n                        // an empty line('paragraph') is created by pressing the arrow keys.\n                        if (direction === \"up\" /* UP */) {\n                            newTr = addParagraphBeforeTable(tr, map, schema);\n                        }\n                        else if (direction === \"down\" /* DOWN */) {\n                            newTr = addParagraphAfterTable(tr, map, schema);\n                        }\n                    }\n                    else {\n                        newTr = moveToCell(direction, tr, cellIndex, map);\n                    }\n                    if (newTr) {\n                        dispatch(newTr);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.deleteCells = function () {\n        return function (state, dispatch) {\n            var schema = state.schema, selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            var textSelection = selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n            if (anchor && head && !textSelection) {\n                var map = TableOffsetMap.create(anchor);\n                var _b = map.getRectOffsets(anchor, head), startRowIdx = _b.startRowIdx, startColIdx = _b.startColIdx, endRowIdx = _b.endRowIdx, endColIdx = _b.endColIdx;\n                for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n                    for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                        if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {\n                            var _c = map.getNodeAndPos(rowIdx, colIdx), node = _c.node, pos = _c.pos;\n                            var cells = createDummyCells(1, rowIdx, schema, node.attrs);\n                            tr.replaceWith(tr.mapping.map(pos), tr.mapping.map(pos + node.nodeSize), cells);\n                        }\n                    }\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.exitTable = function () {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var $from = selection.$from;\n            var cell = findNodeBy($from, function (_a) {\n                var type = _a.type;\n                return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n            });\n            if (cell) {\n                var para = findNodeBy($from, function (_a) {\n                    var type = _a.type;\n                    return type.name === 'paragraph';\n                });\n                if (para) {\n                    var anchor = getResolvedSelection(selection).anchor;\n                    var map = TableOffsetMap.create(anchor);\n                    dispatch(addParagraphAfterTable(tr, map, schema, true));\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.commands = function () {\n        return {\n            addTable: this.addTable(),\n            removeTable: this.removeTable(),\n            addColumnToLeft: this.addColumn(\"left\" /* LEFT */),\n            addColumnToRight: this.addColumn(\"right\" /* RIGHT */),\n            removeColumn: this.removeColumn(),\n            addRowToUp: this.addRow(\"up\" /* UP */),\n            addRowToDown: this.addRow(\"down\" /* DOWN */),\n            removeRow: this.removeRow(),\n            alignColumn: this.alignColumn(),\n        };\n    };\n    Table.prototype.keymaps = function () {\n        var deleteCellContent = this.deleteCells();\n        return {\n            Tab: this.moveToCell(\"right\" /* RIGHT */),\n            'Shift-Tab': this.moveToCell(\"left\" /* LEFT */),\n            ArrowUp: this.moveInCell(\"up\" /* UP */),\n            ArrowDown: this.moveInCell(\"down\" /* DOWN */),\n            ArrowLeft: this.moveInCell(\"left\" /* LEFT */),\n            ArrowRight: this.moveInCell(\"right\" /* RIGHT */),\n            Backspace: deleteCellContent,\n            'Mod-Backspace': deleteCellContent,\n            Delete: deleteCellContent,\n            'Mod-Delete': deleteCellContent,\n            'Mod-Enter': this.exitTable(),\n        };\n    };\n    return Table;\n}(Node$2));\n\nvar TableHead = /** @class */ (function (_super) {\n    __extends$1(TableHead, _super);\n    function TableHead() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableHead.prototype, \"name\", {\n        get: function () {\n            return 'tableHead';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableHead.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'tableRow{1}',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML('thead')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['thead', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableHead;\n}(Node$2));\n\nvar TableBody = /** @class */ (function (_super) {\n    __extends$1(TableBody, _super);\n    function TableBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableBody.prototype, \"name\", {\n        get: function () {\n            return 'tableBody';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableBody.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'tableRow+',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'tbody',\n                        getAttrs: function (dom) {\n                            var rows = dom.querySelectorAll('tr');\n                            var columns = rows[0].children.length;\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            if (!columns) {\n                                return false;\n                            }\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['tbody', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableBody;\n}(Node$2));\n\nvar TableRow = /** @class */ (function (_super) {\n    __extends$1(TableRow, _super);\n    function TableRow() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableRow.prototype, \"name\", {\n        get: function () {\n            return 'tableRow';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableRow.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: '(tableHeadCell | tableBodyCell)*',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'tr',\n                        getAttrs: function (dom) {\n                            var columns = dom.children.length;\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            if (!columns) {\n                                return false;\n                            }\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['tr', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableRow;\n}(Node$2));\n\nvar TableHeadCell = /** @class */ (function (_super) {\n    __extends$1(TableHeadCell, _super);\n    function TableHeadCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableHeadCell.prototype, \"name\", {\n        get: function () {\n            return 'tableHeadCell';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableHeadCell.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'paragraph+',\n                attrs: __assign$1({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, getDefaultCustomAttrs()),\n                isolating: true,\n                parseDOM: [createParsedCellDOM('th')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var cellAttrs = createCellAttrs(attrs);\n                    return ['th', __assign$1(__assign$1({}, cellAttrs), getCustomAttrs(attrs)), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableHeadCell;\n}(Node$2));\n\nvar TableBodyCell = /** @class */ (function (_super) {\n    __extends$1(TableBodyCell, _super);\n    function TableBodyCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableBodyCell.prototype, \"name\", {\n        get: function () {\n            return 'tableBodyCell';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableBodyCell.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: '(paragraph | bulletList | orderedList)+',\n                attrs: {\n                    align: { default: null },\n                    className: { default: null },\n                    rawHTML: { default: null },\n                    colspan: { default: null },\n                    rowspan: { default: null },\n                    extended: { default: null },\n                },\n                isolating: true,\n                parseDOM: [createParsedCellDOM('td')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var cellAttrs = createCellAttrs(attrs);\n                    return ['td', cellAttrs, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableBodyCell;\n}(Node$2));\n\nvar Image = /** @class */ (function (_super) {\n    __extends$1(Image, _super);\n    function Image() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Image.prototype, \"name\", {\n        get: function () {\n            return 'image';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Image.prototype, \"schema\", {\n        get: function () {\n            return {\n                inline: true,\n                attrs: __assign$1({ imageUrl: { default: '' }, altText: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                group: 'inline',\n                selectable: false,\n                parseDOM: [\n                    {\n                        tag: 'img[src]',\n                        getAttrs: function (dom) {\n                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })\n                                .firstChild;\n                            var imageUrl = sanitizedDOM.getAttribute('src') || '';\n                            var rawHTML = sanitizedDOM.getAttribute('data-raw-html');\n                            var altText = sanitizedDOM.getAttribute('alt');\n                            return __assign$1({ imageUrl: imageUrl,\n                                altText: altText }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'img',\n                        __assign$1(__assign$1({ src: escapeXml$1(attrs.imageUrl) }, (attrs.altText && { alt: attrs.altText })), getCustomAttrs(attrs)),\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Image.prototype.addImage = function () {\n        return function (payload) { return function (_a, dispatch) {\n            var schema = _a.schema, tr = _a.tr;\n            var _b = payload, imageUrl = _b.imageUrl, altText = _b.altText;\n            if (!imageUrl) {\n                return false;\n            }\n            var node = schema.nodes.image.createAndFill(__assign$1({ imageUrl: imageUrl }, (altText && { altText: altText })));\n            dispatch(tr.replaceSelectionWith(node).scrollIntoView());\n            return true;\n        }; };\n    };\n    Image.prototype.commands = function () {\n        return {\n            addImage: this.addImage(),\n        };\n    };\n    return Image;\n}(Node$2));\n\nvar ROOT_BLOCK_DEPTH = 1;\nvar ThematicBreak = /** @class */ (function (_super) {\n    __extends$1(ThematicBreak, _super);\n    function ThematicBreak() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ThematicBreak.prototype, \"name\", {\n        get: function () {\n            return 'thematicBreak';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThematicBreak.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                group: 'block',\n                parseDOM: [{ tag: 'hr' }],\n                selectable: false,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['div', getCustomAttrs(attrs), [attrs.rawHTML || 'hr']];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ThematicBreak.prototype.hr = function () {\n        var _this = this;\n        return function () { return function (state, dispatch) {\n            var _a;\n            var _b = state.selection, $from = _b.$from, $to = _b.$to;\n            if ($from === $to) {\n                var doc = state.doc;\n                var _c = state.schema.nodes, thematicBreak = _c.thematicBreak, paragraph = _c.paragraph;\n                var nodes = [thematicBreak.create()];\n                var rootBlock = $from.node(ROOT_BLOCK_DEPTH);\n                var lastBlock = doc.child(doc.childCount - 1) === rootBlock;\n                var blockEnd = doc.resolve($from.after(ROOT_BLOCK_DEPTH));\n                var nextHr = ((_a = $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.type.name) === _this.name;\n                if (lastBlock || nextHr) {\n                    nodes.push(paragraph.create());\n                }\n                dispatch(state.tr.insert(blockEnd.pos, nodes).scrollIntoView());\n                return true;\n            }\n            return false;\n        }; };\n    };\n    ThematicBreak.prototype.commands = function () {\n        return { hr: this.hr() };\n    };\n    ThematicBreak.prototype.keymaps = function () {\n        var hrCommand = this.hr()();\n        return {\n            'Mod-l': hrCommand,\n            'Mod-L': hrCommand,\n        };\n    };\n    return ThematicBreak;\n}(Node$2));\n\nvar Strong = /** @class */ (function (_super) {\n    __extends$1(Strong, _super);\n    function Strong() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strong.prototype, \"name\", {\n        get: function () {\n            return 'strong';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strong.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = ['b', 'strong'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'strong', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strong.prototype.bold = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.strong)(state, dispatch); }; };\n    };\n    Strong.prototype.commands = function () {\n        return { bold: this.bold() };\n    };\n    Strong.prototype.keymaps = function () {\n        var boldCommand = this.bold()();\n        return {\n            'Mod-b': boldCommand,\n            'Mod-B': boldCommand,\n        };\n    };\n    return Strong;\n}(Mark));\n\nvar Emph = /** @class */ (function (_super) {\n    __extends$1(Emph, _super);\n    function Emph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Emph.prototype, \"name\", {\n        get: function () {\n            return 'emph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Emph.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = ['i', 'em'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'em', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Emph.prototype.italic = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.emph)(state, dispatch); }; };\n    };\n    Emph.prototype.commands = function () {\n        return { italic: this.italic() };\n    };\n    Emph.prototype.keymaps = function () {\n        var italicCommand = this.italic()();\n        return {\n            'Mod-i': italicCommand,\n            'Mod-I': italicCommand,\n        };\n    };\n    return Emph;\n}(Mark));\n\nvar Strike = /** @class */ (function (_super) {\n    __extends$1(Strike, _super);\n    function Strike() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strike.prototype, \"name\", {\n        get: function () {\n            return 'strike';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strike.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = ['s', 'del'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'del', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strike.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.strike)(state, dispatch); }; };\n    };\n    Strike.prototype.keymaps = function () {\n        var strikeCommand = this.commands()();\n        return {\n            'Mod-s': strikeCommand,\n            'Mod-S': strikeCommand,\n        };\n    };\n    return Strike;\n}(Mark));\n\nvar Link = /** @class */ (function (_super) {\n    __extends$1(Link, _super);\n    function Link(linkAttributes) {\n        var _this = _super.call(this) || this;\n        _this.linkAttributes = linkAttributes;\n        return _this;\n    }\n    Object.defineProperty(Link.prototype, \"name\", {\n        get: function () {\n            return 'link';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Link.prototype, \"schema\", {\n        get: function () {\n            var _this = this;\n            return {\n                attrs: __assign$1({ linkUrl: { default: '' }, title: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                inclusive: false,\n                parseDOM: [\n                    {\n                        tag: 'a[href]',\n                        getAttrs: function (dom) {\n                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })\n                                .firstChild;\n                            var href = sanitizedDOM.getAttribute('href') || '';\n                            var title = sanitizedDOM.getAttribute('title') || '';\n                            var rawHTML = sanitizedDOM.getAttribute('data-raw-html');\n                            return __assign$1({ linkUrl: href, title: title }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'a',\n                        __assign$1(__assign$1({ href: escapeXml$1(attrs.linkUrl) }, _this.linkAttributes), getCustomAttrs(attrs)),\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Link.prototype.addLink = function () {\n        return function (payload) { return function (state, dispatch) {\n            var _a = payload, linkUrl = _a.linkUrl, _b = _a.linkText, linkText = _b === void 0 ? '' : _b;\n            var schema = state.schema, tr = state.tr, selection = state.selection;\n            var empty = selection.empty, from = selection.from, to = selection.to;\n            if (from && to && linkUrl) {\n                var attrs = { linkUrl: linkUrl };\n                var mark = schema.mark('link', attrs);\n                if (empty && linkText) {\n                    var node = createTextNode$1(schema, linkText, mark);\n                    tr.replaceRangeWith(from, to, node);\n                }\n                else {\n                    tr.addMark(from, to, mark);\n                }\n                dispatch(tr.scrollIntoView());\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Link.prototype.toggleLink = function () {\n        return function (payload) { return function (state, dispatch) {\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.link, payload)(state, dispatch);\n        }; };\n    };\n    Link.prototype.commands = function () {\n        return {\n            addLink: this.addLink(),\n            toggleLink: this.toggleLink(),\n        };\n    };\n    return Link;\n}(Mark));\n\nvar Code = /** @class */ (function (_super) {\n    __extends$1(Code, _super);\n    function Code() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Code.prototype, \"name\", {\n        get: function () {\n            return 'code';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Code.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'code',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'code', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Code.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.code)(state, dispatch); }; };\n    };\n    Code.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return {\n            'Shift-Mod-c': codeCommand,\n            'Shift-Mod-C': codeCommand,\n        };\n    };\n    return Code;\n}(Mark));\n\nvar CustomBlock = /** @class */ (function (_super) {\n    __extends$1(CustomBlock, _super);\n    function CustomBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CustomBlock.prototype, \"name\", {\n        get: function () {\n            return 'customBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                attrs: {\n                    info: { default: null },\n                },\n                atom: true,\n                code: true,\n                defining: true,\n                parseDOM: [\n                    {\n                        tag: 'div[data-custom-info]',\n                        getAttrs: function (dom) {\n                            var info = dom.getAttribute('data-custom-info');\n                            return { info: info };\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['div', { 'data-custom-info': attrs.info || null }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CustomBlock.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            return (payload === null || payload === void 0 ? void 0 : payload.info)\n                ? (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(state.schema.nodes.customBlock, payload)(state, dispatch)\n                : false;\n        }; };\n    };\n    return CustomBlock;\n}(Node$2));\n\nvar FrontMatter = /** @class */ (function (_super) {\n    __extends$1(FrontMatter, _super);\n    function FrontMatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(FrontMatter.prototype, \"name\", {\n        get: function () {\n            return 'frontMatter';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FrontMatter.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                code: true,\n                defining: true,\n                parseDOM: [\n                    {\n                        preserveWhitespace: 'full',\n                        tag: 'div[data-front-matter]',\n                    },\n                ],\n                toDOM: function () {\n                    return ['div', { 'data-front-matter': 'true' }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FrontMatter.prototype.commands = function () {\n        return function () { return function (state, dispatch, view) {\n            var $from = state.selection.$from;\n            if (view.endOfTextblock('down') && $from.node().type.name === 'frontMatter') {\n                return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode)(state, dispatch);\n            }\n            return false;\n        }; };\n    };\n    FrontMatter.prototype.keymaps = function () {\n        return {\n            Enter: this.commands()(),\n        };\n    };\n    return FrontMatter;\n}(Node$2));\n\nvar HTMLComment = /** @class */ (function (_super) {\n    __extends$1(HTMLComment, _super);\n    function HTMLComment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(HTMLComment.prototype, \"name\", {\n        get: function () {\n            return 'htmlComment';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(HTMLComment.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                code: true,\n                defining: true,\n                parseDOM: [{ preserveWhitespace: 'full', tag: 'div[data-html-comment]' }],\n                toDOM: function () {\n                    return ['div', { 'data-html-comment': 'true' }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    HTMLComment.prototype.commands = function () {\n        return function () { return function (state, dispatch, view) {\n            var $from = state.selection.$from;\n            if (view.endOfTextblock('down') && $from.node().type.name === 'htmlComment') {\n                return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode)(state, dispatch);\n            }\n            return false;\n        }; };\n    };\n    HTMLComment.prototype.keymaps = function () {\n        return {\n            Enter: this.commands()(),\n        };\n    };\n    return HTMLComment;\n}(Node$2));\n\nfunction createSpecs(linkAttributes) {\n    return new SpecManager([\n        new Doc(),\n        new Paragraph(),\n        new Text(),\n        new Heading(),\n        new CodeBlock(),\n        new BulletList(),\n        new OrderedList(),\n        new ListItem(),\n        new BlockQuote(),\n        new Table(),\n        new TableHead(),\n        new TableBody(),\n        new TableRow(),\n        new TableHeadCell(),\n        new TableBodyCell(),\n        new Image(),\n        new ThematicBreak(),\n        new Strong(),\n        new Emph(),\n        new Strike(),\n        new Link(linkAttributes),\n        new Code(),\n        new CustomBlock(),\n        new FrontMatter(),\n        new Widget(),\n        new HTMLComment(),\n    ]);\n}\n\nvar CONTENTS_CLASS_NAME = cls('contents');\nvar WysiwygEditor = /** @class */ (function (_super) {\n    __extends$1(WysiwygEditor, _super);\n    function WysiwygEditor(eventEmitter, options) {\n        var _this = _super.call(this, eventEmitter) || this;\n        var toDOMAdaptor = options.toDOMAdaptor, _a = options.htmlSchemaMap, htmlSchemaMap = _a === void 0 ? {} : _a, _b = options.linkAttributes, linkAttributes = _b === void 0 ? {} : _b, _c = options.useCommandShortcut, useCommandShortcut = _c === void 0 ? true : _c, _d = options.wwPlugins, wwPlugins = _d === void 0 ? [] : _d, _e = options.wwNodeViews, wwNodeViews = _e === void 0 ? {} : _e;\n        _this.editorType = 'wysiwyg';\n        _this.el.classList.add('ww-mode');\n        _this.toDOMAdaptor = toDOMAdaptor;\n        _this.linkAttributes = linkAttributes;\n        _this.extraPlugins = wwPlugins;\n        _this.pluginNodeViews = wwNodeViews;\n        _this.specs = _this.createSpecs();\n        _this.schema = _this.createSchema(htmlSchemaMap);\n        _this.context = _this.createContext();\n        _this.keymaps = _this.createKeymaps(useCommandShortcut);\n        _this.view = _this.createView();\n        _this.commands = _this.createCommands();\n        _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));\n        _this.initEvent();\n        return _this;\n    }\n    WysiwygEditor.prototype.createSpecs = function () {\n        return createSpecs(this.linkAttributes);\n    };\n    WysiwygEditor.prototype.createContext = function () {\n        return {\n            schema: this.schema,\n            eventEmitter: this.eventEmitter,\n        };\n    };\n    WysiwygEditor.prototype.createSchema = function (htmlSchemaMap) {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Schema({\n            nodes: __assign$1(__assign$1({}, this.specs.nodes), htmlSchemaMap.nodes),\n            marks: __assign$1(__assign$1({}, this.specs.marks), htmlSchemaMap.marks),\n        });\n    };\n    WysiwygEditor.prototype.createPlugins = function () {\n        return __spreadArray$1([\n            tableSelection(),\n            tableContextMenu(this.eventEmitter),\n            task(),\n            toolbarStateHighlight(this.eventEmitter)\n        ], this.createPluginProps()).concat(this.defaultPlugins);\n    };\n    WysiwygEditor.prototype.createPluginNodeViews = function () {\n        var _a = this, eventEmitter = _a.eventEmitter, pluginNodeViews = _a.pluginNodeViews;\n        var pluginNodeViewMap = {};\n        if (pluginNodeViews) {\n            Object.keys(pluginNodeViews).forEach(function (key) {\n                pluginNodeViewMap[key] = function (node, view, getPos) {\n                    return pluginNodeViews[key](node, view, getPos, eventEmitter);\n                };\n            });\n        }\n        return pluginNodeViewMap;\n    };\n    WysiwygEditor.prototype.createView = function () {\n        var _this = this;\n        var _a = this, toDOMAdaptor = _a.toDOMAdaptor, eventEmitter = _a.eventEmitter;\n        return new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(this.el, {\n            state: this.createState(),\n            attributes: {\n                class: CONTENTS_CLASS_NAME,\n            },\n            nodeViews: __assign$1({ customBlock: function (node, view, getPos) {\n                    return new CustomBlockView(node, view, getPos, toDOMAdaptor);\n                },\n                image: function (node, view, getPos) {\n                    return new ImageView(node, view, getPos, eventEmitter);\n                },\n                codeBlock: function (node, view, getPos) {\n                    return new CodeBlockView(node, view, getPos, eventEmitter);\n                }, widget: widgetNodeView }, this.createPluginNodeViews()),\n            dispatchTransaction: function (tr) {\n                var state = _this.view.state.applyTransaction(tr).state;\n                _this.view.updateState(state);\n                _this.emitChangeEvent(tr.scrollIntoView());\n                _this.eventEmitter.emit('setFocusedNode', state.selection.$from.node(1));\n            },\n            transformPastedHTML: changePastedHTML,\n            transformPasted: function (slice) {\n                return changePastedSlice(slice, _this.schema, isInTableNode(_this.view.state.selection.$from));\n            },\n            handlePaste: function (view, _, slice) { return pasteToTable(view, slice); },\n            handleKeyDown: function (_, ev) {\n                _this.eventEmitter.emit('keydown', _this.editorType, ev);\n                return false;\n            },\n            handleDOMEvents: {\n                paste: function (_, ev) {\n                    var clipboardData = ev.clipboardData || window.clipboardData;\n                    var items = clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.items;\n                    if (items) {\n                        var containRtfItem = toArray_1(items).some(function (item) { return item.kind === 'string' && item.type === 'text/rtf'; });\n                        // if it contains rtf, it's most likely copy paste from office -> no image\n                        if (!containRtfItem) {\n                            var imageBlob = pasteImageOnly(items);\n                            if (imageBlob) {\n                                ev.preventDefault();\n                                emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);\n                            }\n                        }\n                    }\n                    return false;\n                },\n                keyup: function (_, ev) {\n                    _this.eventEmitter.emit('keyup', _this.editorType, ev);\n                    return false;\n                },\n                scroll: function () {\n                    _this.eventEmitter.emit('scroll', 'editor');\n                    return true;\n                },\n            },\n        });\n    };\n    WysiwygEditor.prototype.createCommands = function () {\n        return this.specs.commands(this.view, getWwCommands());\n    };\n    WysiwygEditor.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.view.dom.innerHTML);\n    };\n    WysiwygEditor.prototype.getModel = function () {\n        return this.view.state.doc;\n    };\n    WysiwygEditor.prototype.getSelection = function () {\n        var _a = this.view.state.selection, from = _a.from, to = _a.to;\n        return [from, to];\n    };\n    WysiwygEditor.prototype.getSchema = function () {\n        return this.view.state.schema;\n    };\n    WysiwygEditor.prototype.replaceSelection = function (text, start, end) {\n        var _a = this.view.state, schema = _a.schema, tr = _a.tr;\n        var lineTexts = text.split('\\n');\n        var paras = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(paras), 1, 1);\n        var newTr = isNumber_1(start) && isNumber_1(end)\n            ? tr.replaceRange(start, end, slice)\n            : tr.replaceSelection(slice);\n        this.view.dispatch(newTr);\n        this.focus();\n    };\n    WysiwygEditor.prototype.deleteSelection = function (start, end) {\n        var tr = this.view.state.tr;\n        var newTr = isNumber_1(start) && isNumber_1(end) ? tr.deleteRange(start, end) : tr.deleteSelection();\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    WysiwygEditor.prototype.getSelectedText = function (start, end) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var from = selection.from, to = selection.to;\n        if (isNumber_1(start) && isNumber_1(end)) {\n            from = start;\n            to = end;\n        }\n        return doc.textBetween(from, to, '\\n');\n    };\n    WysiwygEditor.prototype.setModel = function (newDoc, cursorToEnd) {\n        if (cursorToEnd === void 0) { cursorToEnd = false; }\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc;\n        this.view.dispatch(tr.replaceWith(0, doc.content.size, newDoc));\n        if (cursorToEnd) {\n            this.moveCursorToEnd(true);\n        }\n    };\n    WysiwygEditor.prototype.setSelection = function (start, end) {\n        if (end === void 0) { end = start; }\n        var tr = this.view.state.tr;\n        var selection = createTextSelection(tr, start, end);\n        this.view.dispatch(tr.setSelection(selection).scrollIntoView());\n    };\n    WysiwygEditor.prototype.addWidget = function (node, style, pos) {\n        var _a = this.view, dispatch = _a.dispatch, state = _a.state;\n        dispatch(state.tr.setMeta('widget', { pos: pos !== null && pos !== void 0 ? pos : state.selection.to, node: node, style: style }));\n    };\n    WysiwygEditor.prototype.replaceWithWidget = function (start, end, text) {\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema;\n        var nodes = createNodesWithWidget(text, schema);\n        this.view.dispatch(tr.replaceWith(start, end, nodes));\n    };\n    WysiwygEditor.prototype.getRangeInfoOfNode = function (pos) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var $pos = pos ? doc.resolve(pos) : selection.$from;\n        var marks = $pos.marks();\n        var node = $pos.node();\n        var start = $pos.start();\n        var end = $pos.end();\n        var type = node.type.name;\n        if (marks.length || type === 'paragraph') {\n            var mark_1 = marks[marks.length - 1];\n            var maybeHasMark_1 = function (nodeMarks) {\n                return nodeMarks.length ? includes(nodeMarks, mark_1) : true;\n            };\n            type = mark_1 ? mark_1.type.name : 'text';\n            node.forEach(function (child, offset) {\n                var isText = child.isText, nodeSize = child.nodeSize, nodeMarks = child.marks;\n                var startOffset = $pos.pos - start;\n                if (isText &&\n                    offset <= startOffset &&\n                    offset + nodeSize >= startOffset &&\n                    maybeHasMark_1(nodeMarks)) {\n                    start = start + offset;\n                    end = start + nodeSize;\n                }\n            });\n        }\n        return { range: [start, end], type: type };\n    };\n    return WysiwygEditor;\n}(EditorBase));\n\n/**\n * @fileoverview Check whether the given variable is existing or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined = isUndefined_1;\nvar isNull = isNull_1;\n\n/**\n * Check whether the given variable is existing or not.\n * If the given variable is not null and not undefined, returns true.\n * @param {*} param - Target for checking\n * @returns {boolean} Is existy?\n * @memberof module:type\n * @example\n * // ES6\n * import isExisty from 'tui-code-snippet/type/isExisty');\n * \n * // CommonJS\n * const isExisty = require('tui-code-snippet/type/isExisty');\n *\n * isExisty(''); //true\n * isExisty(0); //true\n * isExisty([]); //true\n * isExisty({}); //true\n * isExisty(null); //false\n * isExisty(undefined); //false\n*/\nfunction isExisty$1(param) {\n  return !isUndefined(param) && !isNull(param);\n}\n\nvar isExisty_1 = isExisty$1;\n\n/**\n * @fileoverview Check whether the given variable is truthy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isExisty = isExisty_1;\n\n/**\n * Check whether the given variable is truthy or not.\n * If the given variable is not null or not undefined or not false, returns true.\n * (It regards 0 as true)\n * @param {*} obj - Target for checking\n * @returns {boolean} Is truthy?\n * @memberof module:type\n */\nfunction isTruthy$1(obj) {\n  return isExisty(obj) && obj !== false;\n}\n\nvar isTruthy_1 = isTruthy$1;\n\n/**\n * @fileoverview Check whether the given variable is falsy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isTruthy = isTruthy_1;\n\n/**\n * Check whether the given variable is falsy or not.\n * If the given variable is null or undefined or false, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is falsy?\n * @memberof module:type\n */\nfunction isFalsy(obj) {\n  return !isTruthy(obj);\n}\n\nvar isFalsy_1 = isFalsy;\n\nvar eventTypeList = [\n    'afterPreviewRender',\n    'updatePreview',\n    'changeMode',\n    'needChangeMode',\n    'command',\n    'changePreviewStyle',\n    'changePreviewTabPreview',\n    'changePreviewTabWrite',\n    'scroll',\n    'contextmenu',\n    'show',\n    'hide',\n    'changeLanguage',\n    'changeToolbarState',\n    'toggleScrollSync',\n    'mixinTableOffsetMapPrototype',\n    'setFocusedNode',\n    'removePopupWidget',\n    'query',\n    // provide event for user\n    'openPopup',\n    'closePopup',\n    'addImageBlobHook',\n    'beforePreviewRender',\n    'beforeConvertWysiwygToMarkdown',\n    'load',\n    'loadUI',\n    'change',\n    'caretChange',\n    'destroy',\n    'focus',\n    'blur',\n    'keydown',\n    'keyup',\n];\n/**\n * Class EventEmitter\n * @ignore\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        var _this = this;\n        this.events = new Map$1();\n        this.eventTypes = eventTypeList.reduce(function (types, type) {\n            return __assign$1(__assign$1({}, types), { type: type });\n        }, {});\n        this.hold = false;\n        eventTypeList.forEach(function (eventType) {\n            _this.addEventType(eventType);\n        });\n    }\n    /**\n     * Listen event and bind event handler\n     * @param {string} type Event type string\n     * @param {function} handler Event handler\n     */\n    EventEmitter.prototype.listen = function (type, handler) {\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type) || [];\n        if (!this.hasEventType(typeInfo.type)) {\n            throw new Error(\"There is no event type \" + typeInfo.type);\n        }\n        if (typeInfo.namespace) {\n            handler.namespace = typeInfo.namespace;\n        }\n        eventHandlers.push(handler);\n        this.events.set(typeInfo.type, eventHandlers);\n    };\n    /**\n     * Emit event\n     * @param {string} eventName Event name to emit\n     * @returns {Array}\n     */\n    EventEmitter.prototype.emit = function (type) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type);\n        var results = [];\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, args);\n                if (!isUndefined_1(result)) {\n                    results.push(result);\n                }\n            });\n        }\n        return results;\n    };\n    /**\n     * Emit given event and return result\n     * @param {string} eventName Event name to emit\n     * @param {any} source Source to change\n     * @returns {string}\n     */\n    EventEmitter.prototype.emitReduce = function (type, source) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var eventHandlers = this.events.get(type);\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, __spreadArray$1([source], args));\n                if (!isFalsy_1(result)) {\n                    source = result;\n                }\n            });\n        }\n        return source;\n    };\n    /**\n     * Get event type and namespace\n     * @param {string} type Event type name\n     * @returns {{type: string, namespace: string}}\n     * @private\n     */\n    EventEmitter.prototype.getTypeInfo = function (type) {\n        var splited = type.split('.');\n        return {\n            type: splited[0],\n            namespace: splited[1],\n        };\n    };\n    /**\n     * Check whether event type exists or not\n     * @param {string} type Event type name\n     * @returns {boolean}\n     * @private\n     */\n    EventEmitter.prototype.hasEventType = function (type) {\n        return !isUndefined_1(this.eventTypes[this.getTypeInfo(type).type]);\n    };\n    /**\n     * Add event type when given event not exists\n     * @param {string} type Event type name\n     */\n    EventEmitter.prototype.addEventType = function (type) {\n        if (this.hasEventType(type)) {\n            throw new Error(\"There is already have event type \" + type);\n        }\n        this.eventTypes[type] = type;\n    };\n    /**\n     * Remove event handler from given event type\n     * @param {string} eventType Event type name\n     * @param {function} [handler] - registered event handler\n     */\n    EventEmitter.prototype.removeEventHandler = function (eventType, handler) {\n        var _this = this;\n        var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;\n        if (type && handler) {\n            this.removeEventHandlerWithHandler(type, handler);\n        }\n        else if (type && !namespace) {\n            this.events.delete(type);\n        }\n        else if (!type && namespace) {\n            this.events.forEach(function (_, evtType) {\n                _this.removeEventHandlerWithTypeInfo(evtType, namespace);\n            });\n        }\n        else if (type && namespace) {\n            this.removeEventHandlerWithTypeInfo(type, namespace);\n        }\n    };\n    /**\n     * Remove event handler with event handler\n     * @param {string} type - event type name\n     * @param {function} handler - event handler\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithHandler = function (type, handler) {\n        var eventHandlers = this.events.get(type);\n        if (eventHandlers) {\n            var handlerIndex = eventHandlers.indexOf(handler);\n            if (eventHandlers.indexOf(handler) >= 0) {\n                eventHandlers.splice(handlerIndex, 1);\n            }\n        }\n    };\n    /**\n     * Remove event handler with event type information\n     * @param {string} type Event type name\n     * @param {string} namespace Event namespace\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithTypeInfo = function (type, namespace) {\n        var handlersToSurvive = [];\n        var eventHandlers = this.events.get(type);\n        if (!eventHandlers) {\n            return;\n        }\n        eventHandlers.map(function (handler) {\n            if (handler.namespace !== namespace) {\n                handlersToSurvive.push(handler);\n            }\n            return null;\n        });\n        this.events.set(type, handlersToSurvive);\n    };\n    EventEmitter.prototype.getEvents = function () {\n        return this.events;\n    };\n    EventEmitter.prototype.holdEventInvoke = function (fn) {\n        this.hold = true;\n        fn();\n        this.hold = false;\n    };\n    return EventEmitter;\n}());\n\nvar CommandManager = /** @class */ (function () {\n    function CommandManager(eventEmitter, mdCommands, wwCommands, getEditorType) {\n        this.eventEmitter = eventEmitter;\n        this.mdCommands = mdCommands;\n        this.wwCommands = wwCommands;\n        this.getEditorType = getEditorType;\n        this.initEvent();\n    }\n    CommandManager.prototype.initEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen('command', function (command, payload) {\n            _this.exec(command, payload);\n        });\n    };\n    CommandManager.prototype.addCommand = function (type, name, command) {\n        if (type === 'markdown') {\n            this.mdCommands[name] = command;\n        }\n        else {\n            this.wwCommands[name] = command;\n        }\n    };\n    CommandManager.prototype.deleteCommand = function (type, name) {\n        if (type === 'markdown') {\n            delete this.mdCommands[name];\n        }\n        else {\n            delete this.wwCommands[name];\n        }\n    };\n    CommandManager.prototype.exec = function (name, payload) {\n        var type = this.getEditorType();\n        if (type === 'markdown') {\n            this.mdCommands[name](payload);\n        }\n        else {\n            this.wwCommands[name](payload);\n        }\n    };\n    return CommandManager;\n}());\n\nfunction getTextWithoutTrailingNewline(text) {\n    return text[text.length - 1] === '\\n' ? text.slice(0, text.length - 1) : text;\n}\nfunction isCustomHTMLInlineNode(_a, node) {\n    var schema = _a.schema;\n    var html = node.literal;\n    var matched = html.match(reHTMLTag);\n    if (matched) {\n        var openTagName = matched[1], closeTagName = matched[3];\n        var typeName = (openTagName || closeTagName).toLowerCase();\n        return node.type === 'htmlInline' && !!(schema.marks[typeName] || schema.nodes[typeName]);\n    }\n    return false;\n}\nfunction isInlineNode(_a) {\n    var type = _a.type;\n    return includes(['text', 'strong', 'emph', 'strike', 'image', 'link', 'code'], type);\n}\nfunction isSoftbreak(mdNode) {\n    return (mdNode === null || mdNode === void 0 ? void 0 : mdNode.type) === 'softbreak';\n}\nfunction isListNode(_a) {\n    var type = _a.type, literal = _a.literal;\n    var matched = type === 'htmlInline' && literal.match(reHTMLTag);\n    if (matched) {\n        var openTagName = matched[1], closeTagName = matched[3];\n        var tagName = openTagName || closeTagName;\n        if (tagName) {\n            return includes(['ul', 'ol', 'li'], tagName.toLowerCase());\n        }\n    }\n    return false;\n}\nfunction getListItemAttrs(_a) {\n    var literal = _a.literal;\n    var task = /data-task/.test(literal);\n    var checked = /data-task-checked/.test(literal);\n    return { task: task, checked: checked };\n}\nfunction getMatchedAttributeValue(rawHTML) {\n    var attrNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        attrNames[_i - 1] = arguments[_i];\n    }\n    var wrapper = document.createElement('div');\n    wrapper.innerHTML = sanitizeHTML(rawHTML);\n    var el = wrapper.firstChild;\n    return attrNames.map(function (attrName) { return el.getAttribute(attrName) || ''; });\n}\nfunction createConvertors(convertors) {\n    var convertorMap = {};\n    Object.keys(convertors).forEach(function (key) {\n        var tagNames = key.split(', ');\n        tagNames.forEach(function (tagName) {\n            var name = tagName.toLowerCase();\n            convertorMap[name] = convertors[key];\n        });\n    });\n    return convertorMap;\n}\nvar convertors = {\n    'b, strong': function (state, _, openTagName) {\n        var strong = state.schema.marks.strong;\n        if (openTagName) {\n            state.openMark(strong.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(strong);\n        }\n    },\n    'i, em': function (state, _, openTagName) {\n        var emph = state.schema.marks.emph;\n        if (openTagName) {\n            state.openMark(emph.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(emph);\n        }\n    },\n    's, del': function (state, _, openTagName) {\n        var strike = state.schema.marks.strike;\n        if (openTagName) {\n            state.openMark(strike.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(strike);\n        }\n    },\n    code: function (state, _, openTagName) {\n        var code = state.schema.marks.code;\n        if (openTagName) {\n            state.openMark(code.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(code);\n        }\n    },\n    a: function (state, node, openTagName) {\n        var tag = node.literal;\n        var link = state.schema.marks.link;\n        if (openTagName) {\n            var linkUrl = getMatchedAttributeValue(tag, 'href')[0];\n            state.openMark(link.create({\n                linkUrl: linkUrl,\n                rawHTML: openTagName,\n            }));\n        }\n        else {\n            state.closeMark(link);\n        }\n    },\n    img: function (state, node, openTagName) {\n        var tag = node.literal;\n        if (openTagName) {\n            var _a = getMatchedAttributeValue(tag, 'src', 'alt'), imageUrl = _a[0], altText = _a[1];\n            var image = state.schema.nodes.image;\n            state.addNode(image, __assign$1({ rawHTML: openTagName, imageUrl: imageUrl }, (altText && { altText: altText })));\n        }\n    },\n    hr: function (state, _, openTagName) {\n        state.addNode(state.schema.nodes.thematicBreak, { rawHTML: openTagName });\n    },\n    br: function (state, node) {\n        var paragraph = state.schema.nodes.paragraph;\n        var parent = node.parent, prev = node.prev, next = node.next;\n        if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'paragraph') {\n            // should open a paragraph node when line text has only <br> tag\n            // ex) first line\\n\\n<br>\\nfourth line\n            if (isSoftbreak(prev)) {\n                state.openNode(paragraph);\n            }\n            // should close a paragraph node when line text has only <br> tag\n            // ex) first line\\n\\n<br>\\nfourth line\n            if (isSoftbreak(next)) {\n                state.closeNode();\n                // should close a paragraph node and open a paragraph node to separate between blocks\n                // when <br> tag is in the middle of the paragraph\n                // ex) first <br>line\\nthird line\n            }\n            else if (next) {\n                state.closeNode();\n                state.openNode(paragraph);\n            }\n        }\n        else if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'tableCell') {\n            if (prev && (isInlineNode(prev) || isCustomHTMLInlineNode(state, prev))) {\n                state.closeNode();\n            }\n            if (next && (isInlineNode(next) || isCustomHTMLInlineNode(state, next))) {\n                state.openNode(paragraph);\n            }\n        }\n    },\n    pre: function (state, node, openTagName) {\n        var _a, _b;\n        var container = document.createElement('div');\n        container.innerHTML = node.literal;\n        var literal = (_b = (_a = container.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.textContent;\n        state.openNode(state.schema.nodes.codeBlock, { rawHTML: openTagName });\n        state.addText(getTextWithoutTrailingNewline(literal));\n        state.closeNode();\n    },\n    'ul, ol': function (state, node, openTagName) {\n        // in the table cell, '<ul>', '<ol>' is parsed as 'htmlInline' node\n        if (node.parent.type === 'tableCell') {\n            var _a = state.schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList, paragraph = _a.paragraph;\n            var list = openTagName === 'ul' ? bulletList : orderedList;\n            if (openTagName) {\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.openNode(list, { rawHTML: openTagName });\n            }\n            else {\n                state.closeNode();\n                if (node.next && !isListNode(node.next)) {\n                    state.openNode(paragraph);\n                }\n            }\n        }\n    },\n    li: function (state, node, openTagName) {\n        var _a;\n        // in the table cell, '<li>' is parsed as 'htmlInline' node\n        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'tableCell') {\n            var _b = state.schema.nodes, listItem = _b.listItem, paragraph = _b.paragraph;\n            if (openTagName) {\n                var attrs = getListItemAttrs(node);\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.openNode(listItem, __assign$1({ rawHTML: openTagName }, attrs));\n                if (node.next && !isListNode(node.next)) {\n                    state.openNode(paragraph);\n                }\n            }\n            else {\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.closeNode();\n            }\n        }\n    },\n};\nvar htmlToWwConvertors = createConvertors(convertors);\n\nfunction isBRTag(node) {\n    return node.type === 'htmlInline' && reBR.test(node.literal);\n}\nfunction addRawHTMLAttributeToDOM(parent) {\n    toArray_1(parent.childNodes).forEach(function (child) {\n        if (isElemNode(child)) {\n            var openTagName = child.nodeName.toLowerCase();\n            child.setAttribute('data-raw-html', openTagName);\n            if (child.childNodes) {\n                addRawHTMLAttributeToDOM(child);\n            }\n        }\n    });\n}\nvar toWwConvertors = {\n    text: function (state, node) {\n        state.addText(node.literal || '');\n    },\n    paragraph: function (state, node, _a, customAttrs) {\n        var _b;\n        var entering = _a.entering;\n        if (entering) {\n            var paragraph = state.schema.nodes.paragraph;\n            // The `\\n\\n` entered in markdown separates the paragraph.\n            // When changing to wysiwyg, a newline is added between the two paragraphs.\n            if (((_b = node.prev) === null || _b === void 0 ? void 0 : _b.type) === 'paragraph') {\n                state.openNode(paragraph, customAttrs);\n                state.closeNode();\n            }\n            state.openNode(paragraph, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    heading: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, level = _b.level, headingType = _b.headingType;\n            state.openNode(state.schema.nodes.heading, __assign$1({ level: level, headingType: headingType }, customAttrs));\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    codeBlock: function (state, node, customAttrs) {\n        var codeBlock = state.schema.nodes.codeBlock;\n        var _a = node, info = _a.info, literal = _a.literal;\n        state.openNode(codeBlock, __assign$1({ language: info }, customAttrs));\n        state.addText(getTextWithoutTrailingNewline(literal || ''));\n        state.closeNode();\n    },\n    list: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = state.schema.nodes, bulletList = _b.bulletList, orderedList = _b.orderedList;\n            var _c = node.listData, type = _c.type, start = _c.start;\n            if (type === 'bullet') {\n                state.openNode(bulletList, customAttrs);\n            }\n            else {\n                state.openNode(orderedList, __assign$1({ order: start }, customAttrs));\n            }\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    item: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        var listItem = state.schema.nodes.listItem;\n        var _b = node.listData, task = _b.task, checked = _b.checked;\n        if (entering) {\n            var attrs = __assign$1(__assign$1(__assign$1({}, (task && { task: task })), (checked && { checked: checked })), customAttrs);\n            state.openNode(listItem, attrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    blockQuote: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.blockQuote, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    image: function (state, node, _a, customAttrs) {\n        var entering = _a.entering, skipChildren = _a.skipChildren;\n        var image = state.schema.nodes.image;\n        var _b = node, destination = _b.destination, firstChild = _b.firstChild;\n        if (entering && skipChildren) {\n            skipChildren();\n        }\n        state.addNode(image, __assign$1(__assign$1({ imageUrl: destination }, (firstChild && { altText: firstChild.literal })), customAttrs));\n    },\n    thematicBreak: function (state, node, _, customAttrs) {\n        state.addNode(state.schema.nodes.thematicBreak, customAttrs);\n    },\n    strong: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var strong = state.schema.marks.strong;\n        if (entering) {\n            state.openMark(strong.create(customAttrs));\n        }\n        else {\n            state.closeMark(strong);\n        }\n    },\n    emph: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var emph = state.schema.marks.emph;\n        if (entering) {\n            state.openMark(emph.create(customAttrs));\n        }\n        else {\n            state.closeMark(emph);\n        }\n    },\n    link: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        var link = state.schema.marks.link;\n        var _b = node, destination = _b.destination, title = _b.title;\n        if (entering) {\n            var attrs = __assign$1({ linkUrl: destination, title: title }, customAttrs);\n            state.openMark(link.create(attrs));\n        }\n        else {\n            state.closeMark(link);\n        }\n    },\n    softbreak: function (state, node) {\n        if (node.parent.type === 'paragraph') {\n            var prev = node.prev, next = node.next;\n            if (prev && !isBRTag(prev)) {\n                state.closeNode();\n            }\n            if (next && !isBRTag(next)) {\n                state.openNode(state.schema.nodes.paragraph);\n            }\n        }\n    },\n    // GFM specifications node\n    table: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.table, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableHead: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableHead, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableBody: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableBody, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableRow: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableRow, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableCell: function (state, node, _a) {\n        var entering = _a.entering;\n        if (!node.ignored) {\n            var hasParaNode = function (childNode) {\n                return childNode && (isInlineNode(childNode) || isCustomHTMLInlineNode(state, childNode));\n            };\n            if (entering) {\n                var _b = state.schema.nodes, tableHeadCell = _b.tableHeadCell, tableBodyCell = _b.tableBodyCell, paragraph = _b.paragraph;\n                var tablePart = node.parent.parent;\n                var cell = tablePart.type === 'tableHead' ? tableHeadCell : tableBodyCell;\n                var table = tablePart.parent;\n                var align = (table.columns[node.startIdx] || {}).align;\n                var attrs = __assign$1({}, node.attrs);\n                if (align) {\n                    attrs.align = align;\n                }\n                state.openNode(cell, attrs);\n                if (hasParaNode(node.firstChild)) {\n                    state.openNode(paragraph);\n                }\n            }\n            else {\n                if (hasParaNode(node.lastChild)) {\n                    state.closeNode();\n                }\n                state.closeNode();\n            }\n        }\n    },\n    strike: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var strike = state.schema.marks.strike;\n        if (entering) {\n            state.openMark(strike.create(customAttrs));\n        }\n        else {\n            state.closeMark(strike);\n        }\n    },\n    code: function (state, node, _, customAttrs) {\n        var code = state.schema.marks.code;\n        state.openMark(code.create(customAttrs));\n        state.addText(getTextWithoutTrailingNewline(node.literal || ''));\n        state.closeMark(code);\n    },\n    customBlock: function (state, node) {\n        var _a = state.schema.nodes, customBlock = _a.customBlock, paragraph = _a.paragraph;\n        var _b = node, info = _b.info, literal = _b.literal;\n        state.openNode(customBlock, { info: info });\n        state.addText(getTextWithoutTrailingNewline(literal || ''));\n        state.closeNode();\n        // add empty line to edit the content in next line\n        if (!node.next) {\n            state.openNode(paragraph);\n            state.closeNode();\n        }\n    },\n    frontMatter: function (state, node) {\n        state.openNode(state.schema.nodes.frontMatter);\n        state.addText(node.literal);\n        state.closeNode();\n    },\n    htmlInline: function (state, node) {\n        var html = node.literal;\n        var matched = html.match(reHTMLTag);\n        var openTagName = matched[1], closeTagName = matched[3];\n        var typeName = (openTagName || closeTagName).toLowerCase();\n        var markType = state.schema.marks[typeName];\n        var sanitizedHTML = sanitizeHTML(html);\n        // for user defined html schema\n        if (markType === null || markType === void 0 ? void 0 : markType.spec.attrs.htmlInline) {\n            if (openTagName) {\n                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);\n                state.openMark(markType.create({ htmlAttrs: htmlAttrs }));\n            }\n            else {\n                state.closeMark(markType);\n            }\n        }\n        else {\n            var htmlToWwConvertor = htmlToWwConvertors[typeName];\n            if (htmlToWwConvertor) {\n                htmlToWwConvertor(state, node, openTagName);\n            }\n        }\n    },\n    htmlBlock: function (state, node) {\n        var html = node.literal;\n        var container = document.createElement('div');\n        var isHTMLComment = reHTMLComment.test(html);\n        if (isHTMLComment) {\n            state.openNode(state.schema.nodes.htmlComment);\n            state.addText(node.literal);\n            state.closeNode();\n        }\n        else {\n            var matched = html.match(reHTMLTag);\n            var openTagName = matched[1], closeTagName = matched[3];\n            var typeName = (openTagName || closeTagName).toLowerCase();\n            var nodeType = state.schema.nodes[typeName];\n            var sanitizedHTML = sanitizeHTML(html);\n            // for user defined html schema\n            if (nodeType === null || nodeType === void 0 ? void 0 : nodeType.spec.attrs.htmlBlock) {\n                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);\n                var childrenHTML = getChildrenHTML(node, typeName);\n                state.addNode(nodeType, { htmlAttrs: htmlAttrs, childrenHTML: childrenHTML });\n            }\n            else {\n                container.innerHTML = sanitizedHTML;\n                addRawHTMLAttributeToDOM(container);\n                state.convertByDOMParser(container);\n            }\n        }\n    },\n    customInline: function (state, node, _a) {\n        var entering = _a.entering, skipChildren = _a.skipChildren;\n        var _b = node, info = _b.info, firstChild = _b.firstChild;\n        var schema = state.schema;\n        if (info.indexOf('widget') !== -1 && entering) {\n            var content = getWidgetContent(node);\n            skipChildren();\n            state.addNode(schema.nodes.widget, { info: info }, [\n                schema.text(createWidgetContent(info, content)),\n            ]);\n        }\n        else {\n            var text = '$$';\n            if (entering) {\n                text += firstChild ? info + \" \" : info;\n            }\n            state.addText(text);\n        }\n    },\n};\nfunction createWwConvertors(customConvertors) {\n    var customConvertorTypes = Object.keys(customConvertors);\n    var convertors = __assign$1({}, toWwConvertors);\n    var renderer = new Renderer({\n        gfm: true,\n        nodeId: true,\n        convertors: customConvertors,\n    });\n    var orgConvertors = renderer.getConvertors();\n    customConvertorTypes.forEach(function (type) {\n        var wwConvertor = toWwConvertors[type];\n        if (wwConvertor && !includes(['htmlBlock', 'htmlInline'], type)) {\n            convertors[type] = function (state, node, context) {\n                context.origin = function () { return orgConvertors[type](node, context, orgConvertors); };\n                var tokens = customConvertors[type](node, context);\n                var attrs;\n                if (tokens) {\n                    var _a = Array.isArray(tokens) ? tokens[0] : tokens, htmlAttrs = _a.attributes, classNames = _a.classNames;\n                    attrs = { htmlAttrs: htmlAttrs, classNames: classNames };\n                }\n                wwConvertor(state, node, context, attrs);\n            };\n        }\n    });\n    return convertors;\n}\n\nfunction mergeMarkText(a, b) {\n    if (a.isText && b.isText && prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.sameSet(a.marks, b.marks)) {\n        // @ts-ignore\n        // type is not defined for \"withText\" in prosemirror-model\n        return a.withText(a.text + b.text);\n    }\n    return false;\n}\nvar ToWwConvertorState = /** @class */ (function () {\n    function ToWwConvertorState(schema, convertors) {\n        this.schema = schema;\n        this.convertors = convertors;\n        this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }];\n        this.marks = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none;\n    }\n    ToWwConvertorState.prototype.top = function () {\n        return last$1(this.stack);\n    };\n    ToWwConvertorState.prototype.push = function (node) {\n        if (this.stack.length) {\n            this.top().content.push(node);\n        }\n    };\n    ToWwConvertorState.prototype.addText = function (text) {\n        if (text) {\n            var nodes = this.top().content;\n            var lastNode = last$1(nodes);\n            var node = this.schema.text(text, this.marks);\n            var merged = lastNode && mergeMarkText(lastNode, node);\n            if (merged) {\n                nodes[nodes.length - 1] = merged;\n            }\n            else {\n                nodes.push(node);\n            }\n        }\n    };\n    ToWwConvertorState.prototype.openMark = function (mark) {\n        this.marks = mark.addToSet(this.marks);\n    };\n    ToWwConvertorState.prototype.closeMark = function (mark) {\n        this.marks = mark.removeFromSet(this.marks);\n    };\n    ToWwConvertorState.prototype.addNode = function (type, attrs, content) {\n        var node = type.createAndFill(attrs, content, this.marks);\n        if (node) {\n            this.push(node);\n            return node;\n        }\n        return null;\n    };\n    ToWwConvertorState.prototype.openNode = function (type, attrs) {\n        this.stack.push({ type: type, attrs: attrs, content: [] });\n    };\n    ToWwConvertorState.prototype.closeNode = function () {\n        if (this.marks.length) {\n            this.marks = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none;\n        }\n        var _a = this.stack.pop(), type = _a.type, attrs = _a.attrs, content = _a.content;\n        return this.addNode(type, attrs, content);\n    };\n    ToWwConvertorState.prototype.convertByDOMParser = function (root) {\n        var _this = this;\n        var doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(this.schema).parse(root);\n        doc.content.forEach(function (node) { return _this.push(node); });\n    };\n    ToWwConvertorState.prototype.closeUnmatchedHTMLInline = function (node, entering) {\n        var _a;\n        if (!entering && node.type !== 'htmlInline') {\n            var length_1 = this.stack.length - 1;\n            for (var i = length_1; i >= 0; i -= 1) {\n                var nodeInfo = this.stack[i];\n                if ((_a = nodeInfo.attrs) === null || _a === void 0 ? void 0 : _a.rawHTML) {\n                    if (nodeInfo.content.length) {\n                        this.closeNode();\n                    }\n                    else {\n                        // just pop useless unmatched html inline node\n                        this.stack.pop();\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    };\n    ToWwConvertorState.prototype.convert = function (mdNode, infoForPosSync) {\n        var walker = mdNode.walker();\n        var event = walker.next();\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            var skipped = false;\n            if (convertor) {\n                var context = {\n                    entering: entering,\n                    leaf: !isContainer$2(node),\n                    getChildrenText: getChildrenText$1,\n                    options: { gfm: true, nodeId: false, tagFilter: false, softbreak: '\\n' },\n                    skipChildren: function () {\n                        skipped = true;\n                    },\n                };\n                this_1.closeUnmatchedHTMLInline(node, entering);\n                convertor(this_1, node, context);\n                if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {\n                    var pos = this_1.stack.reduce(function (nodeSize, stackItem) {\n                        return nodeSize +\n                            stackItem.content.reduce(function (contentSize, pmNode) { return contentSize + pmNode.nodeSize; }, 0);\n                    }, 0) + 1;\n                    infoForPosSync.setMappedPos(pos);\n                }\n            }\n            if (skipped) {\n                walker.resumeAt(node, false);\n                walker.next();\n            }\n            event = walker.next();\n        };\n        var this_1 = this;\n        while (event) {\n            _loop_1();\n        }\n    };\n    ToWwConvertorState.prototype.convertNode = function (mdNode, infoForPosSync) {\n        this.convert(mdNode, infoForPosSync);\n        if (this.stack.length) {\n            return this.closeNode();\n        }\n        return null;\n    };\n    return ToWwConvertorState;\n}());\n\nfunction convertToRawHTMLHavingInlines(state, node, _a) {\n    var openTag = _a[0], closeTag = _a[1];\n    state.write(openTag);\n    state.convertInline(node);\n    state.write(closeTag);\n}\nfunction convertToRawHTMLHavingBlocks(state, _a, _b) {\n    var node = _a.node, parent = _a.parent;\n    var openTag = _b[0], closeTag = _b[1];\n    state.stopNewline = true;\n    state.write(openTag);\n    state.convertNode(node);\n    state.write(closeTag);\n    if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === 'doc') {\n        state.closeBlock(node);\n        state.stopNewline = false;\n    }\n}\nfunction createTableHeadDelim(textContent, columnAlign) {\n    var textLen = textContent.length;\n    var leftDelim = '';\n    var rightDelim = '';\n    if (columnAlign === 'left') {\n        leftDelim = ':';\n        textLen -= 1;\n    }\n    else if (columnAlign === 'right') {\n        rightDelim = ':';\n        textLen -= 1;\n    }\n    else if (columnAlign === 'center') {\n        leftDelim = ':';\n        rightDelim = ':';\n        textLen -= 2;\n    }\n    return \"\" + leftDelim + repeat$1('-', Math.max(textLen, 3)) + rightDelim;\n}\nvar nodeTypeWriters = {\n    text: function (state, _a) {\n        var _b;\n        var node = _a.node;\n        var text = (_b = node.text) !== null && _b !== void 0 ? _b : '';\n        if ((node.marks || []).some(function (mark) { return mark.type.name === 'link'; })) {\n            state.text(escapeTextForLink(text), false);\n        }\n        else {\n            state.text(text);\n        }\n    },\n    paragraph: function (state, _a) {\n        var node = _a.node, parent = _a.parent, _b = _a.index, index = _b === void 0 ? 0 : _b;\n        if (state.stopNewline) {\n            state.convertInline(node);\n        }\n        else {\n            var firstChildNode = index === 0;\n            var prevNode = !firstChildNode && parent.child(index - 1);\n            var prevEmptyNode = prevNode && prevNode.childCount === 0;\n            var nextNode = index < parent.childCount - 1 && parent.child(index + 1);\n            var nextParaNode = nextNode && nextNode.type.name === 'paragraph';\n            var emptyNode = node.childCount === 0;\n            if (emptyNode && prevEmptyNode) {\n                state.write('<br>\\n');\n            }\n            else if (emptyNode && !prevEmptyNode && !firstChildNode) {\n                if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === 'listItem') {\n                    var prevDelim = state.getDelim();\n                    state.setDelim('');\n                    state.write('<br>');\n                    state.setDelim(prevDelim);\n                }\n                state.write('\\n');\n            }\n            else {\n                state.convertInline(node);\n                if (nextParaNode) {\n                    state.write('\\n');\n                }\n                else {\n                    state.closeBlock(node);\n                }\n            }\n        }\n    },\n    heading: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        var headingType = node.attrs.headingType;\n        if (headingType === 'atx') {\n            state.write(delim + \" \");\n            state.convertInline(node);\n            state.closeBlock(node);\n        }\n        else {\n            state.convertInline(node);\n            state.ensureNewLine();\n            state.write(delim);\n            state.closeBlock(node);\n        }\n    },\n    codeBlock: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim, text = _b.text;\n        var _c = delim, openDelim = _c[0], closeDelim = _c[1];\n        state.write(openDelim);\n        state.ensureNewLine();\n        state.text(text, false);\n        state.ensureNewLine();\n        state.write(closeDelim);\n        state.closeBlock(node);\n    },\n    blockQuote: function (state, _a, _b) {\n        var node = _a.node, parent = _a.parent;\n        var delim = _b.delim;\n        if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === node.type.name) {\n            state.flushClose(1);\n        }\n        state.wrapBlock(delim, null, node, function () { return state.convertNode(node); });\n    },\n    bulletList: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        // soft-tab(4)\n        state.convertList(node, repeat$1(' ', 4), function () { return delim + \" \"; });\n    },\n    orderedList: function (state, _a) {\n        var node = _a.node;\n        var start = node.attrs.order || 1;\n        // soft-tab(4)\n        state.convertList(node, repeat$1(' ', 4), function (index) {\n            var orderedNum = String(start + index);\n            return orderedNum + \". \";\n        });\n    },\n    listItem: function (state, _a) {\n        var node = _a.node;\n        var _b = node.attrs, task = _b.task, checked = _b.checked;\n        if (task) {\n            state.write(\"[\" + (checked ? 'x' : ' ') + \"] \");\n        }\n        state.convertNode(node);\n    },\n    image: function (state, _, _a) {\n        var attrs = _a.attrs;\n        state.write(\"![\" + (attrs === null || attrs === void 0 ? void 0 : attrs.altText) + \"](\" + (attrs === null || attrs === void 0 ? void 0 : attrs.imageUrl) + \")\");\n    },\n    thematicBreak: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        state.write(delim);\n        state.closeBlock(node);\n    },\n    table: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n        state.closeBlock(node);\n    },\n    tableHead: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        var row = node.firstChild;\n        state.convertNode(node);\n        var result = delim !== null && delim !== void 0 ? delim : '';\n        if (!delim && row) {\n            row.forEach(function (_a) {\n                var textContent = _a.textContent, attrs = _a.attrs;\n                var headDelim = createTableHeadDelim(textContent, attrs.align);\n                result += \"| \" + headDelim + \" \";\n            });\n        }\n        state.write(result + \"|\");\n        state.ensureNewLine();\n    },\n    tableBody: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n    },\n    tableRow: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n        state.write('|');\n        state.ensureNewLine();\n    },\n    tableHeadCell: function (state, _a, _b) {\n        var node = _a.node;\n        var _c = _b.delim, delim = _c === void 0 ? '| ' : _c;\n        state.write(delim);\n        state.convertTableCell(node);\n        state.write(' ');\n    },\n    tableBodyCell: function (state, _a, _b) {\n        var node = _a.node;\n        var _c = _b.delim, delim = _c === void 0 ? '| ' : _c;\n        state.write(delim);\n        state.convertTableCell(node);\n        state.write(' ');\n    },\n    customBlock: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim, text = _b.text;\n        var _c = delim, openDelim = _c[0], closeDelim = _c[1];\n        state.write(openDelim);\n        state.ensureNewLine();\n        state.text(text, false);\n        state.ensureNewLine();\n        state.write(closeDelim);\n        state.closeBlock(node);\n    },\n    frontMatter: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.text(text, false);\n        state.closeBlock(node);\n    },\n    widget: function (state, _, _a) {\n        var text = _a.text;\n        state.write(text);\n    },\n    html: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.write(text);\n        if (node.attrs.htmlBlock) {\n            state.closeBlock(node);\n        }\n    },\n    htmlComment: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.write(text);\n        state.closeBlock(node);\n    },\n};\nfunction write(type, _a) {\n    var state = _a.state, nodeInfo = _a.nodeInfo, params = _a.params;\n    var rawHTML = params.rawHTML;\n    if (rawHTML) {\n        if (inArray_1(type, ['heading', 'codeBlock']) > -1) {\n            convertToRawHTMLHavingInlines(state, nodeInfo.node, rawHTML);\n        }\n        else if (inArray_1(type, ['image', 'thematicBreak']) > -1) {\n            state.write(rawHTML);\n        }\n        else {\n            convertToRawHTMLHavingBlocks(state, nodeInfo, rawHTML);\n        }\n    }\n    else {\n        nodeTypeWriters[type](state, nodeInfo, params);\n    }\n}\n\nfunction addBackticks(node, side) {\n    var text = node.text;\n    var ticks = /`+/g;\n    var len = 0;\n    if (node.isText && text) {\n        var matched = ticks.exec(text);\n        while (matched) {\n            len = Math.max(len, matched[0].length);\n            matched = ticks.exec(text);\n        }\n    }\n    var result = len > 0 && side > 0 ? ' `' : '`';\n    for (var i = 0; i < len; i += 1) {\n        result += '`';\n    }\n    if (len > 0 && side < 0) {\n        result += ' ';\n    }\n    return result;\n}\nfunction getPairRawHTML(rawHTML) {\n    return rawHTML ? [\"<\" + rawHTML + \">\", \"</\" + rawHTML + \">\"] : null;\n}\nfunction getOpenRawHTML(rawHTML) {\n    return rawHTML ? \"<\" + rawHTML + \">\" : null;\n}\nfunction getCloseRawHTML(rawHTML) {\n    return rawHTML ? \"</\" + rawHTML + \">\" : null;\n}\nvar toMdConvertors = {\n    heading: function (_a) {\n        var node = _a.node;\n        var attrs = node.attrs;\n        var level = attrs.level;\n        var delim = repeat$1('#', level);\n        if (attrs.headingType === 'setext') {\n            delim = level === 1 ? '===' : '---';\n        }\n        return {\n            delim: delim,\n            rawHTML: getPairRawHTML(attrs.rawHTML),\n        };\n    },\n    codeBlock: function (_a) {\n        var node = _a.node;\n        var _b = node, attrs = _b.attrs, textContent = _b.textContent;\n        return {\n            delim: [\"```\" + (attrs.language || ''), '```'],\n            rawHTML: getPairRawHTML(attrs.rawHTML),\n            text: textContent,\n        };\n    },\n    blockQuote: function (_a) {\n        var node = _a.node;\n        return {\n            delim: '> ',\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    bulletList: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || 'ul';\n        }\n        return {\n            delim: '*',\n            rawHTML: getPairRawHTML(rawHTML),\n        };\n    },\n    orderedList: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || 'ol';\n        }\n        return {\n            rawHTML: getPairRawHTML(rawHTML),\n        };\n    },\n    listItem: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var _c = node.attrs, task = _c.task, checked = _c.checked;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || 'li';\n        }\n        var className = task ? \" class=\\\"task-list-item\" + (checked ? ' checked' : '') + \"\\\"\" : '';\n        var dataset = task ? \" data-task\" + (checked ? \" data-task-checked\" : '') : '';\n        return {\n            rawHTML: rawHTML ? [\"<\" + rawHTML + className + dataset + \">\", \"</\" + rawHTML + \">\"] : null,\n        };\n    },\n    table: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableHead: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableBody: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableRow: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableHeadCell: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableBodyCell: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    image: function (_a) {\n        var node = _a.node;\n        var attrs = node.attrs;\n        var rawHTML = attrs.rawHTML, altText = attrs.altText;\n        var imageUrl = attrs.imageUrl.replace(/&amp;/g, '&');\n        var altAttr = altText ? \" alt=\\\"\" + escapeXml$1(altText) + \"\\\"\" : '';\n        return {\n            rawHTML: rawHTML ? \"<\" + rawHTML + \" src=\\\"\" + escapeXml$1(imageUrl) + \"\\\"\" + altAttr + \">\" : null,\n            attrs: {\n                altText: escapeTextForLink(altText || ''),\n                imageUrl: imageUrl,\n            },\n        };\n    },\n    thematicBreak: function (_a) {\n        var node = _a.node;\n        return {\n            delim: '***',\n            rawHTML: getOpenRawHTML(node.attrs.rawHTML),\n        };\n    },\n    customBlock: function (_a) {\n        var node = _a.node;\n        var _b = node, attrs = _b.attrs, textContent = _b.textContent;\n        return {\n            delim: [\"$$\" + attrs.info, '$$'],\n            text: textContent,\n        };\n    },\n    frontMatter: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    widget: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    strong: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: '**',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    emph: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: '*',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    strike: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: '~~',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    link: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var attrs = node.attrs;\n        var title = attrs.title, rawHTML = attrs.rawHTML;\n        var linkUrl = attrs.linkUrl.replace(/&amp;/g, '&');\n        var titleAttr = title ? \" title=\\\"\" + escapeXml$1(title) + \"\\\"\" : '';\n        if (entering) {\n            return {\n                delim: '[',\n                rawHTML: rawHTML ? \"<\" + rawHTML + \" href=\\\"\" + escapeXml$1(linkUrl) + \"\\\"\" + titleAttr + \">\" : null,\n            };\n        }\n        return {\n            delim: \"](\" + linkUrl + (title ? \" \" + quote(escapeTextForLink(title)) : '') + \")\",\n            rawHTML: getCloseRawHTML(rawHTML),\n        };\n    },\n    code: function (_a, _b) {\n        var node = _a.node, parent = _a.parent, _c = _a.index, index = _c === void 0 ? 0 : _c;\n        var entering = _b.entering;\n        var delim = entering\n            ? addBackticks(parent.child(index), -1)\n            : addBackticks(parent.child(index - 1), 1);\n        var rawHTML = entering\n            ? getOpenRawHTML(node.attrs.rawHTML)\n            : getCloseRawHTML(node.attrs.rawHTML);\n        return {\n            delim: delim,\n            rawHTML: rawHTML,\n        };\n    },\n    htmlComment: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    // html inline node, html block node\n    html: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var tagName = node.type.name;\n        var attrs = node.attrs.htmlAttrs;\n        var openTag = \"<\" + tagName;\n        var closeTag = \"</\" + tagName + \">\";\n        Object.keys(attrs).forEach(function (attrName) {\n            // To prevent broken converting when attributes has double quote string\n            openTag += \" \" + attrName + \"=\\\"\" + attrs[attrName].replace(/\"/g, \"'\") + \"\\\"\";\n        });\n        openTag += '>';\n        if (node.attrs.htmlInline) {\n            return {\n                rawHTML: entering ? openTag : closeTag,\n            };\n        }\n        return {\n            text: \"\" + openTag + node.attrs.childrenHTML + closeTag,\n        };\n    },\n};\nvar markTypeOptions = {\n    strong: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    emph: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    strike: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    code: {\n        escape: false,\n    },\n    link: null,\n    html: null,\n};\nfunction createNodeTypeConvertors(convertors) {\n    var nodeTypeConvertors = {};\n    var nodeTypes = Object.keys(nodeTypeWriters);\n    nodeTypes.forEach(function (type) {\n        nodeTypeConvertors[type] = function (state, nodeInfo) {\n            var writer = nodeTypeWriters[type];\n            if (writer) {\n                var convertor = convertors[type];\n                var params = convertor\n                    ? convertor(nodeInfo, {\n                        inTable: state.inTable,\n                    })\n                    : {};\n                write(type, { state: state, nodeInfo: nodeInfo, params: params });\n            }\n        };\n    });\n    return nodeTypeConvertors;\n}\nfunction createMarkTypeConvertors(convertors) {\n    var markTypeConvertors = {};\n    var markTypes = Object.keys(markTypeOptions);\n    markTypes.forEach(function (type) {\n        markTypeConvertors[type] = function (nodeInfo, entering) {\n            var markOption = markTypeOptions[type];\n            var convertor = convertors[type];\n            // There are two ways to call the mark type converter\n            // in the `toMdConvertorState` module.\n            // When calling the converter without using `delim` and `rawHTML` values,\n            // the converter is called without parameters.\n            var runConvertor = convertor && nodeInfo && !isUndefined_1(entering);\n            var params = runConvertor ? convertor(nodeInfo, { entering: entering }) : {};\n            return __assign$1(__assign$1({}, params), markOption);\n        };\n    });\n    return markTypeConvertors;\n}\n// Step 1: Create the converter by overriding the custom converter\n//         to the original converter defined in the `toMdConvertors` module.\n//         If the node type is defined in the original converter,\n//         the `origin()` function is exported to the paramter of the converter.\n// Step 2: Create a converter for the node type of ProseMirror by combining the converter\n//         created in Step 1 with the writers defined in the`toMdNodeTypeWriters` module.\n//         Each writer converts the ProseMirror's node to a string with the value returned\n//         by the converter, and then stores the state in the`toMdConverterState` class.\n// Step 3: Create a converter for the mark type of ProseMirror by combining the converter\n//         created in Step 1 with `markTypeOptions`.\n// Step 4: The created node type converter and mark type converter are injected\n//         when creating an instance of the`toMdConverterState` class.\nfunction createMdConvertors(customConvertors) {\n    var customConvertorTypes = Object.keys(customConvertors);\n    customConvertorTypes.forEach(function (type) {\n        var baseConvertor = toMdConvertors[type];\n        var customConvertor = customConvertors[type];\n        if (baseConvertor) {\n            toMdConvertors[type] = function (nodeInfo, context) {\n                context.origin = function () { return baseConvertor(nodeInfo, context); };\n                return customConvertor(nodeInfo, context);\n            };\n        }\n        else {\n            toMdConvertors[type] = customConvertor;\n        }\n        delete customConvertors[type];\n    });\n    var nodeTypeConvertors = createNodeTypeConvertors(toMdConvertors);\n    var markTypeConvertors = createMarkTypeConvertors(toMdConvertors);\n    return {\n        nodeTypeConvertors: nodeTypeConvertors,\n        markTypeConvertors: markTypeConvertors,\n    };\n}\n\nvar ToMdConvertorState = /** @class */ (function () {\n    function ToMdConvertorState(_a) {\n        var nodeTypeConvertors = _a.nodeTypeConvertors, markTypeConvertors = _a.markTypeConvertors;\n        this.nodeTypeConvertors = nodeTypeConvertors;\n        this.markTypeConvertors = markTypeConvertors;\n        this.delim = '';\n        this.result = '';\n        this.closed = false;\n        this.tightList = false;\n        this.stopNewline = false;\n        this.inTable = false;\n    }\n    ToMdConvertorState.prototype.getMarkConvertor = function (mark) {\n        var type = mark.attrs.htmlInline ? 'html' : mark.type.name;\n        return this.markTypeConvertors[type];\n    };\n    ToMdConvertorState.prototype.isInBlank = function () {\n        return /(^|\\n)$/.test(this.result);\n    };\n    ToMdConvertorState.prototype.markText = function (mark, entering, parent, index) {\n        var convertor = this.getMarkConvertor(mark);\n        if (convertor) {\n            var _a = convertor({ node: mark, parent: parent, index: index }, entering), delim = _a.delim, rawHTML = _a.rawHTML;\n            return rawHTML || delim;\n        }\n        return '';\n    };\n    ToMdConvertorState.prototype.setDelim = function (delim) {\n        this.delim = delim;\n    };\n    ToMdConvertorState.prototype.getDelim = function () {\n        return this.delim;\n    };\n    ToMdConvertorState.prototype.flushClose = function (size) {\n        if (!this.stopNewline && this.closed) {\n            if (!this.isInBlank()) {\n                this.result += '\\n';\n            }\n            if (!size) {\n                size = 2;\n            }\n            if (size > 1) {\n                var delimMin = this.delim;\n                var trim = /\\s+$/.exec(delimMin);\n                if (trim) {\n                    delimMin = delimMin.slice(0, delimMin.length - trim[0].length);\n                }\n                for (var i = 1; i < size; i += 1) {\n                    this.result += delimMin + \"\\n\";\n                }\n            }\n            this.closed = false;\n        }\n    };\n    ToMdConvertorState.prototype.wrapBlock = function (delim, firstDelim, node, fn) {\n        var old = this.getDelim();\n        this.write(firstDelim || delim);\n        this.setDelim(this.getDelim() + delim);\n        fn();\n        this.setDelim(old);\n        this.closeBlock(node);\n    };\n    ToMdConvertorState.prototype.ensureNewLine = function () {\n        if (!this.isInBlank()) {\n            this.result += '\\n';\n        }\n    };\n    ToMdConvertorState.prototype.write = function (content) {\n        if (content === void 0) { content = ''; }\n        this.flushClose();\n        if (this.delim && this.isInBlank()) {\n            this.result += this.delim;\n        }\n        if (content) {\n            this.result += content;\n        }\n    };\n    ToMdConvertorState.prototype.closeBlock = function (node) {\n        this.closed = node;\n    };\n    ToMdConvertorState.prototype.text = function (text, escaped) {\n        if (escaped === void 0) { escaped = true; }\n        var lines = text.split('\\n');\n        for (var i = 0; i < lines.length; i += 1) {\n            this.write();\n            this.result += escaped ? escape$1(lines[i]) : lines[i];\n            if (i !== lines.length - 1) {\n                this.result += '\\n';\n            }\n        }\n    };\n    ToMdConvertorState.prototype.convertBlock = function (node, parent, index) {\n        var type = node.type.name;\n        var convertor = this.nodeTypeConvertors[type];\n        var nodeInfo = { node: node, parent: parent, index: index };\n        if (node.attrs.htmlBlock) {\n            this.nodeTypeConvertors.html(this, nodeInfo);\n        }\n        else if (convertor) {\n            convertor(this, nodeInfo);\n        }\n    };\n    ToMdConvertorState.prototype.convertInline = function (parent) {\n        var _this = this;\n        var active = [];\n        var trailing = '';\n        var progress = function (node, _, index) {\n            var marks = node ? node.marks : [];\n            var leading = trailing;\n            trailing = '';\n            // If whitespace has to be expelled from the node, adjust\n            // leading and trailing accordingly.\n            var removedWhitespace = node &&\n                node.isText &&\n                marks.some(function (mark) {\n                    var markConvertor = _this.getMarkConvertor(mark);\n                    var info = markConvertor && markConvertor();\n                    return info && info.removedEnclosingWhitespace;\n                });\n            if (removedWhitespace && node && node.text) {\n                var _a = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text), lead = _a[1], mark = _a[2], trail = _a[3];\n                leading += lead;\n                trailing = trail;\n                if (lead || trail) {\n                    // @ts-ignore\n                    // type is not defined for \"withText\" in prosemirror-model\n                    node = mark ? node.withText(mark) : null;\n                    if (!node) {\n                        marks = active;\n                    }\n                }\n            }\n            var lastMark = marks.length && last$1(marks);\n            var markConvertor = lastMark && _this.getMarkConvertor(lastMark);\n            var markType = markConvertor && markConvertor();\n            var noEscape = markType && markType.escape === false;\n            var len = marks.length - (noEscape ? 1 : 0);\n            // Try to reorder 'mixable' marks, such as em and strong, which\n            // in Markdown may be opened and closed in different order, so\n            // that order of the marks for the token matches the order in\n            // active.\n            for (var i = 0; i < len; i += 1) {\n                var mark = marks[i];\n                if (markType && !markType.mixable) {\n                    break;\n                }\n                for (var j = 0; j < active.length; j += 1) {\n                    var other = active[j];\n                    if (markType && !markType.mixable) {\n                        break;\n                    }\n                    if (mark.eq(other)) {\n                        // eslint-disable-next-line max-depth\n                        if (i > j) {\n                            marks = marks\n                                .slice(0, j)\n                                .concat(mark)\n                                .concat(marks.slice(j, i))\n                                .concat(marks.slice(i + 1, len));\n                        }\n                        else if (j > i) {\n                            marks = marks\n                                .slice(0, i)\n                                .concat(marks.slice(i + 1, j))\n                                .concat(mark)\n                                .concat(marks.slice(j, len));\n                        }\n                        break;\n                    }\n                }\n            }\n            // Find the prefix of the mark set that didn't change\n            var keep = 0;\n            while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) {\n                keep += 1;\n            }\n            // Close the marks that need to be closed\n            while (keep < active.length) {\n                var activedMark = active.pop();\n                if (activedMark) {\n                    _this.text(_this.markText(activedMark, false, parent, index), false);\n                }\n            }\n            // Output any previously expelled trailing whitespace outside the marks\n            if (leading) {\n                _this.text(leading);\n            }\n            // Open the marks that need to be opened\n            if (node) {\n                while (active.length < len) {\n                    var mark = marks[active.length];\n                    active.push(mark);\n                    _this.text(_this.markText(mark, true, parent, index), false);\n                }\n                // Render the node. Special case code marks, since their content\n                // may not be escaped.\n                if (noEscape && node.isText) {\n                    _this.text(_this.markText(lastMark, true, parent, index) +\n                        node.text +\n                        _this.markText(lastMark, false, parent, index + 1), false);\n                }\n                else {\n                    _this.convertBlock(node, parent, index);\n                }\n            }\n        };\n        parent.forEach(progress);\n        progress(null, null, parent.childCount);\n    };\n    // Render a node's content as a list. `delim` should be the extra\n    // indentation added to all lines except the first in an item,\n    // `firstDelimFn` is a function going from an item index to a\n    // delimiter for the first line of the item.\n    ToMdConvertorState.prototype.convertList = function (node, delim, firstDelimFn) {\n        var _this = this;\n        var _a;\n        if (this.closed && this.closed.type === node.type) {\n            this.flushClose(3);\n        }\n        else if (this.tightList) {\n            this.flushClose(1);\n        }\n        var tight = (_a = node.attrs.tight) !== null && _a !== void 0 ? _a : true;\n        var prevTight = this.tightList;\n        this.tightList = tight;\n        node.forEach(function (child, _, index) {\n            if (index && tight) {\n                _this.flushClose(1);\n            }\n            _this.wrapBlock(delim, firstDelimFn(index), node, function () { return _this.convertBlock(child, node, index); });\n        });\n        this.tightList = prevTight;\n    };\n    ToMdConvertorState.prototype.convertTableCell = function (node) {\n        var _this = this;\n        this.stopNewline = true;\n        this.inTable = true;\n        node.forEach(function (child, _, index) {\n            if (includes(['bulletList', 'orderedList'], child.type.name)) {\n                _this.convertBlock(child, node, index);\n                _this.closed = false;\n            }\n            else {\n                _this.convertInline(child);\n                if (index < node.childCount - 1) {\n                    var nextChild = node.child(index + 1);\n                    if (nextChild.type.name === 'paragraph') {\n                        _this.write('<br>');\n                    }\n                }\n            }\n        });\n        this.stopNewline = false;\n        this.inTable = false;\n    };\n    ToMdConvertorState.prototype.convertNode = function (parent, infoForPosSync) {\n        var _this = this;\n        parent.forEach(function (node, _, index) {\n            _this.convertBlock(node, parent, index);\n            if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {\n                var lineTexts = _this.result.split('\\n');\n                infoForPosSync.setMappedPos([lineTexts.length, last$1(lineTexts).length + 1]);\n            }\n        });\n        return this.result;\n    };\n    return ToMdConvertorState;\n}());\n\nvar Convertor = /** @class */ (function () {\n    function Convertor(schema, toMdConvertors, toHTMLConvertors, eventEmitter) {\n        var _this = this;\n        this.setMappedPos = function (pos) {\n            _this.mappedPosWhenConverting = pos;\n        };\n        this.schema = schema;\n        this.eventEmitter = eventEmitter;\n        this.focusedNode = null;\n        this.mappedPosWhenConverting = null;\n        this.toWwConvertors = createWwConvertors(toHTMLConvertors);\n        this.toMdConvertors = createMdConvertors(toMdConvertors || {});\n        this.eventEmitter.listen('setFocusedNode', function (node) { return (_this.focusedNode = node); });\n    }\n    Convertor.prototype.getMappedPos = function () {\n        return this.mappedPosWhenConverting;\n    };\n    Convertor.prototype.getInfoForPosSync = function () {\n        return { node: this.focusedNode, setMappedPos: this.setMappedPos };\n    };\n    Convertor.prototype.toWysiwygModel = function (mdNode) {\n        var state = new ToWwConvertorState(this.schema, this.toWwConvertors);\n        return state.convertNode(mdNode, this.getInfoForPosSync());\n    };\n    Convertor.prototype.toMarkdownText = function (wwNode) {\n        var state = new ToMdConvertorState(this.toMdConvertors);\n        var markdownText = state.convertNode(wwNode, this.getInfoForPosSync());\n        markdownText = this.eventEmitter.emitReduce('beforeConvertWysiwygToMarkdown', markdownText);\n        return markdownText;\n    };\n    return Convertor;\n}());\n\nfunction execPlugin(pluginInfo) {\n    var plugin = pluginInfo.plugin, eventEmitter = pluginInfo.eventEmitter, usageStatistics = pluginInfo.usageStatistics, instance = pluginInfo.instance;\n    var pmState = { Plugin: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin, PluginKey: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey, Selection: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection, TextSelection: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection };\n    var pmView = { Decoration: prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration, DecorationSet: prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet };\n    var pmModel = { Fragment: prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment };\n    var pmRules = { InputRule: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.InputRule, inputRules: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.inputRules, undoInputRule: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.undoInputRule };\n    var pmKeymap = { keymap: prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap };\n    var context = {\n        eventEmitter: eventEmitter,\n        usageStatistics: usageStatistics,\n        instance: instance,\n        pmState: pmState,\n        pmView: pmView,\n        pmModel: pmModel,\n        pmRules: pmRules,\n        pmKeymap: pmKeymap,\n        i18n: i18n,\n    };\n    if (isArray_1(plugin)) {\n        var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;\n        return pluginFn(context, options);\n    }\n    return plugin(context);\n}\nfunction getPluginInfo(pluginsInfo) {\n    var plugins = pluginsInfo.plugins, eventEmitter = pluginsInfo.eventEmitter, usageStatistics = pluginsInfo.usageStatistics, instance = pluginsInfo.instance;\n    eventEmitter.listen('mixinTableOffsetMapPrototype', mixinTableOffsetMapPrototype);\n    return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function (acc, plugin) {\n        var pluginInfoResult = execPlugin({\n            plugin: plugin,\n            eventEmitter: eventEmitter,\n            usageStatistics: usageStatistics,\n            instance: instance,\n        });\n        if (!pluginInfoResult) {\n            throw new Error('The return value of the executed plugin is empty.');\n        }\n        var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;\n        if (toHTMLRenderers) {\n            acc.toHTMLRenderers = deepMergedCopy(acc.toHTMLRenderers, toHTMLRenderers);\n        }\n        if (toMarkdownRenderers) {\n            acc.toMarkdownRenderers = deepMergedCopy(acc.toMarkdownRenderers, toMarkdownRenderers);\n        }\n        if (markdownPlugins) {\n            acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);\n        }\n        if (wysiwygPlugins) {\n            acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);\n        }\n        if (wysiwygNodeViews) {\n            acc.wwNodeViews = __assign$1(__assign$1({}, acc.wwNodeViews), wysiwygNodeViews);\n        }\n        if (markdownCommands) {\n            acc.mdCommands = __assign$1(__assign$1({}, acc.mdCommands), markdownCommands);\n        }\n        if (wysiwygCommands) {\n            acc.wwCommands = __assign$1(__assign$1({}, acc.wwCommands), wysiwygCommands);\n        }\n        if (toolbarItems) {\n            acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);\n        }\n        if (markdownParsers) {\n            acc.markdownParsers = __assign$1(__assign$1({}, acc.markdownParsers), markdownParsers);\n        }\n        return acc;\n    }, {\n        toHTMLRenderers: {},\n        toMarkdownRenderers: {},\n        mdPlugins: [],\n        wwPlugins: [],\n        wwNodeViews: {},\n        mdCommands: {},\n        wwCommands: {},\n        toolbarItems: [],\n        markdownParsers: {},\n    });\n}\n\nvar TASK_ATTR_NAME = 'data-task';\nvar DISABLED_TASK_ATTR_NAME = 'data-task-disabled';\nvar TASK_CHECKED_CLASS_NAME = 'checked';\nfunction registerHTMLTagToWhitelist(convertorMap) {\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            // register tag white list for preventing to remove the html in sanitizer\n            Object.keys(convertorMap[htmlType]).forEach(function (type) { return registerTagWhitelistIfPossible(type); });\n        }\n    });\n}\n/**\n * Class ToastUIEditorViewer\n * @param {object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.initialValue] Editor's initial value\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {string} [options.theme] - The theme to style the viewer with. The default is included in toastui-editor.css.\n */\nvar ToastUIEditorViewer = /** @class */ (function () {\n    function ToastUIEditorViewer(options) {\n        var _this = this;\n        this.options = extend_1({\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            usageStatistics: true,\n            theme: 'light',\n        }, options);\n        this.eventEmitter = new EventEmitter();\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        var _a = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        }) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;\n        var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: __assign$1(__assign$1({}, toHTMLRenderers), customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        registerHTMLTagToWhitelist(rendererOptions.customHTMLRenderer);\n        if (this.options.events) {\n            forEachOwnProperties_1(this.options.events, function (fn, key) {\n                _this.on(key, fn);\n            });\n        }\n        var _c = this.options, el = _c.el, initialValue = _c.initialValue, theme = _c.theme;\n        var existingHTML = el.innerHTML;\n        if (theme !== 'light') {\n            el.classList.add(cls(theme));\n        }\n        el.innerHTML = '';\n        this.toastMark = new ToastMark('', {\n            disallowedHtmlBlockTags: ['br', 'img'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: true }));\n        on_1(this.preview.previewContent, 'mousedown', this.toggleTask.bind(this));\n        if (initialValue) {\n            this.setMarkdown(initialValue);\n        }\n        else if (existingHTML) {\n            this.preview.setHTML(existingHTML);\n        }\n        el.appendChild(this.preview.previewContent);\n        this.eventEmitter.emit('load', this);\n    }\n    /**\n     * Toggle task by detecting mousedown event.\n     * @param {MouseEvent} ev - event\n     * @private\n     */\n    ToastUIEditorViewer.prototype.toggleTask = function (ev) {\n        var element = ev.target;\n        var style = getComputedStyle(element, ':before');\n        if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME) &&\n            element.hasAttribute(TASK_ATTR_NAME) &&\n            isPositionInBox(style, ev.offsetX, ev.offsetY)) {\n            toggleClass(element, TASK_CHECKED_CLASS_NAME);\n            this.eventEmitter.emit('change', {\n                source: 'viewer',\n                date: ev,\n            });\n        }\n    };\n    /**\n     * Set content for preview\n     * @param {string} markdown Markdown text\n     */\n    ToastUIEditorViewer.prototype.setMarkdown = function (markdown) {\n        var lineTexts = this.toastMark.getLineTexts();\n        var length = lineTexts.length;\n        var lastLine = last$1(lineTexts);\n        var endSourcepos = [length, lastLine.length + 1];\n        var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || '');\n        this.eventEmitter.emit('updatePreview', editResult);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorViewer.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove Viewer preview from document\n     */\n    ToastUIEditorViewer.prototype.destroy = function () {\n        off_1(this.preview.el, 'mousedown', this.toggleTask.bind(this));\n        this.preview.destroy();\n        this.eventEmitter.emit('destroy');\n    };\n    /**\n     * Return true\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isViewer = function () {\n        return true;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isMarkdownMode = function () {\n        return false;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isWysiwygMode = function () {\n        return false;\n    };\n    return ToastUIEditorViewer;\n}());\n\nfunction isPmNode(node) {\n    return node instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Node;\n}\nfunction isContainer(type) {\n    var containerTypes = [\n        'document',\n        'blockQuote',\n        'bulletList',\n        'orderedList',\n        'listItem',\n        'paragraph',\n        'heading',\n        'emph',\n        'strong',\n        'strike',\n        'link',\n        'image',\n        'table',\n        'tableHead',\n        'tableBody',\n        'tableRow',\n        'tableHeadCell',\n        'tableBodyCell',\n    ];\n    return includes(containerTypes, type);\n}\nfunction createMdLikeNode(node) {\n    var attrs = node.attrs, type = node.type;\n    var nodeType = type.name;\n    var mdLikeNode = {\n        type: nodeType,\n        wysiwygNode: true,\n        literal: !isContainer(nodeType) && isPmNode(node) ? node.textContent : null,\n    };\n    var nodeTypeMap = {\n        heading: { level: attrs.level },\n        link: { destination: attrs.linkUrl, title: attrs.title },\n        image: { destination: attrs.imageUrl },\n        codeBlock: { info: attrs.language },\n        bulletList: { type: 'list', listData: { type: 'bullet' } },\n        orderedList: { type: 'list', listData: { type: 'ordered', start: attrs.order } },\n        listItem: { type: 'item', listData: { task: attrs.task, checked: attrs.checked } },\n        tableHeadCell: { type: 'tableCell', cellType: 'head', align: attrs.align },\n        tableBodyCell: { type: 'tableCell', cellType: 'body', align: attrs.align },\n        customBlock: { info: attrs.info },\n    };\n    var nodeInfo = nodeTypeMap[nodeType];\n    var attributes = __assign$1(__assign$1({}, mdLikeNode), nodeInfo);\n    // html block, inline node\n    var _a = node.attrs, htmlAttrs = _a.htmlAttrs, childrenHTML = _a.childrenHTML;\n    if (htmlAttrs) {\n        return __assign$1(__assign$1({}, attributes), { attrs: htmlAttrs, childrenHTML: childrenHTML });\n    }\n    return attributes;\n}\n\nvar tokenToDOMNode = {\n    openTag: function (token, stack) {\n        var _a = token, tagName = _a.tagName, classNames = _a.classNames, attributes = _a.attributes;\n        var el = document.createElement(tagName);\n        var attrs = {};\n        if (classNames) {\n            el.className = classNames.join(' ');\n        }\n        if (attributes) {\n            attrs = __assign$1(__assign$1({}, attrs), attributes);\n        }\n        setAttributes(attrs, el);\n        stack.push(el);\n    },\n    closeTag: function (_, stack) {\n        if (stack.length > 1) {\n            var el = stack.pop();\n            last$1(stack).appendChild(el);\n        }\n    },\n    html: function (token, stack) {\n        last$1(stack).insertAdjacentHTML('beforeend', token.content);\n    },\n    text: function (token, stack) {\n        var textNode = document.createTextNode(token.content);\n        last$1(stack).appendChild(textNode);\n    },\n};\nvar WwToDOMAdaptor = /** @class */ (function () {\n    function WwToDOMAdaptor(linkAttributes, customRenderer) {\n        var convertors = getHTMLRenderConvertors(linkAttributes, customRenderer);\n        var customHTMLConvertor = __assign$1(__assign$1({}, customRenderer.htmlBlock), customRenderer.htmlInline);\n        // flatten the html block, inline convertor to other custom convertors\n        this.customConvertorKeys = Object.keys(customRenderer).concat(Object.keys(customHTMLConvertor));\n        this.renderer = new Renderer({\n            gfm: true,\n            convertors: __assign$1(__assign$1({}, convertors), customHTMLConvertor),\n        });\n        this.convertors = this.renderer.getConvertors();\n    }\n    WwToDOMAdaptor.prototype.generateTokens = function (node) {\n        var mdLikeNode = createMdLikeNode(node);\n        var context = {\n            entering: true,\n            leaf: isPmNode(node) ? node.isLeaf : false,\n            options: this.renderer.getOptions(),\n            getChildrenText: function () { return (isPmNode(node) ? node.textContent : ''); },\n            skipChildren: function () { return false; },\n        };\n        var convertor = this.convertors[node.type.name];\n        var converted = convertor(mdLikeNode, context, this.convertors);\n        var tokens = isArray_1(converted) ? converted : [converted];\n        if (isContainer(node.type.name) || node.attrs.htmlInline) {\n            context.entering = false;\n            tokens.push({ type: 'text', content: isPmNode(node) ? node.textContent : '' });\n            tokens = tokens.concat(convertor(mdLikeNode, context, this.convertors));\n        }\n        return tokens;\n    };\n    WwToDOMAdaptor.prototype.toDOMNode = function (node) {\n        var tokens = this.generateTokens(node);\n        var stack = [];\n        tokens.forEach(function (token) { return tokenToDOMNode[token.type](token, stack); });\n        return stack[0];\n    };\n    WwToDOMAdaptor.prototype.getToDOMNode = function (name) {\n        if (includes(this.customConvertorKeys, name)) {\n            return this.toDOMNode.bind(this);\n        }\n        return null;\n    };\n    return WwToDOMAdaptor;\n}());\n\nvar ANIMATION_TIME = 100;\nvar SCROLL_BLOCKING_RESET_DELAY = 15;\nvar currentTimeoutId = null;\nvar releaseTimer = null;\nfunction run(deltaScrollTop, _a) {\n    var syncScrollTop = _a.syncScrollTop, releaseEventBlock = _a.releaseEventBlock;\n    if (releaseTimer) {\n        clearTimeout(releaseTimer);\n    }\n    syncScrollTop(deltaScrollTop);\n    releaseTimer = setTimeout(function () {\n        releaseEventBlock();\n    }, SCROLL_BLOCKING_RESET_DELAY);\n}\nfunction animate(curScrollTop, targetScrollTop, syncCallbacks) {\n    var diff = targetScrollTop - curScrollTop;\n    var startTime = Date.now();\n    var step = function () {\n        var stepTime = Date.now();\n        var progress = (stepTime - startTime) / ANIMATION_TIME;\n        var deltaValue;\n        if (currentTimeoutId) {\n            clearTimeout(currentTimeoutId);\n        }\n        if (progress < 1) {\n            deltaValue = curScrollTop + diff * Math.cos(((1 - progress) * Math.PI) / 2);\n            run(Math.ceil(deltaValue), syncCallbacks);\n            currentTimeoutId = setTimeout(step, 1);\n        }\n        else {\n            run(targetScrollTop, syncCallbacks);\n            currentTimeoutId = null;\n        }\n    };\n    step();\n}\n\nvar EDITOR_BOTTOM_PADDING = 18;\nvar ScrollSync = /** @class */ (function () {\n    function ScrollSync(mdEditor, preview, eventEmitter) {\n        this.latestEditorScrollTop = null;\n        this.latestPreviewScrollTop = null;\n        this.blockedScroll = null;\n        this.active = true;\n        this.timer = null;\n        var previewRoot = preview.previewContent, previewEl = preview.el;\n        this.previewRoot = previewRoot;\n        this.previewEl = previewEl;\n        this.mdEditor = mdEditor;\n        this.editorView = mdEditor.view;\n        this.toastMark = mdEditor.getToastMark();\n        this.eventEmitter = eventEmitter;\n        this.addScrollSyncEvent();\n    }\n    ScrollSync.prototype.addScrollSyncEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen('afterPreviewRender', function () {\n            _this.clearTimer();\n            // Immediately after the 'afterPreviewRender' event has occurred,\n            // browser rendering is not yet complete.\n            // So the size of elements can not be accurately measured.\n            _this.timer = setTimeout(function () {\n                _this.syncPreviewScrollTop(true);\n            }, 200);\n        });\n        this.eventEmitter.listen('scroll', function (type, data) {\n            if (_this.active) {\n                if (type === 'editor' && _this.blockedScroll !== 'editor') {\n                    _this.syncPreviewScrollTop();\n                }\n                else if (type === 'preview' && _this.blockedScroll !== 'preview') {\n                    _this.syncEditorScrollTop(data);\n                }\n            }\n        });\n        this.eventEmitter.listen('toggleScrollSync', function (active) {\n            _this.active = active;\n        });\n    };\n    ScrollSync.prototype.getMdNodeAtPos = function (doc, posInfo) {\n        var indexInfo = doc.content.findIndex(posInfo.pos);\n        var line = indexInfo.index;\n        return this.toastMark.findFirstNodeAtLine(line + 1);\n    };\n    ScrollSync.prototype.getScrollTopByCaretPos = function () {\n        var pos = this.mdEditor.getSelection();\n        var firstMdNode = this.toastMark.findFirstNodeAtLine(pos[0][0]);\n        var previewHeight = this.previewEl.clientHeight;\n        var el = getParentNodeObj(this.previewRoot, firstMdNode).el;\n        var totalOffsetTop = getTotalOffsetTop(el, this.previewRoot) || el.offsetTop;\n        var nodeHeight = el.clientHeight;\n        // multiply 0.5 for calculating the position in the middle of preview area\n        var targetScrollTop = totalOffsetTop + nodeHeight - previewHeight * 0.5;\n        this.latestEditorScrollTop = null;\n        var diff = el.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;\n        return diff < previewHeight ? null : targetScrollTop;\n    };\n    ScrollSync.prototype.syncPreviewScrollTop = function (editing) {\n        if (editing === void 0) { editing = false; }\n        var _a = this, editorView = _a.editorView, previewEl = _a.previewEl, previewRoot = _a.previewRoot;\n        var _b = editorView.dom.getBoundingClientRect(), left = _b.left, top = _b.top;\n        var posInfo = editorView.posAtCoords({ left: left, top: top });\n        var doc = editorView.state.doc;\n        var firstMdNode = this.getMdNodeAtPos(doc, posInfo);\n        if (!firstMdNode || isHTMLNode(firstMdNode)) {\n            return;\n        }\n        var curScrollTop = previewEl.scrollTop;\n        var _c = editorView.dom, scrollTop = _c.scrollTop, scrollHeight = _c.scrollHeight, clientHeight = _c.clientHeight, children = _c.children;\n        var isBottomPos = scrollHeight - scrollTop <= clientHeight + EDITOR_BOTTOM_PADDING;\n        var targetScrollTop = isBottomPos ? previewEl.scrollHeight : 0;\n        if (scrollTop && !isBottomPos) {\n            if (editing) {\n                var scrollTopByEditing = this.getScrollTopByCaretPos();\n                if (!scrollTopByEditing) {\n                    return;\n                }\n                targetScrollTop = scrollTopByEditing;\n            }\n            else {\n                var _d = getParentNodeObj(this.previewRoot, firstMdNode), el = _d.el, mdNode = _d.mdNode;\n                var _e = getEditorRangeHeightInfo(doc, mdNode, children), height = _e.height, rect = _e.rect;\n                var totalOffsetTop = getTotalOffsetTop(el, previewRoot) || el.offsetTop;\n                var nodeHeight = el.clientHeight;\n                var ratio = top > rect.top ? Math.min((top - rect.top) / height, 1) : 0;\n                targetScrollTop = totalOffsetTop + nodeHeight * ratio;\n            }\n            targetScrollTop = this.getResolvedScrollTop('editor', scrollTop, targetScrollTop, curScrollTop);\n            this.latestEditorScrollTop = scrollTop;\n        }\n        if (targetScrollTop !== curScrollTop) {\n            this.run('editor', targetScrollTop, curScrollTop);\n        }\n    };\n    ScrollSync.prototype.syncEditorScrollTop = function (targetNode) {\n        var _a = this, toastMark = _a.toastMark, editorView = _a.editorView, previewRoot = _a.previewRoot, previewEl = _a.previewEl;\n        var dom = editorView.dom, state = editorView.state;\n        var scrollTop = previewEl.scrollTop, clientHeight = previewEl.clientHeight, scrollHeight = previewEl.scrollHeight;\n        var isBottomPos = scrollHeight - scrollTop <= clientHeight;\n        var curScrollTop = dom.scrollTop;\n        var targetScrollTop = isBottomPos ? dom.scrollHeight : 0;\n        if (scrollTop && targetNode && !isBottomPos) {\n            targetNode = findAncestorHavingId(targetNode, previewRoot);\n            if (!targetNode.getAttribute('data-nodeid')) {\n                return;\n            }\n            var children = dom.children;\n            var mdNodeId = Number(targetNode.getAttribute('data-nodeid'));\n            var _b = getParentNodeObj(this.previewRoot, toastMark.findNodeById(mdNodeId)), mdNode = _b.mdNode, el = _b.el;\n            var mdNodeStartLine = getMdStartLine(mdNode);\n            targetScrollTop = children[mdNodeStartLine - 1].offsetTop;\n            var height = getEditorRangeHeightInfo(state.doc, mdNode, children).height;\n            var _c = getAndSaveOffsetInfo(el, previewRoot, mdNodeId), nodeHeight = _c.nodeHeight, offsetTop = _c.offsetTop;\n            targetScrollTop += getAdditionalPos(scrollTop, offsetTop, nodeHeight, height);\n            targetScrollTop = this.getResolvedScrollTop('preview', scrollTop, targetScrollTop, curScrollTop);\n            this.latestPreviewScrollTop = scrollTop;\n        }\n        if (targetScrollTop !== curScrollTop) {\n            this.run('preview', targetScrollTop, curScrollTop);\n        }\n    };\n    ScrollSync.prototype.getResolvedScrollTop = function (from, scrollTop, targetScrollTop, curScrollTop) {\n        var latestScrollTop = from === 'editor' ? this.latestEditorScrollTop : this.latestPreviewScrollTop;\n        if (latestScrollTop === null) {\n            return targetScrollTop;\n        }\n        return latestScrollTop < scrollTop\n            ? Math.max(targetScrollTop, curScrollTop)\n            : Math.min(targetScrollTop, curScrollTop);\n    };\n    ScrollSync.prototype.run = function (from, targetScrollTop, curScrollTop) {\n        var _this = this;\n        var scrollTarget;\n        if (from === 'editor') {\n            scrollTarget = this.previewEl;\n            this.blockedScroll = 'preview';\n        }\n        else {\n            scrollTarget = this.editorView.dom;\n            this.blockedScroll = 'editor';\n        }\n        var syncCallbacks = {\n            syncScrollTop: function (scrollTop) { return (scrollTarget.scrollTop = scrollTop); },\n            releaseEventBlock: function () { return (_this.blockedScroll = null); },\n        };\n        animate(curScrollTop, targetScrollTop, syncCallbacks);\n    };\n    ScrollSync.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    ScrollSync.prototype.destroy = function () {\n        this.clearTimer();\n        this.eventEmitter.removeEventHandler('scroll');\n        this.eventEmitter.removeEventHandler('afterPreviewRender');\n    };\n    return ScrollSync;\n}());\n\nvar queryMap = {\n    getPopupInitialValues: function (editor, payload) {\n        var popupName = payload.popupName;\n        return popupName === 'link' ? { linkText: editor.getSelectedText() } : {};\n    },\n};\nfunction buildQuery(editor) {\n    editor.eventEmitter.listen('query', function (query, payload) {\n        return queryMap[query](editor, payload);\n    });\n}\n\n/**\n * ToastUIEditorCore\n * @param {Object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.height='300px'] - Editor's height style value. Height is applied as border-box ex) '300px', '100%', 'auto'\n *     @param {string} [options.minHeight='200px'] - Editor's min-height style value in pixel ex) '300px'\n *     @param {string} [options.initialValue] - Editor's initial value\n *     @param {string} [options.previewStyle] - Markdown editor's preview style (tab, vertical)\n *     @param {boolean} [options.previewHighlight = true] - Highlight a preview element corresponds to the cursor position in the markdown editor\n *     @param {string} [options.initialEditType] - Initial editor type (markdown, wysiwyg)\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *         @param {function} [options.events.keydown] - It would be emitted when the key is pressed in editor\n *         @param {function} [options.events.keyup] - It would be emitted when the key is released in editor\n *         @param {function} [options.events.beforePreviewRender] - It would be emitted before rendering the markdown preview with html string\n *         @param {function} [options.events.beforeConvertWysiwygToMarkdown] - It would be emitted before converting wysiwyg to markdown with markdown text\n *     @param {Object} [options.hooks] - Hooks\n *         @param {addImageBlobHook} [options.hooks.addImageBlobHook] - hook for image upload\n *     @param {string} [options.language='en-US'] - language\n *     @param {boolean} [options.useCommandShortcut=true] - whether use keyboard shortcuts to perform commands\n *     @param {boolean} [options.usageStatistics=true] - send hostname to google analytics\n *     @param {Array.<string|toolbarItemsValue>} [options.toolbarItems] - toolbar items.\n *     @param {boolean} [options.hideModeSwitch=false] - hide mode switch tab bar\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {string} [options.placeholder] - The placeholder text of the editable element.\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {Object} [options.customMarkdownRenderer=null] - Object containing custom renderer functions correspond to change wysiwyg node to markdown text\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.previewHighlight=false] - whether highlight preview area\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {Array.<object>} [options.widgetRules=[]] - The rules for replacing the text with widget node\n *     @param {string} [options.theme] - The theme to style the editor with. The default is included in toastui-editor.css.\n *     @param {autofocus} [options.autofocus=true] - automatically focus the editor on creation.\n */\nvar ToastUIEditorCore = /** @class */ (function () {\n    function ToastUIEditorCore(options) {\n        var _this = this;\n        this.initialHTML = options.el.innerHTML;\n        options.el.innerHTML = '';\n        this.options = extend_1({\n            previewStyle: 'tab',\n            previewHighlight: true,\n            initialEditType: 'markdown',\n            height: '300px',\n            minHeight: '200px',\n            language: 'en-US',\n            useCommandShortcut: true,\n            usageStatistics: true,\n            toolbarItems: [\n                ['heading', 'bold', 'italic', 'strike'],\n                ['hr', 'quote'],\n                ['ul', 'ol', 'task', 'indent', 'outdent'],\n                ['table', 'image', 'link'],\n                ['code', 'codeblock'],\n                ['scrollSync'],\n            ],\n            hideModeSwitch: false,\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            customMarkdownRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            widgetRules: [],\n            theme: 'light',\n            autofocus: true,\n        }, options);\n        var _a = this.options, customHTMLRenderer = _a.customHTMLRenderer, extendedAutolinks = _a.extendedAutolinks, referenceDefinition = _a.referenceDefinition, frontMatter = _a.frontMatter, customMarkdownRenderer = _a.customMarkdownRenderer, useCommandShortcut = _a.useCommandShortcut, initialEditType = _a.initialEditType, widgetRules = _a.widgetRules, customHTMLSanitizer = _a.customHTMLSanitizer;\n        this.mode = initialEditType || 'markdown';\n        this.mdPreviewStyle = this.options.previewStyle;\n        this.i18n = i18n;\n        this.i18n.setCode(this.options.language);\n        this.eventEmitter = new EventEmitter();\n        setWidgetRules(widgetRules);\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        this.pluginInfo = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        });\n        var _b = this.pluginInfo, toHTMLRenderers = _b.toHTMLRenderers, toMarkdownRenderers = _b.toMarkdownRenderers, mdPlugins = _b.mdPlugins, wwPlugins = _b.wwPlugins, wwNodeViews = _b.wwNodeViews, mdCommands = _b.mdCommands, wwCommands = _b.wwCommands, markdownParsers = _b.markdownParsers;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: deepMergedCopy(toHTMLRenderers, customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        var wwToDOMAdaptor = new WwToDOMAdaptor(linkAttributes, rendererOptions.customHTMLRenderer);\n        var htmlSchemaMap = createHTMLSchemaMap(rendererOptions.customHTMLRenderer, rendererOptions.sanitizer, wwToDOMAdaptor);\n        this.toastMark = new ToastMark('', {\n            disallowedHtmlBlockTags: ['br', 'img'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.mdEditor = new MdEditor(this.eventEmitter, {\n            toastMark: this.toastMark,\n            useCommandShortcut: useCommandShortcut,\n            mdPlugins: mdPlugins,\n        });\n        this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: false, highlight: this.options.previewHighlight }));\n        this.wwEditor = new WysiwygEditor(this.eventEmitter, {\n            toDOMAdaptor: wwToDOMAdaptor,\n            useCommandShortcut: useCommandShortcut,\n            htmlSchemaMap: htmlSchemaMap,\n            linkAttributes: linkAttributes,\n            wwPlugins: wwPlugins,\n            wwNodeViews: wwNodeViews,\n        });\n        this.convertor = new Convertor(this.wwEditor.getSchema(), __assign$1(__assign$1({}, toMarkdownRenderers), customMarkdownRenderer), getHTMLRenderConvertors(linkAttributes, rendererOptions.customHTMLRenderer), this.eventEmitter);\n        this.setMinHeight(this.options.minHeight);\n        this.setHeight(this.options.height);\n        this.setMarkdown(this.options.initialValue, false);\n        if (this.options.placeholder) {\n            this.setPlaceholder(this.options.placeholder);\n        }\n        if (!this.options.initialValue) {\n            this.setHTML(this.initialHTML, false);\n        }\n        this.commandManager = new CommandManager(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function () { return _this.mode; });\n        if (this.options.usageStatistics) {\n            sendHostName();\n        }\n        this.scrollSync = new ScrollSync(this.mdEditor, this.preview, this.eventEmitter);\n        this.addInitEvent();\n        this.addInitCommand(mdCommands, wwCommands);\n        buildQuery(this);\n        if (this.options.hooks) {\n            forEachOwnProperties_1(this.options.hooks, function (fn, key) { return _this.addHook(key, fn); });\n        }\n        if (this.options.events) {\n            forEachOwnProperties_1(this.options.events, function (fn, key) { return _this.on(key, fn); });\n        }\n        this.eventEmitter.emit('load', this);\n        this.moveCursorToStart(this.options.autofocus);\n    }\n    ToastUIEditorCore.prototype.addInitEvent = function () {\n        var _this = this;\n        this.on('needChangeMode', this.changeMode.bind(this));\n        this.on('loadUI', function () {\n            if (_this.height !== 'auto') {\n                // 75px equals default editor ui height - the editing area height\n                var minHeight = Math.min(parseInt(_this.minHeight, 10), parseInt(_this.height, 10) - 75) + \"px\";\n                _this.setMinHeight(minHeight);\n            }\n        });\n        addDefaultImageBlobHook(this.eventEmitter);\n    };\n    ToastUIEditorCore.prototype.addInitCommand = function (mdCommands, wwCommands) {\n        var _this = this;\n        var addPluginCommands = function (type, commandMap) {\n            Object.keys(commandMap).forEach(function (name) {\n                _this.addCommand(type, name, commandMap[name]);\n            });\n        };\n        this.addCommand('markdown', 'toggleScrollSync', function (payload) {\n            _this.eventEmitter.emit('toggleScrollSync', payload.active);\n            return true;\n        });\n        addPluginCommands('markdown', mdCommands);\n        addPluginCommands('wysiwyg', wwCommands);\n    };\n    ToastUIEditorCore.prototype.getCurrentModeEditor = function () {\n        return (this.isMarkdownMode() ? this.mdEditor : this.wwEditor);\n    };\n    /**\n     * Factory method for Editor\n     * @param {object} options Option for initialize TUIEditor\n     * @returns {object} ToastUIEditorCore or ToastUIEditorViewer\n     */\n    ToastUIEditorCore.factory = function (options) {\n        return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditorCore(options);\n    };\n    /**\n     * Set language\n     * @param {string|string[]} code - code for I18N language\n     * @param {object} data - language set\n     */\n    ToastUIEditorCore.setLanguage = function (code, data) {\n        i18n.setLanguage(code, data);\n    };\n    /**\n     * change preview style\n     * @param {string} style - 'tab'|'vertical'\n     */\n    ToastUIEditorCore.prototype.changePreviewStyle = function (style) {\n        if (this.mdPreviewStyle !== style) {\n            this.mdPreviewStyle = style;\n            this.eventEmitter.emit('changePreviewStyle', style);\n        }\n    };\n    /**\n     * execute editor command\n     * @param {string} name - command name\n     * @param {object} [payload] - payload for command\n     */\n    ToastUIEditorCore.prototype.exec = function (name, payload) {\n        this.commandManager.exec(name, payload);\n    };\n    /**\n     * @param {string} type - editor type\n     * @param {string} name - command name\n     * @param {function} command - command handler\n     */\n    ToastUIEditorCore.prototype.addCommand = function (type, name, command) {\n        var _this = this;\n        var commandHoc = function (paylaod) {\n            if (paylaod === void 0) { paylaod = {}; }\n            var view = (type === 'markdown' ? _this.mdEditor : _this.wwEditor).view;\n            command(paylaod, view.state, view.dispatch, view);\n        };\n        this.commandManager.addCommand(type, name, commandHoc);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorCore.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorCore.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorCore.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove hook from TUIEditor event\n     * @param {string} type Event type\n     */\n    ToastUIEditorCore.prototype.removeHook = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Set focus to current Editor\n     */\n    ToastUIEditorCore.prototype.focus = function () {\n        this.getCurrentModeEditor().focus();\n    };\n    /**\n     * Remove focus of current Editor\n     */\n    ToastUIEditorCore.prototype.blur = function () {\n        this.getCurrentModeEditor().blur();\n    };\n    /**\n     * Set cursor position to end\n     * @param {boolean} [focus] - automatically focus the editor\n     */\n    ToastUIEditorCore.prototype.moveCursorToEnd = function (focus) {\n        if (focus === void 0) { focus = true; }\n        this.getCurrentModeEditor().moveCursorToEnd(focus);\n    };\n    /**\n     * Set cursor position to start\n     * @param {boolean} [focus] - automatically focus the editor\n     */\n    ToastUIEditorCore.prototype.moveCursorToStart = function (focus) {\n        if (focus === void 0) { focus = true; }\n        this.getCurrentModeEditor().moveCursorToStart(focus);\n    };\n    /**\n     * Set markdown syntax text.\n     * @param {string} markdown - markdown syntax text.\n     * @param {boolean} [cursorToEnd=true] - move cursor to contents end\n     */\n    ToastUIEditorCore.prototype.setMarkdown = function (markdown, cursorToEnd) {\n        if (markdown === void 0) { markdown = ''; }\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        this.mdEditor.setMarkdown(markdown, cursorToEnd);\n        if (this.isWysiwygMode()) {\n            var mdNode = this.toastMark.getRootNode();\n            var wwNode = this.convertor.toWysiwygModel(mdNode);\n            this.wwEditor.setModel(wwNode, cursorToEnd);\n        }\n    };\n    /**\n     * Set html value.\n     * @param {string} html - html syntax text\n     * @param {boolean} [cursorToEnd=true] - move cursor to contents end\n     */\n    ToastUIEditorCore.prototype.setHTML = function (html, cursorToEnd) {\n        if (html === void 0) { html = ''; }\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        var container = document.createElement('div');\n        // the `br` tag should be replaced with empty block to separate between blocks\n        container.innerHTML = replaceBRWithEmptyBlock(html);\n        var wwNode = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(this.wwEditor.schema).parse(container);\n        if (this.isMarkdownMode()) {\n            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), cursorToEnd);\n        }\n        else {\n            this.wwEditor.setModel(wwNode, cursorToEnd);\n        }\n    };\n    /**\n     * Get content to markdown\n     * @returns {string} markdown text\n     */\n    ToastUIEditorCore.prototype.getMarkdown = function () {\n        if (this.isMarkdownMode()) {\n            return this.mdEditor.getMarkdown();\n        }\n        return this.convertor.toMarkdownText(this.wwEditor.getModel());\n    };\n    /**\n     * Get content to html\n     * @returns {string} html string\n     */\n    ToastUIEditorCore.prototype.getHTML = function () {\n        var _this = this;\n        this.eventEmitter.holdEventInvoke(function () {\n            if (_this.isMarkdownMode()) {\n                var mdNode = _this.toastMark.getRootNode();\n                var wwNode = _this.convertor.toWysiwygModel(mdNode);\n                _this.wwEditor.setModel(wwNode);\n            }\n        });\n        var html = removeProseMirrorHackNodes(this.wwEditor.view.dom.innerHTML);\n        if (this.placeholder) {\n            var rePlaceholder = new RegExp(\"<span class=\\\"placeholder[^>]+>\" + this.placeholder + \"</span>\", 'i');\n            return html.replace(rePlaceholder, '');\n        }\n        return html;\n    };\n    /**\n     * Insert text\n     * @param {string} text - text content\n     */\n    ToastUIEditorCore.prototype.insertText = function (text) {\n        this.getCurrentModeEditor().replaceSelection(text);\n    };\n    /**\n     * Set selection range\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     */\n    ToastUIEditorCore.prototype.setSelection = function (start, end) {\n        this.getCurrentModeEditor().setSelection(start, end);\n    };\n    /**\n     * Replace selection range with given text content\n     * @param {string} text - text content\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     */\n    ToastUIEditorCore.prototype.replaceSelection = function (text, start, end) {\n        this.getCurrentModeEditor().replaceSelection(text, start, end);\n    };\n    /**\n     * Delete the content of selection range\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     */\n    ToastUIEditorCore.prototype.deleteSelection = function (start, end) {\n        this.getCurrentModeEditor().deleteSelection(start, end);\n    };\n    /**\n     * Get selected text content\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     * @returns {string} - selected text content\n     */\n    ToastUIEditorCore.prototype.getSelectedText = function (start, end) {\n        return this.getCurrentModeEditor().getSelectedText(start, end);\n    };\n    /**\n     * Get range of the node\n     * @param {number|Array.<number>} [pos] - position\n     * @returns {Array.<number[]>|Array.<number>} - node [start, end] range\n     * @example\n     * // Markdown mode\n     * const rangeInfo = editor.getRangeInfoOfNode();\n     *\n     * console.log(rangeInfo); // { range: [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]], type: 'emph' }\n     *\n     * // WYSIWYG mode\n     * const rangeInfo = editor.getRangeInfoOfNode();\n     *\n     * console.log(rangeInfo); // { range: [startCursorOffset, endCursorOffset], type: 'emph' }\n     */\n    ToastUIEditorCore.prototype.getRangeInfoOfNode = function (pos) {\n        return this.getCurrentModeEditor().getRangeInfoOfNode(pos);\n    };\n    /**\n     * Add widget to selection\n     * @param {Node} node - widget node\n     * @param {string} style - Adding style \"top\" or \"bottom\"\n     * @param {number|Array.<number>} [pos] - position\n     */\n    ToastUIEditorCore.prototype.addWidget = function (node, style, pos) {\n        this.getCurrentModeEditor().addWidget(node, style, pos);\n    };\n    /**\n     * Replace node with widget to range\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     * @param {string} text - widget text content\n     */\n    ToastUIEditorCore.prototype.replaceWithWidget = function (start, end, text) {\n        this.getCurrentModeEditor().replaceWithWidget(start, end, text);\n    };\n    /**\n     * Set editor height\n     * @param {string} height - editor height in pixel\n     */\n    ToastUIEditorCore.prototype.setHeight = function (height) {\n        var el = this.options.el;\n        if (isString_1(height)) {\n            if (height === 'auto') {\n                addClass_1(el, 'auto-height');\n            }\n            else {\n                removeClass_1(el, 'auto-height');\n            }\n            this.setMinHeight(this.getMinHeight());\n        }\n        css_1(el, { height: height });\n        this.height = height;\n    };\n    /**\n     * Get editor height\n     * @returns {string} editor height in pixel\n     */\n    ToastUIEditorCore.prototype.getHeight = function () {\n        return this.height;\n    };\n    /**\n     * Set minimum height to editor content\n     * @param {string} minHeight - min content height in pixel\n     */\n    ToastUIEditorCore.prototype.setMinHeight = function (minHeight) {\n        if (minHeight !== this.minHeight) {\n            var height = this.height || this.options.height;\n            if (height !== 'auto' && this.options.el.querySelector(\".\" + cls('main'))) {\n                // 75px equals default editor ui height - the editing area height\n                minHeight = Math.min(parseInt(minHeight, 10), parseInt(height, 10) - 75) + \"px\";\n            }\n            var minHeightNum = parseInt(minHeight, 10);\n            this.minHeight = minHeight;\n            this.wwEditor.setMinHeight(minHeightNum);\n            this.mdEditor.setMinHeight(minHeightNum);\n            this.preview.setMinHeight(minHeightNum);\n        }\n    };\n    /**\n     * Get minimum height of editor content\n     * @returns {string} min height in pixel\n     */\n    ToastUIEditorCore.prototype.getMinHeight = function () {\n        return this.minHeight;\n    };\n    /**\n     * Return true if current editor mode is Markdown\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isMarkdownMode = function () {\n        return this.mode === 'markdown';\n    };\n    /**\n     * Return true if current editor mode is WYSIWYG\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isWysiwygMode = function () {\n        return this.mode === 'wysiwyg';\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isViewer = function () {\n        return false;\n    };\n    /**\n     * Get current Markdown editor's preview style\n     * @returns {string}\n     */\n    ToastUIEditorCore.prototype.getCurrentPreviewStyle = function () {\n        return this.mdPreviewStyle;\n    };\n    /**\n     * Change editor's mode to given mode string\n     * @param {string} mode - Editor mode name of want to change\n     * @param {boolean} [withoutFocus] - Change mode without focus\n     */\n    ToastUIEditorCore.prototype.changeMode = function (mode, withoutFocus) {\n        if (this.mode === mode) {\n            return;\n        }\n        this.mode = mode;\n        if (this.isWysiwygMode()) {\n            var mdNode = this.toastMark.getRootNode();\n            var wwNode = this.convertor.toWysiwygModel(mdNode);\n            this.wwEditor.setModel(wwNode);\n        }\n        else {\n            var wwNode = this.wwEditor.getModel();\n            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), !withoutFocus);\n        }\n        this.eventEmitter.emit('removePopupWidget');\n        this.eventEmitter.emit('changeMode', mode);\n        if (!withoutFocus) {\n            var pos = this.convertor.getMappedPos();\n            this.focus();\n            if (this.isWysiwygMode() && isNumber_1(pos)) {\n                this.wwEditor.setSelection(pos);\n            }\n            else if (Array.isArray(pos)) {\n                this.mdEditor.setSelection(pos);\n            }\n        }\n    };\n    /**\n     * Destroy TUIEditor from document\n     */\n    ToastUIEditorCore.prototype.destroy = function () {\n        var _this = this;\n        this.wwEditor.destroy();\n        this.mdEditor.destroy();\n        this.preview.destroy();\n        this.scrollSync.destroy();\n        this.eventEmitter.emit('destroy');\n        this.eventEmitter.getEvents().forEach(function (_, type) { return _this.off(type); });\n    };\n    /**\n     * Hide TUIEditor\n     */\n    ToastUIEditorCore.prototype.hide = function () {\n        this.eventEmitter.emit('hide');\n    };\n    /**\n     * Show TUIEditor\n     */\n    ToastUIEditorCore.prototype.show = function () {\n        this.eventEmitter.emit('show');\n    };\n    /**\n     * Move on scroll position of the editor container\n     * @param {number} value scrollTop value of editor container\n     */\n    ToastUIEditorCore.prototype.setScrollTop = function (value) {\n        this.getCurrentModeEditor().setScrollTop(value);\n    };\n    /**\n     * Get scroll position value of editor container\n     * @returns {number} scrollTop value of editor container\n     */\n    ToastUIEditorCore.prototype.getScrollTop = function () {\n        return this.getCurrentModeEditor().getScrollTop();\n    };\n    /**\n     * Reset TUIEditor\n     */\n    ToastUIEditorCore.prototype.reset = function () {\n        this.wwEditor.setModel([]);\n        this.mdEditor.setMarkdown('');\n    };\n    /**\n     * Get current selection range\n     * @returns {Array.<number[]>|Array.<number>} Returns the range of the selection depending on the editor mode\n     * @example\n     * // Markdown mode\n     * const mdSelection = editor.getSelection();\n     *\n     * console.log(mdSelection); // [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]]\n     *\n     * // WYSIWYG mode\n     * const wwSelection = editor.getSelection();\n     *\n     * console.log(wwSelection); // [startCursorOffset, endCursorOffset]\n     */\n    ToastUIEditorCore.prototype.getSelection = function () {\n        return this.getCurrentModeEditor().getSelection();\n    };\n    /**\n     * Set the placeholder on all editors\n     * @param {string} placeholder - placeholder to set\n     */\n    ToastUIEditorCore.prototype.setPlaceholder = function (placeholder) {\n        this.placeholder = placeholder;\n        this.mdEditor.setPlaceholder(placeholder);\n        this.wwEditor.setPlaceholder(placeholder);\n    };\n    /**\n     * Get markdown editor, preview, wysiwyg editor DOM elements\n     */\n    ToastUIEditorCore.prototype.getEditorElements = function () {\n        return {\n            mdEditor: this.mdEditor.getElement(),\n            mdPreview: this.preview.getElement(),\n            wwEditor: this.wwEditor.getElement(),\n        };\n    };\n    /**\n     * Convert position to match editor mode\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     * @param {string} mode - Editor mode name of want to match converted position to\n     */\n    ToastUIEditorCore.prototype.convertPosToMatchEditorMode = function (start, end, mode) {\n        var _a, _b;\n        if (end === void 0) { end = start; }\n        if (mode === void 0) { mode = this.mode; }\n        var doc = this.mdEditor.view.state.doc;\n        var isFromArray = Array.isArray(start);\n        var isToArray = Array.isArray(end);\n        var convertedFrom = start;\n        var convertedTo = end;\n        if (isFromArray !== isToArray) {\n            throw new Error('Types of arguments must be same');\n        }\n        if (mode === 'markdown' && !isFromArray && !isToArray) {\n            _a = getEditorToMdPos(doc, start, end), convertedFrom = _a[0], convertedTo = _a[1];\n        }\n        else if (mode === 'wysiwyg' && isFromArray && isToArray) {\n            _b = getMdToEditorPos(doc, start, end), convertedFrom = _b[0], convertedTo = _b[1];\n        }\n        return [convertedFrom, convertedTo];\n    };\n    return ToastUIEditorCore;\n}());\n\n// @TODO: change syntax with our convention\n/* eslint-disable */\nfunction html$1 (n) {\n  for (\n    var l,\n      e,\n      s = arguments,\n      t = 1,\n      r = '',\n      u = '',\n      a = [0],\n      c = function (n) {\n        t === 1 && (n || (r = r.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g, '')))\n          ? a.push(n ? s[n] : r)\n          : t === 3 && (n || r)\n          ? ((a[1] = n ? s[n] : r), (t = 2))\n          : t === 2 && r === '...' && n\n          ? (a[2] = assign(a[2] || {}, s[n]))\n          : t === 2 && r && !n\n          ? ((a[2] = a[2] || {})[r] = !0)\n          : t >= 5 &&\n            (t === 5\n              ? (((a[2] = a[2] || {})[e] = n ? (r ? r + s[n] : s[n]) : r), (t = 6))\n              : (n || r) && (a[2][e] += n ? r + s[n] : r)),\n          (r = '');\n      },\n      h = 0;\n    h < n.length;\n    h++\n  ) {\n    h && (t === 1 && c(), c(h));\n    for (let i = 0; i < n[h].length; i++)\n      (l = n[h][i]),\n        t === 1\n          ? l === '<'\n            ? (c(), (a = [a, '', null]), (t = 3))\n            : (r += l)\n          : t === 4\n          ? r === '--' && l === '>'\n            ? ((t = 1), (r = ''))\n            : (r = l + r[0])\n          : u\n          ? l === u\n            ? (u = '')\n            : (r += l)\n          : l === '\"' || l === \"'\"\n          ? (u = l)\n          : l === '>'\n          ? (c(), (t = 1))\n          : t &&\n            (l === '='\n              ? ((t = 5), (e = r), (r = ''))\n              : l === '/' && (t < 5 || n[h][i + 1] === '>')\n              ? (c(),\n                t === 3 && (a = a[0]),\n                (t = a),\n                (a = a[0]).push(this.apply(null, t.slice(1))),\n                (t = 0))\n              : l === ' ' || l === '\\t' || l === '\\n' || l === '\\r'\n              ? (c(), (t = 2))\n              : (r += l)),\n        t === 3 && r === '!--' && ((t = 4), (a = a[0]));\n  }\n  return c(), a.length > 2 ? a.slice(1) : a[1];\n}\n\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a boolean or not.\n *  If the given variable is a boolean, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is boolean?\n * @memberof module:type\n */\nfunction isBoolean(obj) {\n  return typeof obj === 'boolean' || obj instanceof Boolean;\n}\n\nvar isBoolean_1 = isBoolean;\n\nvar VNodeWalker = /** @class */ (function () {\n    function VNodeWalker(current) {\n        this.current = current;\n        this.root = current;\n        this.entering = true;\n    }\n    VNodeWalker.prototype.walk = function () {\n        var _a = this, entering = _a.entering, cur = _a.current;\n        if (!cur) {\n            return null;\n        }\n        if (entering) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next) {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        else {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        return { vnode: cur, entering: entering };\n    };\n    return VNodeWalker;\n}());\nvar VNode = /** @class */ (function () {\n    function VNode(type, props, children) {\n        this.parent = null;\n        this.old = null;\n        this.firstChild = null;\n        this.next = null;\n        this.skip = false;\n        this.type = type;\n        this.props = props;\n        this.children = children;\n        this.props.children = children;\n        if (props.ref) {\n            this.ref = props.ref;\n            delete props.ref;\n        }\n        if (props.key) {\n            this.key = props.key;\n            delete props.key;\n        }\n    }\n    VNode.prototype.walker = function () {\n        return new VNodeWalker(this);\n    };\n    VNode.removalNodes = [];\n    return VNode;\n}());\n\nfunction createTextNode(text) {\n    return new VNode('TEXT_NODE', { nodeValue: text }, []);\n}\nfunction excludeUnnecessaryChild(child, flatted) {\n    var vnode = child;\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    if (isBoolean_1(child) || child == null) {\n        vnode = null;\n    }\n    else if (isString_1(child) || isNumber_1(child)) {\n        vnode = createTextNode(String(child));\n    }\n    if (vnode) {\n        flatted.push(vnode);\n    }\n}\nfunction h(type, props) {\n    var children = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        children[_i - 2] = arguments[_i];\n    }\n    var flatted = [];\n    children.forEach(function (child) {\n        if (Array.isArray(child)) {\n            child.forEach(function (vnode) {\n                excludeUnnecessaryChild(vnode, flatted);\n            });\n        }\n        else {\n            excludeUnnecessaryChild(child, flatted);\n        }\n    });\n    return new VNode(type, props || {}, flatted);\n}\n// @ts-ignore\nvar html = html$1.bind(h);\n\n/**\n * @fileoverview Check whether the given variable is an object or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is an object or not.\n * If the given variable is an object, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is object?\n * @memberof module:type\n */\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\nvar isObject_1 = isObject;\n\n// @TODO: clearfy the type definition for CSSDeclaration\nfunction createNode(vnode) {\n    var node;\n    if (vnode.type === 'TEXT_NODE') {\n        node = document.createTextNode(vnode.props.nodeValue);\n    }\n    else {\n        node = document.createElement(vnode.type);\n        setProps(node, {}, vnode.props);\n    }\n    return node;\n}\nfunction removeNode(vnode, parentNode) {\n    if (vnode.node) {\n        parentNode.removeChild(vnode.node);\n    }\n    else {\n        removeNode(vnode.firstChild, parentNode);\n    }\n}\nfunction innerDiff(node, prevProps, nextProps) {\n    Object.keys(prevProps).forEach(function (propName) {\n        if (/^on/.test(propName)) {\n            if (!nextProps[propName] || prevProps[propName] !== nextProps[propName]) {\n                var eventName = propName.slice(2).toLowerCase();\n                node.removeEventListener(eventName, prevProps[propName]);\n            }\n        }\n        else if (propName !== 'children' && !nextProps[propName] && !isTextNode(node)) {\n            node.removeAttribute(propName);\n        }\n    });\n    setProps(node, prevProps, nextProps, function (propName) { return !shallowEqual(prevProps[propName], nextProps[propName]); });\n}\nvar reNonDimension = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\nfunction setProps(node, prevProps, props, condition) {\n    Object.keys(props).forEach(function (propName) {\n        if (!condition || condition(propName)) {\n            if (/^on/.test(propName)) {\n                var eventName = propName.slice(2).toLowerCase();\n                node.addEventListener(eventName, props[propName]);\n            }\n            else if (propName === 'nodeValue') {\n                node[propName] = props[propName];\n            }\n            else if (propName === 'style' && isObject_1(props[propName])) {\n                setStyleProps(node, prevProps[propName], props[propName]);\n            }\n            else if (propName !== 'children') {\n                if (props[propName] === false) {\n                    node.removeAttribute(propName);\n                }\n                else {\n                    node.setAttribute(propName, props[propName]);\n                }\n            }\n        }\n    });\n}\nfunction setStyleProps(node, prevStyleProps, styleProps) {\n    if (prevStyleProps) {\n        Object.keys(prevStyleProps).forEach(function (styleProp) {\n            // @ts-ignore\n            node.style[styleProp] = '';\n        });\n    }\n    Object.keys(styleProps).forEach(function (styleProp) {\n        var value = styleProps[styleProp];\n        // @ts-ignore\n        node.style[styleProp] =\n            isNumber_1(value) && !reNonDimension.test(styleProp) ? value + \"px\" : value;\n    });\n}\n\nfunction commit(vnode) {\n    VNode.removalNodes.forEach(function (removalNode) { return diff(removalNode); });\n    if (vnode) {\n        var next = void 0;\n        var walker = vnode.walker();\n        while ((next = walker.walk())) {\n            vnode = next.vnode;\n            if (next.entering) {\n                diff(vnode);\n            }\n            else if (isFunction_1(vnode.type)) {\n                var comp = vnode.component;\n                // lifecycle method\n                if (!vnode.old && comp.mounted) {\n                    comp.mounted();\n                }\n                if (vnode.old && comp.updated) {\n                    var prevProps = comp.prevProps || {};\n                    comp.updated(prevProps);\n                }\n            }\n        }\n    }\n}\nfunction getParentNode(vnode) {\n    var parent = vnode.parent;\n    while (!parent.node) {\n        parent = parent.parent;\n    }\n    return parent.node;\n}\nfunction diff(vnode) {\n    if (!vnode || !vnode.parent) {\n        return;\n    }\n    if (vnode.node) {\n        var parentNode = getParentNode(vnode);\n        if (vnode.effect === 'A') {\n            parentNode.appendChild(vnode.node);\n        }\n        else if (vnode.effect === 'U') {\n            innerDiff(vnode.node, vnode.old.props, vnode.props);\n        }\n    }\n    if (vnode.effect === 'D') {\n        var next = void 0;\n        var walker = vnode.walker();\n        while ((next = walker.walk())) {\n            vnode = next.vnode;\n            if (!next.entering) {\n                if (isFunction_1(vnode.type)) {\n                    var comp = vnode.component;\n                    // lifecycle method\n                    if (comp.beforeDestroy) {\n                        comp.beforeDestroy();\n                    }\n                }\n                else {\n                    var parentNode = getParentNode(vnode);\n                    removeNode(vnode, parentNode);\n                }\n            }\n        }\n    }\n    // apply ref\n    if (vnode.ref) {\n        if (vnode.component) {\n            vnode.ref(vnode.component);\n        }\n        else if (vnode.node) {\n            vnode.ref(vnode.node);\n        }\n    }\n}\n\nfunction createComponent(Comp, vnode) {\n    var props = vnode.props, component = vnode.component;\n    if (component) {\n        component.prevProps = component.props;\n        component.props = vnode.props;\n        return component;\n    }\n    return new Comp(props);\n}\nfunction buildVNode(vnode) {\n    var root = vnode;\n    while (vnode && !vnode.skip) {\n        if (isFunction_1(vnode.type)) {\n            var instance = createComponent(vnode.type, vnode);\n            instance.vnode = vnode;\n            vnode.component = instance;\n            vnode.props.children = vnode.children = [instance.render()];\n            buildChildrenVNode(vnode);\n        }\n        else {\n            if (!vnode.node) {\n                vnode.node = createNode(vnode);\n            }\n            buildChildrenVNode(vnode);\n        }\n        if (vnode.firstChild) {\n            vnode = vnode.firstChild;\n        }\n        else {\n            while (vnode && vnode.parent && !vnode.next) {\n                vnode = vnode.parent;\n                if (vnode === root) {\n                    break;\n                }\n            }\n            vnode = vnode.next;\n        }\n    }\n}\nfunction isSameType(old, vnode) {\n    return old && vnode && vnode.type === old.type && (!vnode.key || vnode.key === old.key);\n}\n// @TODO: add key diff algorithm\nfunction buildChildrenVNode(parent) {\n    var children = parent.children;\n    var old = parent.old ? parent.old.firstChild : null;\n    var prev = null;\n    children.forEach(function (vnode, index) {\n        var sameType = isSameType(old, vnode);\n        if (sameType) {\n            vnode.old = old;\n            vnode.parent = parent;\n            vnode.node = old.node;\n            vnode.component = old.component;\n            vnode.effect = 'U';\n        }\n        if (vnode && !sameType) {\n            vnode.old = null;\n            vnode.parent = parent;\n            vnode.node = null;\n            vnode.effect = 'A';\n        }\n        if (old && !sameType) {\n            VNode.removalNodes.push(old);\n            old.effect = 'D';\n        }\n        if (old) {\n            old = old.next;\n        }\n        if (index === 0) {\n            parent.firstChild = vnode;\n        }\n        else if (vnode) {\n            prev.next = vnode;\n        }\n        prev = vnode;\n    });\n    var lastChild = last$1(children);\n    if (!children.length) {\n        while (old) {\n            VNode.removalNodes.push(old);\n            old.effect = 'D';\n            old = old.next;\n        }\n    }\n    while (old && lastChild) {\n        if (old && lastChild.old !== old) {\n            VNode.removalNodes.push(old);\n            old.effect = 'D';\n            old = old.next;\n        }\n    }\n}\n\nfunction destroy(vnode) {\n    vnode.effect = 'D';\n    VNode.removalNodes = [vnode];\n    commit();\n    VNode.removalNodes = [];\n}\nfunction rerender(comp) {\n    var root = comp.vnode;\n    root.effect = 'U';\n    root.old = root;\n    // skip for unnecessary reconciliation\n    if (root.next) {\n        root.next.skip = true;\n    }\n    VNode.removalNodes = [];\n    buildVNode(root);\n    commit(root);\n    if (root.next) {\n        root.next.skip = false;\n    }\n}\nfunction render(container, vnode) {\n    var root = new VNode(container.tagName.toLowerCase(), {}, [vnode]);\n    root.node = container;\n    VNode.removalNodes = [];\n    buildVNode(root);\n    commit(root);\n    return function () { return destroy(root.firstChild); };\n}\n\nvar Component = /** @class */ (function () {\n    function Component(props) {\n        this.props = props;\n        this.state = {};\n        this.refs = {};\n    }\n    Component.prototype.setState = function (state) {\n        var newState = __assign$1(__assign$1({}, this.state), state);\n        if (!shallowEqual(this.state, newState)) {\n            this.state = newState;\n            rerender(this);\n        }\n    };\n    return Component;\n}());\n\nvar Switch = /** @class */ (function (_super) {\n    __extends$1(Switch, _super);\n    function Switch(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {\n            hide: false,\n        };\n        return _this;\n    }\n    Switch.prototype.show = function () {\n        this.setState({ hide: false });\n    };\n    Switch.prototype.hide = function () {\n        this.setState({ hide: true });\n    };\n    Switch.prototype.render = function () {\n        var _a = this.props, editorType = _a.editorType, eventEmitter = _a.eventEmitter;\n        return html(templateObject_1$h || (templateObject_1$h = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" style=\\\"display: \", \"\\\">\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\", \"\\n        >\\n          \", \"\\n        </div>\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\", \"\\n        >\\n          \", \"\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" style=\\\"display: \", \"\\\">\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\",\n            \"\\n        >\\n          \", \"\\n        </div>\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\",\n            \"\\n        >\\n          \", \"\\n        </div>\\n      </div>\\n    \"])), cls('mode-switch'), this.state.hide ? 'none' : 'block', editorType === 'markdown' ? ' active' : '', function () {\n            eventEmitter.emit('needChangeMode', 'markdown');\n        }, i18n.get('Markdown'), editorType === 'wysiwyg' ? ' active' : '', function () {\n            eventEmitter.emit('needChangeMode', 'wysiwyg');\n        }, i18n.get('WYSIWYG'));\n    };\n    return Switch;\n}(Component));\nvar templateObject_1$h;\n\n/**\n * @fileoverview Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed since the last time the debouced function was invoked.\n * @author NHN FE Development Lab <dl_javascript.nhn.com>\n */\n\n/**\n * @module tricks\n */\n\n/**\n * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed\n * since the last time the debouced function was invoked.\n * @param {function} fn The function to debounce.\n * @param {number} [delay=0] The number of milliseconds to delay\n * @returns {function} debounced function.\n * @memberof module:tricks\n * @example\n * // ES6\n * import debounce from 'tui-code-snippet/tricks/debounce';\n * \n * // CommonJS\n * const debounce = require('tui-code-snippet/tricks/debounce');\n *\n * function someMethodToInvokeDebounced() {}\n *\n * const debounced = debounce(someMethodToInvokeDebounced, 300);\n *\n * // invoke repeatedly\n * debounced();\n * debounced();\n * debounced();\n * debounced();\n * debounced();\n * debounced();    // last invoke of debounced()\n *\n * // invoke someMethodToInvokeDebounced() after 300 milliseconds.\n */\nfunction debounce$1(fn, delay) {\n  var timer, args;\n\n  /* istanbul ignore next */\n  delay = delay || 0;\n\n  function debounced() { // eslint-disable-line require-jsdoc\n    args = Array.prototype.slice.call(arguments);\n\n    window.clearTimeout(timer);\n    timer = window.setTimeout(function() {\n      fn.apply(null, args);\n    }, delay);\n  }\n\n  return debounced;\n}\n\nvar debounce_1 = debounce$1;\n\n/**\n * @fileoverview Creates a throttled function that only invokes fn at most once per every interval milliseconds.\n * @author NHN FE Development Lab <dl_javascript.nhn.com>\n */\n\nvar debounce = debounce_1;\n\n/**\n * Creates a throttled function that only invokes fn at most once per every interval milliseconds.\n * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)\n * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.\n * @param {function} fn function to throttle\n * @param {number} [interval=0] the number of milliseconds to throttle invocations to.\n * @returns {function} throttled function\n * @memberof module:tricks\n * @example\n * // ES6\n * import throttle from 'tui-code-snippet/tricks/throttle';\n * \n * // CommonJS\n * const throttle = require('tui-code-snippet/tricks/throttle');\n *\n * function someMethodToInvokeThrottled() {}\n *\n * const throttled = throttle(someMethodToInvokeThrottled, 300);\n *\n * // invoke repeatedly\n * throttled();    // invoke (leading)\n * throttled();\n * throttled();    // invoke (near 300 milliseconds)\n * throttled();\n * throttled();\n * throttled();    // invoke (near 600 milliseconds)\n * // ...\n * // invoke (trailing)\n *\n * // if you need reuse throttled method. then invoke reset()\n * throttled.reset();\n */\nfunction throttle$1(fn, interval) {\n  var base;\n  var isLeading = true;\n  var tick = function(_args) {\n    fn.apply(null, _args);\n    base = null;\n  };\n  var debounced, stamp, args;\n\n  /* istanbul ignore next */\n  interval = interval || 0;\n\n  debounced = debounce(tick, interval);\n\n  function throttled() { // eslint-disable-line require-jsdoc\n    args = Array.prototype.slice.call(arguments);\n\n    if (isLeading) {\n      tick(args);\n      isLeading = false;\n\n      return;\n    }\n\n    stamp = Number(new Date());\n\n    base = base || stamp;\n\n    // pass array directly because `debounce()`, `tick()` are already use\n    // `apply()` method to invoke developer's `fn` handler.\n    //\n    // also, this `debounced` line invoked every time for implements\n    // `trailing` features.\n    debounced(args);\n\n    if ((stamp - base) >= interval) {\n      tick(args);\n    }\n  }\n\n  function reset() { // eslint-disable-line require-jsdoc\n    isLeading = true;\n    base = null;\n  }\n\n  throttled.reset = reset;\n\n  return throttled;\n}\n\nvar throttle_1 = throttle$1;\n\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nvar HeadingPopupBody = /** @class */ (function (_super) {\n    __extends$1(HeadingPopupBody, _super);\n    function HeadingPopupBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    HeadingPopupBody.prototype.execCommand = function (ev) {\n        var el = closest(ev.target, 'li');\n        this.props.execCommand('heading', {\n            level: Number(el.getAttribute('data-level')),\n        });\n    };\n    HeadingPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject([\"\\n      <ul\\n        onClick=\", \"\\n        aria-role=\\\"menu\\\"\\n        aria-label=\\\"\", \"\\\"\\n      >\\n        \", \"\\n        <li data-type=\\\"Paragraph\\\" aria-role=\\\"menuitem\\\">\\n          <div>\", \"</div>\\n        </li>\\n      </ul>\\n    \"], [\"\\n      <ul\\n        onClick=\", \"\\n        aria-role=\\\"menu\\\"\\n        aria-label=\\\"\", \"\\\"\\n      >\\n        \",\n            \"\\n        <li data-type=\\\"Paragraph\\\" aria-role=\\\"menuitem\\\">\\n          <div>\", \"</div>\\n        </li>\\n      </ul>\\n    \"])), function (ev) { return _this.execCommand(ev); }, i18n.get('Headings'), [1, 2, 3, 4, 5, 6].map(function (level) {\n            return html(templateObject_1$g || (templateObject_1$g = __makeTemplateObject([\"\\n              <li data-level=\\\"\", \"\\\" data-type=\\\"Heading\\\" aria-role=\\\"menuitem\\\">\\n                <\", \">\", \" \", \"</$>\\n              </li>\\n            \"], [\"\\n              <li data-level=\\\"\", \"\\\" data-type=\\\"Heading\\\" aria-role=\\\"menuitem\\\">\\n                <\", \">\", \" \", \"</$>\\n              </li>\\n            \"])), level, \"h\" + level, i18n.get('Heading'), level);\n        }), i18n.get('Paragraph'));\n    };\n    return HeadingPopupBody;\n}(Component));\nvar templateObject_1$g, templateObject_2$8;\n\nvar Tabs = /** @class */ (function (_super) {\n    __extends$1(Tabs, _super);\n    function Tabs() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Tabs.prototype.toggleTab = function (ev, activeTab) {\n        this.props.onClick(ev, activeTab);\n    };\n    Tabs.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" aria-role=\\\"tabpanel\\\">\\n        \", \"\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" aria-role=\\\"tabpanel\\\">\\n        \",\n            \"\\n      </div>\\n    \"])), cls('tabs'), this.props.tabs.map(function (_a) {\n            var name = _a.name, text = _a.text;\n            var isActive = _this.props.activeTab === name;\n            return html(templateObject_1$f || (templateObject_1$f = __makeTemplateObject([\"\\n            <div\\n              class=\\\"tab-item\", \"\\\"\\n              onClick=\", \"\\n              aria-role=\\\"tab\\\"\\n              aria-label=\\\"\", \"\\\"\\n              aria-selected=\\\"\", \"\\\"\\n              tabindex=\\\"\", \"\\\"\\n            >\\n              \", \"\\n            </div>\\n          \"], [\"\\n            <div\\n              class=\\\"tab-item\", \"\\\"\\n              onClick=\", \"\\n              aria-role=\\\"tab\\\"\\n              aria-label=\\\"\", \"\\\"\\n              aria-selected=\\\"\", \"\\\"\\n              tabindex=\\\"\", \"\\\"\\n            >\\n              \", \"\\n            </div>\\n          \"])), isActive ? ' active' : '', function (ev) { return _this.toggleTab(ev, name); }, i18n.get(text), isActive ? 'true' : 'false', isActive ? '0' : '-1', i18n.get(text));\n        }));\n    };\n    return Tabs;\n}(Component));\nvar templateObject_1$f, templateObject_2$7;\n\nvar TYPE_UI = 'ui';\nvar ImagePopupBody = /** @class */ (function (_super) {\n    __extends$1(ImagePopupBody, _super);\n    function ImagePopupBody(props) {\n        var _this = _super.call(this, props) || this;\n        _this.initialize = function (activeTab) {\n            if (activeTab === void 0) { activeTab = 'file'; }\n            var urlEl = _this.refs.url;\n            urlEl.value = '';\n            _this.refs.altText.value = '';\n            _this.refs.file.value = '';\n            removeClass_1(urlEl, 'wrong');\n            _this.setState({ activeTab: activeTab, file: null, fileNameElClassName: '' });\n        };\n        _this.execCommand = function () {\n            if (_this.state.activeTab === 'file') {\n                _this.emitAddImageBlob();\n            }\n            else {\n                _this.emitAddImage();\n            }\n        };\n        _this.toggleTab = function (_, activeTab) {\n            if (activeTab !== _this.state.activeTab) {\n                _this.initialize(activeTab);\n            }\n        };\n        _this.showFileSelectBox = function () {\n            _this.refs.file.click();\n        };\n        _this.changeFile = function (ev) {\n            var files = ev.target.files;\n            if (files === null || files === void 0 ? void 0 : files.length) {\n                _this.setState({ file: files[0] });\n            }\n        };\n        _this.state = { activeTab: 'file', file: null, fileNameElClassName: '' };\n        _this.tabs = [\n            { name: 'file', text: 'File' },\n            { name: 'url', text: 'URL' },\n        ];\n        return _this;\n    }\n    ImagePopupBody.prototype.emitAddImageBlob = function () {\n        var _this = this;\n        var files = this.refs.file.files;\n        var altTextEl = this.refs.altText;\n        var fileNameElClassName = ' wrong';\n        if (files === null || files === void 0 ? void 0 : files.length) {\n            fileNameElClassName = '';\n            var imageFile = files.item(0);\n            var hookCallback = function (url, text) {\n                return _this.props.execCommand('addImage', { imageUrl: url, altText: text || altTextEl.value });\n            };\n            this.props.eventEmitter.emit('addImageBlobHook', imageFile, hookCallback, TYPE_UI);\n        }\n        this.setState({ fileNameElClassName: fileNameElClassName });\n    };\n    ImagePopupBody.prototype.emitAddImage = function () {\n        var imageUrlEl = this.refs.url;\n        var altTextEl = this.refs.altText;\n        var imageUrl = imageUrlEl.value;\n        var altText = altTextEl.value || 'image';\n        removeClass_1(imageUrlEl, 'wrong');\n        if (!imageUrl.length) {\n            addClass_1(imageUrlEl, 'wrong');\n            return;\n        }\n        if (imageUrl) {\n            this.props.execCommand('addImage', { imageUrl: imageUrl, altText: altText });\n        }\n    };\n    ImagePopupBody.prototype.preventSelectStart = function (ev) {\n        ev.preventDefault();\n    };\n    ImagePopupBody.prototype.updated = function () {\n        if (!this.props.show) {\n            this.initialize();\n        }\n    };\n    ImagePopupBody.prototype.render = function () {\n        var _this = this;\n        var _a = this.state, activeTab = _a.activeTab, file = _a.file, fileNameElClassName = _a.fileNameElClassName;\n        return html(templateObject_1$e || (templateObject_1$e = __makeTemplateObject([\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        <div style=\\\"display:\", \"\\\">\\n          <label for=\\\"toastuiImageUrlInput\\\">\", \"</label>\\n          <input\\n            id=\\\"toastuiImageUrlInput\\\"\\n            type=\\\"text\\\"\\n            ref=\", \"\\n          />\\n        </div>\\n        <div style=\\\"display:\", \";position: relative;\\\">\\n          <label for=\\\"toastuiImageFileInput\\\">\", \"</label>\\n          <span\\n            class=\\\"\", \"\", \"\\\"\\n            onClick=\", \"\\n            onSelectstart=\", \"\\n          >\\n            \", \"\\n          </span>\\n          <button\\n            type=\\\"button\\\"\\n            class=\\\"\", \"\\\"\\n            onClick=\", \"\\n          >\\n            \", \"\\n          </button>\\n          <input\\n            id=\\\"toastuiImageFileInput\\\"\\n            type=\\\"file\\\"\\n            accept=\\\"image/*\\\"\\n            onChange=\", \"\\n            ref=\", \"\\n          />\\n        </div>\\n        <label for=\\\"toastuiAltTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiAltTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        <div style=\\\"display:\", \"\\\">\\n          <label for=\\\"toastuiImageUrlInput\\\">\", \"</label>\\n          <input\\n            id=\\\"toastuiImageUrlInput\\\"\\n            type=\\\"text\\\"\\n            ref=\", \"\\n          />\\n        </div>\\n        <div style=\\\"display:\", \";position: relative;\\\">\\n          <label for=\\\"toastuiImageFileInput\\\">\", \"</label>\\n          <span\\n            class=\\\"\", \"\", \"\\\"\\n            onClick=\", \"\\n            onSelectstart=\", \"\\n          >\\n            \", \"\\n          </span>\\n          <button\\n            type=\\\"button\\\"\\n            class=\\\"\", \"\\\"\\n            onClick=\", \"\\n          >\\n            \", \"\\n          </button>\\n          <input\\n            id=\\\"toastuiImageFileInput\\\"\\n            type=\\\"file\\\"\\n            accept=\\\"image/*\\\"\\n            onChange=\", \"\\n            ref=\", \"\\n          />\\n        </div>\\n        <label for=\\\"toastuiAltTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiAltTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"])), i18n.get('Insert image'), Tabs, this.tabs, activeTab, this.toggleTab, activeTab === 'url' ? 'block' : 'none', i18n.get('Image URL'), function (el) { return (_this.refs.url = el); }, activeTab === 'file' ? 'block' : 'none', i18n.get('Select image file'), cls('file-name'), file ? ' has-file' : fileNameElClassName, this.showFileSelectBox, this.preventSelectStart, file ? file.name : i18n.get('No file'), cls('file-select-button'), this.showFileSelectBox, i18n.get('Choose a file'), this.changeFile, function (el) { return (_this.refs.file = el); }, i18n.get('Description'), function (el) { return (_this.refs.altText = el); }, cls('button-container'), cls('close-button'), this.props.hidePopup, i18n.get('Cancel'), cls('ok-button'), this.execCommand, i18n.get('OK'));\n    };\n    return ImagePopupBody;\n}(Component));\nvar templateObject_1$e;\n\nvar LinkPopupBody = /** @class */ (function (_super) {\n    __extends$1(LinkPopupBody, _super);\n    function LinkPopupBody() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.execCommand = function () {\n            var linkUrlEl = _this.refs.url;\n            var linkTextEl = _this.refs.text;\n            removeClass_1(linkUrlEl, 'wrong');\n            removeClass_1(linkTextEl, 'wrong');\n            if (linkUrlEl.value.length < 1) {\n                addClass_1(linkUrlEl, 'wrong');\n                return;\n            }\n            var checkLinkText = isUndefined_1(_this.props.initialValues.linkUrl);\n            if (checkLinkText && linkTextEl.value.length < 1) {\n                addClass_1(linkTextEl, 'wrong');\n                return;\n            }\n            _this.props.execCommand('addLink', {\n                linkUrl: linkUrlEl.value,\n                linkText: linkTextEl.value,\n            });\n        };\n        return _this;\n    }\n    LinkPopupBody.prototype.initialize = function () {\n        var _a = this.props.initialValues, linkUrl = _a.linkUrl, linkText = _a.linkText;\n        var linkUrlEl = this.refs.url;\n        var linkTextEl = this.refs.text;\n        removeClass_1(linkUrlEl, 'wrong');\n        removeClass_1(linkTextEl, 'wrong', 'disabled');\n        linkTextEl.removeAttribute('disabled');\n        if (linkUrl) {\n            addClass_1(linkTextEl, 'disabled');\n            linkTextEl.setAttribute('disabled', 'disabled');\n        }\n        linkUrlEl.value = linkUrl || '';\n        linkTextEl.value = linkText || '';\n    };\n    LinkPopupBody.prototype.mounted = function () {\n        this.initialize();\n    };\n    LinkPopupBody.prototype.updated = function (prevProps) {\n        if (!prevProps.show && this.props.show) {\n            this.initialize();\n        }\n    };\n    LinkPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_1$d || (templateObject_1$d = __makeTemplateObject([\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <label for=\\\"toastuiLinkUrlInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkUrlInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <label for=\\\"toastuiLinkTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <label for=\\\"toastuiLinkUrlInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkUrlInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <label for=\\\"toastuiLinkTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"])), i18n.get('Insert link'), i18n.get('URL'), function (el) { return (_this.refs.url = el); }, i18n.get('Link text'), function (el) { return (_this.refs.text = el); }, cls('button-container'), cls('close-button'), this.props.hidePopup, i18n.get('Cancel'), cls('ok-button'), this.execCommand, i18n.get('OK'));\n    };\n    return LinkPopupBody;\n}(Component));\nvar templateObject_1$d;\n\nvar CELL_WIDTH = 20;\nvar CELL_HEIGHT = 20;\nvar MIN_ROW_INDEX = 5;\nvar MAX_ROW_INDEX = 14;\nvar MIN_COL_INDEX = 5;\nvar MAX_COL_INDEX = 9;\nvar MIN_ROW_SELECTION_INDEX = 1;\nvar MIN_COL_SELECTION_INDEX = 1;\nvar BORDER_WIDTH = 1;\nvar TablePopupBody = /** @class */ (function (_super) {\n    __extends$1(TablePopupBody, _super);\n    function TablePopupBody(props) {\n        var _this = _super.call(this, props) || this;\n        _this.extendSelectionRange = function (_a) {\n            var pageX = _a.pageX, pageY = _a.pageY;\n            var x = pageX - _this.offsetRect.left;\n            var y = pageY - _this.offsetRect.top;\n            var range = _this.getSelectionRangeByOffset(x, y);\n            _this.setState(__assign$1({}, range));\n        };\n        _this.execCommand = function () {\n            _this.props.execCommand('addTable', {\n                rowCount: _this.state.rowIdx + 1,\n                columnCount: _this.state.colIdx + 1,\n            });\n        };\n        _this.state = {\n            rowIdx: -1,\n            colIdx: -1,\n        };\n        return _this;\n    }\n    TablePopupBody.prototype.getDescription = function () {\n        return this.state.colIdx === -1 ? '' : this.state.colIdx + 1 + \" x \" + (this.state.rowIdx + 1);\n    };\n    TablePopupBody.prototype.getBoundByRange = function (colIdx, rowIdx) {\n        return {\n            width: (colIdx + 1) * CELL_WIDTH,\n            height: (rowIdx + 1) * CELL_HEIGHT,\n        };\n    };\n    TablePopupBody.prototype.getRangeByOffset = function (x, y) {\n        return {\n            colIdx: Math.floor(x / CELL_WIDTH),\n            rowIdx: Math.floor(y / CELL_HEIGHT),\n        };\n    };\n    TablePopupBody.prototype.getTableRange = function () {\n        var _a = this.state, orgColIdx = _a.colIdx, orgRowIdx = _a.rowIdx;\n        var colIdx = Math.max(orgColIdx, MIN_COL_INDEX);\n        var rowIdx = Math.max(orgRowIdx, MIN_ROW_INDEX);\n        if (orgColIdx >= MIN_COL_INDEX && colIdx < MAX_COL_INDEX) {\n            colIdx += 1;\n        }\n        if (orgRowIdx >= MIN_ROW_INDEX && rowIdx < MAX_ROW_INDEX) {\n            rowIdx += 1;\n        }\n        return { colIdx: colIdx + 1, rowIdx: rowIdx + 1 };\n    };\n    TablePopupBody.prototype.getSelectionAreaBound = function () {\n        var _a = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), width = _a.width, height = _a.height;\n        if (!width && !height) {\n            return { display: 'none' };\n        }\n        return { width: width - BORDER_WIDTH, height: height - BORDER_WIDTH, display: 'block' };\n    };\n    TablePopupBody.prototype.getSelectionRangeByOffset = function (x, y) {\n        var range = this.getRangeByOffset(x, y);\n        range.rowIdx = Math.min(Math.max(range.rowIdx, MIN_ROW_SELECTION_INDEX), MAX_ROW_INDEX);\n        range.colIdx = Math.min(Math.max(range.colIdx, MIN_COL_SELECTION_INDEX), MAX_COL_INDEX);\n        return range;\n    };\n    TablePopupBody.prototype.updated = function () {\n        if (!this.props.show) {\n            this.setState({ colIdx: -1, rowIdx: -1 });\n        }\n        else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {\n            var _a = this.refs.tableEl.getBoundingClientRect(), left = _a.left, top_1 = _a.top;\n            this.offsetRect = {\n                left: window.pageXOffset + left,\n                top: window.pageYOffset + top_1,\n            };\n        }\n    };\n    TablePopupBody.prototype.createTableArea = function (tableRange) {\n        var colIdx = tableRange.colIdx, rowIdx = tableRange.rowIdx;\n        var rows = [];\n        for (var i = 0; i < rowIdx; i += 1) {\n            var cells = [];\n            for (var j = 0; j < colIdx; j += 1) {\n                var cellClassNames = \"\" + cls('table-cell') + (i > 0 ? '' : ' header');\n                cells.push(html(templateObject_1$c || (templateObject_1$c = __makeTemplateObject([\"<div class=\\\"\", \"\\\"></div>\"], [\"<div class=\\\"\", \"\\\"></div>\"])), cellClassNames));\n            }\n            rows.push(html(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject([\"<div class=\\\"\", \"\\\">\", \"</div>\"], [\"<div class=\\\"\", \"\\\">\", \"</div>\"])), cls('table-row'), cells));\n        }\n        return html(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject([\"<div class=\\\"\", \"\\\">\", \"</div>\"], [\"<div class=\\\"\", \"\\\">\", \"</div>\"])), cls('table'), rows);\n    };\n    TablePopupBody.prototype.render = function () {\n        var _this = this;\n        var tableRange = this.getTableRange();\n        var selectionAreaBound = this.getSelectionAreaBound();\n        return html(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject([\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          onMousemove=\", \"\\n          onClick=\", \"\\n        >\\n          \", \"\\n          <div class=\\\"\", \"\\\" style=\", \"></div>\\n        </div>\\n        <p class=\\\"\", \"\\\">\", \"</p>\\n      </div>\\n    \"], [\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          onMousemove=\", \"\\n          onClick=\", \"\\n        >\\n          \", \"\\n          <div class=\\\"\", \"\\\" style=\", \"></div>\\n        </div>\\n        <p class=\\\"\", \"\\\">\", \"</p>\\n      </div>\\n    \"])), i18n.get('Insert table'), cls('table-selection'), function (el) { return (_this.refs.tableEl = el); }, this.extendSelectionRange, this.execCommand, this.createTableArea(tableRange), cls('table-selection-layer'), selectionAreaBound, cls('table-description'), this.getDescription());\n    };\n    return TablePopupBody;\n}(Component));\nvar templateObject_1$c, templateObject_2$6, templateObject_3$2, templateObject_4$1;\n\nvar CustomPopupBody = /** @class */ (function (_super) {\n    __extends$1(CustomPopupBody, _super);\n    function CustomPopupBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CustomPopupBody.prototype.mounted = function () {\n        // append the custom popup body element\n        this.refs.el.appendChild(this.props.body);\n    };\n    CustomPopupBody.prototype.updated = function (prevProps) {\n        // update custom popup element\n        this.refs.el.replaceChild(this.props.body, prevProps.body);\n    };\n    CustomPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_1$b || (templateObject_1$b = __makeTemplateObject([\"<div ref=\", \"></div>\"], [\"<div ref=\", \"></div>\"])), function (el) { return (_this.refs.el = el); });\n    };\n    return CustomPopupBody;\n}(Component));\nvar templateObject_1$b;\n\nfunction createToolbarItemInfo(type) {\n    return isString_1(type) ? createDefaultToolbarItemInfo(type) : type;\n}\nfunction createScrollSyncToolbarItem() {\n    var label = document.createElement('label');\n    var checkbox = document.createElement('input');\n    var toggleSwitch = document.createElement('span');\n    label.className = 'scroll-sync active';\n    checkbox.type = 'checkbox';\n    checkbox.checked = true;\n    toggleSwitch.className = 'switch';\n    var onMounted = function (execCommand) {\n        return checkbox.addEventListener('change', function (ev) {\n            var checked = ev.target.checked;\n            if (checked) {\n                addClass_1(label, 'active');\n            }\n            else {\n                removeClass_1(label, 'active');\n            }\n            execCommand('toggleScrollSync', { active: checked });\n        });\n    };\n    label.appendChild(checkbox);\n    label.appendChild(toggleSwitch);\n    return {\n        name: 'scrollSync',\n        el: label,\n        onMounted: onMounted,\n    };\n}\nfunction createDefaultToolbarItemInfo(type) {\n    var info;\n    switch (type) {\n        case 'heading':\n            info = {\n                name: 'heading',\n                className: 'heading',\n                tooltip: i18n.get('Headings'),\n                state: 'heading',\n            };\n            break;\n        case 'bold':\n            info = {\n                name: 'bold',\n                className: 'bold',\n                command: 'bold',\n                tooltip: i18n.get('Bold'),\n                state: 'strong',\n            };\n            break;\n        case 'italic':\n            info = {\n                name: 'italic',\n                className: 'italic',\n                command: 'italic',\n                tooltip: i18n.get('Italic'),\n                state: 'emph',\n            };\n            break;\n        case 'strike':\n            info = {\n                name: 'strike',\n                className: 'strike',\n                command: 'strike',\n                tooltip: i18n.get('Strike'),\n                state: 'strike',\n            };\n            break;\n        case 'hr':\n            info = {\n                name: 'hr',\n                className: 'hrline',\n                command: 'hr',\n                tooltip: i18n.get('Line'),\n                state: 'thematicBreak',\n            };\n            break;\n        case 'quote':\n            info = {\n                name: 'quote',\n                className: 'quote',\n                command: 'blockQuote',\n                tooltip: i18n.get('Blockquote'),\n                state: 'blockQuote',\n            };\n            break;\n        case 'ul':\n            info = {\n                name: 'ul',\n                className: 'bullet-list',\n                command: 'bulletList',\n                tooltip: i18n.get('Unordered list'),\n                state: 'bulletList',\n            };\n            break;\n        case 'ol':\n            info = {\n                name: 'ol',\n                className: 'ordered-list',\n                command: 'orderedList',\n                tooltip: i18n.get('Ordered list'),\n                state: 'orderedList',\n            };\n            break;\n        case 'task':\n            info = {\n                name: 'task',\n                className: 'task-list',\n                command: 'taskList',\n                tooltip: i18n.get('Task'),\n                state: 'taskList',\n            };\n            break;\n        case 'table':\n            info = {\n                name: 'table',\n                className: 'table',\n                tooltip: i18n.get('Insert table'),\n                state: 'table',\n            };\n            break;\n        case 'image':\n            info = {\n                name: 'image',\n                className: 'image',\n                tooltip: i18n.get('Insert image'),\n            };\n            break;\n        case 'link':\n            info = {\n                name: 'link',\n                className: 'link',\n                tooltip: i18n.get('Insert link'),\n            };\n            break;\n        case 'code':\n            info = {\n                name: 'code',\n                className: 'code',\n                command: 'code',\n                tooltip: i18n.get('Code'),\n                state: 'code',\n            };\n            break;\n        case 'codeblock':\n            info = {\n                name: 'codeblock',\n                className: 'codeblock',\n                command: 'codeBlock',\n                tooltip: i18n.get('Insert CodeBlock'),\n                state: 'codeBlock',\n            };\n            break;\n        case 'indent':\n            info = {\n                name: 'indent',\n                className: 'indent',\n                command: 'indent',\n                tooltip: i18n.get('Indent'),\n                state: 'indent',\n            };\n            break;\n        case 'outdent':\n            info = {\n                name: 'outdent',\n                className: 'outdent',\n                command: 'outdent',\n                tooltip: i18n.get('Outdent'),\n                state: 'outdent',\n            };\n            break;\n        case 'scrollSync':\n            info = createScrollSyncToolbarItem();\n            break;\n        case 'more':\n            info = {\n                name: 'more',\n                className: 'more',\n                tooltip: i18n.get('More'),\n            };\n            break;\n        // do nothing\n    }\n    if (info.name !== 'scrollSync') {\n        info.className += \" \" + cls('toolbar-icons');\n    }\n    return info;\n}\nfunction createPopupInfo(type, payload) {\n    var el = payload.el, pos = payload.pos, popup = payload.popup, initialValues = payload.initialValues;\n    switch (type) {\n        case 'heading':\n            return {\n                render: function (props) { return html(templateObject_1$a || (templateObject_1$a = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), HeadingPopupBody, props); },\n                className: cls('popup-add-heading'),\n                fromEl: el,\n                pos: pos,\n            };\n        case 'link':\n            return {\n                render: function (props) { return html(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), LinkPopupBody, props); },\n                className: cls('popup-add-link'),\n                fromEl: el,\n                pos: pos,\n                initialValues: initialValues,\n            };\n        case 'image':\n            return {\n                render: function (props) { return html(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), ImagePopupBody, props); },\n                className: cls('popup-add-image'),\n                fromEl: el,\n                pos: pos,\n            };\n        case 'table':\n            return {\n                render: function (props) { return html(templateObject_4 || (templateObject_4 = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), TablePopupBody, props); },\n                className: cls('popup-add-table'),\n                fromEl: el,\n                pos: pos,\n            };\n        case 'customPopupBody':\n            if (!popup) {\n                return null;\n            }\n            return __assign$1({ render: function (props) { return html(templateObject_5 || (templateObject_5 = __makeTemplateObject([\"<\", \" ...\", \" body=\", \" />\"], [\"<\", \" ...\", \" body=\", \" />\"])), CustomPopupBody, props, popup.body); }, fromEl: el, pos: pos }, popup);\n        default:\n            return null;\n    }\n}\nfunction setGroupState(group) {\n    group.hidden = group.length === group.filter(function (info) { return info.hidden; }).length;\n}\nfunction groupToolbarItems(toolbarItems, hiddenScrollSync) {\n    var toggleScrollSyncState = function (item) {\n        item.hidden = item.name === 'scrollSync' && hiddenScrollSync;\n        return item;\n    };\n    return toolbarItems.reduce(function (acc, item) {\n        acc.push(item.map(function (type) { return toggleScrollSyncState(createToolbarItemInfo(type)); }));\n        var group = acc[(acc.length || 1) - 1];\n        if (group) {\n            setGroupState(group);\n        }\n        return acc;\n    }, []);\n}\nfunction toggleScrollSync(toolbarItems, hiddenScrollSync) {\n    toolbarItems.forEach(function (group) {\n        group.forEach(function (item) { return (item.hidden = item.name === 'scrollSync' && hiddenScrollSync); });\n        setGroupState(group);\n    });\n}\nvar templateObject_1$a, templateObject_2$5, templateObject_3$1, templateObject_4, templateObject_5;\n\nvar MARGIN_FROM_RIGHT_SIDE = 20;\nvar Popup = /** @class */ (function (_super) {\n    __extends$1(Popup, _super);\n    function Popup() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleMousedown = function (ev) {\n            if (!closest(ev.target, \".\" + cls('popup')) &&\n                !closest(ev.target, _this.props.info.fromEl)) {\n                _this.props.hidePopup();\n            }\n        };\n        return _this;\n    }\n    Popup.prototype.mounted = function () {\n        document.addEventListener('mousedown', this.handleMousedown);\n        this.props.eventEmitter.listen('closePopup', this.props.hidePopup);\n    };\n    Popup.prototype.beforeDestroy = function () {\n        document.removeEventListener('mousedown', this.handleMousedown);\n    };\n    Popup.prototype.updated = function (prevProps) {\n        var _a = this.props, show = _a.show, info = _a.info;\n        if (show && info.pos && prevProps.show !== show) {\n            var popupPos = __assign$1({}, info.pos);\n            var offsetWidth = this.refs.el.offsetWidth;\n            var toolbarEl = closest(this.refs.el, \".\" + cls('toolbar'));\n            var toolbarOffsetWidth = toolbarEl.offsetWidth;\n            if (popupPos.left + offsetWidth >= toolbarOffsetWidth) {\n                popupPos.left = toolbarOffsetWidth - offsetWidth - MARGIN_FROM_RIGHT_SIDE;\n            }\n            if (!shallowEqual(this.state.popupPos, popupPos)) {\n                this.setState({ popupPos: popupPos });\n            }\n        }\n    };\n    Popup.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, info = _a.info, show = _a.show, hidePopup = _a.hidePopup, eventEmitter = _a.eventEmitter, execCommand = _a.execCommand;\n        var _b = info || {}, _c = _b.className, className = _c === void 0 ? '' : _c, style = _b.style, render = _b.render, _d = _b.initialValues, initialValues = _d === void 0 ? {} : _d;\n        var popupStyle = __assign$1(__assign$1({ display: show ? 'block' : 'none' }, style), this.state.popupPos);\n        return html(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject([\"\\n      <div\\n        class=\\\"\", \" \", \"\\\"\\n        style=\", \"\\n        ref=\", \"\\n        aria-role=\\\"dialog\\\"\\n      >\\n        <div class=\\\"\", \"\\\">\\n          \", \"\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div\\n        class=\\\"\", \" \", \"\\\"\\n        style=\", \"\\n        ref=\", \"\\n        aria-role=\\\"dialog\\\"\\n      >\\n        <div class=\\\"\", \"\\\">\\n          \", \"\\n        </div>\\n      </div>\\n    \"])), cls('popup'), className, popupStyle, function (el) { return (_this.refs.el = el); }, cls('popup-body'), render && render({ eventEmitter: eventEmitter, show: show, hidePopup: hidePopup, execCommand: execCommand, initialValues: initialValues }));\n    };\n    return Popup;\n}(Component));\nvar templateObject_1$9;\n\nvar TOOLTIP_INDENT = 6;\nfunction connectHOC(WrappedComponent) {\n    return /** @class */ (function (_super) {\n        __extends$1(ButtonHOC, _super);\n        function ButtonHOC(props) {\n            var _this = _super.call(this, props) || this;\n            _this.showTooltip = function (el) {\n                var tooltip = _this.props.item.tooltip;\n                if (!_this.props.disabled && tooltip) {\n                    var bound = _this.getBound(el);\n                    var left = bound.left + TOOLTIP_INDENT + \"px\";\n                    var top_1 = bound.top + TOOLTIP_INDENT + \"px\";\n                    css_1(_this.props.tooltipRef.current, { display: 'block', left: left, top: top_1 });\n                    _this.props.tooltipRef.current.querySelector('.text').textContent = tooltip;\n                }\n            };\n            _this.hideTooltip = function () {\n                css_1(_this.props.tooltipRef.current, 'display', 'none');\n            };\n            _this.state = { active: false, disabled: props.disabled };\n            _this.addEvent();\n            return _this;\n        }\n        ButtonHOC.prototype.addEvent = function () {\n            var _this = this;\n            var _a = this.props, item = _a.item, eventEmitter = _a.eventEmitter;\n            if (item.state) {\n                eventEmitter.listen('changeToolbarState', function (_a) {\n                    var _b;\n                    var toolbarState = _a.toolbarState;\n                    var _c = (_b = toolbarState[item.state]) !== null && _b !== void 0 ? _b : {}, active = _c.active, disabled = _c.disabled;\n                    _this.setState({ active: !!active, disabled: disabled !== null && disabled !== void 0 ? disabled : _this.props.disabled });\n                });\n            }\n        };\n        ButtonHOC.prototype.getBound = function (el) {\n            var _a = getTotalOffset(el, closest(el, \".\" + cls('toolbar'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;\n            return { left: offsetLeft, top: el.offsetHeight + offsetTop };\n        };\n        ButtonHOC.prototype.render = function () {\n            return html(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject([\"\\n        <\", \"\\n          ...\", \"\\n          active=\", \"\\n          showTooltip=\", \"\\n          hideTooltip=\", \"\\n          getBound=\", \"\\n          disabled=\", \"\\n        />\\n      \"], [\"\\n        <\", \"\\n          ...\", \"\\n          active=\", \"\\n          showTooltip=\", \"\\n          hideTooltip=\", \"\\n          getBound=\", \"\\n          disabled=\", \"\\n        />\\n      \"])), WrappedComponent, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);\n        };\n        return ButtonHOC;\n    }(Component));\n}\nvar templateObject_1$8;\n\nvar DEFAULT_WIDTH = 80;\nvar ToolbarButtonComp = /** @class */ (function (_super) {\n    __extends$1(ToolbarButtonComp, _super);\n    function ToolbarButtonComp() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.execCommand = function () {\n            var _a = _this.props, item = _a.item, execCommand = _a.execCommand, setPopupInfo = _a.setPopupInfo, getBound = _a.getBound, eventEmitter = _a.eventEmitter;\n            var command = item.command, name = item.name, popup = item.popup;\n            if (command) {\n                execCommand(command);\n            }\n            else {\n                var popupName = popup ? 'customPopupBody' : name;\n                var initialValues = eventEmitter.emit('query', 'getPopupInitialValues', { popupName: popupName })[0];\n                var info = createPopupInfo(popupName, {\n                    el: _this.refs.el,\n                    pos: getBound(_this.refs.el),\n                    popup: popup,\n                    initialValues: initialValues,\n                });\n                if (info) {\n                    setPopupInfo(info);\n                }\n            }\n        };\n        return _this;\n    }\n    ToolbarButtonComp.prototype.mounted = function () {\n        this.setItemWidth();\n    };\n    ToolbarButtonComp.prototype.updated = function (prevProps) {\n        if (prevProps.item.name !== this.props.item.name) {\n            this.setItemWidth();\n        }\n    };\n    ToolbarButtonComp.prototype.setItemWidth = function () {\n        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;\n        // set width only if it is not a dropdown toolbar\n        if (setItemWidth) {\n            setItemWidth(item.name, getOuterWidth(this.refs.el) + (item.hidden ? DEFAULT_WIDTH : 0));\n        }\n    };\n    ToolbarButtonComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, hideTooltip = _a.hideTooltip, disabled = _a.disabled, item = _a.item, active = _a.active;\n        var style = __assign$1({ display: item.hidden ? 'none' : null }, item.style);\n        var classNames = \"\" + (item.className || '') + (active ? ' active' : '');\n        return html(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject([\"\\n      <button\\n        ref=\", \"\\n        type=\\\"button\\\"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n        disabled=\", \"\\n        aria-label=\", \"\\n      >\\n        \", \"\\n      </button>\\n    \"], [\"\\n      <button\\n        ref=\", \"\\n        type=\\\"button\\\"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n        disabled=\", \"\\n        aria-label=\", \"\\n      >\\n        \", \"\\n      </button>\\n    \"])), function (el) { return (_this.refs.el = el); }, style, classNames, this.execCommand, this.showTooltip, hideTooltip, !!disabled, item.text || item.tooltip || '', item.text || '');\n    };\n    return ToolbarButtonComp;\n}(Component));\nvar ToolbarButton = connectHOC(ToolbarButtonComp);\nvar templateObject_1$7;\n\nvar CustomToolbarItemComp = /** @class */ (function (_super) {\n    __extends$1(CustomToolbarItemComp, _super);\n    function CustomToolbarItemComp() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.showPopup = function () {\n            var info = createPopupInfo('customPopupBody', {\n                el: _this.refs.el,\n                pos: _this.props.getBound(_this.refs.el),\n                popup: _this.props.item.popup,\n            });\n            if (info) {\n                _this.props.setPopupInfo(info);\n            }\n        };\n        return _this;\n    }\n    CustomToolbarItemComp.prototype.mounted = function () {\n        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;\n        // append the custom html element\n        this.refs.el.appendChild(item.el);\n        // set width only if it is not a dropdown toolbar\n        if (setItemWidth) {\n            setItemWidth(item.name, getOuterWidth(this.refs.el));\n        }\n        if (item.onMounted) {\n            item.onMounted(this.props.execCommand);\n        }\n    };\n    CustomToolbarItemComp.prototype.updated = function (prevProps) {\n        var _a;\n        var _b = this.props, item = _b.item, active = _b.active, disabled = _b.disabled;\n        if (prevProps.active !== active || prevProps.disabled !== disabled) {\n            (_a = item.onUpdated) === null || _a === void 0 ? void 0 : _a.call(item, { active: active, disabled: disabled });\n        }\n    };\n    CustomToolbarItemComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, disabled = _a.disabled, item = _a.item;\n        var style = { display: item.hidden ? 'none' : 'inline-block' };\n        var getListener = function (listener) { return (disabled ? null : listener); };\n        return html(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject([\"\\n      <div\\n        ref=\", \"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n      ></div>\\n    \"], [\"\\n      <div\\n        ref=\", \"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n      ></div>\\n    \"])), function (el) { return (_this.refs.el = el); }, style, cls('toolbar-item-wrapper'), getListener(this.showPopup), getListener(this.showTooltip), getListener(this.props.hideTooltip));\n    };\n    return CustomToolbarItemComp;\n}(Component));\nvar CustomToolbarItem = connectHOC(CustomToolbarItemComp);\nvar templateObject_1$6;\n\nvar ToolbarGroup = /** @class */ (function (_super) {\n    __extends$1(ToolbarGroup, _super);\n    function ToolbarGroup() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ToolbarGroup.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, group = _a.group, hiddenDivider = _a.hiddenDivider;\n        var groupStyle = group.hidden ? { display: 'none' } : null;\n        var dividerStyle = hiddenDivider ? { display: 'none' } : null;\n        return html(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        \", \"\\n        <div class=\\\"\", \"\\\" style=\", \"></div>\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        \",\n            \"\\n        <div class=\\\"\", \"\\\" style=\", \"></div>\\n      </div>\\n    \"])), cls('toolbar-group'), groupStyle, group.map(function (item) {\n            var Comp = item.el ? CustomToolbarItem : ToolbarButton;\n            return html(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject([\"<\", \" key=\", \" ...\", \" item=\", \" />\"], [\"<\", \" key=\", \" ...\", \" item=\", \" />\"])), Comp, item.name, _this.props, item);\n        }), cls('toolbar-divider'), dividerStyle);\n    };\n    return ToolbarGroup;\n}(Component));\nvar templateObject_1$5, templateObject_2$4;\n\nvar POPUP_INDENT = 4;\nvar DropdownToolbarButtonComp = /** @class */ (function (_super) {\n    __extends$1(DropdownToolbarButtonComp, _super);\n    function DropdownToolbarButtonComp(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleClickDocument = function (_a) {\n            var target = _a.target;\n            if (!closest(target, \".\" + cls('dropdown-toolbar')) &&\n                !closest(target, '.more')) {\n                _this.setState({ showDropdown: false, dropdownPos: null });\n            }\n        };\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.state = { showDropdown: false, dropdownPos: null };\n        return _this;\n    }\n    DropdownToolbarButtonComp.prototype.getBound = function () {\n        var rect = this.props.getBound(this.refs.el);\n        rect.top += POPUP_INDENT;\n        return __assign$1(__assign$1({}, rect), { left: null, right: 10 });\n    };\n    DropdownToolbarButtonComp.prototype.mounted = function () {\n        document.addEventListener('click', this.handleClickDocument);\n    };\n    DropdownToolbarButtonComp.prototype.updated = function () {\n        if (this.state.showDropdown && !this.state.dropdownPos) {\n            this.setState({ dropdownPos: this.getBound() });\n        }\n    };\n    DropdownToolbarButtonComp.prototype.beforeDestroy = function () {\n        document.removeEventListener('click', this.handleClickDocument);\n    };\n    DropdownToolbarButtonComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.state, showDropdown = _a.showDropdown, dropdownPos = _a.dropdownPos;\n        var _b = this.props, disabled = _b.disabled, item = _b.item, items = _b.items, hideTooltip = _b.hideTooltip;\n        var visibleItems = items.filter(function (dropdownItem) { return !dropdownItem.hidden; });\n        var groupStyle = visibleItems.length ? null : { display: 'none' };\n        var dropdownStyle = showDropdown ? null : { display: 'none' };\n        return html(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        <button\\n          ref=\", \"\\n          type=\\\"button\\\"\\n          class=\", \"\\n          onClick=\", \"\\n          onMouseover=\", \"\\n          onMouseout=\", \"\\n          disabled=\", \"\\n        ></button>\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\", \"\\n          ref=\", \"\\n        >\\n          \", \"\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        <button\\n          ref=\", \"\\n          type=\\\"button\\\"\\n          class=\", \"\\n          onClick=\", \"\\n          onMouseover=\", \"\\n          onMouseout=\", \"\\n          disabled=\", \"\\n        ></button>\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\", \"\\n          ref=\", \"\\n        >\\n          \",\n            \"\\n        </div>\\n      </div>\\n    \"])), cls('toolbar-group'), groupStyle, function (el) { return (_this.refs.el = el); }, item.className, function () { return _this.setState({ showDropdown: true }); }, this.showTooltip, hideTooltip, disabled, cls('dropdown-toolbar'), __assign$1(__assign$1({}, dropdownStyle), dropdownPos), function (el) { return (_this.refs.dropdownEl = el); }, visibleItems.length\n            ? visibleItems.map(function (group, index) {\n                var _a;\n                return html(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject([\"\\n                  <\", \"\\n                    group=\", \"\\n                    hiddenDivider=\", \"\\n                    ...\", \"\\n                  />\\n                \"], [\"\\n                  <\", \"\\n                    group=\", \"\\n                    hiddenDivider=\",\n                    \"\\n                    ...\", \"\\n                  />\\n                \"])), ToolbarGroup, group, index === visibleItems.length - 1 ||\n                    ((_a = visibleItems[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.props);\n            })\n            : null);\n    };\n    return DropdownToolbarButtonComp;\n}(Component));\nvar DropdownToolbarButton = connectHOC(DropdownToolbarButtonComp);\nvar templateObject_1$4, templateObject_2$3;\n\nvar INLINE_PADDING = 50;\nvar Toolbar = /** @class */ (function (_super) {\n    __extends$1(Toolbar, _super);\n    function Toolbar(props) {\n        var _this = _super.call(this, props) || this;\n        _this.toggleTab = function (_, activeTab) {\n            var eventEmitter = _this.props.eventEmitter;\n            if (_this.state.activeTab !== activeTab) {\n                var event_1 = activeTab === 'write' ? 'changePreviewTabWrite' : 'changePreviewTabPreview';\n                eventEmitter.emit(event_1);\n                _this.setState({ activeTab: activeTab });\n            }\n        };\n        _this.setItemWidth = function (name, width) {\n            _this.itemWidthMap[name] = width;\n        };\n        _this.setPopupInfo = function (popupInfo) {\n            _this.setState({ showPopup: true, popupInfo: popupInfo });\n        };\n        _this.openPopup = function (popupName, initialValues) {\n            if (initialValues === void 0) { initialValues = {}; }\n            var el = _this.refs.el.querySelector(\".\" + cls('toolbar-group') + \" .\" + popupName);\n            if (el) {\n                var _a = getTotalOffset(el, closest(el, \".\" + cls('toolbar'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;\n                var info = createPopupInfo(popupName, {\n                    el: el,\n                    pos: { left: offsetLeft, top: el.offsetHeight + offsetTop },\n                    initialValues: initialValues,\n                });\n                if (info) {\n                    _this.setPopupInfo(info);\n                }\n            }\n        };\n        _this.hidePopup = function () {\n            if (_this.state.showPopup) {\n                _this.setState({ showPopup: false });\n            }\n        };\n        _this.execCommand = function (command, payload) {\n            var eventEmitter = _this.props.eventEmitter;\n            eventEmitter.emit('command', command, payload);\n            _this.hidePopup();\n        };\n        _this.tabs = [\n            { name: 'write', text: 'Write' },\n            { name: 'preview', text: 'Preview' },\n        ];\n        _this.itemWidthMap = {};\n        _this.initialItems = groupToolbarItems(props.toolbarItems || [], _this.hiddenScrollSync());\n        _this.state = {\n            items: _this.initialItems,\n            dropdownItems: [],\n            showPopup: false,\n            popupInfo: {},\n            activeTab: 'write',\n        };\n        _this.tooltipRef = { current: null };\n        _this.resizeObserver = new index(function () { return _this.handleResize(); });\n        _this.addEvent();\n        return _this;\n    }\n    Toolbar.prototype.insertToolbarItem = function (indexList, item) {\n        var groupIndex = indexList.groupIndex, itemIndex = indexList.itemIndex;\n        var group = this.initialItems[groupIndex];\n        item = createToolbarItemInfo(item);\n        if (group) {\n            group.splice(itemIndex, 0, item);\n        }\n        else {\n            this.initialItems.push([item]);\n        }\n        this.setState(this.classifyToolbarItems());\n    };\n    Toolbar.prototype.removeToolbarItem = function (name) {\n        var _this = this;\n        forEachArray_1(this.initialItems, function (group) {\n            var found = false;\n            forEachArray_1(group, function (item, index) {\n                if (item.name === name) {\n                    found = true;\n                    group.splice(index, 1);\n                    _this.setState(_this.classifyToolbarItems());\n                    return false;\n                }\n                return true;\n            });\n            return !found;\n        });\n    };\n    Toolbar.prototype.addEvent = function () {\n        var _this = this;\n        var eventEmitter = this.props.eventEmitter;\n        this.handleResize = throttle_1(function () {\n            // reset toolbar items to re-layout toolbar items with each clientWidth\n            _this.setState({ items: _this.initialItems, dropdownItems: [] });\n            _this.setState(_this.classifyToolbarItems());\n        }, 200);\n        eventEmitter.listen('openPopup', this.openPopup);\n    };\n    Toolbar.prototype.appendTooltipToRoot = function () {\n        var tooltip = \"<div class=\\\"\" + cls('tooltip') + \"\\\" style=\\\"display:none\\\">\\n        <div class=\\\"arrow\\\"></div>\\n        <span class=\\\"text\\\"></span>\\n      </div>\";\n        this.tooltipRef.current = createElementWith(tooltip, this.refs.el);\n    };\n    Toolbar.prototype.hiddenScrollSync = function () {\n        return this.props.editorType === 'wysiwyg' || this.props.previewStyle === 'tab';\n    };\n    Toolbar.prototype.movePrevItemToDropdownToolbar = function (itemIndex, items, group, dropdownGroup) {\n        var moveItem = function (targetGroup) {\n            var item = targetGroup.pop();\n            if (item) {\n                dropdownGroup.push(item);\n            }\n        };\n        if (itemIndex > 1) {\n            moveItem(group);\n        }\n        else {\n            var prevGroup = last$1(items);\n            if (prevGroup) {\n                moveItem(prevGroup);\n            }\n        }\n    };\n    Toolbar.prototype.classifyToolbarItems = function () {\n        var _this = this;\n        var totalWidth = 0;\n        var clientWidth = this.refs.el.clientWidth;\n        var divider = this.refs.el.querySelector(\".\" + cls('toolbar-divider'));\n        var dividerWidth = divider ? getOuterWidth(divider) : 0;\n        var items = [];\n        var dropdownItems = [];\n        var moved = false;\n        this.initialItems.forEach(function (initialGroup, groupIndex) {\n            var group = [];\n            var dropdownGroup = [];\n            initialGroup.forEach(function (item, itemIndex) {\n                if (!item.hidden) {\n                    totalWidth += _this.itemWidthMap[item.name];\n                    if (totalWidth > clientWidth - INLINE_PADDING) {\n                        // should move the prev item to dropdown toolbar for placing the more button\n                        if (!moved) {\n                            _this.movePrevItemToDropdownToolbar(itemIndex, items, group, dropdownGroup);\n                            moved = true;\n                        }\n                        dropdownGroup.push(item);\n                    }\n                    else {\n                        group.push(item);\n                    }\n                }\n            });\n            if (group.length) {\n                setGroupState(group);\n                items.push(group);\n            }\n            if (dropdownGroup.length) {\n                setGroupState(dropdownGroup);\n                dropdownItems.push(dropdownGroup);\n            }\n            // add divider width\n            if (groupIndex < _this.state.items.length - 1) {\n                totalWidth += dividerWidth;\n            }\n        });\n        return { items: items, dropdownItems: dropdownItems };\n    };\n    Toolbar.prototype.mounted = function () {\n        if (this.props.previewStyle === 'tab') {\n            this.props.eventEmitter.emit('changePreviewTabWrite', true);\n        }\n        // classify toolbar and dropdown toolbar after DOM has been rendered\n        this.setState(this.classifyToolbarItems());\n        this.appendTooltipToRoot();\n        this.resizeObserver.observe(this.refs.el);\n    };\n    Toolbar.prototype.updated = function (prevProps) {\n        var _a = this.props, editorType = _a.editorType, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter;\n        var changedStyle = previewStyle !== prevProps.previewStyle;\n        var changedType = editorType !== prevProps.editorType;\n        if (changedStyle || changedType) {\n            // show or hide scrollSync button\n            toggleScrollSync(this.initialItems, this.hiddenScrollSync());\n            var newState = this.classifyToolbarItems();\n            if (changedStyle || (previewStyle === 'tab' && editorType === 'markdown')) {\n                eventEmitter.emit('changePreviewTabWrite');\n                newState.activeTab = 'write';\n            }\n            this.setState(newState);\n        }\n    };\n    Toolbar.prototype.beforeDestroy = function () {\n        window.removeEventListener('resize', this.handleResize);\n        this.resizeObserver.disconnect();\n        removeNode$1(this.tooltipRef.current);\n    };\n    Toolbar.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter, editorType = _a.editorType;\n        var _b = this.state, popupInfo = _b.popupInfo, showPopup = _b.showPopup, activeTab = _b.activeTab, items = _b.items, dropdownItems = _b.dropdownItems;\n        var props = {\n            eventEmitter: eventEmitter,\n            tooltipRef: this.tooltipRef,\n            disabled: editorType === 'markdown' && previewStyle === 'tab' && activeTab === 'preview',\n            execCommand: this.execCommand,\n            setPopupInfo: this.setPopupInfo,\n        };\n        var toolbarStyle = previewStyle === 'tab' ? { borderTopLeftRadius: 0 } : null;\n        return html(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\\\"display: \", \"\\\"\\n        >\\n          <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        </div>\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          style=\", \"\\n        >\\n          \", \"\\n          <\", \"\\n            item=\", \"\\n            items=\", \"\\n            ...\", \"\\n          />\\n        </div>\\n        <\", \"\\n          info=\", \"\\n          show=\", \"\\n          eventEmitter=\", \"\\n          hidePopup=\", \"\\n          execCommand=\", \"\\n        />\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\\\"display: \",\n            \"\\\"\\n        >\\n          <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        </div>\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          style=\", \"\\n        >\\n          \",\n            \"\\n          <\", \"\\n            item=\", \"\\n            items=\", \"\\n            ...\", \"\\n          />\\n        </div>\\n        <\", \"\\n          info=\", \"\\n          show=\", \"\\n          eventEmitter=\", \"\\n          hidePopup=\", \"\\n          execCommand=\", \"\\n        />\\n      </div>\\n    \"])), cls('toolbar'), cls('md-tab-container'), editorType === 'wysiwyg' || previewStyle === 'vertical'\n            ? 'none'\n            : 'block', Tabs, this.tabs, activeTab, this.toggleTab, cls('defaultUI-toolbar'), function (el) { return (_this.refs.el = el); }, toolbarStyle, items.map(function (group, index) {\n            var _a;\n            return html(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject([\"\\n              <\", \"\\n                group=\", \"\\n                hiddenDivider=\", \"\\n                setItemWidth=\", \"\\n                ...\", \"\\n              />\\n            \"], [\"\\n              <\", \"\\n                group=\", \"\\n                hiddenDivider=\", \"\\n                setItemWidth=\", \"\\n                ...\", \"\\n              />\\n            \"])), ToolbarGroup, group, index === items.length - 1 || ((_a = items[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.setItemWidth, props);\n        }), DropdownToolbarButton, createToolbarItemInfo('more'), dropdownItems, props, Popup, popupInfo, showPopup, eventEmitter, this.hidePopup, this.execCommand);\n    };\n    return Toolbar;\n}(Component));\nvar templateObject_1$3, templateObject_2$2;\n\nvar ContextMenu = /** @class */ (function (_super) {\n    __extends$1(ContextMenu, _super);\n    function ContextMenu(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleClickDocument = function (ev) {\n            if (!closest(ev.target, \".\" + cls('context-menu'))) {\n                _this.setState({ pos: null });\n            }\n        };\n        _this.state = {\n            pos: null,\n            menuGroups: [],\n        };\n        _this.addEvent();\n        return _this;\n    }\n    ContextMenu.prototype.addEvent = function () {\n        var _this = this;\n        this.props.eventEmitter.listen('contextmenu', function (_a) {\n            var pos = _a.pos, menuGroups = _a.menuGroups;\n            _this.setState({ pos: pos, menuGroups: menuGroups });\n        });\n    };\n    ContextMenu.prototype.mounted = function () {\n        document.addEventListener('click', this.handleClickDocument);\n    };\n    ContextMenu.prototype.beforeDestroy = function () {\n        document.removeEventListener('click', this.handleClickDocument);\n    };\n    ContextMenu.prototype.getMenuGroupElements = function () {\n        var _this = this;\n        var _a = this.state, pos = _a.pos, menuGroups = _a.menuGroups;\n        return pos\n            ? menuGroups.reduce(function (acc, group) {\n                var menuItem = [];\n                group.forEach(function (_a) {\n                    var label = _a.label, _b = _a.className, className = _b === void 0 ? false : _b, disabled = _a.disabled, onClick = _a.onClick;\n                    var handleClick = function () {\n                        if (!disabled) {\n                            onClick();\n                            _this.setState({ pos: null });\n                        }\n                    };\n                    menuItem.push(html(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject([\"\\n                <li\\n                  onClick=\", \"\\n                  class=\\\"menu-item\", \"\\\"\\n                  aria-role=\\\"menuitem\\\"\\n                >\\n                  <span class=\\\"\", \"\\\">\", \"</span>\\n                </li>\\n              \"], [\"\\n                <li\\n                  onClick=\", \"\\n                  class=\\\"menu-item\", \"\\\"\\n                  aria-role=\\\"menuitem\\\"\\n                >\\n                  <span class=\\\"\", \"\\\">\", \"</span>\\n                </li>\\n              \"])), handleClick, disabled ? ' disabled' : '', className, label));\n                });\n                acc.push(html(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([\"<ul class=\\\"menu-group\\\">\\n              \", \"\\n            </ul>\"], [\"<ul class=\\\"menu-group\\\">\\n              \", \"\\n            </ul>\"])), menuItem));\n                return acc;\n            }, [])\n            : [];\n    };\n    ContextMenu.prototype.render = function () {\n        var style = __assign$1({ display: this.state.pos ? 'block' : 'none' }, this.state.pos);\n        return html(templateObject_3 || (templateObject_3 = __makeTemplateObject([\"<div class=\\\"\", \"\\\" style=\", \" aria-role=\\\"menu\\\">\\n      \", \"\\n    </div>\"], [\"<div class=\\\"\", \"\\\" style=\", \" aria-role=\\\"menu\\\">\\n      \", \"\\n    </div>\"])), cls('context-menu'), style, this.getMenuGroupElements());\n    };\n    return ContextMenu;\n}(Component));\nvar templateObject_1$2, templateObject_2$1, templateObject_3;\n\nvar Layout = /** @class */ (function (_super) {\n    __extends$1(Layout, _super);\n    function Layout(props) {\n        var _this = _super.call(this, props) || this;\n        _this.changeMode = function (editorType) {\n            if (editorType !== _this.state.editorType) {\n                _this.setState({ editorType: editorType });\n            }\n        };\n        _this.changePreviewStyle = function (previewStyle) {\n            if (previewStyle !== _this.state.previewStyle) {\n                _this.setState({ previewStyle: previewStyle });\n            }\n        };\n        _this.hide = function () {\n            _this.setState({ hide: true });\n        };\n        _this.show = function () {\n            _this.setState({ hide: false });\n        };\n        var editorType = props.editorType, previewStyle = props.previewStyle;\n        _this.state = {\n            editorType: editorType,\n            previewStyle: previewStyle,\n            hide: false,\n        };\n        _this.addEvent();\n        return _this;\n    }\n    Layout.prototype.mounted = function () {\n        var _a = this.props.slots, wwEditor = _a.wwEditor, mdEditor = _a.mdEditor, mdPreview = _a.mdPreview;\n        this.refs.wwContainer.appendChild(wwEditor);\n        this.refs.mdContainer.insertAdjacentElement('afterbegin', mdEditor);\n        this.refs.mdContainer.appendChild(mdPreview);\n    };\n    Layout.prototype.insertToolbarItem = function (indexList, item) {\n        this.toolbar.insertToolbarItem(indexList, item);\n    };\n    Layout.prototype.removeToolbarItem = function (name) {\n        this.toolbar.removeToolbarItem(name);\n    };\n    Layout.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, eventEmitter = _a.eventEmitter, hideModeSwitch = _a.hideModeSwitch, toolbarItems = _a.toolbarItems, theme = _a.theme;\n        var _b = this.state, hide = _b.hide, previewStyle = _b.previewStyle, editorType = _b.editorType;\n        var displayClassName = hide ? ' hidden' : '';\n        var editorTypeClassName = cls(editorType === 'markdown' ? 'md-mode' : 'ww-mode');\n        var previewClassName = cls('md') + \"-\" + previewStyle + \"-style\";\n        var themeClassName = cls([theme !== 'light', theme + \" \"]);\n        return html(templateObject_2 || (templateObject_2 = __makeTemplateObject([\"\\n      <div\\n        class=\\\"\", \"\", \"\", \"\\\"\\n        ref=\", \"\\n      >\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          previewStyle=\", \"\\n          toolbarItems=\", \"\\n          editorType=\", \"\\n        />\\n        <div\\n          class=\\\"\", \" \", \"\\\"\\n          ref=\", \"\\n        >\\n          <div class=\\\"\", \"\\\">\\n            <div\\n              class=\\\"\", \" \", \"\\\"\\n              ref=\", \"\\n            >\\n              <div class=\\\"\", \"\\\"></div>\\n            </div>\\n            <div\\n              class=\\\"\", \"\\\"\\n              ref=\", \"\\n            />\\n          </div>\\n        </div>\\n        \", \"\\n        <\", \" eventEmitter=\", \" />\\n      </div>\\n    \"], [\"\\n      <div\\n        class=\\\"\", \"\", \"\", \"\\\"\\n        ref=\", \"\\n      >\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          previewStyle=\", \"\\n          toolbarItems=\", \"\\n          editorType=\", \"\\n        />\\n        <div\\n          class=\\\"\", \" \", \"\\\"\\n          ref=\", \"\\n        >\\n          <div class=\\\"\", \"\\\">\\n            <div\\n              class=\\\"\", \" \", \"\\\"\\n              ref=\", \"\\n            >\\n              <div class=\\\"\", \"\\\"></div>\\n            </div>\\n            <div\\n              class=\\\"\", \"\\\"\\n              ref=\", \"\\n            />\\n          </div>\\n        </div>\\n        \",\n            \"\\n        <\", \" eventEmitter=\", \" />\\n      </div>\\n    \"])), themeClassName, cls('defaultUI'), displayClassName, function (el) { return (_this.refs.el = el); }, Toolbar, function (toolbar) { return (_this.toolbar = toolbar); }, eventEmitter, previewStyle, toolbarItems, editorType, cls('main'), editorTypeClassName, function (el) { return (_this.refs.editorSection = el); }, cls('main-container'), cls('md-container'), previewClassName, function (el) { return (_this.refs.mdContainer = el); }, cls('md-splitter'), cls('ww-container'), function (el) { return (_this.refs.wwContainer = el); }, !hideModeSwitch && html(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject([\"<\", \" eventEmitter=\", \" editorType=\", \" />\"], [\"<\", \" eventEmitter=\", \" editorType=\", \" />\"])), Switch, eventEmitter, editorType), ContextMenu, eventEmitter);\n    };\n    Layout.prototype.addEvent = function () {\n        var eventEmitter = this.props.eventEmitter;\n        eventEmitter.listen('hide', this.hide);\n        eventEmitter.listen('show', this.show);\n        eventEmitter.listen('changeMode', this.changeMode);\n        eventEmitter.listen('changePreviewStyle', this.changePreviewStyle);\n    };\n    return Layout;\n}(Component));\nvar templateObject_1$1, templateObject_2;\n\n/**\n * ToastUI Editor\n * @extends ToastUIEditorCore\n */\nvar ToastUIEditor = /** @class */ (function (_super) {\n    __extends$1(ToastUIEditor, _super);\n    function ToastUIEditor(options) {\n        var _a;\n        var _this = _super.call(this, options) || this;\n        var layoutComp;\n        var destroy = render(_this.options.el, html(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          slots=\", \"\\n          hideModeSwitch=\", \"\\n          toolbarItems=\", \"\\n          previewStyle=\", \"\\n          editorType=\", \"\\n          theme=\", \"\\n        />\\n      \"], [\"\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          slots=\", \"\\n          hideModeSwitch=\", \"\\n          toolbarItems=\", \"\\n          previewStyle=\", \"\\n          editorType=\", \"\\n          theme=\", \"\\n        />\\n      \"])), Layout, function (layout) { return (layoutComp = layout); }, _this.eventEmitter, _this.getEditorElements(), _this.options.hideModeSwitch, _this.options.toolbarItems, _this.options.previewStyle, _this.options.initialEditType, _this.options.theme));\n        _this.setMinHeight(_this.options.minHeight);\n        _this.setHeight(_this.options.height);\n        _this.defaultUI = {\n            insertToolbarItem: layoutComp.insertToolbarItem.bind(layoutComp),\n            removeToolbarItem: layoutComp.removeToolbarItem.bind(layoutComp),\n            destroy: destroy,\n        };\n        (_a = _this.pluginInfo.toolbarItems) === null || _a === void 0 ? void 0 : _a.forEach(function (toolbarItem) {\n            var groupIndex = toolbarItem.groupIndex, itemIndex = toolbarItem.itemIndex, item = toolbarItem.item;\n            _this.defaultUI.insertToolbarItem({ groupIndex: groupIndex, itemIndex: itemIndex }, item);\n        });\n        _this.eventEmitter.emit('loadUI', _this);\n        return _this;\n    }\n    /**\n     * Factory method for Editor\n     * @param {object} options Option for initialize TUIEditor\n     * @returns {object} ToastUIEditor or ToastUIEditorViewer\n     */\n    ToastUIEditor.factory = function (options) {\n        return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditor(options);\n    };\n    /**\n     * add toolbar item\n     * @param {Object} indexInfo group index and item index of the toolbar item\n     * @param {string|Object} item toolbar item\n     */\n    ToastUIEditor.prototype.insertToolbarItem = function (indexInfo, item) {\n        this.defaultUI.insertToolbarItem(indexInfo, item);\n    };\n    /**\n     * Remove toolbar item\n     * @param {string} itemName toolbar item name\n     */\n    ToastUIEditor.prototype.removeToolbarItem = function (itemName) {\n        this.defaultUI.removeToolbarItem(itemName);\n    };\n    /**\n     * Destroy TUIEditor from document\n     */\n    ToastUIEditor.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        this.defaultUI.destroy();\n    };\n    return ToastUIEditor;\n}(ToastUIEditorCore));\nvar templateObject_1;\n\n/**\n * @fileoverview I18N for English\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\nToastUIEditorCore.setLanguage(['en', 'en-US'], {\n    Markdown: 'Markdown',\n    WYSIWYG: 'WYSIWYG',\n    Write: 'Write',\n    Preview: 'Preview',\n    Headings: 'Headings',\n    Paragraph: 'Paragraph',\n    Bold: 'Bold',\n    Italic: 'Italic',\n    Strike: 'Strike',\n    Code: 'Inline code',\n    Line: 'Line',\n    Blockquote: 'Blockquote',\n    'Unordered list': 'Unordered list',\n    'Ordered list': 'Ordered list',\n    Task: 'Task',\n    Indent: 'Indent',\n    Outdent: 'Outdent',\n    'Insert link': 'Insert link',\n    'Insert CodeBlock': 'Insert codeBlock',\n    'Insert table': 'Insert table',\n    'Insert image': 'Insert image',\n    Heading: 'Heading',\n    'Image URL': 'Image URL',\n    'Select image file': 'Select image file',\n    'Choose a file': 'Choose a file',\n    'No file': 'No file',\n    Description: 'Description',\n    OK: 'OK',\n    More: 'More',\n    Cancel: 'Cancel',\n    File: 'File',\n    URL: 'URL',\n    'Link text': 'Link text',\n    'Add row to up': 'Add row to up',\n    'Add row to down': 'Add row to down',\n    'Add column to left': 'Add column to left',\n    'Add column to right': 'Add column to right',\n    'Remove row': 'Remove row',\n    'Remove column': 'Remove column',\n    'Align column to left': 'Align column to left',\n    'Align column to center': 'Align column to center',\n    'Align column to right': 'Align column to right',\n    'Remove table': 'Remove table',\n    'Would you like to paste as table?': 'Would you like to paste as table?',\n    'Text color': 'Text color',\n    'Auto scroll enabled': 'Auto scroll enabled',\n    'Auto scroll disabled': 'Auto scroll disabled',\n    'Choose language': 'Choose language',\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0g7QUFDekM7QUFDZ0I7QUFDaUQ7QUFDOUY7QUFDeUk7QUFDdkc7QUFDVDs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQSxJQUFJO0FBQ0osZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdB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S0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVDQUF1QztBQUM3RSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtEQUErRDtBQUNwSCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBMEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUEwQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILGlDQUFpQztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWUsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsRUFBRSxnQ0FBZ0MsS0FBSyw2Q0FBNkMsS0FBSztBQUM5SSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMkNBQTJDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUcsR0FBRyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSxhQUFhLElBQUk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixHQUFHLFdBQVcsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakMsd0NBQXdDLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRztBQUMzRTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2Qyx5QkFBeUIsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQ0FBMkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0QkFBNEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFD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VjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsTUFBTTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdUZBQXVGLGdFQUFnRTtBQUN2Sjs7QUFFQTtBQUNBLE1BQU0sd0NBQXdDLHdGQUF3RixvS0FBb0ssdUhBQXVILG1CQUFtQjtBQUNwYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBEQUEwRCxnQ0FBZ0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNCQUFzQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFrRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDhCQUE4QixrREFBa0Q7QUFDaEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG9CQUFvQjtBQUNsRiwyQ0FBMkM7QUFDM0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3REFBd0QsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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ekw7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1vQkFBbW9CLCtCQUErQjtBQUNscUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDhDQUE4QztBQUM5RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRTZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZvcmdlLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9lZGl0b3IvZGlzdC9lc20vaW5kZXguanM/YTBjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0b2FzdC11aS9lZGl0b3JcbiAqIEB2ZXJzaW9uIDMuMi4yIHwgRnJpIEZlYiAxNyAyMDIzXG4gKiBAYXV0aG9yIE5ITiBDbG91ZCBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbmltcG9ydCB7IEZyYWdtZW50LCBTY2hlbWEsIFNsaWNlLCBOb2RlUmFuZ2UsIE1hcmsgYXMgTWFyayQxLCBET01QYXJzZXIsIE5vZGUgYXMgTm9kZSQzIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiwgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgUmVwbGFjZUFyb3VuZFN0ZXAsIGxpZnRUYXJnZXQsIGNhblNwbGl0LCBTdGVwTWFwIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24sIFBsdWdpbiwgUGx1Z2luS2V5LCBFZGl0b3JTdGF0ZSwgQWxsU2VsZWN0aW9uLCBTZWxlY3Rpb24sIFNlbGVjdGlvblJhbmdlLCBOb2RlU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsga2V5bWFwIH0gZnJvbSAncHJvc2VtaXJyb3Ita2V5bWFwJztcbmltcG9ydCB7IGRlbGV0ZVNlbGVjdGlvbiwgc2VsZWN0QWxsLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBqb2luRm9yd2FyZCwgbmV3bGluZUluQ29kZSwgc2V0QmxvY2tUeXBlLCB3cmFwSW4sIHRvZ2dsZU1hcmsgYXMgdG9nZ2xlTWFyayQxLCBleGl0Q29kZSB9IGZyb20gJ3Byb3NlbWlycm9yLWNvbW1hbmRzJztcbmltcG9ydCB7IElucHV0UnVsZSwgaW5wdXRSdWxlcywgdW5kb0lucHV0UnVsZSB9IGZyb20gJ3Byb3NlbWlycm9yLWlucHV0cnVsZXMnO1xuaW1wb3J0IHsgdW5kbywgcmVkbywgaGlzdG9yeSwgdW5kb0RlcHRoIH0gZnJvbSAncHJvc2VtaXJyb3ItaGlzdG9yeSc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyQxID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyQxID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyQxKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzJDEoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzJDEoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduJDEgPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduJDEgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkkMSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdCB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgdGhlIGxvb3Agd2lsbCBiZSBzdG9wcGVkLlxuICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgMSkgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogIDIpIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICogIDMpIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQodGhpcykgb2YgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGZvckVhY2hPd25Qcm9wZXJ0aWVzIGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoT3duUHJvcGVydGllcyc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBmb3JFYWNoT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoT3duUHJvcGVydGllcycpOyBcbiAqXG4gKiBsZXQgc3VtID0gMDtcbiAqXG4gKiBmb3JFYWNoT3duUHJvcGVydGllcyh7YToxLGI6MixjOjN9LCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICogYWxlcnQoc3VtKTsgLy8gNlxuICovXG5mdW5jdGlvbiBmb3JFYWNoT3duUHJvcGVydGllcyQyKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgdmFyIGtleTtcblxuICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgaWYgKGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmb3JFYWNoT3duUHJvcGVydGllc18xID0gZm9yRWFjaE93blByb3BlcnRpZXMkMjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4dGVuZCB0aGUgdGFyZ2V0IG9iamVjdCBmcm9tIG90aGVyIG9iamVjdHMuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIEBtb2R1bGUgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBFeHRlbmQgdGhlIHRhcmdldCBvYmplY3QgZnJvbSBvdGhlciBvYmplY3RzLlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIE9iamVjdCB0aGF0IHdpbGwgYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7Li4ub2JqZWN0fSBvYmplY3RzIC0gT2JqZWN0cyBhcyBzb3VyY2VzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBFeHRlbmRlZCBvYmplY3RcbiAqIEBtZW1iZXJvZiBtb2R1bGU6b2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIG9iamVjdHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgaGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBzb3VyY2UsIHByb3AsIGksIGxlbjtcblxuICBmb3IgKGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgaWYgKGhhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgZXh0ZW5kXzEgPSBleHRlbmQ7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZyBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZywgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBzdHJpbmc/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmckMyhvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZztcbn1cblxudmFyIGlzU3RyaW5nXzEgPSBpc1N0cmluZyQzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQXJyYXkgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQXJyYXksIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgYXJyYXkgaW5zdGFuY2U/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSQzKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXk7XG59XG5cbnZhciBpc0FycmF5XzEgPSBpc0FycmF5JDM7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkob3IgQXJyYXktbGlrZSBvYmplY3QpIGluIGFzY2VuZGluZyBvcmRlci5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnRcbiAqIGluIHRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudFxuICogIDIpIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudFxuICogIDMpIFRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c3xOb2RlTGlzdH0gYXJyIFRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgZm9yRWFjaEFycmF5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoQXJyYXknO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaEFycmF5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2hBcnJheScpOyBcbiAqXG4gKiBsZXQgc3VtID0gMDtcbiAqXG4gKiBmb3JFYWNoQXJyYXkoWzEsMiwzXSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFycmF5JDMoYXJyLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuXG4gIGZvciAoOyBpbmRleCA8IGxlbjsgaW5kZXggKz0gMSkge1xuICAgIGlmIChpdGVyYXRlZS5jYWxsKGNvbnRleHQsIGFycltpbmRleF0sIGluZGV4LCBhcnIpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbnZhciBmb3JFYWNoQXJyYXlfMSA9IGZvckVhY2hBcnJheSQzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qob3IgZWxlbWVudCBvZiBhcnJheSkgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNBcnJheSQyID0gaXNBcnJheV8xO1xudmFyIGZvckVhY2hBcnJheSQyID0gZm9yRWFjaEFycmF5XzE7XG52YXIgZm9yRWFjaE93blByb3BlcnRpZXMkMSA9IGZvckVhY2hPd25Qcm9wZXJ0aWVzXzE7XG5cbi8qKlxuICogQG1vZHVsZSBjb2xsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdChvciBlbGVtZW50IG9mIGFycmF5KSB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIElmIHRoZSBvYmplY3QgaXMgQXJyYXktbGlrZSBvYmplY3QoZXgtYXJndW1lbnRzIG9iamVjdCksIEl0IG5lZWRzIHRvIHRyYW5zZm9ybSB0byBBcnJheS4oc2VlICdleDInIG9mIGV4YW1wbGUpLlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50KVxuICogIDIpIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eShvciBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQpXG4gKiAgMykgVGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBmb3JFYWNoIGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoJzsgXG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBmb3JFYWNoID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2gnKTsgXG4gKlxuICogbGV0IHN1bSA9IDA7XG4gKlxuICogZm9yRWFjaChbMSwyLDNdLCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICogYWxlcnQoc3VtKTsgLy8gNlxuICpcbiAqIC8vIEluIGNhc2Ugb2YgQXJyYXktbGlrZSBvYmplY3RcbiAqIGNvbnN0IGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTsgLy8gY2hhbmdlIHRvIGFycmF5XG4gKiBmb3JFYWNoKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmb3JFYWNoJDQob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICBpZiAoaXNBcnJheSQyKG9iaikpIHtcbiAgICBmb3JFYWNoQXJyYXkkMihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoT3duUHJvcGVydGllcyQxKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9XG59XG5cbnZhciBmb3JFYWNoXzEgPSBmb3JFYWNoJDQ7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTZXR0aW5nIGVsZW1lbnQgc3R5bGVcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc1N0cmluZyQyID0gaXNTdHJpbmdfMTtcbnZhciBmb3JFYWNoJDMgPSBmb3JFYWNoXzE7XG5cbi8qKlxuICogU2V0dGluZyBlbGVtZW50IHN0eWxlXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIGVsZW1lbnQgdG8gc2V0dGluZyBzdHlsZVxuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IGtleSAtIHN0eWxlIHByb3AgbmFtZSBvciB7cHJvcDogdmFsdWV9IHBhaXIgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSAtIHN0eWxlIHZhbHVlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gY3NzKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblxuICBpZiAoaXNTdHJpbmckMihrZXkpKSB7XG4gICAgc3R5bGVba2V5XSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaCQzKGtleSwgZnVuY3Rpb24odiwgaykge1xuICAgIHN0eWxlW2tdID0gdjtcbiAgfSk7XG59XG5cbnZhciBjc3NfMSA9IGNzcztcblxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuXG52YXIgaXNBcnJheSQxID0gaXNBcnJheV8xO1xuXG4vKipcbiAqIEBtb2R1bGUgYXJyYXlcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIGFycmF5XG4gKiBmcm9tIHN0YXJ0IGluZGV4KGRlZmF1bHQgMCksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICogSXQgY29tcGFyZXMgc2VhcmNoRWxlbWVudCB0byBlbGVtZW50cyBvZiB0aGUgQXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gKiAodGhlIHNhbWUgbWV0aG9kIHVzZWQgYnkgdGhlID09PSwgb3IgdHJpcGxlLWVxdWFscywgb3BlcmF0b3IpLlxuICogQHBhcmFtIHsqfSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFN0YXJ0IGluZGV4IGluIGFycmF5IGZvciBzZWFyY2hpbmcgKGRlZmF1bHQgMClcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBGaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmFycmF5XG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgaW5BcnJheSBmcm9tICd0dWktY29kZS1zbmlwcGV0L2FycmF5L2luQXJyYXknO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgaW5BcnJheSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvYXJyYXkvaW5BcnJheScpO1xuICpcbiAqIGNvbnN0IGFyciA9IFsnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJ107XG4gKiBjb25zdCBpZHgxID0gaW5BcnJheSgnb25lJywgYXJyLCAzKTsgLy8gLTFcbiAqIGNvbnN0IGlkeDIgPSBpbkFycmF5KCdvbmUnLCBhcnIpOyAvLyAwXG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkkNChzZWFyY2hFbGVtZW50LCBhcnJheSwgc3RhcnRJbmRleCkge1xuICB2YXIgaTtcbiAgdmFyIGxlbmd0aDtcbiAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcblxuICBpZiAoIWlzQXJyYXkkMShhcnJheSkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgc2VhcmNoRWxlbWVudCwgc3RhcnRJbmRleCk7XG4gIH1cblxuICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGZvciAoaSA9IHN0YXJ0SW5kZXg7IHN0YXJ0SW5kZXggPj0gMCAmJiBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxudmFyIGluQXJyYXlfMSA9IGluQXJyYXkkNDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyB1bmRlZmluZWQ/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQkNChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmaW5lZFxufVxuXG52YXIgaXNVbmRlZmluZWRfMSA9IGlzVW5kZWZpbmVkJDQ7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBHZXQgSFRNTCBlbGVtZW50J3MgZGVzaWduIGNsYXNzZXMuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNVbmRlZmluZWQkMyA9IGlzVW5kZWZpbmVkXzE7XG5cbi8qKlxuICogR2V0IEhUTUwgZWxlbWVudCdzIGRlc2lnbiBjbGFzc2VzLlxuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgdGFyZ2V0IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVsZW1lbnQgY3NzIGNsYXNzIG5hbWVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBnZXRDbGFzcyQzKGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LmNsYXNzTmFtZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChpc1VuZGVmaW5lZCQzKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWw7XG59XG5cbnZhciBnZXRDbGFzc18xID0gZ2V0Q2xhc3MkMztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNldCBjbGFzc05hbWUgdmFsdWVcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc0FycmF5ID0gaXNBcnJheV8xO1xudmFyIGlzVW5kZWZpbmVkJDIgPSBpc1VuZGVmaW5lZF8xO1xuXG4vKipcbiAqIFNldCBjbGFzc05hbWUgdmFsdWVcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IGNzc0NsYXNzIC0gY2xhc3MgbmFtZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldENsYXNzTmFtZSQyKGVsZW1lbnQsIGNzc0NsYXNzKSB7XG4gIGNzc0NsYXNzID0gaXNBcnJheShjc3NDbGFzcykgPyBjc3NDbGFzcy5qb2luKCcgJykgOiBjc3NDbGFzcztcblxuICBjc3NDbGFzcyA9IGNzc0NsYXNzLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG5cbiAgaWYgKGlzVW5kZWZpbmVkJDIoZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCA9IGNzc0NsYXNzO1xufVxuXG52YXIgX3NldENsYXNzTmFtZSA9IHNldENsYXNzTmFtZSQyO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQWRkIGNzcyBjbGFzcyB0byBlbGVtZW50XG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgZm9yRWFjaCQyID0gZm9yRWFjaF8xO1xudmFyIGluQXJyYXkkMyA9IGluQXJyYXlfMTtcbnZhciBnZXRDbGFzcyQyID0gZ2V0Q2xhc3NfMTtcbnZhciBzZXRDbGFzc05hbWUkMSA9IF9zZXRDbGFzc05hbWU7XG5cbi8qKlxuICogZG9tVXRpbCBtb2R1bGVcbiAqIEBtb2R1bGUgZG9tVXRpbFxuICovXG5cbi8qKlxuICogQWRkIGNzcyBjbGFzcyB0byBlbGVtZW50XG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0gey4uLnN0cmluZ30gY3NzQ2xhc3MgLSBjc3MgY2xhc3NlcyB0byBhZGRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50KSB7XG4gIHZhciBjc3NDbGFzcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgdmFyIG5ld0NsYXNzID0gW107XG4gIHZhciBvcmlnaW47XG5cbiAgaWYgKGNsYXNzTGlzdCkge1xuICAgIGZvckVhY2gkMihjc3NDbGFzcywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3JpZ2luID0gZ2V0Q2xhc3MkMihlbGVtZW50KTtcblxuICBpZiAob3JpZ2luKSB7XG4gICAgY3NzQ2xhc3MgPSBbXS5jb25jYXQob3JpZ2luLnNwbGl0KC9cXHMrLyksIGNzc0NsYXNzKTtcbiAgfVxuXG4gIGZvckVhY2gkMihjc3NDbGFzcywgZnVuY3Rpb24oY2xzKSB7XG4gICAgaWYgKGluQXJyYXkkMyhjbHMsIG5ld0NsYXNzKSA8IDApIHtcbiAgICAgIG5ld0NsYXNzLnB1c2goY2xzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNldENsYXNzTmFtZSQxKGVsZW1lbnQsIG5ld0NsYXNzKTtcbn1cblxudmFyIGFkZENsYXNzXzEgPSBhZGRDbGFzcztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlbW92ZSBjc3MgY2xhc3MgZnJvbSBlbGVtZW50XG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgZm9yRWFjaEFycmF5JDEgPSBmb3JFYWNoQXJyYXlfMTtcbnZhciBpbkFycmF5JDIgPSBpbkFycmF5XzE7XG52YXIgZ2V0Q2xhc3MkMSA9IGdldENsYXNzXzE7XG52YXIgc2V0Q2xhc3NOYW1lID0gX3NldENsYXNzTmFtZTtcblxuLyoqXG4gKiBSZW1vdmUgY3NzIGNsYXNzIGZyb20gZWxlbWVudFxuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgLSB0YXJnZXQgZWxlbWVudFxuICogQHBhcmFtIHsuLi5zdHJpbmd9IGNzc0NsYXNzIC0gY3NzIGNsYXNzZXMgdG8gcmVtb3ZlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCkge1xuICB2YXIgY3NzQ2xhc3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG4gIHZhciBvcmlnaW4sIG5ld0NsYXNzO1xuXG4gIGlmIChjbGFzc0xpc3QpIHtcbiAgICBmb3JFYWNoQXJyYXkkMShjc3NDbGFzcywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9yaWdpbiA9IGdldENsYXNzJDEoZWxlbWVudCkuc3BsaXQoL1xccysvKTtcbiAgbmV3Q2xhc3MgPSBbXTtcbiAgZm9yRWFjaEFycmF5JDEob3JpZ2luLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKGluQXJyYXkkMihuYW1lLCBjc3NDbGFzcykgPCAwKSB7XG4gICAgICBuZXdDbGFzcy5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2V0Q2xhc3NOYW1lKGVsZW1lbnQsIG5ld0NsYXNzKTtcbn1cblxudmFyIHJlbW92ZUNsYXNzXzEgPSByZW1vdmVDbGFzcztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgbnVtYmVyIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBudW1iZXIgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgbnVtYmVyLCByZXR1cm4gdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIG51bWJlcj9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIE51bWJlcjtcbn1cblxudmFyIGlzTnVtYmVyXzEgPSBpc051bWJlcjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG51bGwgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBudWxsIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZShhcmd1bWVudHNbMF0pIGlzIG51bGwsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIG51bGw/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNOdWxsJDEob2JqKSB7XG4gIHJldHVybiBvYmogPT09IG51bGw7XG59XG5cbnZhciBpc051bGxfMSA9IGlzTnVsbCQxO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWVzdCBpbWFnZSBwaW5nLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGZvckVhY2hPd25Qcm9wZXJ0aWVzID0gZm9yRWFjaE93blByb3BlcnRpZXNfMTtcblxuLyoqXG4gKiBAbW9kdWxlIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaW1hZ2UgcGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgdXJsIGZvciBwaW5nIHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFja2luZ0luZm8gaW5mb3MgZm9yIG1ha2UgcXVlcnkgc3RyaW5nXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnJlcXVlc3RcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBpbWFnZVBpbmcgZnJvbSAndHVpLWNvZGUtc25pcHBldC9yZXF1ZXN0L2ltYWdlUGluZyc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBpbWFnZVBpbmcgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L3JlcXVlc3QvaW1hZ2VQaW5nJyk7XG4gKlxuICogaW1hZ2VQaW5nKCdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9jb2xsZWN0Jywge1xuICogICB2OiAxLFxuICogICB0OiAnZXZlbnQnLFxuICogICB0aWQ6ICd0cmFja2luZ2lkJyxcbiAqICAgY2lkOiAnY2lkJyxcbiAqICAgZHA6ICdkcCcsXG4gKiAgIGRoOiAnZGgnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gaW1hZ2VQaW5nJDEodXJsLCB0cmFja2luZ0luZm8pIHtcbiAgdmFyIHRyYWNraW5nRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICB2YXIgcXVlcnlTdHJpbmcgPSAnJztcbiAgZm9yRWFjaE93blByb3BlcnRpZXModHJhY2tpbmdJbmZvLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcXVlcnlTdHJpbmcgKz0gJyYnICsga2V5ICsgJz0nICsgdmFsdWU7XG4gIH0pO1xuICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnN1YnN0cmluZygxKTtcblxuICB0cmFja2luZ0VsZW1lbnQuc3JjID0gdXJsICsgJz8nICsgcXVlcnlTdHJpbmc7XG5cbiAgdHJhY2tpbmdFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodHJhY2tpbmdFbGVtZW50KTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0cmFja2luZ0VsZW1lbnQpO1xuXG4gIHJldHVybiB0cmFja2luZ0VsZW1lbnQ7XG59XG5cbnZhciBpbWFnZVBpbmdfMSA9IGltYWdlUGluZyQxO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VuZCBob3N0bmFtZSBvbiBET01Db250ZW50TG9hZGVkLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzVW5kZWZpbmVkJDEgPSBpc1VuZGVmaW5lZF8xO1xudmFyIGltYWdlUGluZyA9IGltYWdlUGluZ18xO1xuXG52YXIgbXM3ZGF5cyA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkYXRlIGhhcyBwYXNzZWQgNyBkYXlzXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0ZSAtIG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0V4cGlyZWQoZGF0ZSkge1xuICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgcmV0dXJuIG5vdyAtIGRhdGUgPiBtczdkYXlzO1xufVxuXG4vKipcbiAqIFNlbmQgaG9zdG5hbWUgb24gRE9NQ29udGVudExvYWRlZC5cbiAqIFRvIHByZXZlbnQgaG9zdG5hbWUgc2V0IHR1aS51c2FnZVN0YXRpc3RpY3MgdG8gZmFsc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwTmFtZSAtIGFwcGxpY2F0aW9uIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja2luZ0lkIC0gR0EgdHJhY2tpbmcgSURcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gc2VuZEhvc3RuYW1lKGFwcE5hbWUsIHRyYWNraW5nSWQpIHtcbiAgdmFyIHVybCA9ICdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9jb2xsZWN0JztcbiAgdmFyIGhvc3RuYW1lID0gbG9jYXRpb24uaG9zdG5hbWU7XG4gIHZhciBoaXRUeXBlID0gJ2V2ZW50JztcbiAgdmFyIGV2ZW50Q2F0ZWdvcnkgPSAndXNlJztcbiAgdmFyIGFwcGxpY2F0aW9uS2V5Rm9yU3RvcmFnZSA9ICdUT0FTVCBVSSAnICsgYXBwTmFtZSArICcgZm9yICcgKyBob3N0bmFtZSArICc6IFN0YXRpc3RpY3MnO1xuICB2YXIgZGF0ZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShhcHBsaWNhdGlvbktleUZvclN0b3JhZ2UpO1xuXG4gIC8vIHNraXAgaWYgdGhlIGZsYWcgaXMgZGVmaW5lZCBhbmQgaXMgc2V0IHRvIGZhbHNlIGV4cGxpY2l0bHlcbiAgaWYgKCFpc1VuZGVmaW5lZCQxKHdpbmRvdy50dWkpICYmIHdpbmRvdy50dWkudXNhZ2VTdGF0aXN0aWNzID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNraXAgaWYgbm90IHBhc3Mgc2V2ZW4gZGF5cyBvbGRcbiAgaWYgKGRhdGUgJiYgIWlzRXhwaXJlZChkYXRlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShhcHBsaWNhdGlvbktleUZvclN0b3JhZ2UsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGltYWdlUGluZyh1cmwsIHtcbiAgICAgICAgdjogMSxcbiAgICAgICAgdDogaGl0VHlwZSxcbiAgICAgICAgdGlkOiB0cmFja2luZ0lkLFxuICAgICAgICBjaWQ6IGhvc3RuYW1lLFxuICAgICAgICBkcDogaG9zdG5hbWUsXG4gICAgICAgIGRoOiBhcHBOYW1lLFxuICAgICAgICBlbDogYXBwTmFtZSxcbiAgICAgICAgZWM6IGV2ZW50Q2F0ZWdvcnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgMTAwMCk7XG59XG5cbnZhciBzZW5kSG9zdG5hbWVfMSA9IHNlbmRIb3N0bmFtZTtcblxuL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xudmFyIHJlU3BhY2VNb3JlVGhhbk9uZSA9IC9bXFx1MDAyMF0rL2c7XG52YXIgcmVFc2NhcGVDaGFycyQxID0gL1s+KCl7fVtcXF0rLS4hI3xdL2c7XG52YXIgcmVFc2NhcGVIVE1MID0gLzwoW2EtekEtWl9dW2EtekEtWjAtOVxcLS5fXSopKFxcc3xbXlxcXFw+XSkqXFwvPz58PChcXC8pKFthLXpBLVpfXVthLXpBLVowLTlcXC0uX10qKVxccypcXC8/Pnw8IS0tW14tXSstLT58PChbYS16QS1aX11bYS16QS1aMC05XFwtLjovXSopPi9nO1xudmFyIHJlRXNjYXBlQmFja1NsYXNoID0gL1xcXFxbIVwiIyQlJicoKSorLC0uLzo7PD0+P0BbXFxdXl9ge3x9flxcXFxdL2c7XG52YXIgcmVFc2NhcGVQYWlyZWRDaGFycyA9IC9bKl9+YF0vZztcbnZhciByZU1kSW1hZ2VTeW50YXggPSAvIVxcWy4qXFxdXFwoLipcXCkvZztcbnZhciByZUVzY2FwZWRDaGFySW5MaW5rU3ludGF4ID0gL1tbXFxdXS9nO1xudmFyIHJlRXNjYXBlQmFja1NsYXNoSW5TZW50ZW5jZSA9IC8oPzpefFteXFxcXF0pXFxcXCg/IVxcXFwpL2c7XG52YXIgWE1MU1BFQ0lBTCQxID0gJ1smPD5cIl0nO1xudmFyIHJlWG1sU3BlY2lhbCQxID0gbmV3IFJlZ0V4cChYTUxTUEVDSUFMJDEsICdnJyk7XG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhciQxKGNoYXIpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjaGFyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZVhtbCQxKHRleHQpIHtcbiAgICBpZiAocmVYbWxTcGVjaWFsJDEudGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlWG1sU3BlY2lhbCQxLCByZXBsYWNlVW5zYWZlQ2hhciQxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBzZW5kSG9zdE5hbWUoKSB7XG4gICAgc2VuZEhvc3RuYW1lXzEoJ2VkaXRvcicsICdVQS0xMjk5NjY5MjktMScpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyLCB0YXJnZXRJdGVtKSB7XG4gICAgcmV0dXJuIGFyci5pbmRleE9mKHRhcmdldEl0ZW0pICE9PSAtMTtcbn1cbnZhciBhdmFpbGFibGVMaW5rQXR0cmlidXRlcyA9IFsncmVsJywgJ3RhcmdldCcsICdocmVmbGFuZycsICd0eXBlJ107XG52YXIgcmVNYXJrZG93blRleHRUb0VzY2FwZU1hcCA9IHtcbiAgICBjb2RlYmxvY2s6IC8oXiB7NH1bXlxcbl0rXFxuKikrLyxcbiAgICB0aGVtYXRpY0JyZWFrOiAvXiAqKChcXCogKil7Myx9fCgtICopezMsfSAqfChfICopezMsfSkgKi8sXG4gICAgYXR4SGVhZGluZzogL14oI3sxLDZ9KSArW1xcc1xcU10rLyxcbiAgICBzZVRleHRoZWFkaW5nOiAvXihbXlxcbl0rKVxcbiAqKD18LSl7Mix9ICovLFxuICAgIGJsb2NrcXVvdGU6IC9eKCAqPlteXFxuXSsuKikrLyxcbiAgICBsaXN0OiAvXiAqKFxcKit8LSt8XFxkK1xcLikgW1xcc1xcU10rLyxcbiAgICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArW1wiKF0oW15cXG5dKylbXCIpXSk/ICovLFxuICAgIGxpbms6IC8hP1xcWy4qXFxdXFwoLipcXCkvLFxuICAgIHJlZmxpbms6IC8hP1xcWy4qXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8sXG4gICAgdmVydGljYWxCYXI6IC9cXHUwMDdDLyxcbiAgICBmZW5jZWRDb2RlYmxvY2s6IC9eKChgfH4pezMsfSkvLFxufTtcbmZ1bmN0aW9uIHNhbml0aXplTGlua0F0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICBpZiAoIWF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0ge307XG4gICAgYXZhaWxhYmxlTGlua0F0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWRfMShhdHRyaWJ1dGVba2V5XSkpIHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzW2tleV0gPSBhdHRyaWJ1dGVba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsaW5rQXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIHJlcGVhdCQxKHRleHQsIGNvdW50KSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgICByZXN1bHQgKz0gdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzTmVlZEVzY2FwZVRleHQodGV4dCkge1xuICAgIHZhciBuZWVkRXNjYXBlID0gZmFsc2U7XG4gICAgZm9yRWFjaE93blByb3BlcnRpZXNfMShyZU1hcmtkb3duVGV4dFRvRXNjYXBlTWFwLCBmdW5jdGlvbiAocmVNYXJrZG93blRleHRUb0VzY2FwZSkge1xuICAgICAgICBpZiAocmVNYXJrZG93blRleHRUb0VzY2FwZS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICBuZWVkRXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW5lZWRFc2NhcGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5lZWRFc2NhcGU7XG59XG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yTGluayh0ZXh0KSB7XG4gICAgdmFyIGltYWdlU3ludGF4UmFuZ2VzID0gW107XG4gICAgdmFyIHJlc3VsdCA9IHJlTWRJbWFnZVN5bnRheC5leGVjKHRleHQpO1xuICAgIHdoaWxlIChyZXN1bHQpIHtcbiAgICAgICAgaW1hZ2VTeW50YXhSYW5nZXMucHVzaChbcmVzdWx0LmluZGV4LCByZXN1bHQuaW5kZXggKyByZXN1bHRbMF0ubGVuZ3RoXSk7XG4gICAgICAgIHJlc3VsdCA9IHJlTWRJbWFnZVN5bnRheC5leGVjKHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlRXNjYXBlZENoYXJJbkxpbmtTeW50YXgsIGZ1bmN0aW9uIChtYXRjaGVkLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGlzRGVsaW1pdGVyID0gaW1hZ2VTeW50YXhSYW5nZXMuc29tZShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIG9mZnNldCA+IHJhbmdlWzBdICYmIG9mZnNldCA8IHJhbmdlWzFdOyB9KTtcbiAgICAgICAgcmV0dXJuIGlzRGVsaW1pdGVyID8gbWF0Y2hlZCA6IFwiXFxcXFwiICsgbWF0Y2hlZDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZSQxKHRleHQpIHtcbiAgICB2YXIgYWhlYWRSZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaGVkKSB7IHJldHVybiBcIlxcXFxcIiArIG1hdGNoZWQ7IH07XG4gICAgdmFyIGJlaGluZFJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoZWQpIHsgcmV0dXJuIG1hdGNoZWQgKyBcIlxcXFxcIjsgfTtcbiAgICB2YXIgZXNjYXBlZFRleHQgPSB0ZXh0LnJlcGxhY2UocmVTcGFjZU1vcmVUaGFuT25lLCAnICcpO1xuICAgIGlmIChyZUVzY2FwZUJhY2tTbGFzaC50ZXN0KGVzY2FwZWRUZXh0KSkge1xuICAgICAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVCYWNrU2xhc2gsIGFoZWFkUmVwbGFjZXIpO1xuICAgIH1cbiAgICBpZiAocmVFc2NhcGVCYWNrU2xhc2hJblNlbnRlbmNlLnRlc3QoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZUJhY2tTbGFzaEluU2VudGVuY2UsIGJlaGluZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlUGFpcmVkQ2hhcnMsIGFoZWFkUmVwbGFjZXIpO1xuICAgIGlmIChyZUVzY2FwZUhUTUwudGVzdChlc2NhcGVkVGV4dCkpIHtcbiAgICAgICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlSFRNTCwgYWhlYWRSZXBsYWNlcik7XG4gICAgfVxuICAgIGlmIChpc05lZWRFc2NhcGVUZXh0KGVzY2FwZWRUZXh0KSkge1xuICAgICAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVDaGFycyQxLCBhaGVhZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xufVxuZnVuY3Rpb24gcXVvdGUodGV4dCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHRleHQuaW5kZXhPZignXCInKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzdWx0ID0gJ1wiXCInO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGV4dC5pbmRleE9mKFwiJ1wiKSA9PT0gLTEgPyBcIicnXCIgOiAnKCknO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0WzBdICsgdGV4dCArIHJlc3VsdFsxXTtcbn1cbmZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVsbF8xKHZhbHVlKSB8fCBpc1VuZGVmaW5lZF8xKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvMSwgbzIpIHtcbiAgICBpZiAobzEgPT09IG51bGwgJiYgbzEgPT09IG8yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8xICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbzIgIT09ICdvYmplY3QnIHx8IGlzTmlsKG8xKSB8fCBpc05pbChvMikpIHtcbiAgICAgICAgcmV0dXJuIG8xID09PSBvMjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG8xKSB7XG4gICAgICAgIGlmIChvMVtrZXldICE9PSBvMltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG8yKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBvMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGxhc3QkMShhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGJldHdlZW4kMSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0JDEob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZWRDb3B5KHRhcmdldE9iaiwgb2JqKSB7XG4gICAgdmFyIHJlc3VsdE9iaiA9IF9fYXNzaWduJDEoe30sIHRhcmdldE9iaik7XG4gICAgaWYgKHRhcmdldE9iaiAmJiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QkMShyZXN1bHRPYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwQ29weUFycmF5KG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdE9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwTWVyZ2VkQ29weShyZXN1bHRPYmpbcHJvcF0sIG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwQ29weShvYmpbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRPYmo7XG59XG5mdW5jdGlvbiBkZWVwQ29weUFycmF5KGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXNPYmplY3QkMShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBkZWVwQ29weUFycmF5KGl0ZW0pIDogZGVlcENvcHkoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCkge1xuICAgICAgICBpZiAoaXNPYmplY3QkMShvYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICBhY2NbcHJvcF0gPSBBcnJheS5pc0FycmF5KG9ialtwcm9wXSkgPyBkZWVwQ29weUFycmF5KG9ialtwcm9wXSkgOiBkZWVwQ29weShvYmpbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWNjW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldE9iaiwgb2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdm9pZCAwKSB7IG9iaiA9IHt9OyB9XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICh0YXJnZXRPYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgdHlwZW9mIHRhcmdldE9ialtwcm9wXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmpbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NpZ24odGFyZ2V0T2JqW3Byb3BdLCBvYmpbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldE9iajtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZE51bVBhaXIodmFsdWVBLCB2YWx1ZUIpIHtcbiAgICByZXR1cm4gdmFsdWVBID4gdmFsdWVCID8gW3ZhbHVlQiwgdmFsdWVBXSA6IFt2YWx1ZUEsIHZhbHVlQl07XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUcmFuc2Zvcm0gdGhlIEFycmF5LWxpa2Ugb2JqZWN0IHRvIEFycmF5LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGZvckVhY2hBcnJheSA9IGZvckVhY2hBcnJheV8xO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgQXJyYXktbGlrZSBvYmplY3QgdG8gQXJyYXkuXG4gKiBJbiBsb3cgSUUgKGJlbG93IDgpLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCBpcyBub3QgcGVyZmVjdC4gU28sIHRyeS1jYXRjaCBzdGF0ZW1lbnQgaXMgdXNlZC5cbiAqIEBwYXJhbSB7Kn0gYXJyYXlMaWtlIEFycmF5LWxpa2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCB0b0FycmF5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi90b0FycmF5JzsgXG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL3RvQXJyYXknKTsgXG4gKlxuICogY29uc3QgYXJyYXlMaWtlID0ge1xuICogICAwOiAnb25lJyxcbiAqICAgMTogJ3R3bycsXG4gKiAgIDI6ICd0aHJlZScsXG4gKiAgIDM6ICdmb3VyJyxcbiAqICAgbGVuZ3RoOiA0XG4gKiB9O1xuICogY29uc3QgcmVzdWx0ID0gdG9BcnJheShhcnJheUxpa2UpO1xuICpcbiAqIGFsZXJ0KHJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KTsgLy8gdHJ1ZVxuICogYWxlcnQocmVzdWx0KTsgLy8gb25lLHR3byx0aHJlZSxmb3VyXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkkMShhcnJheUxpa2UpIHtcbiAgdmFyIGFycjtcbiAgdHJ5IHtcbiAgICBhcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYXJyID0gW107XG4gICAgZm9yRWFjaEFycmF5KGFycmF5TGlrZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbnZhciB0b0FycmF5XzEgPSB0b0FycmF5JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFncmFwaChzY2hlbWEsIGNvbnRlbnQpIHtcbiAgICB2YXIgcGFyYWdyYXBoID0gc2NoZW1hLm5vZGVzLnBhcmFncmFwaDtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFncmFwaC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhZ3JhcGguY3JlYXRlKG51bGwsIGlzU3RyaW5nXzEoY29udGVudCkgPyBzY2hlbWEudGV4dChjb250ZW50KSA6IGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHRleHQsIG1hcmtzKSB7XG4gICAgcmV0dXJuIHNjaGVtYS50ZXh0KHRleHQsIG1hcmtzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGZyb20sIHRvKSB7XG4gICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBmcm9tOyB9XG4gICAgdmFyIGNvbnRlbnRTaXplID0gdHIuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICB2YXIgc2l6ZSA9IGNvbnRlbnRTaXplID4gMCA/IGNvbnRlbnRTaXplIC0gMSA6IDE7XG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgTWF0aC5taW4oZnJvbSwgc2l6ZSksIE1hdGgubWluKHRvLCBzaXplKSk7XG59XG5mdW5jdGlvbiBhZGRQYXJhZ3JhcGgodHIsIF9hLCBzY2hlbWEpIHtcbiAgICB2YXIgcG9zID0gX2EucG9zO1xuICAgIHRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCBjcmVhdGVQYXJhZ3JhcGgoc2NoZW1hKSk7XG4gICAgcmV0dXJuIHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBwb3MgKyAxKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGV4dE5vZGUoX2EpIHtcbiAgICB2YXIgc3RhdGUgPSBfYS5zdGF0ZSwgZnJvbSA9IF9hLmZyb20sIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4LCBjcmVhdGVUZXh0ID0gX2EuY3JlYXRlVGV4dDtcbiAgICB2YXIgdHIgPSBzdGF0ZS50ciwgZG9jID0gc3RhdGUuZG9jLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPD0gZW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgX2IgPSBkb2MuY2hpbGQoaSksIG5vZGVTaXplID0gX2Iubm9kZVNpemUsIHRleHRDb250ZW50ID0gX2IudGV4dENvbnRlbnQsIGNvbnRlbnQgPSBfYi5jb250ZW50O1xuICAgICAgICB2YXIgdGV4dCA9IGNyZWF0ZVRleHQodGV4dENvbnRlbnQpO1xuICAgICAgICB2YXIgbm9kZSA9IHRleHQgPyBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgdGV4dCkgOiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgdmFyIG1hcHBlZEZyb20gPSB0ci5tYXBwaW5nLm1hcChmcm9tKTtcbiAgICAgICAgdmFyIG1hcHBlZFRvID0gbWFwcGVkRnJvbSArIGNvbnRlbnQuc2l6ZTtcbiAgICAgICAgdHIucmVwbGFjZVdpdGgobWFwcGVkRnJvbSwgbWFwcGVkVG8sIG5vZGUpO1xuICAgICAgICBmcm9tICs9IG5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBzcGxpdEFuZEV4dGVuZEJsb2NrKHRyLCBwb3MsIHRleHQsIG5vZGUpIHtcbiAgICB2YXIgdGV4dExlbiA9IHRleHQubGVuZ3RoO1xuICAgIHRyLnNwbGl0KHBvcylcbiAgICAgICAgLmRlbGV0ZShwb3MgLSB0ZXh0TGVuLCBwb3MpXG4gICAgICAgIC5pbnNlcnQodHIubWFwcGluZy5tYXAocG9zKSwgbm9kZSlcbiAgICAgICAgLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChwb3MpIC0gdGV4dExlbikpO1xufVxuXG5mdW5jdGlvbiBnZXRNZFN0YXJ0TGluZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlLnNvdXJjZXBvc1swXVswXTtcbn1cbmZ1bmN0aW9uIGdldE1kRW5kTGluZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlLnNvdXJjZXBvc1sxXVswXTtcbn1cbmZ1bmN0aW9uIGdldE1kU3RhcnRDaChtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlLnNvdXJjZXBvc1swXVsxXTtcbn1cbmZ1bmN0aW9uIGdldE1kRW5kQ2gobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZS5zb3VyY2Vwb3NbMV1bMV07XG59XG5mdW5jdGlvbiBpc0hUTUxOb2RlKG1kTm9kZSkge1xuICAgIHZhciB0eXBlID0gbWROb2RlLnR5cGU7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdodG1sQmxvY2snIHx8IHR5cGUgPT09ICdodG1sSW5saW5lJztcbn1cbmZ1bmN0aW9uIGlzU3R5bGVkSW5saW5lTm9kZShtZE5vZGUpIHtcbiAgICB2YXIgdHlwZSA9IG1kTm9kZS50eXBlO1xuICAgIHJldHVybiAodHlwZSA9PT0gJ3N0cmlrZScgfHxcbiAgICAgICAgdHlwZSA9PT0gJ3N0cm9uZycgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2VtcGgnIHx8XG4gICAgICAgIHR5cGUgPT09ICdjb2RlJyB8fFxuICAgICAgICB0eXBlID09PSAnbGluaycgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2ltYWdlJyk7XG59XG5mdW5jdGlvbiBpc0NvZGVCbG9ja05vZGUobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZSAmJiBtZE5vZGUudHlwZSA9PT0gJ2NvZGVCbG9jayc7XG59XG5mdW5jdGlvbiBpc0xpc3ROb2RlJDEobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZSAmJiAobWROb2RlLnR5cGUgPT09ICdpdGVtJyB8fCBtZE5vZGUudHlwZSA9PT0gJ2xpc3QnKTtcbn1cbmZ1bmN0aW9uIGlzT3JkZXJlZExpc3ROb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBpc0xpc3ROb2RlJDEobWROb2RlKSAmJiBtZE5vZGUubGlzdERhdGEudHlwZSA9PT0gJ29yZGVyZWQnO1xufVxuZnVuY3Rpb24gaXNCdWxsZXRMaXN0Tm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gaXNMaXN0Tm9kZSQxKG1kTm9kZSkgJiYgbWROb2RlLmxpc3REYXRhLnR5cGUgIT09ICdvcmRlcmVkJztcbn1cbmZ1bmN0aW9uIGlzVGFibGVDZWxsTm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlICYmIChtZE5vZGUudHlwZSA9PT0gJ3RhYmxlQ2VsbCcgfHwgbWROb2RlLnR5cGUgPT09ICd0YWJsZURlbGltQ2VsbCcpO1xufVxuZnVuY3Rpb24gaXNJbmxpbmVOb2RlJDEobWROb2RlKSB7XG4gICAgc3dpdGNoIChtZE5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICBjYXNlICdodG1sSW5saW5lJzpcbiAgICAgICAgY2FzZSAnbGluZWJyZWFrJzpcbiAgICAgICAgY2FzZSAnc29mdGJyZWFrJzpcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0Tm9kZShtZE5vZGUsIGNvbmRpdGlvbiwgaW5jbHVkZVNlbGYpIHtcbiAgICBpZiAoaW5jbHVkZVNlbGYgPT09IHZvaWQgMCkgeyBpbmNsdWRlU2VsZiA9IHRydWU7IH1cbiAgICBtZE5vZGUgPSBpbmNsdWRlU2VsZiA/IG1kTm9kZSA6IG1kTm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKG1kTm9kZSAmJiBtZE5vZGUudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICBpZiAoY29uZGl0aW9uKG1kTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBhcmVudE5vZGVzKG1kTm9kZSwgaXRlcmF0ZWUsIGluY2x1ZGVTZWxmKSB7XG4gICAgaWYgKGluY2x1ZGVTZWxmID09PSB2b2lkIDApIHsgaW5jbHVkZVNlbGYgPSB0cnVlOyB9XG4gICAgbWROb2RlID0gaW5jbHVkZVNlbGYgPyBtZE5vZGUgOiBtZE5vZGUucGFyZW50O1xuICAgIHdoaWxlIChtZE5vZGUgJiYgbWROb2RlLnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgaXRlcmF0ZWUobWROb2RlKTtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRPZmZzZXRQb3Mob3JpZ2luUG9zLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gW29yaWdpblBvc1swXSwgb3JpZ2luUG9zWzFdICsgb2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIHNldE9mZnNldFBvcyhvcmlnaW5Qb3MsIG5ld09mZnNldCkge1xuICAgIHJldHVybiBbb3JpZ2luUG9zWzBdLCBuZXdPZmZzZXRdO1xufVxuZnVuY3Rpb24gZ2V0SW5saW5lTWFya2Rvd25UZXh0KG1kTm9kZSkge1xuICAgIHZhciB0ZXh0ID0gbWROb2RlLmZpcnN0Q2hpbGQubGl0ZXJhbDtcbiAgICBzd2l0Y2ggKG1kTm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICAgICAgcmV0dXJuIFwiKlwiICsgdGV4dCArIFwiKlwiO1xuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICAgICAgcmV0dXJuIFwiKipcIiArIHRleHQgKyBcIioqXCI7XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgICAgICByZXR1cm4gXCJ+flwiICsgdGV4dCArIFwifn5cIjtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgICByZXR1cm4gXCJgXCIgKyB0ZXh0ICsgXCJgXCI7XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuICAgICAgICAgICAgdmFyIF9hID0gbWROb2RlLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uLCB0aXRsZSA9IF9hLnRpdGxlO1xuICAgICAgICAgICAgdmFyIGRlbGltID0gbWROb2RlLnR5cGUgPT09ICdsaW5rJyA/ICcnIDogJyEnO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGltICsgXCJbXCIgKyB0ZXh0ICsgXCJdKFwiICsgZGVzdGluYXRpb24gKyAodGl0bGUgPyBcIiBcXFwiXCIgKyB0aXRsZSArIFwiXFxcIlwiIDogJycpICsgXCIpXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5lciQyKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrUXVvdGUnOlxuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICBjYXNlICd0YWJsZUhlYWQnOlxuICAgICAgICBjYXNlICd0YWJsZUJvZHknOlxuICAgICAgICBjYXNlICd0YWJsZVJvdyc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQ2VsbCc6XG4gICAgICAgIGNhc2UgJ3RhYmxlRGVsaW1Sb3cnOlxuICAgICAgICBjYXNlICdjdXN0b21JbmxpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW5UZXh0JDEobm9kZSkge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgd2Fsa2VyID0gbm9kZS53YWxrZXIoKTtcbiAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGNoaWxkTm9kZS5saXRlcmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xufVxuXG52YXIgd2lkZ2V0UnVsZXMgPSBbXTtcbnZhciB3aWRnZXRSdWxlTWFwID0ge307XG52YXIgcmVXaWRnZXRQcmVmaXggPSAvXFwkXFwkd2lkZ2V0XFxkK1xccy87XG5mdW5jdGlvbiB1bndyYXBXaWRnZXRTeW50YXgodGV4dCkge1xuICAgIHZhciBpbmRleCA9IHRleHQuc2VhcmNoKHJlV2lkZ2V0UHJlZml4KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGV4dC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSByZXN0LnJlcGxhY2UocmVXaWRnZXRQcmVmaXgsICcnKS5yZXBsYWNlKCckJCcsICcnKTtcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgdGV4dCArPSB1bndyYXBXaWRnZXRTeW50YXgocmVwbGFjZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpZGdldENvbnRlbnQoaW5mbywgdGV4dCkge1xuICAgIHJldHVybiBcIiQkXCIgKyBpbmZvICsgXCIgXCIgKyB0ZXh0ICsgXCIkJFwiO1xufVxuZnVuY3Rpb24gd2lkZ2V0VG9ET00oaW5mbywgdGV4dCkge1xuICAgIHZhciBfYSA9IHdpZGdldFJ1bGVNYXBbaW5mb10sIHJ1bGUgPSBfYS5ydWxlLCB0b0RPTSA9IF9hLnRvRE9NO1xuICAgIHZhciBtYXRjaGVzID0gdW53cmFwV2lkZ2V0U3ludGF4KHRleHQpLm1hdGNoKHJ1bGUpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHRleHQgPSBtYXRjaGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdG9ET00odGV4dCk7XG59XG5mdW5jdGlvbiBnZXRXaWRnZXRSdWxlcygpIHtcbiAgICByZXR1cm4gd2lkZ2V0UnVsZXM7XG59XG5mdW5jdGlvbiBzZXRXaWRnZXRSdWxlcyhydWxlcykge1xuICAgIHdpZGdldFJ1bGVzID0gcnVsZXM7XG4gICAgd2lkZ2V0UnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSwgaW5kZXgpIHtcbiAgICAgICAgd2lkZ2V0UnVsZU1hcFtcIndpZGdldFwiICsgaW5kZXhdID0gcnVsZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1lcmdlTm9kZXMobm9kZXMsIHRleHQsIHNjaGVtYSwgcnVsZUluZGV4KSB7XG4gICAgcmV0dXJuIG5vZGVzLmNvbmNhdChjcmVhdGVOb2Rlc1dpdGhXaWRnZXQodGV4dCwgc2NoZW1hLCBydWxlSW5kZXgpKTtcbn1cbi8qKlxuICogY3JlYXRlIG5vZGVzIHdpdGggcGxhaW4gdGV4dCBhbmQgcmVwbGFjZSB0ZXh0IG1hdGNoZWQgdG8gdGhlIHdpZGdldCBydWxlcyB3aXRoIHRoZSB3aWRnZXQgbm9kZVxuICogRm9yIGV4YW1wbGUsIGluIGNhc2UgdGhlIHRleHQgYW5kIHdpZGdldCBydWxlcyBhcyBiZWxvd1xuICpcbiAqIHRleHQ6ICR0ZXN0IHBsYWluIHRleHQgI3Rlc3RcbiAqIHdpZGdldCBydWxlczogW3sgcnVsZTogLyQuKy8gfSwgeyBydWxlOiAvIy4rLyB9XVxuICpcbiAqIFRoZSBjcmVhdGluZyBub2RlIHByb2Nlc3MgaXMgcmVjdXJzaXZlIGFuZCBpcyBhcyBmb2xsb3dzLlxuICpcbiAqIGluIGZpcnN0IHdpZGdldCBydWxlKC8kLisvKVxuICogICR0ZXN0IC0+IHdpZGdldCBub2RlXG4gKiAgcGxhaW4gdGV4dCAtPiBtYXRjaCB3aXRoIG5leHQgd2lkZ2V0IHJ1bGVcbiAqICAjdGVzdCAtPiBtYXRjaCB3aXRoIG5leHQgd2lkZ2V0IHJ1bGVcbiAqXG4gKiBpbiBzZWNvbmQgd2lkZ2V0IHJ1bGUoLyMuKy8pXG4gKiAgcGxhaW4gdGV4dCAtPiB0ZXh0IG5vZGUobm8gcnVsZSBmb3IgbWF0Y2hpbmcpXG4gKiAgI3Rlc3QgLT4gd2lkZ2V0IG5vZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KHRleHQsIHNjaGVtYSwgcnVsZUluZGV4KSB7XG4gICAgaWYgKHJ1bGVJbmRleCA9PT0gdm9pZCAwKSB7IHJ1bGVJbmRleCA9IDA7IH1cbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgcnVsZSA9ICh3aWRnZXRSdWxlc1tydWxlSW5kZXhdIHx8IHt9KS5ydWxlO1xuICAgIHZhciBuZXh0UnVsZUluZGV4ID0gcnVsZUluZGV4ICsgMTtcbiAgICB0ZXh0ID0gdW53cmFwV2lkZ2V0U3ludGF4KHRleHQpO1xuICAgIGlmIChydWxlICYmIHJ1bGUudGVzdCh0ZXh0KSkge1xuICAgICAgICB2YXIgaW5kZXggPSB2b2lkIDA7XG4gICAgICAgIHdoaWxlICgoaW5kZXggPSB0ZXh0LnNlYXJjaChydWxlKSkgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRleHQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIC8vIGdldCB3aWRnZXQgbm9kZSBvbiBmaXJzdCBzcGxpdHRlZCB0ZXh0IHVzaW5nIG5leHQgd2lkZ2V0IHJ1bGVcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgbm9kZXMgPSBtZXJnZU5vZGVzKG5vZGVzLCBwcmV2LCBzY2hlbWEsIG5leHRSdWxlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnVpbGQgd2lkZ2V0IG5vZGUgdXNpbmcgY3VycmVudCB3aWRnZXQgcnVsZVxuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gdGV4dC5tYXRjaChydWxlKVswXTtcbiAgICAgICAgICAgIHZhciBpbmZvID0gXCJ3aWRnZXRcIiArIHJ1bGVJbmRleDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goc2NoZW1hLm5vZGVzLndpZGdldC5jcmVhdGUoeyBpbmZvOiBpbmZvIH0sIHNjaGVtYS50ZXh0KGNyZWF0ZVdpZGdldENvbnRlbnQoaW5mbywgbGl0ZXJhbCkpKSk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCB3aWRnZXQgbm9kZSBvbiBsYXN0IHNwbGl0dGVkIHRleHQgdXNpbmcgbmV4dCB3aWRnZXQgcnVsZVxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgbm9kZXMgPSBtZXJnZU5vZGVzKG5vZGVzLCB0ZXh0LCBzY2hlbWEsIG5leHRSdWxlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleHQpIHtcbiAgICAgICAgbm9kZXMgPVxuICAgICAgICAgICAgcnVsZUluZGV4IDwgd2lkZ2V0UnVsZXMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgID8gbWVyZ2VOb2Rlcyhub2RlcywgdGV4dCwgc2NoZW1hLCBuZXh0UnVsZUluZGV4KVxuICAgICAgICAgICAgICAgIDogW3NjaGVtYS50ZXh0KHRleHQpXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZnVuY3Rpb24gZ2V0V2lkZ2V0Q29udGVudCh3aWRnZXROb2RlKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgdmFyIHdhbGtlciA9IHdpZGdldE5vZGUud2Fsa2VyKCk7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gd2lkZ2V0Tm9kZSAmJiBub2RlLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gZ2V0SW5saW5lTWFya2Rvd25UZXh0KG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgd2Fsa2VyLnJlc3VtZUF0KHdpZGdldE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGV0ZVNlbGVjdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVsZXRlU2VsZWN0aW9uOyB9LFxuICAgICAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdEFsbDsgfSxcbiAgICAgICAgdW5kbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kbzsgfSxcbiAgICAgICAgcmVkbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVkbzsgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBzdGF0ZS5kb2M7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBkb2MuY2hpbGRDb3VudCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBkb2MuZmlyc3RDaGlsZC5pc1RleHRibG9jayAmJlxuICAgICAgICAgICAgICAgICAgICBkb2MuZmlyc3RDaGlsZC5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlSG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzc18xKHBsYWNlSG9sZGVyLCAncGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzc18xKHBsYWNlSG9sZGVyLCBvcHRpb25zLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGxhY2VIb2xkZXIudGV4dENvbnRlbnQgPSBvcHRpb25zLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIFtEZWNvcmF0aW9uLndpZGdldCgxLCBwbGFjZUhvbGRlcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgZWxlbWVudCBoYXMgc3BlY2lmaWMgY3NzIGNsYXNzXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaW5BcnJheSQxID0gaW5BcnJheV8xO1xudmFyIGdldENsYXNzID0gZ2V0Q2xhc3NfMTtcblxuLyoqXG4gKiBDaGVjayBlbGVtZW50IGhhcyBzcGVjaWZpYyBjc3MgY2xhc3NcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NDbGFzcyAtIGNzcyBjbGFzc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgdmFyIG9yaWdpbjtcblxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpO1xuICB9XG5cbiAgb3JpZ2luID0gZ2V0Q2xhc3MoZWxlbWVudCkuc3BsaXQoL1xccysvKTtcblxuICByZXR1cm4gaW5BcnJheSQxKGNzc0NsYXNzLCBvcmlnaW4pID4gLTE7XG59XG5cbnZhciBoYXNDbGFzc18xID0gaGFzQ2xhc3M7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayBlbGVtZW50IG1hdGNoIHNlbGVjdG9yXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaW5BcnJheSA9IGluQXJyYXlfMTtcbnZhciB0b0FycmF5ID0gdG9BcnJheV8xO1xuXG52YXIgZWxQcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xudmFyIG1hdGNoU2VsZWN0b3IgPSBlbFByb3RvLm1hdGNoZXMgfHxcbiAgICBlbFByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgIGVsUHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZWxQcm90by5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2N1bWVudCB8fCB0aGlzLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgIHJldHVybiBpbkFycmF5KHRoaXMsIHRvQXJyYXkoZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSkgPiAtMTtcbiAgICB9O1xuXG4vKipcbiAqIENoZWNrIGVsZW1lbnQgbWF0Y2ggc2VsZWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBzZWxlY3RvciB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IGlzIHNlbGVjdG9yIG1hdGNoZWQgdG8gZWxlbWVudD9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBtYXRjaFNlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufVxuXG52YXIgbWF0Y2hlc18xID0gbWF0Y2hlcztcblxudmFyIFRBR19OQU1FID0gJ1tBLVphLXpdW0EtWmEtejAtOS1dKic7XG52YXIgQVRUUklCVVRFX05BTUUgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xudmFyIFVOUVVPVEVEX1ZBTFVFID0gJ1teXCJcXCc9PD5gXFxcXHgwMC1cXFxceDIwXSsnO1xudmFyIFNJTkdMRV9RVU9URURfVkFMVUUgPSBcIidbXiddKidcIjtcbnZhciBET1VCTEVfUVVPVEVEX1ZBTFVFID0gJ1wiW15cIl0qXCInO1xudmFyIEFUVFJJQlVURV9WQUxVRSA9IFwiKD86XCIgKyBVTlFVT1RFRF9WQUxVRSArIFwifFwiICsgU0lOR0xFX1FVT1RFRF9WQUxVRSArIFwifFwiICsgRE9VQkxFX1FVT1RFRF9WQUxVRSArIFwiKVwiO1xudmFyIEFUVFJJQlVURV9WQUxVRV9TUEVDID0gXCJcIiArICcoPzpcXFxccyo9XFxcXHMqJyArIEFUVFJJQlVURV9WQUxVRSArIFwiKVwiO1xudmFyIEFUVFJJQlVURSQxID0gXCJcIiArICcoPzpcXFxccysnICsgQVRUUklCVVRFX05BTUUgKyBBVFRSSUJVVEVfVkFMVUVfU1BFQyArIFwiPylcIjtcbnZhciBPUEVOX1RBRyA9IFwiPChcIiArIFRBR19OQU1FICsgXCIpKFwiICsgQVRUUklCVVRFJDEgKyBcIikqXFxcXHMqLz8+XCI7XG52YXIgQ0xPU0VfVEFHID0gXCI8LyhcIiArIFRBR19OQU1FICsgXCIpXFxcXHMqWz5dXCI7XG52YXIgSFRNTF9UQUcgPSBcIig/OlwiICsgT1BFTl9UQUcgKyBcInxcIiArIENMT1NFX1RBRyArIFwiKVwiO1xudmFyIHJlSFRNTFRhZyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBIVE1MX1RBRywgJ2knKTtcbnZhciByZUJSID0gLzxiclxccypcXC8qPi9pO1xudmFyIHJlSFRNTENvbW1lbnQgPSAvPCEgLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4vO1xudmFyIEFMVEVSTkFUSVZFX1RBR19GT1JfQlIgPSAnPC9wPjxwPic7XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbkJveChzdHlsZSwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIHZhciBsZWZ0ID0gcGFyc2VJbnQoc3R5bGUubGVmdCwgMTApO1xuICAgIHZhciB0b3AgPSBwYXJzZUludChzdHlsZS50b3AsIDEwKTtcbiAgICB2YXIgd2lkdGggPSBwYXJzZUludChzdHlsZS53aWR0aCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ0xlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xuICAgIHZhciBoZWlnaHQgPSBwYXJzZUludChzdHlsZS5oZWlnaHQsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3AsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICByZXR1cm4gb2Zmc2V0WCA+PSBsZWZ0ICYmIG9mZnNldFggPD0gbGVmdCArIHdpZHRoICYmIG9mZnNldFkgPj0gdG9wICYmIG9mZnNldFkgPD0gdG9wICsgaGVpZ2h0O1xufVxudmFyIENMU19QUkVGSVggPSAndG9hc3R1aS1lZGl0b3ItJztcbmZ1bmN0aW9uIGNscygpIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBuYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgX2EgPSAwLCBuYW1lc18xID0gbmFtZXM7IF9hIDwgbmFtZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVzXzFbX2FdO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdm9pZCAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lXzEpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBuYW1lXzFbMF0gPyBuYW1lXzFbMV0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gbmFtZV8xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiXCIgKyBDTFNfUFJFRklYICsgY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGNsc1dpdGhNZFByZWZpeCgpIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBuYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMubWFwKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuIENMU19QUkVGSVggKyBcIm1kLVwiICsgY2xhc3NOYW1lOyB9KS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5ub2RlVHlwZSkgPT09IE5vZGUuVEVYVF9OT0RFO1xufVxuZnVuY3Rpb24gaXNFbGVtTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG5mdW5jdGlvbiBmaW5kTm9kZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbm9kZUxpc3QgPSB0b0FycmF5XzEoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgaWYgKG5vZGVMaXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbm9kZUxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGFwcGVuZE5vZGVzKG5vZGUsIG5vZGVzVG9BcHBlbmQpIHtcbiAgICBub2Rlc1RvQXBwZW5kID0gaXNBcnJheV8xKG5vZGVzVG9BcHBlbmQpID8gdG9BcnJheV8xKG5vZGVzVG9BcHBlbmQpIDogW25vZGVzVG9BcHBlbmRdO1xuICAgIG5vZGVzVG9BcHBlbmQuZm9yRWFjaChmdW5jdGlvbiAobm9kZVRvQXBwZW5kKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobm9kZVRvQXBwZW5kKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZU5vZGUoaW5zZXJ0ZWROb2RlLCBub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGluc2VydGVkTm9kZSwgbm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlTm9kZSQxKG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bndyYXBOb2RlKG5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICByZXN1bHQucHVzaChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUuZmlyc3RDaGlsZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTm9kZSQxKG5vZGUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIHN0YXRlKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkXzEoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlID0gIWhhc0NsYXNzXzEoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgdmFyIHRvZ2dsZUZuID0gc3RhdGUgPyBhZGRDbGFzc18xIDogcmVtb3ZlQ2xhc3NfMTtcbiAgICB0b2dnbGVGbihlbGVtZW50LCBjbGFzc05hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGgoY29udGVudHMsIHRhcmdldCkge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpZiAoaXNTdHJpbmdfMShjb250ZW50cykpIHtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGNvbnRlbnRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRlbnRzKTtcbiAgICB9XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBnZXRPdXRlcldpZHRoKGVsKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHJldHVybiAoWydtYXJnaW4tbGVmdCcsICdtYXJnaW4tcmlnaHQnXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHlwZSkgeyByZXR1cm4gYWNjICsgcGFyc2VJbnQoY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSh0eXBlKSwgMTApOyB9LCAwKSArIGVsLm9mZnNldFdpZHRoKTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3Qobm9kZSwgZm91bmQpIHtcbiAgICB2YXIgY29uZGl0aW9uO1xuICAgIGlmIChpc1N0cmluZ18xKGZvdW5kKSkge1xuICAgICAgICBjb25kaXRpb24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiBtYXRjaGVzXzEodGFyZ2V0LCBmb3VuZCk7IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25kaXRpb24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgPT09IGZvdW5kOyB9O1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBkb2N1bWVudCkge1xuICAgICAgICBpZiAoaXNFbGVtTm9kZShub2RlKSAmJiBjb25kaXRpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VG90YWxPZmZzZXQoZWwsIHJvb3QpIHtcbiAgICB2YXIgb2Zmc2V0VG9wID0gMDtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IDA7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSByb290KSB7XG4gICAgICAgIHZhciB0b3BfMSA9IGVsLm9mZnNldFRvcCwgbGVmdCA9IGVsLm9mZnNldExlZnQsIG9mZnNldFBhcmVudCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICAgICAgb2Zmc2V0VG9wICs9IHRvcF8xO1xuICAgICAgICBvZmZzZXRMZWZ0ICs9IGxlZnQ7XG4gICAgICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IHJvb3Qub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHsgb2Zmc2V0VG9wOiBvZmZzZXRUb3AsIG9mZnNldExlZnQ6IG9mZnNldExlZnQgfTtcbn1cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcywgZWxlbWVudCkge1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIGlmIChpc05pbChhdHRyaWJ1dGVzW2F0dHJOYW1lXSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyaWJ1dGVzW2F0dHJOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VCUldpdGhFbXB0eUJsb2NrKGh0bWwpIHtcbiAgICAvLyByZW1vdmUgYnIgaW4gcGFyYWdyYXBoIHRvIGNvbXBhdGlibGUgd2l0aCBtYXJrZG93blxuICAgIHZhciByZXBsYWNlZEhUTUwgPSBodG1sLnJlcGxhY2UoLzxwPjxiclxccypcXC8qPjxcXC9wPi9naSwgJzxwPjwvcD4nKTtcbiAgICB2YXIgcmVIVE1MVGFnID0gbmV3IFJlZ0V4cChIVE1MX1RBRywgJ2lnJyk7XG4gICAgdmFyIGh0bWxUYWdNYXRjaGVkID0gcmVwbGFjZWRIVE1MLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgaHRtbFRhZ01hdGNoZWQgPT09IG51bGwgfHwgaHRtbFRhZ01hdGNoZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0bWxUYWdNYXRjaGVkLmZvckVhY2goZnVuY3Rpb24gKGh0bWxUYWcsIGluZGV4KSB7XG4gICAgICAgIGlmIChyZUJSLnRlc3QoaHRtbFRhZykpIHtcbiAgICAgICAgICAgIHZhciBhbHRlcm5hdGl2ZVRhZyA9IEFMVEVSTkFUSVZFX1RBR19GT1JfQlI7XG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlRhZyA9IGh0bWxUYWdNYXRjaGVkW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIG9wZW5UYWdNYXRjaGVkID0gcHJldlRhZy5tYXRjaChPUEVOX1RBRyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5UYWdNYXRjaGVkICYmICEvYnIvaS50ZXN0KG9wZW5UYWdNYXRjaGVkWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnTmFtZSA9IG9wZW5UYWdNYXRjaGVkWzFdO1xuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZVRhZyA9IFwiPC9cIiArIHRhZ05hbWUgKyBcIj48XCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZWRIVE1MID0gcmVwbGFjZWRIVE1MLnJlcGxhY2UocmVCUiwgYWx0ZXJuYXRpdmVUYWcpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcGxhY2VkSFRNTDtcbn1cbmZ1bmN0aW9uIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKGh0bWwpIHtcbiAgICB2YXIgcmVQcm9zZU1pcnJvckltYWdlID0gLzxpbWcgY2xhc3M9XCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIiBhbHQ9XCJcIj4vZztcbiAgICB2YXIgcmVQcm9zZU1pcnJvclRyYWlsaW5nQnJlYWsgPSAvIGNsYXNzPVwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiL2c7XG4gICAgdmFyIHJlc3VsdEhUTUwgPSBodG1sO1xuICAgIHJlc3VsdEhUTUwgPSByZXN1bHRIVE1MLnJlcGxhY2UocmVQcm9zZU1pcnJvckltYWdlLCAnJyk7XG4gICAgcmVzdWx0SFRNTCA9IHJlc3VsdEhUTUwucmVwbGFjZShyZVByb3NlTWlycm9yVHJhaWxpbmdCcmVhaywgJycpO1xuICAgIHJldHVybiByZXN1bHRIVE1MO1xufVxuXG52YXIgcGx1Z2luS2V5JDEgPSBuZXcgUGx1Z2luS2V5KCd3aWRnZXQnKTtcbnZhciBNQVJHSU4gPSA1O1xudmFyIFBvcHVwV2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvcHVwV2lkZ2V0KHZpZXcsIGV2ZW50RW1pdHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW1vdmVXaWRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucG9wdXApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yb290RWwucmVtb3ZlQ2hpbGQoX3RoaXMucG9wdXApO1xuICAgICAgICAgICAgICAgIF90aGlzLnBvcHVwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yb290RWwgPSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdibHVyJywgdGhpcy5yZW1vdmVXaWRnZXQpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2xvYWRVSScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJvb3RFbCA9IGNsb3Nlc3Qodmlldy5kb20ucGFyZW50RWxlbWVudCwgXCIuXCIgKyBjbHMoJ2RlZmF1bHRVSScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbigncmVtb3ZlUG9wdXBXaWRnZXQnLCB0aGlzLnJlbW92ZVdpZGdldCk7XG4gICAgfVxuICAgIFBvcHVwV2lkZ2V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodmlldykge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gcGx1Z2luS2V5JDEuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlV2lkZ2V0KCk7XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gd2lkZ2V0Lm5vZGUsIHN0eWxlID0gd2lkZ2V0LnN0eWxlO1xuICAgICAgICAgICAgdmFyIF9hID0gdmlldy5jb29yZHNBdFBvcyh3aWRnZXQucG9zKSwgdG9wXzEgPSBfYS50b3AsIGxlZnQgPSBfYS5sZWZ0LCBib3R0b20gPSBfYS5ib3R0b207XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wXzE7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMucm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHJlbFRvcFBvcyA9IHRvcF8xIC0gcmVjdC50b3A7XG4gICAgICAgICAgICBjc3NfMShub2RlLCB7IG9wYWNpdHk6ICcwJyB9KTtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgY3NzXzEobm9kZSwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQgLSByZWN0LmxlZnQgKyBNQVJHSU4gKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgdG9wOiAoc3R5bGUgPT09ICdib3R0b20nID8gcmVsVG9wUG9zICsgaGVpZ2h0IC0gTUFSR0lOIDogcmVsVG9wUG9zIC0gaGVpZ2h0KSArIFwicHhcIixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAnMScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucG9wdXAgPSBub2RlO1xuICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3B1cFdpZGdldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKCdibHVyJywgdGhpcy5yZW1vdmVXaWRnZXQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcHVwV2lkZ2V0O1xufSgpKTtcbmZ1bmN0aW9uIGFkZFdpZGdldChldmVudEVtaXR0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogcGx1Z2luS2V5JDEsXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHk6IGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ci5nZXRNZXRhKCd3aWRnZXQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uIChlZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvcHVwV2lkZ2V0KGVkaXRvclZpZXcsIGV2ZW50RW1pdHRlcik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERlZmF1bHRJbWFnZUJsb2JIb29rKGV2ZW50RW1pdHRlcikge1xuICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ2FkZEltYWdlQmxvYkhvb2snLCBmdW5jdGlvbiAoYmxvYiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW1pdEltYWdlQmxvYkhvb2soZXZlbnRFbWl0dGVyLCBibG9iLCB0eXBlKSB7XG4gICAgdmFyIGhvb2sgPSBmdW5jdGlvbiAoaW1hZ2VVcmwsIGFsdFRleHQpIHtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbW1hbmQnLCAnYWRkSW1hZ2UnLCB7XG4gICAgICAgICAgICBpbWFnZVVybDogaW1hZ2VVcmwsXG4gICAgICAgICAgICBhbHRUZXh0OiBhbHRUZXh0IHx8IGJsb2IubmFtZSB8fCAnaW1hZ2UnLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGV2ZW50RW1pdHRlci5lbWl0KCdhZGRJbWFnZUJsb2JIb29rJywgYmxvYiwgaG9vaywgdHlwZSk7XG59XG5mdW5jdGlvbiBwYXN0ZUltYWdlT25seShpdGVtcykge1xuICAgIHZhciBpbWFnZXMgPSB0b0FycmF5XzEoaXRlbXMpLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5pbmRleE9mKCdpbWFnZScpICE9PSAtMTtcbiAgICB9KTtcbiAgICBpZiAoaW1hZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgaXRlbSA9IGltYWdlc1swXTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmdldEFzRmlsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkcm9wSW1hZ2UoX2EpIHtcbiAgICB2YXIgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIGRyb3A6IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IChfYSA9IGV2LmRhdGFUcmFuc2ZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2hBcnJheV8xKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUuaW5kZXhPZignaW1hZ2UnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRJbWFnZUJsb2JIb29rKGV2ZW50RW1pdHRlciwgaXRlbSwgZXYudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxudmFyIE5vZGUkMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdub2RlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5vZGUucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuXG5mdW5jdGlvbiB3aWRnZXROb2RlVmlldyhwbU5vZGUpIHtcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHZhciBub2RlID0gd2lkZ2V0VG9ET00ocG1Ob2RlLmF0dHJzLmluZm8sIHBtTm9kZS50ZXh0Q29udGVudCk7XG4gICAgZG9tLmNsYXNzTmFtZSA9ICd0dWktd2lkZ2V0JztcbiAgICBkb20uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIHsgZG9tOiBkb20gfTtcbn1cbmZ1bmN0aW9uIGlzV2lkZ2V0Tm9kZShwbU5vZGUpIHtcbiAgICByZXR1cm4gcG1Ob2RlLnR5cGUubmFtZSA9PT0gJ3dpZGdldCc7XG59XG52YXIgV2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFdpZGdldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaWRnZXQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpZGdldC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd3aWRnZXQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpZGdldC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGV4dConLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF0b206IHRydWUsXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6ICd0dWktd2lkZ2V0JyB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ3NwYW4udHVpLXdpZGdldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZG9tLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHRleHQubWF0Y2goL1xcJFxcJCh3aWRnZXRcXGQrKS8pLCBpbmZvID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5mbzogaW5mbyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBXaWRnZXQ7XG59KE5vZGUkMikpO1xuXG52YXIgRWRpdG9yQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGl0b3JCYXNlKGV2ZW50RW1pdHRlcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTmFtZSA9ICd0b2FzdHVpLWVkaXRvcic7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0geyB0ZXh0OiAnJyB9O1xuICAgIH1cbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jcmVhdGVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgcGx1Z2luczogdGhpcy5jcmVhdGVQbHVnaW5zKCksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXIsIHZpZXcgPSBfYS52aWV3LCBlZGl0b3JUeXBlID0gX2EuZWRpdG9yVHlwZTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudEVtaXR0ZXIuZW1pdCgnZm9jdXMnLCBlZGl0b3JUeXBlKTsgfSk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudEVtaXR0ZXIuZW1pdCgnYmx1cicsIGVkaXRvclR5cGUpOyB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmVtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICh0cikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjYXJldENoYW5nZScsIHRoaXMuZWRpdG9yVHlwZSk7XG4gICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWRpdG9yQmFzZS5wcm90b3R5cGUsIFwiZGVmYXVsdFBsdWdpbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMuY3JlYXRlSW5wdXRSdWxlcygpO1xuICAgICAgICAgICAgdmFyIHBsdWdpbnMgPSBfX3NwcmVhZEFycmF5JDEoX19zcHJlYWRBcnJheSQxKFtdLCB0aGlzLmtleW1hcHMpLCBbXG4gICAgICAgICAgICAgICAga2V5bWFwKF9fYXNzaWduJDEoeyAnU2hpZnQtRW50ZXInOiBiYXNlS2V5bWFwLkVudGVyIH0sIGJhc2VLZXltYXApKSxcbiAgICAgICAgICAgICAgICBoaXN0b3J5KCksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIodGhpcy5wbGFjZWhvbGRlciksXG4gICAgICAgICAgICAgICAgYWRkV2lkZ2V0KHRoaXMuZXZlbnRFbWl0dGVyKSxcbiAgICAgICAgICAgICAgICBkcm9wSW1hZ2UodGhpcy5jb250ZXh0KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzID8gcGx1Z2lucy5jb25jYXQocnVsZXMpIDogcGx1Z2lucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmNyZWF0ZUlucHV0UnVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3aWRnZXRSdWxlcyA9IGdldFdpZGdldFJ1bGVzKCk7XG4gICAgICAgIHZhciBydWxlcyA9IHdpZGdldFJ1bGVzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBydWxlID0gX2EucnVsZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHJ1bGUsIGZ1bmN0aW9uIChzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCB0ciA9IHN0YXRlLnRyLCBkb2MgPSBzdGF0ZS5kb2M7XG4gICAgICAgICAgICAgICAgdmFyIGFsbE1hdGNoZWQgPSBtYXRjaC5pbnB1dC5tYXRjaChuZXcgUmVnRXhwKHJ1bGUsICdnJykpO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBkb2MucmVzb2x2ZShzdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBvcy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNXaWRnZXROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcG9zLm5vZGUocG9zLmRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gaXNXaWRnZXROb2RlKGNoaWxkKSAmJiAoY291bnQgKz0gMSk7IH0pO1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGNvbnRlbnQgb25seSBpZiB0aGUgY291bnQgb2YgbWF0Y2hlZCBydWxlcyBpbiB3aG9sZSB0ZXh0IGlzIGdyZWF0ZXIgdGhhbiBjdXJyZW50IHdpZGdldCBub2RlIGNvdW50XG4gICAgICAgICAgICAgICAgaWYgKGFsbE1hdGNoZWQubGVuZ3RoID4gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBsYXN0JDEoYWxsTWF0Y2hlZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IGNyZWF0ZU5vZGVzV2l0aFdpZGdldChjb250ZW50LCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3Qgc3RhcnQgcG9zaXRpb24gYmFzZWQgb24gd2lkZ2V0IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2VXaXRoKGVuZCAtIGNvbnRlbnQubGVuZ3RoICsgMSwgZW5kLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnVsZXMubGVuZ3RoID8gaW5wdXRSdWxlcyh7IHJ1bGVzOiBydWxlcyB9KSA6IG51bGw7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmNyZWF0ZVNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgICAgICAgICAgbm9kZXM6IHRoaXMuc3BlY3Mubm9kZXMsXG4gICAgICAgICAgICBtYXJrczogdGhpcy5zcGVjcy5tYXJrcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jcmVhdGVLZXltYXBzID0gZnVuY3Rpb24gKHVzZUNvbW1hbmRTaG9ydGN1dCkge1xuICAgICAgICB2YXIgX2EgPSBnZXREZWZhdWx0Q29tbWFuZHMoKSwgdW5kbyA9IF9hLnVuZG8sIHJlZG8gPSBfYS5yZWRvO1xuICAgICAgICB2YXIgYWxsS2V5bWFwcyA9IHRoaXMuc3BlY3Mua2V5bWFwcyh1c2VDb21tYW5kU2hvcnRjdXQpO1xuICAgICAgICB2YXIgaGlzdG9yeUtleW1hcCA9IHtcbiAgICAgICAgICAgICdNb2Qteic6IHVuZG8oKSxcbiAgICAgICAgICAgICdTaGlmdC1Nb2Qteic6IHJlZG8oKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHVzZUNvbW1hbmRTaG9ydGN1dCA/IGFsbEtleW1hcHMuY29uY2F0KGtleW1hcChoaXN0b3J5S2V5bWFwKSkgOiBhbGxLZXltYXBzO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuY3JlYXRlQ29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWNzLmNvbW1hbmRzKHRoaXMudmlldyk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jcmVhdGVQbHVnaW5Qcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFQbHVnaW5zLm1hcChmdW5jdGlvbiAocGx1Z2luKSB7IHJldHVybiBwbHVnaW4oX3RoaXMuZXZlbnRFbWl0dGVyKTsgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGVycm9yIGZvciBJRTExXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuZGlzcGF0Y2goX3RoaXMudmlldy5zdGF0ZS50ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLmJsdXIoKTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICB0aGlzLnZpZXcuZGVzdHJveSgpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXNbcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUubW92ZUN1cnNvclRvU3RhcnQgPSBmdW5jdGlvbiAoZm9jdXMpIHtcbiAgICAgICAgdmFyIHRyID0gdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIDEpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLm1vdmVDdXJzb3JUb0VuZCA9IGZ1bmN0aW9uIChmb2N1cykge1xuICAgICAgICB2YXIgdHIgPSB0aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIuZG9jLmNvbnRlbnQuc2l6ZSAtIDEpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICh0b3ApIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5zY3JvbGxUb3AgPSB0b3A7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZG9tLnNjcm9sbFRvcDtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLnNldFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlci50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRoaXMudmlldy5zdGF0ZS50ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgY3NzXzEodGhpcy5lbCwgeyBoZWlnaHQ6IGhlaWdodCArIFwicHhcIiB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLnNldE1pbkhlaWdodCA9IGZ1bmN0aW9uIChtaW5IZWlnaHQpIHtcbiAgICAgICAgY3NzXzEodGhpcy5lbCwgeyBtaW5IZWlnaHQ6IG1pbkhlaWdodCArIFwicHhcIiB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsO1xuICAgIH07XG4gICAgcmV0dXJuIEVkaXRvckJhc2U7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvbiBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24sIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgZnVuY3Rpb24/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuXG52YXIgaXNGdW5jdGlvbl8xID0gaXNGdW5jdGlvbjtcblxudmFyIGRlZmF1bHRDb21tYW5kU2hvcnRjdXRzID0gW1xuICAgICdFbnRlcicsXG4gICAgJ1NoaWZ0LUVudGVyJyxcbiAgICAnTW9kLUVudGVyJyxcbiAgICAnVGFiJyxcbiAgICAnU2hpZnQtVGFiJyxcbiAgICAnRGVsZXRlJyxcbiAgICAnQmFja3NwYWNlJyxcbiAgICAnTW9kLURlbGV0ZScsXG4gICAgJ01vZC1CYWNrc3BhY2UnLFxuICAgICdBcnJvd1VwJyxcbiAgICAnQXJyb3dEb3duJyxcbiAgICAnQXJyb3dMZWZ0JyxcbiAgICAnQXJyb3dSaWdodCcsXG4gICAgJ01vZC1kJyxcbiAgICAnTW9kLUQnLFxuICAgICdBbHQtQXJyb3dVcCcsXG4gICAgJ0FsdC1BcnJvd0Rvd24nLFxuXTtcbmZ1bmN0aW9uIGV4ZWNDb21tYW5kKHZpZXcsIGNvbW1hbmQsIHBheWxvYWQpIHtcbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgcmV0dXJuIGNvbW1hbmQocGF5bG9hZCkodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldyk7XG59XG52YXIgU3BlY01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3BlY01hbmFnZXIoc3BlY3MpIHtcbiAgICAgICAgdGhpcy5zcGVjcyA9IHNwZWNzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BlY01hbmFnZXIucHJvdG90eXBlLCBcIm5vZGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGVjc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHNwZWMpIHsgcmV0dXJuIHNwZWMudHlwZSA9PT0gJ25vZGUnOyB9KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG5vZGVzLCBfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBub2RlcyksIChfYiA9IHt9LCBfYltuYW1lXSA9IHNjaGVtYSwgX2IpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGVjTWFuYWdlci5wcm90b3R5cGUsIFwibWFya3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwZWNzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc3BlYykgeyByZXR1cm4gc3BlYy50eXBlID09PSAnbWFyayc7IH0pXG4gICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAobWFya3MsIF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIG1hcmtzKSwgKF9iID0ge30sIF9iW25hbWVdID0gc2NoZW1hLCBfYikpO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3BlY01hbmFnZXIucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKHZpZXcsIGFkZGVkQ29tbWFuZHMpIHtcbiAgICAgICAgdmFyIHNwZWNDb21tYW5kcyA9IHRoaXMuc3BlY3NcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY29tbWFuZHMgPSBfYS5jb21tYW5kcztcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFsbENvbW1hbmRzLCBzcGVjKSB7XG4gICAgICAgICAgICB2YXIgY29tbWFuZHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBzcGVjQ29tbWFuZCA9IHNwZWMuY29tbWFuZHMoKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uXzEoc3BlY0NvbW1hbmQpKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZHNbc3BlYy5uYW1lXSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBleGVjQ29tbWFuZCh2aWV3LCBzcGVjQ29tbWFuZCwgcGF5bG9hZCk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzcGVjQ29tbWFuZCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1tuYW1lXSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBleGVjQ29tbWFuZCh2aWV3LCBzcGVjQ29tbWFuZFtuYW1lXSwgcGF5bG9hZCk7IH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhbGxDb21tYW5kcyksIGNvbW1hbmRzKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgZGVmYXVsdENvbW1hbmRzID0gZ2V0RGVmYXVsdENvbW1hbmRzKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRDb21tYW5kcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgc3BlY0NvbW1hbmRzW25hbWVdID0gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGV4ZWNDb21tYW5kKHZpZXcsIGRlZmF1bHRDb21tYW5kc1tuYW1lXSwgcGF5bG9hZCk7IH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWRkZWRDb21tYW5kcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkZWRDb21tYW5kcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHNwZWNDb21tYW5kc1tuYW1lXSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBleGVjQ29tbWFuZCh2aWV3LCBhZGRlZENvbW1hbmRzW25hbWVdLCBwYXlsb2FkKTsgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGVjQ29tbWFuZHM7XG4gICAgfTtcbiAgICBTcGVjTWFuYWdlci5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICh1c2VDb21tYW5kU2hvcnRjdXQpIHtcbiAgICAgICAgdmFyIHNwZWNLZXltYXBzID0gdGhpcy5zcGVjcy5maWx0ZXIoZnVuY3Rpb24gKHNwZWMpIHsgcmV0dXJuIHNwZWMua2V5bWFwczsgfSkubWFwKGZ1bmN0aW9uIChzcGVjKSB7IHJldHVybiBzcGVjLmtleW1hcHMoKTsgfSk7XG4gICAgICAgIHJldHVybiBzcGVjS2V5bWFwcy5tYXAoZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIGlmICghdXNlQ29tbWFuZFNob3J0Y3V0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoa2V5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5jbHVkZXMoZGVmYXVsdENvbW1hbmRTaG9ydGN1dHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBrZXlzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXltYXAoa2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3BlY01hbmFnZXIucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLnNwZWNzLmZvckVhY2goZnVuY3Rpb24gKHNwZWMpIHtcbiAgICAgICAgICAgIHNwZWMuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3BlY01hbmFnZXI7XG59KCkpO1xuXG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uUG9zKHNlbGVjdGlvbikge1xuICAgIHZhciBmcm9tID0gc2VsZWN0aW9uLmZyb20sIHRvID0gc2VsZWN0aW9uLnRvO1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFtmcm9tICsgMSwgdG8gLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIFtmcm9tLCB0b107XG59XG5mdW5jdGlvbiBnZXRNZExpbmUocmVzb2x2ZWRQb3MpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRQb3MuaW5kZXgoMCkgKyAxO1xufVxuZnVuY3Rpb24gZ2V0V2lkZ2V0Tm9kZVBvcyhub2RlLCBjaFBvcywgZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7IGRpcmVjdGlvbiA9IDE7IH1cbiAgICB2YXIgYWRkaXRpb25hbFBvcyA9IDA7XG4gICAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgcG9zKSB7XG4gICAgICAgIC8vIGFkZCBvciBzdWJ0cmFjdCB3aWRnZXQgbm9kZSB0YWdcbiAgICAgICAgaWYgKGlzV2lkZ2V0Tm9kZShjaGlsZCkgJiYgcG9zICsgMiA8IGNoUG9zKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUG9zICs9IDIgKiBkaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWRkaXRpb25hbFBvcztcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclRvTWRQb3MoZG9jLCBmcm9tLCB0bykge1xuICAgIGlmICh0byA9PT0gdm9pZCAwKSB7IHRvID0gZnJvbTsgfVxuICAgIHZhciBjb2xsYXBzZWQgPSBmcm9tID09PSB0bztcbiAgICB2YXIgc3RhcnRSZXNvbHZlZFBvcyA9IGRvYy5yZXNvbHZlKGZyb20pO1xuICAgIHZhciBzdGFydExpbmUgPSBnZXRNZExpbmUoc3RhcnRSZXNvbHZlZFBvcyk7XG4gICAgdmFyIGVuZExpbmUgPSBzdGFydExpbmU7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gc3RhcnRSZXNvbHZlZFBvcy5zdGFydCgxKTtcbiAgICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgLy8gcHJldmVudCB0aGUgZW5kIG9mZnNldCBmcm9tIHBvaW50aW5nIHRvIHRoZSByb290IGRvY3VtZW50IHBvc2l0aW9uXG4gICAgICAgIHZhciBlbmRSZXNvbHZlZFBvcyA9IGRvYy5yZXNvbHZlKHRvID09PSBkb2MuY29udGVudC5zaXplID8gdG8gLSAxIDogdG8pO1xuICAgICAgICBlbmRPZmZzZXQgPSBlbmRSZXNvbHZlZFBvcy5zdGFydCgxKTtcbiAgICAgICAgZW5kTGluZSA9IGdldE1kTGluZShlbmRSZXNvbHZlZFBvcyk7XG4gICAgICAgIC8vIFRvIHJlc29sdmUgdGhlIGVuZCBvZmZzZXQgZXhjbHVkaW5nIGRvY3VtZW50IHRhZyBzaXplXG4gICAgICAgIGlmIChlbmRSZXNvbHZlZFBvcy5wb3MgPT09IGRvYy5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIHRvID0gZG9jLmNvbnRlbnQuc2l6ZSAtIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0YXJ0Q2ggPSBNYXRoLm1heChmcm9tIC0gc3RhcnRPZmZzZXQgKyAxLCAxKTtcbiAgICB2YXIgZW5kQ2ggPSBNYXRoLm1heCh0byAtIGVuZE9mZnNldCArIDEsIDEpO1xuICAgIHJldHVybiBbXG4gICAgICAgIFtzdGFydExpbmUsIHN0YXJ0Q2ggKyBnZXRXaWRnZXROb2RlUG9zKGRvYy5jaGlsZChzdGFydExpbmUgLSAxKSwgc3RhcnRDaCwgLTEpXSxcbiAgICAgICAgW2VuZExpbmUsIGVuZENoICsgZ2V0V2lkZ2V0Tm9kZVBvcyhkb2MuY2hpbGQoZW5kTGluZSAtIDEpLCBlbmRDaCwgLTEpXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRQb3NMaXN0UGVyTGluZShkb2MsIGVuZEluZGV4KSB7XG4gICAgdmFyIHN0YXJ0UG9zTGlzdFBlckxpbmUgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgaSA8IGVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gZG9jLmNoaWxkKGkpO1xuICAgICAgICBzdGFydFBvc0xpc3RQZXJMaW5lW2ldID0gcG9zO1xuICAgICAgICBwb3MgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBvc0xpc3RQZXJMaW5lO1xufVxuZnVuY3Rpb24gZ2V0TWRUb0VkaXRvclBvcyhkb2MsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICB2YXIgc3RhcnRQb3NMaXN0UGVyTGluZSA9IGdldFN0YXJ0UG9zTGlzdFBlckxpbmUoZG9jLCBlbmRQb3NbMF0pO1xuICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnRQb3NbMF0gLSAxO1xuICAgIHZhciBlbmRJbmRleCA9IGVuZFBvc1swXSAtIDE7XG4gICAgdmFyIHN0YXJ0Tm9kZSA9IGRvYy5jaGlsZChzdGFydEluZGV4KTtcbiAgICB2YXIgZW5kTm9kZSA9IGRvYy5jaGlsZChlbmRJbmRleCk7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBsaW5lXG4gICAgdmFyIGZyb20gPSBzdGFydFBvc0xpc3RQZXJMaW5lW3N0YXJ0SW5kZXhdO1xuICAgIHZhciB0byA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbZW5kSW5kZXhdO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgY2hhcmFjdGVyIG9mZnNldCBvZiB0aGUgbGluZVxuICAgIGZyb20gKz0gc3RhcnRQb3NbMV0gKyBnZXRXaWRnZXROb2RlUG9zKHN0YXJ0Tm9kZSwgc3RhcnRQb3NbMV0gLSAxKTtcbiAgICB0byArPSBlbmRQb3NbMV0gKyBnZXRXaWRnZXROb2RlUG9zKGVuZE5vZGUsIGVuZFBvc1sxXSAtIDEpO1xuICAgIHJldHVybiBbZnJvbSwgTWF0aC5taW4odG8sIGRvYy5jb250ZW50LnNpemUpXTtcbn1cbmZ1bmN0aW9uIGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pIHtcbiAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG87XG4gICAgdmFyIGRvYyA9ICRmcm9tLmRvYztcbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uKSB7XG4gICAgICAgICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSArIDEpO1xuICAgICAgICAkdG8gPSBkb2MucmVzb2x2ZSh0byAtIDEpO1xuICAgIH1cbiAgICBpZiAoJGZyb20uZGVwdGggPT09IDApIHtcbiAgICAgICAgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tIC0gMSk7XG4gICAgICAgICR0byA9ICRmcm9tO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydEZyb21PZmZzZXQ6ICRmcm9tLnN0YXJ0KDEpLFxuICAgICAgICBlbmRGcm9tT2Zmc2V0OiAkdG8uc3RhcnQoMSksXG4gICAgICAgIHN0YXJ0VG9PZmZzZXQ6ICRmcm9tLmVuZCgxKSxcbiAgICAgICAgZW5kVG9PZmZzZXQ6ICR0by5lbmQoMSksXG4gICAgICAgIHN0YXJ0SW5kZXg6ICRmcm9tLmluZGV4KDApLFxuICAgICAgICBlbmRJbmRleDogJHRvLmluZGV4KDApLFxuICAgICAgICBmcm9tOiAkZnJvbS5wb3MsXG4gICAgICAgIHRvOiAkdG8ucG9zLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXROb2RlQ29udGVudE9mZnNldFJhbmdlKGRvYywgdGFyZ2V0SW5kZXgpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSAxO1xuICAgIHZhciBlbmRPZmZzZXQgPSAxO1xuICAgIGZvciAodmFyIGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgZG9jLmNoaWxkQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbm9kZVNpemUgPSBkb2MuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBjb250ZW50IHN0YXJ0LCBlbmQgb2Zmc2V0KG5vdCBub2RlIG9mZnNldClcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQgKyAxO1xuICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQgKyBub2RlU2l6ZSAtIDE7XG4gICAgICAgIGlmIChpID09PSB0YXJnZXRJbmRleCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IG5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsIGVuZE9mZnNldDogZW5kT2Zmc2V0IH07XG59XG5cbnZhciBIRUFESU5HID0gJ2hlYWRpbmcnO1xudmFyIEJMT0NLX1FVT1RFID0gJ2Jsb2NrUXVvdGUnO1xudmFyIExJU1RfSVRFTSA9ICdsaXN0SXRlbSc7XG52YXIgVEFCTEUgPSAndGFibGUnO1xudmFyIFRBQkxFX0NFTEwgPSAndGFibGVDZWxsJztcbnZhciBDT0RFX0JMT0NLID0gJ2NvZGVCbG9jayc7XG52YXIgVEhFTUFUSUNfQlJFQUsgPSAndGhlbWF0aWNCcmVhayc7XG52YXIgTElOSyA9ICdsaW5rJztcbnZhciBDT0RFID0gJ2NvZGUnO1xudmFyIE1FVEEgPSAnbWV0YSc7XG52YXIgREVMSU0gPSAnZGVsaW1pdGVyJztcbnZhciBUQVNLX0RFTElNID0gJ3Rhc2tEZWxpbWl0ZXInO1xudmFyIFRFWFQgPSAnbWFya2VkVGV4dCc7XG52YXIgSFRNTCA9ICdodG1sJztcbnZhciBDVVNUT01fQkxPQ0sgPSAnY3VzdG9tQmxvY2snO1xudmFyIGRlbGltU2l6ZSA9IHtcbiAgICBzdHJvbmc6IDIsXG4gICAgZW1waDogMSxcbiAgICBzdHJpa2U6IDIsXG59O1xuZnVuY3Rpb24gbWFya0luZm8oc3RhcnQsIGVuZCwgdHlwZSwgYXR0cnMpIHtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBzcGVjOiB7IHR5cGU6IHR5cGUsIGF0dHJzOiBhdHRycyB9IH07XG59XG5mdW5jdGlvbiBoZWFkaW5nJDEoX2EsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbGV2ZWwgPSBfYS5sZXZlbCwgaGVhZGluZ1R5cGUgPSBfYS5oZWFkaW5nVHlwZTtcbiAgICB2YXIgbWFya3MgPSBbbWFya0luZm8oc3RhcnQsIGVuZCwgSEVBRElORywgeyBsZXZlbDogbGV2ZWwgfSldO1xuICAgIGlmIChoZWFkaW5nVHlwZSA9PT0gJ2F0eCcpIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhzdGFydCwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBsZXZlbCksIERFTElNKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKHNldE9mZnNldFBvcyhlbmQsIDApLCBlbmQsIEhFQURJTkcsIHsgc2VUZXh0OiB0cnVlIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuZnVuY3Rpb24gZW1waGFzaXNBbmRTdHJpa2V0aHJvdWdoKF9hLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgIHZhciBzdGFydERlbGltUG9zID0gYWRkT2Zmc2V0UG9zKHN0YXJ0LCBkZWxpbVNpemVbdHlwZV0pO1xuICAgIHZhciBlbmREZWxpbVBvcyA9IGFkZE9mZnNldFBvcyhlbmQsIC1kZWxpbVNpemVbdHlwZV0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtJbmZvKHN0YXJ0RGVsaW1Qb3MsIGVuZERlbGltUG9zLCB0eXBlKSxcbiAgICAgICAgbWFya0luZm8oc3RhcnQsIHN0YXJ0RGVsaW1Qb3MsIERFTElNKSxcbiAgICAgICAgbWFya0luZm8oZW5kRGVsaW1Qb3MsIGVuZCwgREVMSU0pLFxuICAgIF07XG59XG5mdW5jdGlvbiBtYXJrTGluayhzdGFydCwgZW5kLCBsaW5rVGV4dFN0YXJ0LCBsYXN0Q2hpbGRDaCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtJbmZvKHN0YXJ0LCBlbmQsIExJTkspLFxuICAgICAgICBtYXJrSW5mbyhzZXRPZmZzZXRQb3Moc3RhcnQsIGxpbmtUZXh0U3RhcnRbMV0gKyAxKSwgc2V0T2Zmc2V0UG9zKGVuZCwgbGFzdENoaWxkQ2gpLCBMSU5LLCB7XG4gICAgICAgICAgICBkZXNjOiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgbWFya0luZm8oc2V0T2Zmc2V0UG9zKGVuZCwgbGFzdENoaWxkQ2ggKyAyKSwgYWRkT2Zmc2V0UG9zKGVuZCwgLTEpLCBMSU5LLCB7IHVybDogdHJ1ZSB9KSxcbiAgICBdO1xufVxuZnVuY3Rpb24gaW1hZ2UkMShfYSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSBfYS5sYXN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RDaGlsZENoID0gbGFzdENoaWxkID8gZ2V0TWRFbmRDaChsYXN0Q2hpbGQpICsgMSA6IDM7IC8vIDM6IGxlbmd0aCBvZiAnIVtdJ1xuICAgIHZhciBsaW5rVGV4dEVuZCA9IGFkZE9mZnNldFBvcyhzdGFydCwgMSk7XG4gICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkkMShbbWFya0luZm8oc3RhcnQsIGxpbmtUZXh0RW5kLCBNRVRBKV0sIG1hcmtMaW5rKHN0YXJ0LCBlbmQsIGxpbmtUZXh0RW5kLCBsYXN0Q2hpbGRDaCkpO1xufVxuZnVuY3Rpb24gbGluayhfYSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSBfYS5sYXN0Q2hpbGQsIGV4dGVuZGVkQXV0b2xpbmsgPSBfYS5leHRlbmRlZEF1dG9saW5rO1xuICAgIHZhciBsYXN0Q2hpbGRDaCA9IGxhc3RDaGlsZCA/IGdldE1kRW5kQ2gobGFzdENoaWxkKSArIDEgOiAyOyAvLyAyOiBsZW5ndGggb2YgJ1tdJ1xuICAgIHJldHVybiBleHRlbmRlZEF1dG9saW5rXG4gICAgICAgID8gW21hcmtJbmZvKHN0YXJ0LCBlbmQsIExJTkssIHsgZGVzYzogdHJ1ZSB9KV1cbiAgICAgICAgOiBtYXJrTGluayhzdGFydCwgZW5kLCBzdGFydCwgbGFzdENoaWxkQ2gpO1xufVxuZnVuY3Rpb24gY29kZShfYSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciB0aWNrQ291bnQgPSBfYS50aWNrQ291bnQ7XG4gICAgdmFyIG9wZW5EZWxpbUVuZCA9IGFkZE9mZnNldFBvcyhzdGFydCwgdGlja0NvdW50KTtcbiAgICB2YXIgY2xvc2VEZWxpbVN0YXJ0ID0gYWRkT2Zmc2V0UG9zKGVuZCwgLXRpY2tDb3VudCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFya0luZm8oc3RhcnQsIGVuZCwgQ09ERSksXG4gICAgICAgIG1hcmtJbmZvKHN0YXJ0LCBvcGVuRGVsaW1FbmQsIENPREUsIHsgc3RhcnQ6IHRydWUgfSksXG4gICAgICAgIG1hcmtJbmZvKG9wZW5EZWxpbUVuZCwgY2xvc2VEZWxpbVN0YXJ0LCBDT0RFLCB7IG1hcmtlZDogdHJ1ZSB9KSxcbiAgICAgICAgbWFya0luZm8oY2xvc2VEZWxpbVN0YXJ0LCBlbmQsIENPREUsIHsgZW5kOiB0cnVlIH0pLFxuICAgIF07XG59XG5mdW5jdGlvbiBsaW5lQmFja2dyb3VuZChwYXJlbnQsIHN0YXJ0LCBlbmQsIHByZWZpeCkge1xuICAgIHZhciBkZWZhdWx0QmFja2dyb3VuZCA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgc3BlYzoge1xuICAgICAgICAgICAgYXR0cnM6IHsgY2xhc3NOYW1lOiBwcmVmaXggKyBcIi1saW5lLWJhY2tncm91bmRcIiwgY29kZVN0YXJ0OiBzdGFydFswXSwgY29kZUVuZDogZW5kWzBdIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVCYWNrZ3JvdW5kOiB0cnVlLFxuICAgIH07XG4gICAgcmV0dXJuIHBhcmVudC50eXBlICE9PSAnaXRlbScgJiYgcGFyZW50LnR5cGUgIT09ICdibG9ja1F1b3RlJ1xuICAgICAgICA/IFtcbiAgICAgICAgICAgIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgZGVmYXVsdEJhY2tncm91bmQpLCB7IGVuZDogc3RhcnQsIHNwZWM6IHsgYXR0cnM6IHsgY2xhc3NOYW1lOiBwcmVmaXggKyBcIi1saW5lLWJhY2tncm91bmQgc3RhcnRcIiB9IH0gfSksXG4gICAgICAgICAgICBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGRlZmF1bHRCYWNrZ3JvdW5kKSwgeyBzdGFydDogW01hdGgubWluKHN0YXJ0WzBdICsgMSwgZW5kWzBdKSwgc3RhcnRbMV1dIH0pLFxuICAgICAgICBdXG4gICAgICAgIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvZGVCbG9jayQxKG5vZGUsIHN0YXJ0LCBlbmQsIGVuZExpbmUpIHtcbiAgICB2YXIgZmVuY2VPZmZzZXQgPSBub2RlLmZlbmNlT2Zmc2V0LCBmZW5jZUxlbmd0aCA9IG5vZGUuZmVuY2VMZW5ndGgsIGZlbmNlQ2hhciA9IG5vZGUuZmVuY2VDaGFyLCBpbmZvID0gbm9kZS5pbmZvLCBpbmZvUGFkZGluZyA9IG5vZGUuaW5mb1BhZGRpbmcsIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIHZhciBmZW5jZUVuZCA9IGZlbmNlT2Zmc2V0ICsgZmVuY2VMZW5ndGg7XG4gICAgdmFyIG1hcmtzID0gW21hcmtJbmZvKHNldE9mZnNldFBvcyhzdGFydCwgMSksIGVuZCwgQ09ERV9CTE9DSyldO1xuICAgIGlmIChmZW5jZUNoYXIpIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhzdGFydCwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBmZW5jZUVuZCksIERFTElNKSk7XG4gICAgfVxuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oYWRkT2Zmc2V0UG9zKHN0YXJ0LCBmZW5jZUxlbmd0aCksIGFkZE9mZnNldFBvcyhzdGFydCwgZmVuY2VMZW5ndGggKyBpbmZvUGFkZGluZyArIGluZm8ubGVuZ3RoKSwgTUVUQSkpO1xuICAgIH1cbiAgICB2YXIgY29kZUJsb2NrRW5kID0gXCJeKFxcXFxzezAsNH0pKFwiICsgZmVuY2VDaGFyICsgXCJ7XCIgKyBmZW5jZUxlbmd0aCArIFwiLH0pXCI7XG4gICAgdmFyIHJlQ29kZUJsb2NrRW5kID0gbmV3IFJlZ0V4cChjb2RlQmxvY2tFbmQpO1xuICAgIGlmIChyZUNvZGVCbG9ja0VuZC50ZXN0KGVuZExpbmUpKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oc2V0T2Zmc2V0UG9zKGVuZCwgMSksIGVuZCwgREVMSU0pKTtcbiAgICB9XG4gICAgdmFyIGxpbmVCYWNrZ3JvdW5kTWFya0luZm8gPSBsaW5lQmFja2dyb3VuZChwYXJlbnQsIHN0YXJ0LCBlbmQsICdjb2RlLWJsb2NrJyk7XG4gICAgcmV0dXJuIGxpbmVCYWNrZ3JvdW5kTWFya0luZm8gPyBtYXJrcy5jb25jYXQobGluZUJhY2tncm91bmRNYXJrSW5mbykgOiBtYXJrcztcbn1cbmZ1bmN0aW9uIGN1c3RvbUJsb2NrJDIobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBfYSA9IG5vZGUsIG9mZnNldCA9IF9hLm9mZnNldCwgc3ludGF4TGVuZ3RoID0gX2Euc3ludGF4TGVuZ3RoLCBpbmZvID0gX2EuaW5mbywgcGFyZW50ID0gX2EucGFyZW50O1xuICAgIHZhciBzeW50YXhFbmQgPSBvZmZzZXQgKyBzeW50YXhMZW5ndGg7XG4gICAgdmFyIG1hcmtzID0gW21hcmtJbmZvKHNldE9mZnNldFBvcyhzdGFydCwgMSksIGVuZCwgQ1VTVE9NX0JMT0NLKV07XG4gICAgbWFya3MucHVzaChtYXJrSW5mbyhzdGFydCwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBzeW50YXhFbmQpLCBERUxJTSkpO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oYWRkT2Zmc2V0UG9zKHN0YXJ0LCBzeW50YXhFbmQpLCBhZGRPZmZzZXRQb3Moc3RhcnQsIHN5bnRheExlbmd0aCArIGluZm8ubGVuZ3RoKSwgTUVUQSkpO1xuICAgIH1cbiAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKHNldE9mZnNldFBvcyhlbmQsIDEpLCBlbmQsIERFTElNKSk7XG4gICAgdmFyIGxpbmVCYWNrZ3JvdW5kTWFya0luZm8gPSBsaW5lQmFja2dyb3VuZChwYXJlbnQsIHN0YXJ0LCBlbmQsICdjdXN0b20tYmxvY2snKTtcbiAgICByZXR1cm4gbGluZUJhY2tncm91bmRNYXJrSW5mbyA/IG1hcmtzLmNvbmNhdChsaW5lQmFja2dyb3VuZE1hcmtJbmZvKSA6IG1hcmtzO1xufVxuZnVuY3Rpb24gbWFya0xpc3RJdGVtQ2hpbGRyZW4obm9kZSwgbWFya1R5cGUpIHtcbiAgICB2YXIgbWFya3MgPSBbXTtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IHR5cGUgPT09ICdjb2RlQmxvY2snKSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKFtnZXRNZFN0YXJ0TGluZShub2RlKSwgZ2V0TWRTdGFydENoKG5vZGUpIC0gMV0sIFtnZXRNZEVuZExpbmUobm9kZSksIGdldE1kRW5kQ2gobm9kZSkgKyAxXSwgbWFya1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbWFya3M7XG59XG5mdW5jdGlvbiBtYXJrUGFyYWdyYXBoSW5CbG9ja1F1b3RlKG5vZGUpIHtcbiAgICB2YXIgbWFya3MgPSBbXTtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKFtnZXRNZFN0YXJ0TGluZShub2RlKSwgZ2V0TWRTdGFydENoKG5vZGUpXSwgW2dldE1kRW5kTGluZShub2RlKSwgZ2V0TWRFbmRDaChub2RlKSArIDFdLCBURVhUKSk7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBtYXJrcztcbn1cbmZ1bmN0aW9uIGJsb2NrUXVvdGUkMihub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIG1hcmtzID0gbm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2Jsb2NrUXVvdGUnID8gW21hcmtJbmZvKHN0YXJ0LCBlbmQsIEJMT0NLX1FVT1RFKV0gOiBbXTtcbiAgICBpZiAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZE1hcmtzID0gW107XG4gICAgICAgIGlmIChub2RlLmZpcnN0Q2hpbGQudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIGNoaWxkTWFya3MgPSBtYXJrUGFyYWdyYXBoSW5CbG9ja1F1b3RlKG5vZGUuZmlyc3RDaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLmZpcnN0Q2hpbGQudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICBjaGlsZE1hcmtzID0gbWFya0xpc3RJdGVtQ2hpbGRyZW4obm9kZS5maXJzdENoaWxkLCBURVhUKTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcyA9IF9fc3ByZWFkQXJyYXkkMShfX3NwcmVhZEFycmF5JDEoW10sIG1hcmtzKSwgY2hpbGRNYXJrcyk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrcztcbn1cbmZ1bmN0aW9uIGdldFNwZWNPZkxpc3RJdGVtU3R5bGUobm9kZSkge1xuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgd2hpbGUgKG5vZGUucGFyZW50LnBhcmVudCAmJiBub2RlLnBhcmVudC5wYXJlbnQudHlwZSA9PT0gJ2l0ZW0nKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudC5wYXJlbnQ7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgfVxuICAgIHZhciBhdHRycyA9IFt7IG9kZDogdHJ1ZSB9LCB7IGV2ZW46IHRydWUgfV1bZGVwdGggJSAyXTtcbiAgICByZXR1cm4gW0xJU1RfSVRFTSwgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhdHRycyksIHsgbGlzdFN0eWxlOiB0cnVlIH0pXTtcbn1cbmZ1bmN0aW9uIGl0ZW0kMShub2RlLCBzdGFydCkge1xuICAgIHZhciBfYSA9IG5vZGUubGlzdERhdGEsIHBhZGRpbmcgPSBfYS5wYWRkaW5nLCB0YXNrID0gX2EudGFzaztcbiAgICB2YXIgc3BlYyA9IGdldFNwZWNPZkxpc3RJdGVtU3R5bGUobm9kZSk7XG4gICAgdmFyIG1hcmtzID0gW21hcmtJbmZvLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheSQxKFtzdGFydCwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBwYWRkaW5nKV0sIHNwZWMpKV07XG4gICAgaWYgKHRhc2spIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhhZGRPZmZzZXRQb3Moc3RhcnQsIHBhZGRpbmcpLCBhZGRPZmZzZXRQb3Moc3RhcnQsIHBhZGRpbmcgKyAzKSwgVEFTS19ERUxJTSkpO1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKGFkZE9mZnNldFBvcyhzdGFydCwgcGFkZGluZyArIDEpLCBhZGRPZmZzZXRQb3Moc3RhcnQsIHBhZGRpbmcgKyAyKSwgTUVUQSkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3MuY29uY2F0KG1hcmtMaXN0SXRlbUNoaWxkcmVuKG5vZGUuZmlyc3RDaGlsZCwgVEVYVCkpO1xufVxudmFyIG1hcmtOb2RlRnVuY01hcCA9IHtcbiAgICBoZWFkaW5nOiBoZWFkaW5nJDEsXG4gICAgc3Ryb25nOiBlbXBoYXNpc0FuZFN0cmlrZXRocm91Z2gsXG4gICAgZW1waDogZW1waGFzaXNBbmRTdHJpa2V0aHJvdWdoLFxuICAgIHN0cmlrZTogZW1waGFzaXNBbmRTdHJpa2V0aHJvdWdoLFxuICAgIGxpbms6IGxpbmssXG4gICAgaW1hZ2U6IGltYWdlJDEsXG4gICAgY29kZTogY29kZSxcbiAgICBjb2RlQmxvY2s6IGNvZGVCbG9jayQxLFxuICAgIGJsb2NrUXVvdGU6IGJsb2NrUXVvdGUkMixcbiAgICBpdGVtOiBpdGVtJDEsXG4gICAgY3VzdG9tQmxvY2s6IGN1c3RvbUJsb2NrJDIsXG59O1xudmFyIHNpbXBsZU1hcmtDbGFzc05hbWVNYXAgPSB7XG4gICAgdGhlbWF0aWNCcmVhazogVEhFTUFUSUNfQlJFQUssXG4gICAgdGFibGU6IFRBQkxFLFxuICAgIHRhYmxlQ2VsbDogVEFCTEVfQ0VMTCxcbiAgICBodG1sSW5saW5lOiBIVE1MLFxufTtcbmZ1bmN0aW9uIGdldE1hcmtJbmZvKG5vZGUsIHN0YXJ0LCBlbmQsIGVuZExpbmUpIHtcbiAgICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcbiAgICBpZiAoaXNGdW5jdGlvbl8xKG1hcmtOb2RlRnVuY01hcFt0eXBlXSkpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gbWFya05vZGVGdW5jTWFwW3R5cGVdKG5vZGUsIHN0YXJ0LCBlbmQsIGVuZExpbmUpO1xuICAgIH1cbiAgICBpZiAoc2ltcGxlTWFya0NsYXNzTmFtZU1hcFt0eXBlXSkge1xuICAgICAgICByZXR1cm4gW21hcmtJbmZvKHN0YXJ0LCBlbmQsIHNpbXBsZU1hcmtDbGFzc05hbWVNYXBbdHlwZV0pXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZW1vdmluZ0JhY2tncm91bmRJbmRleE1hcCA9IHt9O1xuZnVuY3Rpb24gc3ludGF4SGlnaGxpZ2h0KF9hKSB7XG4gICAgdmFyIHNjaGVtYSA9IF9hLnNjaGVtYSwgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrO1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246IGZ1bmN0aW9uICh0cmFuc2FjdGlvbnMsIF8sIG5ld1N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgdHIgPSB0cmFuc2FjdGlvbnNbMF07XG4gICAgICAgICAgICB2YXIgbmV3VHIgPSBuZXdTdGF0ZS50cjtcbiAgICAgICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtJbmZvXzEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IHRyLmdldE1ldGEoJ2VkaXRSZXN1bHQnKTtcbiAgICAgICAgICAgICAgICBlZGl0UmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSByZXN1bHQubm9kZXMsIHJlbW92ZWROb2RlUmFuZ2UgPSByZXN1bHQucmVtb3ZlZE5vZGVSYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya0luZm9fMSA9IG1hcmtJbmZvXzEuY29uY2F0KGdldE1hcmtGb3JSZW1vdmluZyhuZXdUciwgbm9kZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbm9kZXNfMSA9IG5vZGVzOyBfaSA8IG5vZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gbm9kZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhbGtlciA9IHBhcmVudF8xLndhbGtlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZXZlbnRfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50XzEubm9kZSwgZW50ZXJpbmcgPSBldmVudF8xLmVudGVyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtJbmZvXzEgPSBtYXJrSW5mb18xLmNvbmNhdChnZXRNYXJrRm9yQWRkaW5nKG5vZGUsIHRvYXN0TWFyaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzEgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZW1vdmVkTm9kZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4SW5kZXggPSBuZXdUci5kb2MuY2hpbGRDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSByZW1vdmVkTm9kZVJhbmdlLmxpbmUsIHN0YXJ0TGluZSA9IF9hWzBdLCBlbmRMaW5lID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0TGluZSwgbWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gTWF0aC5taW4oZW5kTGluZSwgbWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGUgdGhlIGluZGV4IHRvIHJlbW92ZSBjb2RlIGJsb2NrLCBjdXN0b20gYmxvY2sgYmFja2dyb3VuZCB3aGVuIHRoZXJlIGFyZSBubyBhZGRpbmcgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmluZ0JhY2tncm91bmRJbmRleE1hcFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhcHBlbmRNYXJrVHIobmV3VHIsIHNjaGVtYSwgbWFya0luZm9fMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3VHIuc2V0TWV0YSgnd2lkZ2V0JywgdHIuZ2V0TWV0YSgnd2lkZ2V0JykpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNEaWZmZXJlbnRCbG9jayhkb2MsIGluZGV4LCBhdHRycykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRycykuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYXR0cnNbbmFtZV0gIT09IGRvYy5jaGlsZChpbmRleCkuYXR0cnNbbmFtZV07IH0pO1xufVxuZnVuY3Rpb24gYWRkTGluZUJhY2tncm91bmQodHIsIGRvYywgcGFyYWdyYXBoLCBibG9ja1Bvc0luZm8sIGF0dHJzKSB7XG4gICAgaWYgKGF0dHJzID09PSB2b2lkIDApIHsgYXR0cnMgPSB7fTsgfVxuICAgIHZhciBzdGFydEluZGV4ID0gYmxvY2tQb3NJbmZvLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gYmxvY2tQb3NJbmZvLmVuZEluZGV4LCBmcm9tID0gYmxvY2tQb3NJbmZvLmZyb20sIHRvID0gYmxvY2tQb3NJbmZvLnRvO1xuICAgIHZhciBzaG91bGRDaGFuZ2VCbG9ja1R5cGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgIC8vIHByZXZlbnQgdG8gcmVtb3ZlIGJhY2tncm91bmQgb2YgdGhlIG5vZGUgdGhhdCBuZWVkIHRvIGhhdmUgYmFja2dyb3VuZFxuICAgICAgICBkZWxldGUgcmVtb3ZpbmdCYWNrZ3JvdW5kSW5kZXhNYXBbaV07XG4gICAgICAgIHNob3VsZENoYW5nZUJsb2NrVHlwZSA9IGlzRGlmZmVyZW50QmxvY2soZG9jLCBpLCBhdHRycyk7XG4gICAgfVxuICAgIGlmIChzaG91bGRDaGFuZ2VCbG9ja1R5cGUpIHtcbiAgICAgICAgdHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBwYXJhZ3JhcGgsIGF0dHJzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmRNYXJrVHIodHIsIHNjaGVtYSwgbWFya3MpIHtcbiAgICB2YXIgZG9jID0gdHIuZG9jO1xuICAgIHZhciBwYXJhZ3JhcGggPSBzY2hlbWEubm9kZXMucGFyYWdyYXBoO1xuICAgIC8vIGdldCBzdGFydCBwb3NpdGlvbiBwZXIgbGluZSBmb3IgbGF6eSBjYWxjdWxhdGlvblxuICAgIHZhciBzdGFydFBvc0xpc3RQZXJMaW5lID0gZ2V0U3RhcnRQb3NMaXN0UGVyTGluZShkb2MsIGRvYy5jaGlsZENvdW50KTtcbiAgICBtYXJrcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kLCBzcGVjID0gX2Euc3BlYywgbGluZUJhY2tncm91bmQgPSBfYS5saW5lQmFja2dyb3VuZDtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydFswXSwgZG9jLmNoaWxkQ291bnQpIC0gMTtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gTWF0aC5taW4oZW5kWzBdLCBkb2MuY2hpbGRDb3VudCkgLSAxO1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gZG9jLmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgICAgICB2YXIgZW5kTm9kZSA9IGRvYy5jaGlsZChlbmRJbmRleCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgbGluZVxuICAgICAgICB2YXIgZnJvbSA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbc3RhcnRJbmRleF07XG4gICAgICAgIHZhciB0byA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbZW5kSW5kZXhdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNoYXJhY3RlciBvZmZzZXQgb2YgdGhlIGxpbmVcbiAgICAgICAgZnJvbSArPSBzdGFydFsxXSArIGdldFdpZGdldE5vZGVQb3Moc3RhcnROb2RlLCBzdGFydFsxXSAtIDEpO1xuICAgICAgICB0byArPSBlbmRbMV0gKyBnZXRXaWRnZXROb2RlUG9zKGVuZE5vZGUsIGVuZFsxXSAtIDEpO1xuICAgICAgICBpZiAoc3BlYykge1xuICAgICAgICAgICAgaWYgKGxpbmVCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc0luZm8gPSB7IGZyb206IGZyb20sIHRvOiB0bywgc3RhcnRJbmRleDogc3RhcnRJbmRleCwgZW5kSW5kZXg6IGVuZEluZGV4IH07XG4gICAgICAgICAgICAgICAgYWRkTGluZUJhY2tncm91bmQodHIsIGRvYywgcGFyYWdyYXBoLCBwb3NJbmZvLCBzcGVjLmF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIHNjaGVtYS5tYXJrKHNwZWMudHlwZSwgc3BlYy5hdHRycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZW1vdmVCbG9ja0JhY2tncm91bmQodHIsIHN0YXJ0UG9zTGlzdFBlckxpbmUsIHBhcmFncmFwaCk7XG59XG5mdW5jdGlvbiByZW1vdmVCbG9ja0JhY2tncm91bmQodHIsIHN0YXJ0UG9zTGlzdFBlckxpbmUsIHBhcmFncmFwaCkge1xuICAgIE9iamVjdC5rZXlzKHJlbW92aW5nQmFja2dyb3VuZEluZGV4TWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IE51bWJlcihpbmRleCk7XG4gICAgICAgIC8vIGdldCB0aGUgZW5kIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgd2l0aCB0aGUgbmV4dCBub2RlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAgICB2YXIgZW5kSW5kZXggPSBNYXRoLm1pbihOdW1iZXIoaW5kZXgpICsgMSwgdHIuZG9jLmNoaWxkQ291bnQgLSAxKTtcbiAgICAgICAgdmFyIGZyb20gPSBzdGFydFBvc0xpc3RQZXJMaW5lW3N0YXJ0SW5kZXhdO1xuICAgICAgICAvLyBzdWJ0cmFjdCAnMScgZm9yIGdldHRpbmcgZW5kIHBvc2l0aW9uIG9mIHRoZSBsaW5lXG4gICAgICAgIHZhciB0byA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbZW5kSW5kZXhdIC0gMTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IGVuZEluZGV4KSB7XG4gICAgICAgICAgICB0byArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHRyLnNldEJsb2NrVHlwZShmcm9tLCB0bywgcGFyYWdyYXBoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNhY2hlSW5kZXhUb1JlbW92ZUJhY2tncm91bmQoZG9jLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHNraXBMaW5lcyA9IFtdO1xuICAgIHJlbW92aW5nQmFja2dyb3VuZEluZGV4TWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0WzBdIC0gMTsgaSA8IGVuZFswXTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jLmNoaWxkKGkpO1xuICAgICAgICB2YXIgY29kZUVuZCA9IG5vZGUuYXR0cnMuY29kZUVuZDtcbiAgICAgICAgdmFyIGNvZGVTdGFydCA9IG5vZGUuYXR0cnMuY29kZVN0YXJ0O1xuICAgICAgICBpZiAoY29kZVN0YXJ0ICYmIGNvZGVFbmQgJiYgIWluY2x1ZGVzKHNraXBMaW5lcywgY29kZVN0YXJ0KSkge1xuICAgICAgICAgICAgc2tpcExpbmVzLnB1c2goY29kZVN0YXJ0KTtcbiAgICAgICAgICAgIGNvZGVFbmQgPSBNYXRoLm1pbihjb2RlRW5kLCBkb2MuY2hpbGRDb3VudCk7XG4gICAgICAgICAgICAvLyBzaG91bGQgc3VidHJhY3QgJzEnIHRvIG1hcmtkb3duIGxpbmUgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIGJlY2F1c2UgbWFya2Rvd24gcGFyc2VyIGhhcyAnMScobm90IHplcm8pIGFzIHRoZSBzdGFydCBudW1iZXJcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gY29kZVN0YXJ0IC0gMTtcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IGVuZFswXTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBlbmRJbmRleDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgIHJlbW92aW5nQmFja2dyb3VuZEluZGV4TWFwW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNYXJrRm9yUmVtb3ZpbmcoX2EsIG5vZGVzKSB7XG4gICAgdmFyIGRvYyA9IF9hLmRvYztcbiAgICB2YXIgc3RhcnQgPSBub2Rlc1swXS5zb3VyY2Vwb3NbMF07XG4gICAgdmFyIF9iID0gbGFzdCQxKG5vZGVzKS5zb3VyY2Vwb3MsIGVuZCA9IF9iWzFdO1xuICAgIHZhciBzdGFydFBvcyA9IFtzdGFydFswXSwgc3RhcnRbMV1dO1xuICAgIHZhciBlbmRQb3MgPSBbZW5kWzBdLCBlbmRbMV0gKyAxXTtcbiAgICB2YXIgbWFya3MgPSBbXTtcbiAgICBjYWNoZUluZGV4VG9SZW1vdmVCYWNrZ3JvdW5kKGRvYywgc3RhcnQsIGVuZCk7XG4gICAgbWFya3MucHVzaCh7IHN0YXJ0OiBzdGFydFBvcywgZW5kOiBlbmRQb3MgfSk7XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuZnVuY3Rpb24gZ2V0TWFya0ZvckFkZGluZyhub2RlLCB0b2FzdE1hcmspIHtcbiAgICB2YXIgbGluZVRleHRzID0gdG9hc3RNYXJrLmdldExpbmVUZXh0cygpO1xuICAgIHZhciBzdGFydFBvcyA9IFtnZXRNZFN0YXJ0TGluZShub2RlKSwgZ2V0TWRTdGFydENoKG5vZGUpXTtcbiAgICB2YXIgZW5kUG9zID0gW2dldE1kRW5kTGluZShub2RlKSwgZ2V0TWRFbmRDaChub2RlKSArIDFdO1xuICAgIHZhciBtYXJrSW5mbyA9IGdldE1hcmtJbmZvKG5vZGUsIHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVUZXh0c1tlbmRQb3NbMF0gLSAxXSk7XG4gICAgcmV0dXJuIG1hcmtJbmZvICE9PSBudWxsICYmIG1hcmtJbmZvICE9PSB2b2lkIDAgPyBtYXJrSW5mbyA6IFtdO1xufVxuXG52YXIgZGVmYXVsdFRvb2xiYXJTdGF0ZUtleXMgPSBbXG4gICAgJ3Rhc2tMaXN0JyxcbiAgICAnb3JkZXJlZExpc3QnLFxuICAgICdidWxsZXRMaXN0JyxcbiAgICAndGFibGUnLFxuICAgICdzdHJvbmcnLFxuICAgICdlbXBoJyxcbiAgICAnc3RyaWtlJyxcbiAgICAnaGVhZGluZycsXG4gICAgJ3RoZW1hdGljQnJlYWsnLFxuICAgICdibG9ja1F1b3RlJyxcbiAgICAnY29kZScsXG4gICAgJ2NvZGVCbG9jaycsXG4gICAgJ2luZGVudCcsXG4gICAgJ291dGRlbnQnLFxuXTtcbmZ1bmN0aW9uIGdldFRvb2xiYXJTdGF0ZVR5cGUkMShtZE5vZGUpIHtcbiAgICB2YXIgdHlwZSA9IG1kTm9kZS50eXBlO1xuICAgIGlmIChpc0xpc3ROb2RlJDEobWROb2RlKSkge1xuICAgICAgICBpZiAobWROb2RlLmxpc3REYXRhLnRhc2spIHtcbiAgICAgICAgICAgIHJldHVybiAndGFza0xpc3QnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZE5vZGUubGlzdERhdGEudHlwZSA9PT0gJ29yZGVyZWQnID8gJ29yZGVyZWRMaXN0JyA6ICdidWxsZXRMaXN0JztcbiAgICB9XG4gICAgaWYgKHR5cGUuaW5kZXhPZigndGFibGUnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuICd0YWJsZSc7XG4gICAgfVxuICAgIGlmICghaW5jbHVkZXMoZGVmYXVsdFRvb2xiYXJTdGF0ZUtleXMsIHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbmZ1bmN0aW9uIGdldFRvb2xiYXJTdGF0ZSQxKHRhcmdldE5vZGUpIHtcbiAgICB2YXIgdG9vbGJhclN0YXRlID0ge1xuICAgICAgICBpbmRlbnQ6IHsgYWN0aXZlOiBmYWxzZSwgZGlzYWJsZWQ6IHRydWUgfSxcbiAgICAgICAgb3V0ZGVudDogeyBhY3RpdmU6IGZhbHNlLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgIH07XG4gICAgdmFyIGxpc3RFbmFibGVkID0gdHJ1ZTtcbiAgICB0cmF2ZXJzZVBhcmVudE5vZGVzKHRhcmdldE5vZGUsIGZ1bmN0aW9uIChtZE5vZGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUb29sYmFyU3RhdGVUeXBlJDEobWROb2RlKTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdidWxsZXRMaXN0JyB8fCB0eXBlID09PSAnb3JkZXJlZExpc3QnKSB7XG4gICAgICAgICAgICAvLyB0byBhcHBseSB0aGUgbmVhcmxpc3QgbGlzdCBzdGF0ZSBpbiB0aGUgbmVzdGVkIGxpc3RcbiAgICAgICAgICAgIGlmIChsaXN0RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJTdGF0ZVt0eXBlXSA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgdG9vbGJhclN0YXRlLmluZGVudC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRvb2xiYXJTdGF0ZS5vdXRkZW50LmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGlzdEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZVt0eXBlXSA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdG9vbGJhclN0YXRlO1xufVxuZnVuY3Rpb24gcHJldmlld0hpZ2hsaWdodChfYSkge1xuICAgIHZhciB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcmssIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodmlldywgcHJldlN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBzdGF0ZS5kb2MsIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZTdGF0ZSAmJiBwcmV2U3RhdGUuZG9jLmVxKGRvYykgJiYgcHJldlN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q2hPZmZzZXQgPSBzdGF0ZS5kb2MucmVzb2x2ZShmcm9tKS5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHN0YXRlLmRvYy5jb250ZW50LmZpbmRJbmRleChmcm9tKS5pbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IGZyb20gLSBzdGFydENoT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gc3RhcnRDaE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yUG9zID0gW2xpbmUsIGNoXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kTm9kZUF0UG9zaXRpb24oY3Vyc29yUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvb2xiYXJTdGF0ZSA9IGdldFRvb2xiYXJTdGF0ZSQxKG1kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2VUb29sYmFyU3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JQb3M6IGN1cnNvclBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1kTm9kZTogbWROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbGJhclN0YXRlOiB0b29sYmFyU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnc2V0Rm9jdXNlZE5vZGUnLCBtZE5vZGUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG52YXIgRG9jJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoRG9jLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvYygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ2Jsb2NrKycsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERvYztcbn0oTm9kZSQyKSk7XG5cbnZhciBNYXJrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcmsoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXJrLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21hcmsnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWFyay5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTWFyaztcbn0oKSk7XG5cbmZ1bmN0aW9uIGdldFRleHRCeU1kTGluZShkb2MsIG1kTGluZSkge1xuICAgIHJldHVybiBnZXRUZXh0Q29udGVudChkb2MsIG1kTGluZSAtIDEpO1xufVxuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnQoZG9jLCBpbmRleCkge1xuICAgIHJldHVybiBkb2MuY2hpbGQoaW5kZXgpLnRleHRDb250ZW50O1xufVxuXG52YXIgcmVCbG9ja1F1b3RlID0gL15cXHMqPiA/LztcbnZhciBCbG9ja1F1b3RlJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQmxvY2tRdW90ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja1F1b3RlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9ja1F1b3RlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Jsb2NrUXVvdGUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrUXVvdGUucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdibG9jay1xdW90ZScpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQmxvY2tRdW90ZS5wcm90b3R5cGUuY3JlYXRlQmxvY2tRdW90ZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgaXNCbG9ja1F1b3RlKSB7XG4gICAgICAgIHJldHVybiBpc0Jsb2NrUXVvdGUgPyB0ZXh0LnJlcGxhY2UocmVCbG9ja1F1b3RlLCAnJykudHJpbSgpIDogXCI+IFwiICsgdGV4dC50cmltKCk7XG4gICAgfTtcbiAgICBCbG9ja1F1b3RlLnByb3RvdHlwZS5leHRlbmRCbG9ja1F1b3RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgZG9jID0gX2EuZG9jLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgZW5kRnJvbU9mZnNldCA9IF9iLmVuZEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2IuZW5kVG9PZmZzZXQsIGVuZEluZGV4ID0gX2IuZW5kSW5kZXgsIHRvID0gX2IudG87XG4gICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChkb2MsIGVuZEluZGV4KTtcbiAgICAgICAgICAgIHZhciBpc0Jsb2NrUXVvdGUgPSByZUJsb2NrUXVvdGUudGVzdCh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICBpZiAoaXNCbG9ja1F1b3RlICYmIHRvID4gZW5kRnJvbU9mZnNldCAmJiBzZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNFbXB0eSA9ICF0ZXh0Q29udGVudC5yZXBsYWNlKHJlQmxvY2tRdW90ZSwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGVSYW5nZShlbmRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCkuc3BsaXQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGljZWRUZXh0ID0gdGV4dENvbnRlbnQuc2xpY2UodG8gLSBlbmRGcm9tT2Zmc2V0KS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIF90aGlzLmNyZWF0ZUJsb2NrUXVvdGVUZXh0KHNsaWNlZFRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRBbmRFeHRlbmRCbG9jayh0ciwgZW5kVG9PZmZzZXQsIHNsaWNlZFRleHQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCbG9ja1F1b3RlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIGRvYyA9IHN0YXRlLmRvYztcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4O1xuICAgICAgICAgICAgdmFyIGlzQmxvY2tRdW90ZSA9IHJlQmxvY2tRdW90ZS50ZXN0KGdldFRleHRDb250ZW50KGRvYywgc3RhcnRJbmRleCkpO1xuICAgICAgICAgICAgdmFyIHRyID0gcmVwbGFjZVRleHROb2RlKHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgICBlbmRJbmRleDogZW5kSW5kZXgsXG4gICAgICAgICAgICAgICAgZnJvbTogc3RhcnRGcm9tT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNyZWF0ZVRleHQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlQmxvY2tRdW90ZVRleHQodGV4dENvbnRlbnQsIGlzQmxvY2tRdW90ZSk7IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIEJsb2NrUXVvdGUucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBibG9ja1F1b3RlQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2FsdC1xJzogYmxvY2tRdW90ZUNvbW1hbmQsXG4gICAgICAgICAgICAnYWx0LVEnOiBibG9ja1F1b3RlQ29tbWFuZCxcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmV4dGVuZEJsb2NrUXVvdGUoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja1F1b3RlO1xufShNYXJrKSk7XG5cbnZhciByZUxpc3QgPSAvKF5cXHMqKShbLSorXSB8W1xcZF0rXFwuICkvO1xudmFyIHJlT3JkZXJlZExpc3QgPSAvKF5cXHMqKShbXFxkXSkrXFwuKCBcXFtbIHhYXV0pPyAvO1xudmFyIHJlT3JkZXJlZExpc3RHcm91cCA9IC9eKFxccyopKChcXGQrKShbLildXFxzKD86XFxbKD86eHxcXHMpXFxdXFxzKT8pKSguKikvO1xudmFyIHJlQ2FuQmVUYXNrTGlzdCA9IC8oXlxccyopKFstKitdfFtcXGRdK1xcLikoIFxcW1sgeFhdXSk/IC87XG52YXIgcmVCdWxsZXRMaXN0R3JvdXAgPSAvXihcXHMqKShbLSorXSsoXFxzKD86XFxbKD86eHxcXHMpXFxdXFxzKT8pKSguKikvO1xudmFyIHJlVGFza0xpc3QgPSAvKF5cXHMqKShbLSorXSB8W1xcZF0rXFwuICkoXFxbWyB4WF1dICkvO1xudmFyIHJlQnVsbGV0VGFza0xpc3QgPSAvKF5cXHMqKShbLSorXSkoIFxcW1sgeFhdXSkgLztcbmZ1bmN0aW9uIGdldExpc3RUeXBlKHRleHQpIHtcbiAgICByZXR1cm4gcmVPcmRlcmVkTGlzdC50ZXN0KHRleHQpID8gJ29yZGVyZWQnIDogJ2J1bGxldCc7XG59XG5mdW5jdGlvbiBnZXRMaXN0RGVwdGgobWROb2RlKSB7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICB3aGlsZSAobWROb2RlICYmIG1kTm9kZS50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIGlmIChtZE5vZGUudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBkZXB0aDtcbn1cbmZ1bmN0aW9uIGZpbmRTYW1lRGVwdGhMaXN0KHRvYXN0TWFyaywgY3VycmVudExpbmUsIGRlcHRoLCBiYWNrd2FyZCkge1xuICAgIHZhciBsaW5lVGV4dHMgPSB0b2FzdE1hcmsuZ2V0TGluZVRleHRzKCk7XG4gICAgdmFyIGxpbmVMZW4gPSBsaW5lVGV4dHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbGluZSA9IGN1cnJlbnRMaW5lO1xuICAgIHdoaWxlIChiYWNrd2FyZCA/IGxpbmUgPCBsaW5lTGVuIDogbGluZSA+IDEpIHtcbiAgICAgICAgbGluZSA9IGJhY2t3YXJkID8gbGluZSArIDEgOiBsaW5lIC0gMTtcbiAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGxpbmUpO1xuICAgICAgICB2YXIgY3VycmVudExpc3REZXB0aCA9IGdldExpc3REZXB0aChtZE5vZGUpO1xuICAgICAgICBpZiAoY3VycmVudExpc3REZXB0aCA9PT0gZGVwdGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgbGluZTogbGluZSwgZGVwdGg6IGRlcHRoLCBtZE5vZGU6IG1kTm9kZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50TGlzdERlcHRoIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRTYW1lRGVwdGhJdGVtcyhfYSkge1xuICAgIHZhciB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcmssIG1kTm9kZSA9IF9hLm1kTm9kZSwgbGluZSA9IF9hLmxpbmU7XG4gICAgdmFyIGRlcHRoID0gZ2V0TGlzdERlcHRoKG1kTm9kZSk7XG4gICAgdmFyIGZvcndhcmRMaXN0ID0gZmluZFNhbWVEZXB0aExpc3QodG9hc3RNYXJrLCBsaW5lLCBkZXB0aCwgZmFsc2UpLnJldmVyc2UoKTtcbiAgICB2YXIgYmFja3dhcmRMaXN0ID0gZmluZFNhbWVEZXB0aExpc3QodG9hc3RNYXJrLCBsaW5lLCBkZXB0aCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvcndhcmRMaXN0LmNvbmNhdChbeyBsaW5lOiBsaW5lLCBkZXB0aDogZGVwdGgsIG1kTm9kZTogbWROb2RlIH1dKS5jb25jYXQoYmFja3dhcmRMaXN0KTtcbn1cbmZ1bmN0aW9uIHRleHRUb0J1bGxldCh0ZXh0KSB7XG4gICAgaWYgKCFyZUxpc3QudGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gXCIqIFwiICsgdGV4dDtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBnZXRMaXN0VHlwZSh0ZXh0KTtcbiAgICBpZiAodHlwZSA9PT0gJ2J1bGxldCcgJiYgcmVDYW5CZVRhc2tMaXN0LnRlc3QodGV4dCkpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZUJ1bGxldFRhc2tMaXN0LCAnJDEkMiAnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ29yZGVyZWQnKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVPcmRlcmVkTGlzdCwgJyQxKiAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiB0ZXh0VG9PcmRlcmVkKHRleHQsIG9yZGluYWxOdW0pIHtcbiAgICBpZiAoIXJlTGlzdC50ZXN0KHRleHQpKSB7XG4gICAgICAgIHJldHVybiBvcmRpbmFsTnVtICsgXCIuIFwiICsgdGV4dDtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBnZXRMaXN0VHlwZSh0ZXh0KTtcbiAgICBpZiAodHlwZSA9PT0gJ2J1bGxldCcgfHwgKHR5cGUgPT09ICdvcmRlcmVkJyAmJiByZUNhbkJlVGFza0xpc3QudGVzdCh0ZXh0KSkpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZUNhbkJlVGFza0xpc3QsIFwiJDFcIiArIG9yZGluYWxOdW0gKyBcIi4gXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnb3JkZXJlZCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBzdGFydCA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKHRleHQpWzNdO1xuICAgICAgICBpZiAoTnVtYmVyKHN0YXJ0KSAhPT0gb3JkaW5hbE51bSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZU9yZGVyZWRMaXN0LCBcIiQxXCIgKyBvcmRpbmFsTnVtICsgXCIuIFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGdldENoYW5nZWRJbmZvKGRvYywgc2FtZURlcHRoSXRlbXMsIHR5cGUsIHN0YXJ0KSB7XG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgdmFyIGZpcnN0SW5kZXggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgIHZhciBjaGFuZ2VkUmVzdWx0cyA9IHNhbWVEZXB0aEl0ZW1zLm1hcChmdW5jdGlvbiAoX2EsIGluZGV4KSB7XG4gICAgICAgIHZhciBsaW5lID0gX2EubGluZTtcbiAgICAgICAgZmlyc3RJbmRleCA9IE1hdGgubWluKGxpbmUgLSAxLCBmaXJzdEluZGV4KTtcbiAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgobGluZSAtIDEsIGxhc3RJbmRleCk7XG4gICAgICAgIHZhciB0ZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHRleHQgPSB0eXBlID09PSAnYnVsbGV0JyA/IHRleHRUb0J1bGxldCh0ZXh0KSA6IHRleHRUb09yZGVyZWQodGV4dCwgaW5kZXggKyAxICsgc3RhcnQpO1xuICAgICAgICByZXR1cm4geyB0ZXh0OiB0ZXh0LCBsaW5lOiBsaW5lIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgY2hhbmdlZFJlc3VsdHM6IGNoYW5nZWRSZXN1bHRzLCBmaXJzdEluZGV4OiBmaXJzdEluZGV4LCBsYXN0SW5kZXg6IGxhc3RJbmRleCB9O1xufVxuZnVuY3Rpb24gZ2V0QnVsbGV0T3JPcmRlcmVkKHR5cGUsIGNvbnRleHQpIHtcbiAgICB2YXIgc2FtZURlcHRoTGlzdEluZm8gPSBnZXRTYW1lRGVwdGhJdGVtcyhjb250ZXh0KTtcbiAgICByZXR1cm4gZ2V0Q2hhbmdlZEluZm8oY29udGV4dC5kb2MsIHNhbWVEZXB0aExpc3RJbmZvLCB0eXBlKTtcbn1cbnZhciBvdGhlckxpc3RUb0xpc3QgPSB7XG4gICAgYnVsbGV0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZ2V0QnVsbGV0T3JPcmRlcmVkKCdidWxsZXQnLCBjb250ZXh0KTtcbiAgICB9LFxuICAgIG9yZGVyZWQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBnZXRCdWxsZXRPck9yZGVyZWQoJ29yZGVyZWQnLCBjb250ZXh0KTtcbiAgICB9LFxuICAgIHRhc2s6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbWROb2RlID0gX2EubWROb2RlLCBkb2MgPSBfYS5kb2MsIGxpbmUgPSBfYS5saW5lO1xuICAgICAgICB2YXIgdGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICBpZiAobWROb2RlLmxpc3REYXRhLnRhc2spIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVUYXNrTGlzdCwgJyQxJDInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xpc3ROb2RlJDEobWROb2RlKSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZUxpc3QsICckMSQyWyBdICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZWRSZXN1bHRzOiBbeyB0ZXh0OiB0ZXh0LCBsaW5lOiBsaW5lIH1dIH07XG4gICAgfSxcbn07XG52YXIgb3RoZXJOb2RlVG9MaXN0ID0ge1xuICAgIGJ1bGxldDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkb2MgPSBfYS5kb2MsIGxpbmUgPSBfYS5saW5lO1xuICAgICAgICB2YXIgbGluZVRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgdmFyIGNoYW5nZWRSZXN1bHRzID0gW3sgdGV4dDogXCIqIFwiICsgbGluZVRleHQsIGxpbmU6IGxpbmUgfV07XG4gICAgICAgIHJldHVybiB7IGNoYW5nZWRSZXN1bHRzOiBjaGFuZ2VkUmVzdWx0cyB9O1xuICAgIH0sXG4gICAgb3JkZXJlZDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcmssIGRvYyA9IF9hLmRvYywgbGluZSA9IF9hLmxpbmUsIHN0YXJ0TGluZSA9IF9hLnN0YXJ0TGluZTtcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHZhciBmaXJzdE9yZGVyZWRMaXN0TnVtID0gMTtcbiAgICAgICAgdmFyIGZpcnN0T3JkZXJlZExpc3RMaW5lID0gc3RhcnRMaW5lO1xuICAgICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmUgLSAxOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUoaSk7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGkpO1xuICAgICAgICAgICAgdmFyIGNhbkJlTGlzdE5vZGUgPSB0ZXh0ICYmICEhZmluZENsb3Nlc3ROb2RlKG1kTm9kZSwgZnVuY3Rpb24gKHRhcmdldE5vZGUpIHsgcmV0dXJuIGlzTGlzdE5vZGUkMSh0YXJnZXROb2RlKTsgfSk7XG4gICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWMoZ2V0VGV4dEJ5TWRMaW5lKGRvYywgaSkpO1xuICAgICAgICAgICAgaWYgKCFzZWFyY2hSZXN1bHQgJiYgIWNhbkJlTGlzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VhcmNoUmVzdWx0ICYmIGNhbkJlTGlzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkICs9IDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBzZWFyY2hSZXN1bHQsIGluZGVudCA9IF9iWzFdLCBzdGFydCA9IF9iWzNdO1xuICAgICAgICAgICAgLy8gYmFzaXMgb24gb25lIGRlcHRoIGxpc3RcbiAgICAgICAgICAgIGlmICghaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RPcmRlcmVkTGlzdE51bSA9IE51bWJlcihzdGFydCk7XG4gICAgICAgICAgICAgICAgZmlyc3RPcmRlcmVkTGlzdExpbmUgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvcmRpbmFsTnVtID0gZmlyc3RPcmRlcmVkTGlzdE51bSArIGxpbmUgLSBmaXJzdE9yZGVyZWRMaXN0TGluZSAtIHNraXBwZWQ7XG4gICAgICAgIHZhciBjaGFuZ2VkUmVzdWx0cyA9IFt7IHRleHQ6IG9yZGluYWxOdW0gKyBcIi4gXCIgKyBsaW5lVGV4dCwgbGluZTogbGluZSB9XTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZFJlc3VsdHM6IGNoYW5nZWRSZXN1bHRzIH07XG4gICAgfSxcbiAgICB0YXNrOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRvYyA9IF9hLmRvYywgbGluZSA9IF9hLmxpbmU7XG4gICAgICAgIHZhciBsaW5lVGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICB2YXIgY2hhbmdlZFJlc3VsdHMgPSBbeyB0ZXh0OiBcIiogWyBdIFwiICsgbGluZVRleHQsIGxpbmU6IGxpbmUgfV07XG4gICAgICAgIHJldHVybiB7IGNoYW5nZWRSZXN1bHRzOiBjaGFuZ2VkUmVzdWx0cyB9O1xuICAgIH0sXG59O1xudmFyIGV4dGVuZExpc3QgPSB7XG4gICAgYnVsbGV0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBfYS5saW5lLCBkb2MgPSBfYS5kb2M7XG4gICAgICAgIHZhciBsaW5lVGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICB2YXIgX2IgPSByZUJ1bGxldExpc3RHcm91cC5leGVjKGxpbmVUZXh0KSwgaW5kZW50ID0gX2JbMV0sIGRlbGltaXRlciA9IF9iWzJdO1xuICAgICAgICByZXR1cm4geyBsaXN0U3ludGF4OiBcIlwiICsgaW5kZW50ICsgZGVsaW1pdGVyIH07XG4gICAgfSxcbiAgICBvcmRlcmVkOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaywgbGluZSA9IF9hLmxpbmUsIG1kTm9kZSA9IF9hLm1kTm9kZSwgZG9jID0gX2EuZG9jO1xuICAgICAgICB2YXIgZGVwdGggPSBnZXRMaXN0RGVwdGgobWROb2RlKTtcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHZhciBfYiA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKGxpbmVUZXh0KSwgaW5kZW50ID0gX2JbMV0sIHN0YXJ0ID0gX2JbM10sIGRlbGltaXRlciA9IF9iWzRdO1xuICAgICAgICB2YXIgb3JkaW5hbE51bSA9IE51bWJlcihzdGFydCkgKyAxO1xuICAgICAgICB2YXIgbGlzdFN5bnRheCA9IFwiXCIgKyBpbmRlbnQgKyBvcmRpbmFsTnVtICsgZGVsaW1pdGVyO1xuICAgICAgICB2YXIgYmFja3dhcmRMaXN0ID0gZmluZFNhbWVEZXB0aExpc3QodG9hc3RNYXJrLCBsaW5lLCBkZXB0aCwgdHJ1ZSk7XG4gICAgICAgIHZhciBmaWx0ZXJlZExpc3QgPSBiYWNrd2FyZExpc3QuZmlsdGVyKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWMoZ2V0VGV4dEJ5TWRMaW5lKGRvYywgaW5mby5saW5lKSk7XG4gICAgICAgICAgICByZXR1cm4gKHNlYXJjaFJlc3VsdCAmJlxuICAgICAgICAgICAgICAgIHNlYXJjaFJlc3VsdFsxXS5sZW5ndGggPT09IGluZGVudC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAhIWZpbmRDbG9zZXN0Tm9kZShpbmZvLm1kTm9kZSwgZnVuY3Rpb24gKHRhcmdldE5vZGUpIHsgcmV0dXJuIGlzT3JkZXJlZExpc3ROb2RlKHRhcmdldE5vZGUpOyB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7IGxpc3RTeW50YXg6IGxpc3RTeW50YXggfSwgZ2V0Q2hhbmdlZEluZm8oZG9jLCBmaWx0ZXJlZExpc3QsICdvcmRlcmVkJywgb3JkaW5hbE51bSkpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gZ2V0UmVvcmRlcmVkTGlzdEluZm8oZG9jLCBzY2hlbWEsIGxpbmUsIG9yZGluYWxOdW0sIHByZXZJbmRlbnRMZW5ndGgpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgbGluZVRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICB2YXIgc2VhcmNoUmVzdWx0ID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWMobGluZVRleHQpO1xuICAgIHdoaWxlIChzZWFyY2hSZXN1bHQpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IHNlYXJjaFJlc3VsdFsxXSwgZGVsaW1pdGVyID0gc2VhcmNoUmVzdWx0WzRdLCB0ZXh0ID0gc2VhcmNoUmVzdWx0WzVdO1xuICAgICAgICB2YXIgaW5kZW50TGVuZ3RoID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGVudExlbmd0aCA9PT0gcHJldkluZGVudExlbmd0aCkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgXCJcIiArIGluZGVudCArIG9yZGluYWxOdW0gKyBkZWxpbWl0ZXIgKyB0ZXh0KSk7XG4gICAgICAgICAgICBvcmRpbmFsTnVtICs9IDE7XG4gICAgICAgICAgICBsaW5lICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZW50TGVuZ3RoID4gcHJldkluZGVudExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5lc3RlZExpc3RJbmZvID0gZ2V0UmVvcmRlcmVkTGlzdEluZm8oZG9jLCBzY2hlbWEsIGxpbmUsIDEsIGluZGVudExlbmd0aCk7XG4gICAgICAgICAgICBsaW5lID0gbmVzdGVkTGlzdEluZm8ubGluZTtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KG5lc3RlZExpc3RJbmZvLm5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZW50TGVuZ3RoIDwgcHJldkluZGVudExlbmd0aCB8fCBsaW5lID4gZG9jLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHNlYXJjaFJlc3VsdCA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKGxpbmVUZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLCBsaW5lOiBsaW5lIH07XG59XG5cbnZhciByZVN0YXJ0U3BhY2UgPSAvKF5cXHN7MSw0fSkoLiopLztcbmZ1bmN0aW9uIGlzQmxvY2tVbml0KGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgcmV0dXJuIGZyb20gPCB0byB8fCByZUxpc3QudGVzdCh0ZXh0KSB8fCByZUJsb2NrUXVvdGUudGVzdCh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzSW5UYWJsZUNlbGxOb2RlKGRvYywgc2NoZW1hLCBzZWxlY3Rpb24pIHtcbiAgICB2YXIgJHBvcyA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgICBpZiAoJHBvcy5kZXB0aCA9PT0gMCkge1xuICAgICAgICAkcG9zID0gZG9jLnJlc29sdmUoJHBvcy5wb3MgLSAxKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSAkcG9zLm5vZGUoMSk7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gJHBvcy5zdGFydCgxKTtcbiAgICB2YXIgY29udGVudFNpemUgPSBub2RlLmNvbnRlbnQuc2l6ZTtcbiAgICByZXR1cm4gKG5vZGUucmFuZ2VIYXNNYXJrKDAsIGNvbnRlbnRTaXplLCBzY2hlbWEubWFya3MudGFibGUpICYmXG4gICAgICAgICRwb3MucG9zIC0gc3RhcnRPZmZzZXQgIT09IGNvbnRlbnRTaXplICYmXG4gICAgICAgICRwb3MucG9zICE9PSBzdGFydE9mZnNldCk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb24odHIsIHBvc0luZm8pIHtcbiAgICB2YXIgZnJvbSA9IHBvc0luZm8uZnJvbSwgdG8gPSBwb3NJbmZvLnRvO1xuICAgIGlmIChwb3NJbmZvLnR5cGUgPT09ICdpbmRlbnQnKSB7XG4gICAgICAgIHZhciBzb2Z0VGFiTGVuID0gNDtcbiAgICAgICAgZnJvbSArPSBzb2Z0VGFiTGVuO1xuICAgICAgICB0byArPSAocG9zSW5mby5saW5lTGVuICsgMSkgKiBzb2Z0VGFiTGVuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHNwYWNlTGVuTGlzdCA9IHBvc0luZm8uc3BhY2VMZW5MaXN0O1xuICAgICAgICBmcm9tIC09IHNwYWNlTGVuTGlzdFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZUxlbkxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRvIC09IHNwYWNlTGVuTGlzdFtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgZnJvbSwgdG8pO1xufVxudmFyIFBhcmFncmFwaCQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFBhcmFncmFwaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJhZ3JhcGgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFncmFwaC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdwYXJhZ3JhcGgnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFncmFwaC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdpbmxpbmUqJyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBjb2RlU3RhcnQ6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBjb2RlRW5kOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbeyB0YWc6ICdkaXYnIH1dLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycy5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gWydkaXYnLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoYXR0cnMuY2xhc3NOYW1lKSB9LCAwXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbJ2RpdicsIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5yZW9yZGVyTGlzdCA9IGZ1bmN0aW9uIChzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCB2aWV3ID0gX2EudmlldywgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgIHZhciBfYiA9IHZpZXcuc3RhdGUsIHRyID0gX2IudHIsIHNlbGVjdGlvbiA9IF9iLnNlbGVjdGlvbiwgZG9jID0gX2IuZG9jO1xuICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUoc3RhcnRMaW5lKTtcbiAgICAgICAgdmFyIHRvcExpc3ROb2RlID0gbWROb2RlO1xuICAgICAgICB3aGlsZSAobWROb2RlICYmICFpc0J1bGxldExpc3ROb2RlKG1kTm9kZSkgJiYgbWROb2RlLnBhcmVudC50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICBtZE5vZGUgPSBtZE5vZGUucGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzT3JkZXJlZExpc3ROb2RlKG1kTm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0b3BMaXN0Tm9kZSA9IG1kTm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9wTGlzdE5vZGUpIHtcbiAgICAgICAgICAgIHN0YXJ0TGluZSA9IHRvcExpc3ROb2RlLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSByZU9yZGVyZWRMaXN0R3JvdXAuZXhlYyhnZXRUZXh0QnlNZExpbmUoZG9jLCBzdGFydExpbmUpKSwgaW5kZW50ID0gX2NbMV0sIHN0YXJ0ID0gX2NbM107XG4gICAgICAgIHZhciBpbmRlbnRMZW4gPSBpbmRlbnQubGVuZ3RoO1xuICAgICAgICB2YXIgX2QgPSBnZXRSZW9yZGVyZWRMaXN0SW5mbyhkb2MsIHNjaGVtYSwgc3RhcnRMaW5lLCBOdW1iZXIoc3RhcnQpLCBpbmRlbnRMZW4pLCBsaW5lID0gX2QubGluZSwgbm9kZXMgPSBfZC5ub2RlcztcbiAgICAgICAgZW5kTGluZSA9IE1hdGgubWF4KGVuZExpbmUsIGxpbmUgLSAxKTtcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZ2V0Tm9kZUNvbnRlbnRPZmZzZXRSYW5nZShkb2MsIHN0YXJ0TGluZSAtIDEpLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lIC0gMTsgaSA8PSBlbmRMaW5lIC0gMTsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgX2UgPSBkb2MuY2hpbGQoaSksIG5vZGVTaXplID0gX2Uubm9kZVNpemUsIGNvbnRlbnQgPSBfZS5jb250ZW50O1xuICAgICAgICAgICAgdmFyIG1hcHBlZEZyb20gPSB0ci5tYXBwaW5nLm1hcChzdGFydE9mZnNldCk7XG4gICAgICAgICAgICB2YXIgbWFwcGVkVG8gPSBtYXBwZWRGcm9tICsgY29udGVudC5zaXplO1xuICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgobWFwcGVkRnJvbSwgbWFwcGVkVG8sIG5vZGVzW2kgLSBzdGFydExpbmUgKyAxXSk7XG4gICAgICAgICAgICBzdGFydE9mZnNldCArPSBub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgc2VsZWN0aW9uLmZyb20sIHNlbGVjdGlvbi50byk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbikpO1xuICAgIH07XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbiAodGFiS2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWJLZXkgPT09IHZvaWQgMCkgeyB0YWJLZXkgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBkb2MgPSBzdGF0ZS5kb2M7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG8sIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgc3RhcnRJbmRleCA9IF9hLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXg7XG4gICAgICAgICAgICBpZiAodGFiS2V5ICYmIGlzSW5UYWJsZUNlbGxOb2RlKGRvYywgc2NoZW1hLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0TGluZVRleHQgPSBnZXRUZXh0Q29udGVudChkb2MsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKCh0YWJLZXkgJiYgaXNCbG9ja1VuaXQoZnJvbSwgdG8sIHN0YXJ0TGluZVRleHQpKSB8fFxuICAgICAgICAgICAgICAgICghdGFiS2V5ICYmIHJlTGlzdC50ZXN0KHN0YXJ0TGluZVRleHQpKSkge1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IHJlcGxhY2VUZXh0Tm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogc3RhcnRGcm9tT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmRJbmRleDogZW5kSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRleHQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkgeyByZXR1cm4gXCIgICAgXCIgKyB0ZXh0Q29udGVudDsgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2luZGVudCcsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgICAgICAgICAgbGluZUxlbjogZW5kSW5kZXggLSBzdGFydEluZGV4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVNlbGVjdGlvbih0ciwgcG9zSW5mbykpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVPcmRlcmVkTGlzdEdyb3VwLnRlc3Qoc3RhcnRMaW5lVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVvcmRlckxpc3Qoc3RhcnRJbmRleCArIDEsIGVuZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFiS2V5KSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0KHRvLCBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgJyAgICAnKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLm91dGRlbnQgPSBmdW5jdGlvbiAodGFiS2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWJLZXkgPT09IHZvaWQgMCkgeyB0YWJLZXkgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgZG9jID0gc3RhdGUuZG9jLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG8sIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgc3RhcnRJbmRleCA9IF9hLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXg7XG4gICAgICAgICAgICBpZiAodGFiS2V5ICYmIGlzSW5UYWJsZUNlbGxOb2RlKGRvYywgc2NoZW1hLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0TGluZVRleHQgPSBnZXRUZXh0Q29udGVudChkb2MsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKCh0YWJLZXkgJiYgaXNCbG9ja1VuaXQoZnJvbSwgdG8sIHN0YXJ0TGluZVRleHQpKSB8fFxuICAgICAgICAgICAgICAgICghdGFiS2V5ICYmIHJlTGlzdC50ZXN0KHN0YXJ0TGluZVRleHQpKSkge1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZUxlbkxpc3RfMSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IHJlcGxhY2VUZXh0Tm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogc3RhcnRGcm9tT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmRJbmRleDogZW5kSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRleHQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlYXJjaFJlc3VsdCA9IHJlU3RhcnRTcGFjZS5leGVjKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlTGVuTGlzdF8xLnB1c2goc2VhcmNoUmVzdWx0ID8gc2VhcmNoUmVzdWx0WzFdLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHRDb250ZW50LnJlcGxhY2UocmVTdGFydFNwYWNlLCAnJDInKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zSW5mbyA9IHsgdHlwZTogJ291dGRlbnQnLCBmcm9tOiBmcm9tLCB0bzogdG8sIHNwYWNlTGVuTGlzdDogc3BhY2VMZW5MaXN0XzEgfTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlU2VsZWN0aW9uKHRyLCBwb3NJbmZvKSkpO1xuICAgICAgICAgICAgICAgIGlmIChyZU9yZGVyZWRMaXN0R3JvdXAudGVzdChzdGFydExpbmVUZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW9yZGVyTGlzdChzdGFydEluZGV4ICsgMSwgZW5kSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YWJLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUZXh0ID0gc3RhcnRMaW5lVGV4dC5zbGljZSgwLCB0byAtIHN0YXJ0RnJvbU9mZnNldCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGV4dFdpdGhvdXRTcGFjZSA9IHN0YXJ0VGV4dC5yZXBsYWNlKC9cXHN7MSw0fSQvLCAnJyk7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGV0U3RhcnQgPSB0byAtIChzdGFydFRleHQubGVuZ3RoIC0gc3RhcnRUZXh0V2l0aG91dFNwYWNlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKGRlbGV0U3RhcnQsIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUuZGVsZXRlTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IF90aGlzLmNvbnRleHQudmlldztcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzdGF0ZS5zZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICB2YXIgZGVsZXRlUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlUmFuZ2Uoc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbkNvbW1hbmRzKGRlbGV0ZVJhbmdlLCBqb2luRm9yd2FyZCkoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUubW92ZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gc3RhdGUuZG9jLCB0ciA9IHN0YXRlLnRyLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXg7XG4gICAgICAgICAgICBpZiAoZW5kSW5kZXggPCBkb2MuY29udGVudC5jaGlsZENvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGRvYy5jaGlsZChlbmRJbmRleCArIDEpLCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplLCB0ZXh0Q29udGVudCA9IF9iLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShlbmRUb09mZnNldCwgZW5kVG9PZmZzZXQgKyBub2RlU2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KHN0YXJ0RnJvbU9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgMihzdGFydCwgZW5kIHRhZyBsZW5ndGgpIHRvIGluc2VydCBwcmV2IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgLmluc2VydCh0ci5tYXBwaW5nLm1hcChzdGFydEZyb21PZmZzZXQpIC0gMiwgY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHRleHRDb250ZW50KSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5tb3ZlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgdHIgPSBzdGF0ZS50ciwgZG9jID0gc3RhdGUuZG9jLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4O1xuICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gZG9jLmNoaWxkKHN0YXJ0SW5kZXggLSAxKSwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZSwgdGV4dENvbnRlbnQgPSBfYi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGUoc3RhcnRGcm9tT2Zmc2V0IC0gbm9kZVNpemUsIHN0YXJ0RnJvbU9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSlcbiAgICAgICAgICAgICAgICAgICAgLmluc2VydCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCksIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCB0ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50KCksXG4gICAgICAgICAgICBvdXRkZW50OiB0aGlzLm91dGRlbnQoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFRhYjogdGhpcy5pbmRlbnQodHJ1ZSkoKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiB0aGlzLm91dGRlbnQodHJ1ZSkoKSxcbiAgICAgICAgICAgICdNb2QtZCc6IHRoaXMuZGVsZXRlTGluZXMoKSxcbiAgICAgICAgICAgICdNb2QtRCc6IHRoaXMuZGVsZXRlTGluZXMoKSxcbiAgICAgICAgICAgICdBbHQtQXJyb3dVcCc6IHRoaXMubW92ZVVwKCksXG4gICAgICAgICAgICAnQWx0LUFycm93RG93bic6IHRoaXMubW92ZURvd24oKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJhZ3JhcGg7XG59KE5vZGUkMikpO1xuXG52YXIgVGV4dCQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0ZXh0JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUZXh0O1xufShOb2RlJDIpKTtcblxudmFyIHJlSGVhZGluZyA9IC9eI3sxLDZ9XFxzLztcbnZhciBIZWFkaW5nJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSGVhZGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkaW5nKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkaW5nLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2hlYWRpbmcnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRpbmcucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbDogeyBkZWZhdWx0OiAxIH0sXG4gICAgICAgICAgICAgICAgICAgIHNlVGV4dDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVsID0gYXR0cnMubGV2ZWwsIHNlVGV4dCA9IGF0dHJzLnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBcImhlYWRpbmd8aGVhZGluZ1wiICsgbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xkZWxpbWl0ZXJ8c2V0ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4LmFwcGx5KHZvaWQgMCwgY2xhc3NOYW1lcy5zcGxpdCgnfCcpKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEhlYWRpbmcucHJvdG90eXBlLmNyZWF0ZUhlYWRpbmdUZXh0ID0gZnVuY3Rpb24gKGxldmVsLCB0ZXh0LCBjdXJIZWFkaW5nU3ludGF4KSB7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IHRleHQucmVwbGFjZShjdXJIZWFkaW5nU3ludGF4LCAnJykudHJpbSgpO1xuICAgICAgICB2YXIgaGVhZGluZ1RleHQgPSAnJztcbiAgICAgICAgd2hpbGUgKGxldmVsID4gMCkge1xuICAgICAgICAgICAgaGVhZGluZ1RleHQgKz0gJyMnO1xuICAgICAgICAgICAgbGV2ZWwgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGluZ1RleHQgKyBcIiBcIiArIHRleHRDb250ZW50O1xuICAgIH07XG4gICAgSGVhZGluZy5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gcGF5bG9hZC5sZXZlbDtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzdGF0ZS5zZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4O1xuICAgICAgICAgICAgdmFyIHRyID0gcmVwbGFjZVRleHROb2RlKHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgZnJvbTogc3RhcnRGcm9tT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgZW5kSW5kZXg6IGVuZEluZGV4LFxuICAgICAgICAgICAgICAgIGNyZWF0ZVRleHQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZEhlYWRpbmcgPSB0ZXh0Q29udGVudC5tYXRjaChyZUhlYWRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VySGVhZGluZ1N5bnRheCA9IG1hdGNoZWRIZWFkaW5nID8gbWF0Y2hlZEhlYWRpbmdbMF0gOiAnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZUhlYWRpbmdUZXh0KGxldmVsLCB0ZXh0Q29udGVudCwgY3VySGVhZGluZ1N5bnRheCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgcmV0dXJuIEhlYWRpbmc7XG59KE1hcmspKTtcblxudmFyIGZlbmNlZENvZGVCbG9ja1N5bnRheCA9ICdgYGAnO1xudmFyIENvZGVCbG9jayQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENvZGVCbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGVCbG9jay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdjb2RlQmxvY2snO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGVCbG9jay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2NvZGUtYmxvY2snKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvZGVCbG9jay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGZlbmNlZE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgZmVuY2VkQ29kZUJsb2NrU3ludGF4KTtcbiAgICAgICAgICAgIC8vIGFkZCBmZW5jZWQgc3RhcnQgYmxvY2tcbiAgICAgICAgICAgIHRyLmluc2VydChzdGFydEZyb21PZmZzZXQsIGZlbmNlZE5vZGUpLnNwbGl0KHN0YXJ0RnJvbU9mZnNldCArIGZlbmNlZENvZGVCbG9ja1N5bnRheC5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gYWRkIGZlbmNlZCBlbmQgYmxvY2tcbiAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSwgZmVuY2VkTm9kZSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgICAvLyBzdWJ0cmFjdCBmZW5jZWQgc3ludGF4IGxlbmd0aCBhbmQgb3BlbiwgY2xvc2UgdGFnKDIpXG4gICAgICAgICAgICBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkgLSAoZmVuY2VkQ29kZUJsb2NrU3ludGF4Lmxlbmd0aCArIDIpKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBDb2RlQmxvY2sucHJvdG90eXBlLmtlZXBJbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYywgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgdmFyIHRvYXN0TWFyayA9IF90aGlzLmNvbnRleHQudG9hc3RNYXJrO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0RnJvbU9mZnNldCA9IF9iLnN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYi5lbmRUb09mZnNldCwgZW5kSW5kZXggPSBfYi5lbmRJbmRleCwgZnJvbSA9IF9iLmZyb20sIHRvID0gX2IudG87XG4gICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChkb2MsIGVuZEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0byAmJiB0ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IHRleHRDb250ZW50Lm1hdGNoKC9eXFxzKy8pO1xuICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShlbmRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NvZGVCbG9ja05vZGUobWROb2RlKSAmJiBtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSBtYXRjaGVkWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpY2VkVGV4dCA9IHRleHRDb250ZW50LnNsaWNlKHRvIC0gc3RhcnRGcm9tT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgc3BhY2VzICsgc2xpY2VkVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0QW5kRXh0ZW5kQmxvY2sodHIsIGVuZFRvT2Zmc2V0LCBzbGljZWRUZXh0LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb2RlQmxvY2sucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2RlQmxvY2tDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnU2hpZnQtTW9kLXAnOiBjb2RlQmxvY2tDb21tYW5kLFxuICAgICAgICAgICAgJ1NoaWZ0LU1vZC1QJzogY29kZUJsb2NrQ29tbWFuZCxcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmtlZXBJbmRlbnRhdGlvbigpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvZGVCbG9jaztcbn0oTWFyaykpO1xuXG52YXIgcmVFbXB0eVRhYmxlID0gL1xcfHxcXHMvZztcbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlSGVhZGVyKGNvbHVtbkNvdW50KSB7XG4gICAgcmV0dXJuIFtjcmVhdGVUYWJsZVJvdyhjb2x1bW5Db3VudCksIGNyZWF0ZVRhYmxlUm93KGNvbHVtbkNvdW50LCB0cnVlKV07XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUJvZHkkMShjb2x1bW5Db3VudCwgcm93Q291bnQpIHtcbiAgICB2YXIgYm9keVJvd3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgYm9keVJvd3MucHVzaChjcmVhdGVUYWJsZVJvdyhjb2x1bW5Db3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gYm9keVJvd3M7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZVJvdyhjb2x1bW5Db3VudCwgZGVsaW0pIHtcbiAgICB2YXIgcm93ID0gJ3wnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICByb3cgKz0gZGVsaW0gPyAnIC0tLSB8JyA6ICcgIHwnO1xuICAgIH1cbiAgICByZXR1cm4gcm93O1xufVxuZnVuY3Rpb24gY3JlYXRlVGFyZ2V0VHlwZXMobW92ZU5leHQpIHtcbiAgICByZXR1cm4gbW92ZU5leHRcbiAgICAgICAgPyB7IHR5cGU6ICduZXh0JywgcGFyZW50VHlwZTogJ3RhYmxlSGVhZCcsIGNoaWxkVHlwZTogJ2ZpcnN0Q2hpbGQnIH1cbiAgICAgICAgOiB7IHR5cGU6ICdwcmV2JywgcGFyZW50VHlwZTogJ3RhYmxlQm9keScsIGNoaWxkVHlwZTogJ2xhc3RDaGlsZCcgfTtcbn1cbnZhciBUYWJsZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGUucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCd0YWJsZScpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGFibGUucHJvdG90eXBlLmV4dGVuZFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgZG9jID0gX2EuZG9jLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYiA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBlbmRGcm9tT2Zmc2V0ID0gX2IuZW5kRnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYi5lbmRUb09mZnNldCwgZW5kSW5kZXggPSBfYi5lbmRJbmRleCwgdG8gPSBfYi50bztcbiAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGRvYywgZW5kSW5kZXgpO1xuICAgICAgICAgICAgLy8gc2hvdWxkIGFkZCBgMWAgdG8gbGluZSBmb3IgdGhlIG1hcmtkb3duIHBhcnNlclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBtYXJrZG93biBwYXJzZXIgaGFzIGAxYChub3QgemVybykgYXMgdGhlIHN0YXJ0IG51bWJlclxuICAgICAgICAgICAgdmFyIG1kUG9zID0gW2VuZEluZGV4ICsgMSwgdG8gLSBlbmRGcm9tT2Zmc2V0ICsgMV07XG4gICAgICAgICAgICB2YXIgbWROb2RlID0gX3RoaXMuY29udGV4dC50b2FzdE1hcmsuZmluZE5vZGVBdFBvc2l0aW9uKG1kUG9zKTtcbiAgICAgICAgICAgIHZhciBjZWxsTm9kZSA9IGZpbmRDbG9zZXN0Tm9kZShtZE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVGFibGVDZWxsTm9kZShub2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ3RhYmxlRGVsaW1Sb3cnIHx8IG5vZGUucGFyZW50LnBhcmVudC50eXBlID09PSAndGFibGVCb2R5Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjZWxsTm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gIXRleHRDb250ZW50LnJlcGxhY2UocmVFbXB0eVRhYmxlLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IGNlbGxOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBwYXJlbnRfMS5wYXJlbnQucGFyZW50LmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBjcmVhdGVUYWJsZVJvdyhjb2x1bW5Db3VudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlUmFuZ2UoZW5kRnJvbU9mZnNldCwgZW5kVG9PZmZzZXQpLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KGVuZFRvT2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCksIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCByb3cpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHN1YnRyYWN0IGAyYCB0byBzZWxlY3Rpb24gZW5kIHBvc2l0aW9uIGNvbnNpZGVyaW5nIGAgfGAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkgLSAyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5tb3ZlVGFibGVDZWxsID0gZnVuY3Rpb24gKG1vdmVOZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIGVuZEZyb21PZmZzZXQgPSBfYi5lbmRGcm9tT2Zmc2V0LCBlbmRJbmRleCA9IF9iLmVuZEluZGV4LCB0byA9IF9iLnRvO1xuICAgICAgICAgICAgdmFyIG1kUG9zID0gW2VuZEluZGV4ICsgMSwgdG8gLSBlbmRGcm9tT2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBtZE5vZGUgPSBfdGhpcy5jb250ZXh0LnRvYXN0TWFyay5maW5kTm9kZUF0UG9zaXRpb24obWRQb3MpO1xuICAgICAgICAgICAgdmFyIGNlbGxOb2RlID0gZmluZENsb3Nlc3ROb2RlKG1kTm9kZSwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGlzVGFibGVDZWxsTm9kZShub2RlKTsgfSk7XG4gICAgICAgICAgICBpZiAoY2VsbE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzIgPSBjZWxsTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gY3JlYXRlVGFyZ2V0VHlwZXMobW92ZU5leHQpLCB0eXBlID0gX2MudHlwZSwgcGFyZW50VHlwZSA9IF9jLnBhcmVudFR5cGUsIGNoaWxkVHlwZSA9IF9jLmNoaWxkVHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgY2hPZmZzZXQgPSBnZXRNZEVuZENoKGNlbGxOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbE5vZGVbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hPZmZzZXQgPSBnZXRNZEVuZENoKGNlbGxOb2RlW3R5cGVdKSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gIXBhcmVudF8yW3R5cGVdICYmIHBhcmVudF8yLnBhcmVudC50eXBlID09PSBwYXJlbnRUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmVudF8yLnBhcmVudFt0eXBlXVtjaGlsZFR5cGVdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmVudF8yW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBuZXh0IHJvdywgdGhlIGJhc2Ugb2Zmc2V0IHdvdWxkIGJlIGVuZCBwb3NpdGlvbiBvZiB0aGUgbmV4dCByb3cncyBmaXJzdCBjaGlsZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGJhc2Ugb2Zmc2V0IGlzIHplcm8uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZU9mZnNldCA9IHJvdyA/IGdldE1kRW5kQ2gocm93W2NoaWxkVHlwZV0pIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0YWcob3BlbiwgY2xvc2UpIHBvc2l0aW9uKCcyJykgZm9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY2hPZmZzZXQgKz0gYmFzZU9mZnNldCArIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3ByZXYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBwcmV2IHJvdywgdGhlIHRhcmdldCBwb3NpdGlvbiB3b3VsZCBiZSAnLTQnIGZvciBjYWxjdWxhdGluZyAnIHwnIGNoYXJhY3RlcnMgYW5kIHRhZyhvcGVuLCBjbG9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHRhcmdldCBwb3NpdGlvbiBpcyB6ZXJvLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hPZmZzZXQgPSByb3cgPyAtNCA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGVuZEZyb21PZmZzZXQgKyBjaE9mZnNldCkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2IgPSBwYXlsb2FkLCBjb2x1bW5Db3VudCA9IF9iLmNvbHVtbkNvdW50LCByb3dDb3VudCA9IF9iLnJvd0NvdW50O1xuICAgICAgICAgICAgdmFyIGVuZFRvT2Zmc2V0ID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbikuZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICB2YXIgaGVhZGVyUm93cyA9IGNyZWF0ZVRhYmxlSGVhZGVyKGNvbHVtbkNvdW50KTtcbiAgICAgICAgICAgIHZhciBib2R5Um93cyA9IGNyZWF0ZVRhYmxlQm9keSQxKGNvbHVtbkNvdW50LCByb3dDb3VudCAtIDEpO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSBfX3NwcmVhZEFycmF5JDEoX19zcHJlYWRBcnJheSQxKFtdLCBoZWFkZXJSb3dzKSwgYm9keVJvd3MpO1xuICAgICAgICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpLmluc2VydCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCksIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCByb3cpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gc2hvdWxkIGFkZCBgNGAgdG8gc2VsZWN0aW9uIHBvc2l0aW9uIGNvbnNpZGVyaW5nIGB8IGAgdGV4dCBhbmQgc3RhcnQgYmxvY2sgdGFnIGxlbmd0aFxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGVuZFRvT2Zmc2V0ICsgNCkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBhZGRUYWJsZTogdGhpcy5hZGRUYWJsZSgpIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmV4dGVuZFRhYmxlKCksXG4gICAgICAgICAgICBUYWI6IHRoaXMubW92ZVRhYmxlQ2VsbCh0cnVlKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiB0aGlzLm1vdmVUYWJsZUNlbGwoZmFsc2UpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlO1xufShNYXJrKSk7XG5cbnZhciB0aGVtYXRpY0JyZWFrU3ludGF4ID0gJyoqKic7XG52YXIgVGhlbWF0aWNCcmVhayQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRoZW1hdGljQnJlYWssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGhlbWF0aWNCcmVhaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGhlbWF0aWNCcmVhay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0aGVtYXRpY0JyZWFrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaGVtYXRpY0JyZWFrLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgndGhlbWF0aWMtYnJlYWsnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRoZW1hdGljQnJlYWsucHJvdG90eXBlLmhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvLCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgdGhlbWF0aWNCcmVha1N5bnRheCk7XG4gICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgIC5zcGxpdChmcm9tKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlV2l0aCh0ci5tYXBwaW5nLm1hcChmcm9tKSwgdHIubWFwcGluZy5tYXAodG8pLCBub2RlKVxuICAgICAgICAgICAgICAgIC5zcGxpdCh0ci5tYXBwaW5nLm1hcCh0bykpLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGhlbWF0aWNCcmVhay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGhyOiB0aGlzLmhyKCkgfTtcbiAgICB9O1xuICAgIFRoZW1hdGljQnJlYWsucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW5lQ29tbWFuZCA9IHRoaXMuaHIoKSgpO1xuICAgICAgICByZXR1cm4geyAnTW9kLWwnOiBsaW5lQ29tbWFuZCwgJ01vZC1MJzogbGluZUNvbW1hbmQgfTtcbiAgICB9O1xuICAgIHJldHVybiBUaGVtYXRpY0JyZWFrO1xufShNYXJrKSk7XG5cbmZ1bmN0aW9uIGNhbm5vdEJlTGlzdE5vZGUoX2EsIGxpbmUpIHtcbiAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIHNvdXJjZXBvcyA9IF9hLnNvdXJjZXBvcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICB2YXIgc3RhcnRMaW5lID0gc291cmNlcG9zWzBdWzBdO1xuICAgIHJldHVybiBsaW5lIDw9IHN0YXJ0TGluZSAmJiAodHlwZSA9PT0gJ2NvZGVCbG9jaycgfHwgdHlwZSA9PT0gJ2hlYWRpbmcnIHx8IHR5cGUubWF0Y2goJ3RhYmxlJykpO1xufVxudmFyIExpc3RJdGVtJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTGlzdEl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGlzdEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RJdGVtLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xpc3RJdGVtJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0SXRlbS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIG9kZDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICBldmVuOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIGxpc3RTdHlsZTogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9kZCA9IGF0dHJzLm9kZCwgZXZlbiA9IGF0dHJzLmV2ZW4sIGxpc3RTdHlsZSA9IGF0dHJzLmxpc3RTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAnbGlzdC1pdGVtJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGxpc3QtaXRlbS1zdHlsZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9kZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGxpc3QtaXRlbS1vZGQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8bGlzdC1pdGVtLWV2ZW4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXguYXBwbHkodm9pZCAwLCBjbGFzc05hbWVzLnNwbGl0KCd8JykpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLmV4dGVuZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCBkb2MgPSBfYS5kb2MsIHNjaGVtYSA9IF9hLnNjaGVtYSwgdHIgPSBfYS50cjtcbiAgICAgICAgICAgIHZhciB0b2FzdE1hcmsgPSBfdGhpcy5jb250ZXh0LnRvYXN0TWFyaztcbiAgICAgICAgICAgIHZhciBfYiA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCB0byA9IF9iLnRvLCBzdGFydEZyb21PZmZzZXQgPSBfYi5zdGFydEZyb21PZmZzZXQsIGVuZEZyb21PZmZzZXQgPSBfYi5lbmRGcm9tT2Zmc2V0LCBlbmRJbmRleCA9IF9iLmVuZEluZGV4LCBlbmRUb09mZnNldCA9IF9iLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQoZG9jLCBlbmRJbmRleCk7XG4gICAgICAgICAgICB2YXIgaXNMaXN0ID0gcmVMaXN0LnRlc3QodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0xpc3QgfHwgc2VsZWN0aW9uLmZyb20gPT09IHN0YXJ0RnJvbU9mZnNldCB8fCAhc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSAhdGV4dENvbnRlbnQucmVwbGFjZShyZUNhbkJlVGFza0xpc3QsICcnKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGVuZEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0KS5zcGxpdCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hbmRUeXBlID0gZ2V0TGlzdFR5cGUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhZGQgYDFgIHRvIGxpbmUgZm9yIHRoZSBtYXJrZG93biBwYXJzZXJcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIG1hcmtkb3duIHBhcnNlciBoYXMgYDFgKG5vdCB6ZXJvKSBhcyB0aGUgc3RhcnQgbnVtYmVyXG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGVuZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHNsaWNlZFRleHQgPSB0ZXh0Q29udGVudC5zbGljZSh0byAtIGVuZEZyb21PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0geyB0b2FzdE1hcms6IHRvYXN0TWFyaywgbWROb2RlOiBtZE5vZGUsIGRvYzogZG9jLCBsaW5lOiBlbmRJbmRleCArIDEgfTtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBleHRlbmRMaXN0W2NvbW1hbmRUeXBlXShjb250ZXh0KSwgbGlzdFN5bnRheCA9IF9jLmxpc3RTeW50YXgsIGNoYW5nZWRSZXN1bHRzID0gX2MuY2hhbmdlZFJlc3VsdHM7XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlIG9yZGluYWwgbnVtYmVyIG9mIGJhY2t3YXJkIG9yZGVyZWQgbGlzdFxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkUmVzdWx0cyA9PT0gbnVsbCB8fCBjaGFuZ2VkUmVzdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbmdlZFJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICB0ci5zcGxpdCh0byk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBmaXJzdCBvcmRlcmVkIGxpc3QgaW5mb1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkUmVzdWx0cy51bnNoaWZ0KHsgdGV4dDogbGlzdFN5bnRheCArIHNsaWNlZFRleHQsIGxpbmU6IGVuZEluZGV4ICsgMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlVG9MaXN0UGVyTGluZSh0ciwgY2hhbmdlZFJlc3VsdHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3VidHJhY3QgMSBiZWNhdXNlIHRoZSBsaW5lIGhhcyBpbmNyZWFzZWQgdGhyb3VnaCAnc3BsaXQnIGNvbW1hbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydExpbmU6IGNoYW5nZWRSZXN1bHRzWzBdLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRMaW5lOiBsYXN0JDEoY2hhbmdlZFJlc3VsdHMpLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpIC0gc2xpY2VkVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBwb3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIGxpc3RTeW50YXggKyBzbGljZWRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRBbmRFeHRlbmRCbG9jayh0ciwgZW5kVG9PZmZzZXQsIHNsaWNlZFRleHQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLnRvTGlzdCA9IGZ1bmN0aW9uIChjb21tYW5kVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IF9hLmRvYywgdHIgPSBfYS50ciwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICAgICAgdmFyIHRvYXN0TWFyayA9IF90aGlzLmNvbnRleHQudG9hc3RNYXJrO1xuICAgICAgICAgICAgdmFyIHJhbmdlSW5mbyA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pO1xuICAgICAgICAgICAgLy8gc2hvdWxkIGFkZCBgMWAgdG8gbGluZSBmb3IgdGhlIG1hcmtkb3duIHBhcnNlclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBtYXJrZG93biBwYXJzZXIgaGFzIGAxYChub3QgemVybykgYXMgdGhlIHN0YXJ0IG51bWJlclxuICAgICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHJhbmdlSW5mby5zdGFydEluZGV4ICsgMTtcbiAgICAgICAgICAgIHZhciBlbmRMaW5lID0gcmFuZ2VJbmZvLmVuZEluZGV4ICsgMTtcbiAgICAgICAgICAgIHZhciBlbmRUb09mZnNldCA9IHJhbmdlSW5mby5lbmRUb09mZnNldDtcbiAgICAgICAgICAgIHZhciBza2lwTGluZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGxpbmUgPSBzdGFydExpbmU7IGxpbmUgPD0gZW5kTGluZTsgbGluZSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgIGlmIChtZE5vZGUgJiYgY2Fubm90QmVMaXN0Tm9kZShtZE5vZGUsIGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0byBza2lwIHVubmVjZXNzYXJ5IHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICBpZiAoc2tpcExpbmVzLmluZGV4T2YobGluZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHsgdG9hc3RNYXJrOiB0b2FzdE1hcmssIG1kTm9kZTogbWROb2RlLCBkb2M6IGRvYywgbGluZTogbGluZSwgc3RhcnRMaW5lOiBzdGFydExpbmUgfTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZFJlc3VsdHMgPSAoaXNMaXN0Tm9kZSQxKG1kTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgPyBvdGhlckxpc3RUb0xpc3RbY29tbWFuZFR5cGVdKGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgIDogb3RoZXJOb2RlVG9MaXN0W2NvbW1hbmRUeXBlXShjb250ZXh0KSkuY2hhbmdlZFJlc3VsdHM7XG4gICAgICAgICAgICAgICAgdmFyIGVuZE9mZnNldCA9IF90aGlzLmNoYW5nZVRvTGlzdFBlckxpbmUodHIsIGNoYW5nZWRSZXN1bHRzLCB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGdldE5vZGVDb250ZW50T2Zmc2V0UmFuZ2UoZG9jLCBjaGFuZ2VkUmVzdWx0c1swXS5saW5lIC0gMSkuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZTogY2hhbmdlZFJlc3VsdHNbMF0ubGluZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kTGluZTogbGFzdCQxKGNoYW5nZWRSZXN1bHRzKS5saW5lLFxuICAgICAgICAgICAgICAgICAgICBpbmRleERpZmY6IDEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZW5kVG9PZmZzZXQgPSBNYXRoLm1heChlbmRPZmZzZXQsIGVuZFRvT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZFJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcExpbmVzID0gc2tpcExpbmVzLmNvbmNhdChjaGFuZ2VkUmVzdWx0cy5tYXAoZnVuY3Rpb24gKGluZm8pIHsgcmV0dXJuIGluZm8ubGluZTsgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS5jaGFuZ2VUb0xpc3RQZXJMaW5lID0gZnVuY3Rpb24gKHRyLCBjaGFuZ2VkUmVzdWx0cywgX2EpIHtcbiAgICAgICAgdmFyIGZyb20gPSBfYS5mcm9tLCBzdGFydExpbmUgPSBfYS5zdGFydExpbmUsIGVuZExpbmUgPSBfYS5lbmRMaW5lLCBfYiA9IF9hLmluZGV4RGlmZiwgaW5kZXhEaWZmID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYjtcbiAgICAgICAgdmFyIG1heEVuZE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBfYyA9IHRyLmRvYy5jaGlsZChpKSwgbm9kZVNpemUgPSBfYy5ub2RlU2l6ZSwgY29udGVudCA9IF9jLmNvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgbWFwcGVkRnJvbSA9IHRyLm1hcHBpbmcubWFwKGZyb20pO1xuICAgICAgICAgICAgdmFyIG1hcHBlZFRvID0gbWFwcGVkRnJvbSArIGNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkUmVzdWx0ID0gY2hhbmdlZFJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5saW5lIC0gaW5kZXhEaWZmID09PSBpOyB9KVswXTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgobWFwcGVkRnJvbSwgbWFwcGVkVG8sIGNyZWF0ZVRleHROb2RlJDEodGhpc18xLmNvbnRleHQuc2NoZW1hLCBjaGFuZ2VkUmVzdWx0LnRleHQpKTtcbiAgICAgICAgICAgICAgICBtYXhFbmRPZmZzZXQgPSBNYXRoLm1heChtYXhFbmRPZmZzZXQsIGZyb20gKyBjb250ZW50LnNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbSArPSBub2RlU2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmUgLSBpbmRleERpZmY7IGkgPD0gZW5kTGluZSAtIGluZGV4RGlmZjsgaSArPSAxKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhFbmRPZmZzZXQ7XG4gICAgfTtcbiAgICBMaXN0SXRlbS5wcm90b3R5cGUudG9nZ2xlVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYywgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgdmFyIHRvYXN0TWFyayA9IF90aGlzLmNvbnRleHQudG9hc3RNYXJrO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0SW5kZXggPSBfYi5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9iLmVuZEluZGV4O1xuICAgICAgICAgICAgdmFyIG5ld1RyID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUoaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChpc0xpc3ROb2RlJDEobWROb2RlKSAmJiBtZE5vZGUubGlzdERhdGEudGFzaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBtZE5vZGUubGlzdERhdGEsIGNoZWNrZWQgPSBfYy5jaGVja2VkLCBwYWRkaW5nID0gX2MucGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlQ2hhciA9IGNoZWNrZWQgPyAnICcgOiAneCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZFBvcyA9IG1kTm9kZS5zb3VyY2Vwb3NbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IGdldE5vZGVDb250ZW50T2Zmc2V0UmFuZ2UoZG9jLCBtZFBvc1swXSAtIDEpLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldCArPSBtZFBvc1sxXSArIHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RyID0gdHIucmVwbGFjZVdpdGgoc3RhcnRPZmZzZXQsIHN0YXJ0T2Zmc2V0ICsgMSwgc2NoZW1hLnRleHQoc3RhdGVDaGFyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1RyKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVsbGV0TGlzdDogdGhpcy50b0xpc3QoJ2J1bGxldCcpLFxuICAgICAgICAgICAgb3JkZXJlZExpc3Q6IHRoaXMudG9MaXN0KCdvcmRlcmVkJyksXG4gICAgICAgICAgICB0YXNrTGlzdDogdGhpcy50b0xpc3QoJ3Rhc2snKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVsbGV0Q29tbWFuZCA9IHRoaXMudG9MaXN0KCdidWxsZXQnKSgpO1xuICAgICAgICB2YXIgb3JkZXJlZENvbW1hbmQgPSB0aGlzLnRvTGlzdCgnb3JkZXJlZCcpKCk7XG4gICAgICAgIHZhciB0YXNrQ29tbWFuZCA9IHRoaXMudG9MaXN0KCd0YXNrJykoKTtcbiAgICAgICAgdmFyIHRvZ2xlVGFza0NvbW1hbmQgPSB0aGlzLnRvZ2dsZVRhc2soKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtdSc6IGJ1bGxldENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLVUnOiBidWxsZXRDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1vJzogb3JkZXJlZENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLU8nOiBvcmRlcmVkQ29tbWFuZCxcbiAgICAgICAgICAgICdhbHQtdCc6IHRhc2tDb21tYW5kLFxuICAgICAgICAgICAgJ2FsdC1UJzogdGFza0NvbW1hbmQsXG4gICAgICAgICAgICAnU2hpZnQtQ3RybC14JzogdG9nbGVUYXNrQ29tbWFuZCxcbiAgICAgICAgICAgICdTaGlmdC1DdHJsLVgnOiB0b2dsZVRhc2tDb21tYW5kLFxuICAgICAgICAgICAgRW50ZXI6IHRoaXMuZXh0ZW5kTGlzdCgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIExpc3RJdGVtO1xufShNYXJrKSk7XG5cbmZ1bmN0aW9uIHRvZ2dsZU1hcmsoY29uZGl0aW9uLCBzeW50YXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgdHIgPSBfYS50ciwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgY29uZGl0aW9uRm4gPSAhaXNGdW5jdGlvbl8xKGNvbmRpdGlvbilcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIGNvbmRpdGlvbi50ZXN0KHRleHQpOyB9XG4gICAgICAgICAgICA6IGNvbmRpdGlvbjtcbiAgICAgICAgdmFyIHN5bnRheExlbiA9IHN5bnRheC5sZW5ndGg7XG4gICAgICAgIHZhciBkb2MgPSB0ci5kb2M7XG4gICAgICAgIHZhciBfYiA9IHJlc29sdmVTZWxlY3Rpb25Qb3Moc2VsZWN0aW9uKSwgZnJvbSA9IF9iWzBdLCB0byA9IF9iWzFdO1xuICAgICAgICB2YXIgcHJldlBvcyA9IE1hdGgubWF4KGZyb20gLSBzeW50YXhMZW4sIDEpO1xuICAgICAgICB2YXIgbmV4dFBvcyA9IE1hdGgubWluKHRvICsgc3ludGF4TGVuLCBkb2MuY29udGVudC5zaXplIC0gMSk7XG4gICAgICAgIHZhciBzbGljZSA9IHNlbGVjdGlvbi5jb250ZW50KCk7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCAnXFxuJyk7XG4gICAgICAgIHZhciBwcmV2VGV4dCA9IGRvYy50ZXh0QmV0d2VlbihwcmV2UG9zLCBmcm9tLCAnXFxuJyk7XG4gICAgICAgIHZhciBuZXh0VGV4dCA9IGRvYy50ZXh0QmV0d2Vlbih0bywgbmV4dFBvcywgJ1xcbicpO1xuICAgICAgICB0ZXh0Q29udGVudCA9IFwiXCIgKyBwcmV2VGV4dCArIHRleHRDb250ZW50ICsgbmV4dFRleHQ7XG4gICAgICAgIGlmIChwcmV2VGV4dCAmJiBuZXh0VGV4dCAmJiBjb25kaXRpb25Gbih0ZXh0Q29udGVudCkpIHtcbiAgICAgICAgICAgIHRyLmRlbGV0ZShuZXh0UG9zIC0gc3ludGF4TGVuLCBuZXh0UG9zKS5kZWxldGUocHJldlBvcywgcHJldlBvcyArIHN5bnRheExlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ci5pbnNlcnRUZXh0KHN5bnRheCwgdG8pLmluc2VydFRleHQoc3ludGF4LCBmcm9tKTtcbiAgICAgICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZW1wdHlcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGZyb20gKyBzeW50YXhMZW4pXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBmcm9tICsgc3ludGF4TGVuLCB0byArIHN5bnRheExlbik7XG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07IH07XG59XG5cbnZhciByZVN0cm9uZyA9IC9eKFxcKnsyfXxfezJ9KS4qKFtcXHNcXFNdKilcXDEkL207XG52YXIgc3Ryb25nU3ludGF4ID0gJyoqJztcbnZhciBTdHJvbmckMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShTdHJvbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Ryb25nKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJvbmcucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3Ryb25nJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJvbmcucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdzdHJvbmcnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0cm9uZy5wcm90b3R5cGUuYm9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvZ2dsZU1hcmsocmVTdHJvbmcsIHN0cm9uZ1N5bnRheCk7XG4gICAgfTtcbiAgICBTdHJvbmcucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBib2xkOiB0aGlzLmJvbGQoKSB9O1xuICAgIH07XG4gICAgU3Ryb25nLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9sZENvbW1hbmQgPSB0aGlzLmJvbGQoKSgpO1xuICAgICAgICByZXR1cm4geyAnTW9kLWInOiBib2xkQ29tbWFuZCwgJ01vZC1CJzogYm9sZENvbW1hbmQgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJvbmc7XG59KE1hcmspKTtcblxudmFyIHJlU3RyaWtlID0gL14ofnsyfSkuKihbXFxzXFxTXSopXFwxJC9tO1xudmFyIHN0cmlrZVN5bnRheCA9ICd+fic7XG52YXIgU3RyaWtlJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoU3RyaWtlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmlrZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWtlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cmlrZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWtlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnc3RyaWtlJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHJpa2UucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9nZ2xlTWFyayhyZVN0cmlrZSwgc3RyaWtlU3ludGF4KTtcbiAgICB9O1xuICAgIFN0cmlrZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0cmlrZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHsgJ01vZC1zJzogc3RyaWtlQ29tbWFuZCwgJ01vZC1TJzogc3RyaWtlQ29tbWFuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmlrZTtcbn0oTWFyaykpO1xuXG52YXIgcmVFbXBoID0gL14oXFwqfF8pLiooW1xcc1xcU10qKVxcMSQvbTtcbnZhciBlbXBoU3ludGF4ID0gJyonO1xudmFyIEVtcGgkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShFbXBoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcGgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtcGgucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZW1waCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1waC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2VtcGgnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVtcGgucHJvdG90eXBlLml0YWxpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvZ2dsZU1hcmsocmVFbXBoLCBlbXBoU3ludGF4KTtcbiAgICB9O1xuICAgIEVtcGgucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBpdGFsaWM6IHRoaXMuaXRhbGljKCkgfTtcbiAgICB9O1xuICAgIEVtcGgucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGFsaWNDb21tYW5kID0gdGhpcy5pdGFsaWMoKSgpO1xuICAgICAgICByZXR1cm4geyAnTW9kLWknOiBpdGFsaWNDb21tYW5kLCAnTW9kLUknOiBpdGFsaWNDb21tYW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gRW1waDtcbn0oTWFyaykpO1xuXG52YXIgcmVDb2RlID0gL14oYCkuKihbXFxzXFxTXSopXFwxJC9tO1xudmFyIGNvZGVTeW50YXggPSAnYCc7XG52YXIgQ29kZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENvZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdjb2RlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2RlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlZDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChtYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IG1hcmsuYXR0cnMsIHN0YXJ0ID0gX2Euc3RhcnQsIGVuZCA9IF9hLmVuZCwgbWFya2VkID0gX2EubWFya2VkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9ICdjb2RlJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8ZGVsaW1pdGVyfHN0YXJ0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8ZGVsaW1pdGVyfGVuZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfG1hcmtlZC10ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4LmFwcGx5KHZvaWQgMCwgY2xhc3NOYW1lcy5zcGxpdCgnfCcpKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvZGUucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9nZ2xlTWFyayhyZUNvZGUsIGNvZGVTeW50YXgpO1xuICAgIH07XG4gICAgQ29kZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGVDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7ICdTaGlmdC1Nb2QtYyc6IGNvZGVDb21tYW5kLCAnU2hpZnQtTW9kLUMnOiBjb2RlQ29tbWFuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvZGU7XG59KE1hcmspKTtcblxudmFyIExpbmskMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmsucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGluayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGluay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gYXR0cnMudXJsLCBkZXNjID0gYXR0cnMuZGVzYztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAnbGluayc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xsaW5rLXVybHxtYXJrZWQtdGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xsaW5rLWRlc2N8bWFya2VkLXRleHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXguYXBwbHkodm9pZCAwLCBjbGFzc05hbWVzLnNwbGl0KCd8JykpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGluay5wcm90b3R5cGUuYWRkTGlua09ySW1hZ2UgPSBmdW5jdGlvbiAoY29tbWFuZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2IgPSByZXNvbHZlU2VsZWN0aW9uUG9zKHNlbGVjdGlvbiksIGZyb20gPSBfYlswXSwgdG8gPSBfYlsxXTtcbiAgICAgICAgICAgIHZhciBfYyA9IHBheWxvYWQsIGxpbmtUZXh0ID0gX2MubGlua1RleHQsIGFsdFRleHQgPSBfYy5hbHRUZXh0LCBsaW5rVXJsID0gX2MubGlua1VybCwgaW1hZ2VVcmwgPSBfYy5pbWFnZVVybDtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gbGlua1RleHQ7XG4gICAgICAgICAgICB2YXIgdXJsID0gbGlua1VybDtcbiAgICAgICAgICAgIHZhciBzeW50YXggPSAnJztcbiAgICAgICAgICAgIGlmIChjb21tYW5kVHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBhbHRUZXh0O1xuICAgICAgICAgICAgICAgIHVybCA9IGltYWdlVXJsO1xuICAgICAgICAgICAgICAgIHN5bnRheCA9ICchJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSBlc2NhcGVUZXh0Rm9yTGluayh0ZXh0KTtcbiAgICAgICAgICAgIHN5bnRheCArPSBcIltcIiArIHRleHQgKyBcIl0oXCIgKyB1cmwgKyBcIilcIjtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnJlcGxhY2VXaXRoKGZyb20sIHRvLCBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgc3ludGF4KSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZEltYWdlOiB0aGlzLmFkZExpbmtPckltYWdlKCdpbWFnZScpLFxuICAgICAgICAgICAgYWRkTGluazogdGhpcy5hZGRMaW5rT3JJbWFnZSgnbGluaycpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIExpbms7XG59KE1hcmspKTtcblxudmFyIFRhc2tEZWxpbWl0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFza0RlbGltaXRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYXNrRGVsaW1pdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYXNrRGVsaW1pdGVyLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Rhc2tEZWxpbWl0ZXInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhc2tEZWxpbWl0ZXIucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdkZWxpbWl0ZXInLCAnbGlzdC1pdGVtJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFza0RlbGltaXRlcjtcbn0oTWFyaykpO1xudmFyIERlbGltaXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShEZWxpbWl0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVsaW1pdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWxpbWl0ZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGVsaW1pdGVyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWxpbWl0ZXIucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdkZWxpbWl0ZXInKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBEZWxpbWl0ZXI7XG59KE1hcmspKTtcbnZhciBNZXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKE1ldGEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWV0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWV0YS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdtZXRhJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXRhLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnbWV0YScpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE1ldGE7XG59KE1hcmspKTtcbnZhciBNYXJrZWRUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKE1hcmtlZFRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFya2VkVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFya2VkVGV4dC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdtYXJrZWRUZXh0JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXJrZWRUZXh0LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnbWFya2VkLXRleHQnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBNYXJrZWRUZXh0O1xufShNYXJrKSk7XG52YXIgVGFibGVDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlQ2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQ2VsbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZUNlbGwnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQ2VsbC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ3RhYmxlLWNlbGwnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUYWJsZUNlbGw7XG59KE1hcmspKTtcblxudmFyIEh0bWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSHRtbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdG1sKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIdG1sLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2h0bWwnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEh0bWwucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdodG1sJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gSHRtbDtcbn0oTWFyaykpO1xuXG52YXIgY3VzdG9tQmxvY2tTeW50YXggPSAnJCQnO1xudmFyIEN1c3RvbUJsb2NrJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ3VzdG9tQmxvY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUJsb2NrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2N1c3RvbUJsb2NrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21CbG9jay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2N1c3RvbS1ibG9jaycpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ3VzdG9tQmxvY2sucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIShwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQuaW5mbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VzdG9tQmxvY2sgPSBcIlwiICsgY3VzdG9tQmxvY2tTeW50YXggKyBwYXlsb2FkLmluZm87XG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIGN1c3RvbUJsb2NrKTtcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIGN1c3RvbUJsb2NrU3ludGF4KTtcbiAgICAgICAgICAgIHRyLmluc2VydChzdGFydEZyb21PZmZzZXQsIHN0YXJ0Tm9kZSkuc3BsaXQoc3RhcnRGcm9tT2Zmc2V0ICsgY3VzdG9tQmxvY2subGVuZ3RoKTtcbiAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSwgZW5kTm9kZSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpIC0gKGN1c3RvbUJsb2NrU3ludGF4Lmxlbmd0aCArIDIpKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICByZXR1cm4gQ3VzdG9tQmxvY2s7XG59KE1hcmspKTtcblxudmFyIHJlVGFza01hcmtlcktleSA9IC94fGJhY2tzcGFjZS9pO1xudmFyIHJlVGFza01hcmtlciA9IC9eXFxbKFxccyopKHg/KShcXHMqKVxcXSg/OlxccyspL2k7XG5mdW5jdGlvbiBzbWFydFRhc2soX2EpIHtcbiAgICB2YXIgc2NoZW1hID0gX2Euc2NoZW1hLCB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcms7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAga2V5dXA6IGZ1bmN0aW9uICh2aWV3LCBldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IHZpZXcuc3RhdGUsIGRvYyA9IF9iLmRvYywgdHIgPSBfYi50ciwgc2VsZWN0aW9uID0gX2Iuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5ICYmIHJlVGFza01hcmtlcktleS50ZXN0KGV2LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEluZGV4ID0gX2Muc3RhcnRJbmRleCwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Muc3RhcnRGcm9tT2Zmc2V0LCBmcm9tID0gX2MuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhZGQgYDFgIHRvIGxpbmUgZm9yIHRoZSBtYXJrZG93biBwYXJzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgbWFya2Rvd24gcGFyc2VyIGhhcyBgMWAobm90IHplcm8pIGFzIHRoZSBzdGFydCBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZFBvcyA9IFtzdGFydEluZGV4ICsgMSwgZnJvbSAtIHN0YXJ0RnJvbU9mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kTm9kZUF0UG9zaXRpb24obWRQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFOb2RlID0gZmluZENsb3Nlc3ROb2RlKG1kTm9kZSwgZnVuY3Rpb24gKG5vZGUpIHsgdmFyIF9hOyByZXR1cm4gbm9kZS50eXBlID09PSAncGFyYWdyYXBoJyAmJiAoKF9hID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gJ2l0ZW0nOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBwYXJhTm9kZSA9PT0gbnVsbCB8fCBwYXJhTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYU5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IHBhcmFOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBmaXJzdENoaWxkLmxpdGVyYWwubWF0Y2gocmVUYXNrTWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRNZFBvcyA9IGZpcnN0Q2hpbGQuc291cmNlcG9zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRTcGFjZXMgPSBtYXRjaGVkWzFdLCBzdGF0ZUNoYXIgPSBtYXRjaGVkWzJdLCBsYXN0U3BhY2VzID0gbWF0Y2hlZFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYWNlcyA9IHN0YXJ0U3BhY2VzLmxlbmd0aCArIGxhc3RTcGFjZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBnZXROb2RlQ29udGVudE9mZnNldFJhbmdlKGRvYywgc3RhcnRNZFBvc1swXSAtIDEpLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBzdGFydE1kUG9zWzFdICsgc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZFBvcyA9IHNwYWNlcyA/IHNwYWNlcyArIDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoc3RhcnRQb3MsIGFkZGVkUG9zICsgc3RhcnRQb3MsIHNjaGVtYS50ZXh0KHN0YXRlQ2hhcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNwYWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dCgnICcsIHN0YXJ0UG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxudmFyIEVWRU5UX1RZUEUgPSAnY3V0JztcbnZhciByZUxpbmVFbmRpbmckMiA9IC9cXHJcXG58XFxufFxcci87XG52YXIgTWRFZGl0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTWRFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRFZGl0b3IoZXZlbnRFbWl0dGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGV2ZW50RW1pdHRlcikgfHwgdGhpcztcbiAgICAgICAgdmFyIHRvYXN0TWFyayA9IG9wdGlvbnMudG9hc3RNYXJrLCBfYSA9IG9wdGlvbnMudXNlQ29tbWFuZFNob3J0Y3V0LCB1c2VDb21tYW5kU2hvcnRjdXQgPSBfYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9hLCBfYiA9IG9wdGlvbnMubWRQbHVnaW5zLCBtZFBsdWdpbnMgPSBfYiA9PT0gdm9pZCAwID8gW10gOiBfYjtcbiAgICAgICAgX3RoaXMuZWRpdG9yVHlwZSA9ICdtYXJrZG93bic7XG4gICAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ21kLW1vZGUnKTtcbiAgICAgICAgX3RoaXMudG9hc3RNYXJrID0gdG9hc3RNYXJrO1xuICAgICAgICBfdGhpcy5leHRyYVBsdWdpbnMgPSBtZFBsdWdpbnM7XG4gICAgICAgIF90aGlzLnNwZWNzID0gX3RoaXMuY3JlYXRlU3BlY3MoKTtcbiAgICAgICAgX3RoaXMuc2NoZW1hID0gX3RoaXMuY3JlYXRlU2NoZW1hKCk7XG4gICAgICAgIF90aGlzLmNvbnRleHQgPSBfdGhpcy5jcmVhdGVDb250ZXh0KCk7XG4gICAgICAgIF90aGlzLmtleW1hcHMgPSBfdGhpcy5jcmVhdGVLZXltYXBzKHVzZUNvbW1hbmRTaG9ydGN1dCk7XG4gICAgICAgIF90aGlzLnZpZXcgPSBfdGhpcy5jcmVhdGVWaWV3KCk7XG4gICAgICAgIF90aGlzLmNvbW1hbmRzID0gX3RoaXMuY3JlYXRlQ29tbWFuZHMoKTtcbiAgICAgICAgX3RoaXMuc3BlY3Muc2V0Q29udGV4dChfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIF90aGlzLmNvbnRleHQpLCB7IHZpZXc6IF90aGlzLnZpZXcgfSkpO1xuICAgICAgICBfdGhpcy5jcmVhdGVDbGlwYm9hcmQoKTtcbiAgICAgICAgLy8gVG8gcHJldmVudCB1bm5lY2Vzc2FyeSBmb2N1cyBzZXR0aW5nIGR1cmluZyBpbml0aWFsIHJlbmRlcmluZ1xuICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VQcmV2aWV3VGFiV3JpdGUnLCBmdW5jdGlvbiAoaXNNYXJrZG93blRhYk1vdW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUodHJ1ZSwgaXNNYXJrZG93blRhYk1vdW50ZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlUHJldmlld1RhYlByZXZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUoZmFsc2UpOyB9KTtcbiAgICAgICAgX3RoaXMuaW5pdEV2ZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLnRvZ2dsZUFjdGl2ZSA9IGZ1bmN0aW9uIChhY3RpdmUsIGlzTWFya2Rvd25UYWJNb3VudGVkKSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWwsICdhY3RpdmUnLCBhY3RpdmUpO1xuICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoIWlzTWFya2Rvd25UYWJNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVDbGlwYm9hcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgdGhpcy5jbGlwYm9hcmQuY2xhc3NOYW1lID0gY2xzKCdwc2V1ZG8tY2xpcGJvYXJkJyk7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkLmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgY2xpcGJvYXJkRGF0YSA9IGV2LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBjbGlwYm9hcmREYXRhICYmIGNsaXBib2FyZERhdGEuaXRlbXM7XG4gICAgICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpblJ0Zkl0ZW0gPSB0b0FycmF5XzEoaXRlbXMpLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ua2luZCA9PT0gJ3N0cmluZycgJiYgaXRlbS50eXBlID09PSAndGV4dC9ydGYnOyB9KTtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBjb250YWlucyBydGYsIGl0J3MgbW9zdCBsaWtlbHkgY29weSBwYXN0ZSBmcm9tIG9mZmljZSAtPiBubyBpbWFnZVxuICAgICAgICAgICAgICAgIGlmICghY29udGFpblJ0Zkl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlQmxvYiA9IHBhc3RlSW1hZ2VPbmx5KGl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlQmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRJbWFnZUJsb2JIb29rKF90aGlzLmV2ZW50RW1pdHRlciwgaW1hZ2VCbG9iLCBldi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHByb2Nlc3MgdGhlIHBhc3RlZCBkYXRhIGluIGlucHV0IGV2ZW50IGZvciBJRTExXG4gICAgICAgIHRoaXMuY2xpcGJvYXJkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGV2LnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXYudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsLmluc2VydEJlZm9yZSh0aGlzLmNsaXBib2FyZCwgdGhpcy52aWV3LmRvbSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvYXN0TWFyazogdGhpcy50b2FzdE1hcmssXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiB0aGlzLmV2ZW50RW1pdHRlcixcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVTcGVjcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcGVjTWFuYWdlcihbXG4gICAgICAgICAgICBuZXcgRG9jJDEoKSxcbiAgICAgICAgICAgIG5ldyBQYXJhZ3JhcGgkMSgpLFxuICAgICAgICAgICAgbmV3IFdpZGdldCgpLFxuICAgICAgICAgICAgbmV3IFRleHQkMSgpLFxuICAgICAgICAgICAgbmV3IEhlYWRpbmckMSgpLFxuICAgICAgICAgICAgbmV3IEJsb2NrUXVvdGUkMSgpLFxuICAgICAgICAgICAgbmV3IENvZGVCbG9jayQxKCksXG4gICAgICAgICAgICBuZXcgQ3VzdG9tQmxvY2skMSgpLFxuICAgICAgICAgICAgbmV3IFRhYmxlJDEoKSxcbiAgICAgICAgICAgIG5ldyBUYWJsZUNlbGwoKSxcbiAgICAgICAgICAgIG5ldyBUaGVtYXRpY0JyZWFrJDEoKSxcbiAgICAgICAgICAgIG5ldyBMaXN0SXRlbSQxKCksXG4gICAgICAgICAgICBuZXcgU3Ryb25nJDEoKSxcbiAgICAgICAgICAgIG5ldyBTdHJpa2UkMSgpLFxuICAgICAgICAgICAgbmV3IEVtcGgkMSgpLFxuICAgICAgICAgICAgbmV3IENvZGUkMSgpLFxuICAgICAgICAgICAgbmV3IExpbmskMSgpLFxuICAgICAgICAgICAgbmV3IERlbGltaXRlcigpLFxuICAgICAgICAgICAgbmV3IFRhc2tEZWxpbWl0ZXIoKSxcbiAgICAgICAgICAgIG5ldyBNYXJrZWRUZXh0KCksXG4gICAgICAgICAgICBuZXcgTWV0YSgpLFxuICAgICAgICAgICAgbmV3IEh0bWwoKSxcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuY3JlYXRlUGx1Z2lucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkkMShbXG4gICAgICAgICAgICBzeW50YXhIaWdobGlnaHQodGhpcy5jb250ZXh0KSxcbiAgICAgICAgICAgIHByZXZpZXdIaWdobGlnaHQodGhpcy5jb250ZXh0KSxcbiAgICAgICAgICAgIHNtYXJ0VGFzayh0aGlzLmNvbnRleHQpXG4gICAgICAgIF0sIHRoaXMuY3JlYXRlUGx1Z2luUHJvcHMoKSkuY29uY2F0KHRoaXMuZGVmYXVsdFBsdWdpbnMpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yVmlldyh0aGlzLmVsLCB7XG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jcmVhdGVTdGF0ZSgpLFxuICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlTWFya2Rvd24odHIpO1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF90aGlzLnZpZXcuc3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdENoYW5nZUV2ZW50KHRyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGV2Lm1ldGFLZXkgfHwgZXYuY3RybEtleSkgJiYgZXYua2V5LnRvVXBwZXJDYXNlKCkgPT09ICdWJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGlwYm9hcmQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2tleWRvd24nLCBfdGhpcy5lZGl0b3JUeXBlLCBldik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIGNvcHk6IGZ1bmN0aW9uIChfLCBldikgeyByZXR1cm4gX3RoaXMuY2FwdHVyZUNvcHkoZXYpOyB9LFxuICAgICAgICAgICAgICAgIGN1dDogZnVuY3Rpb24gKF8sIGV2KSB7IHJldHVybiBfdGhpcy5jYXB0dXJlQ29weShldiwgRVZFTlRfVFlQRSk7IH0sXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdzY3JvbGwnLCAnZWRpdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2V5dXA6IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgna2V5dXAnLCBfdGhpcy5lZGl0b3JUeXBlLCBldik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vZGVWaWV3czoge1xuICAgICAgICAgICAgICAgIHdpZGdldDogd2lkZ2V0Tm9kZVZpZXcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVDb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlY3MuY29tbWFuZHModGhpcy52aWV3KTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jYXB0dXJlQ29weSA9IGZ1bmN0aW9uIChldiwgdHlwZSkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50cjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldENoYW5nZWQoc2VsZWN0aW9uLmNvbnRlbnQoKSk7XG4gICAgICAgIGlmIChldi5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICBldi5jbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEoJ1RleHQnLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gRVZFTlRfVFlQRSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YSgndWlFdmVudCcsIEVWRU5UX1RZUEUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS51cGRhdGVNYXJrZG93biA9IGZ1bmN0aW9uICh0cikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgdHIuc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcC5zbGljZSAmJiAhKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHRyLmRvY3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBbc3RlcC5mcm9tLCBzdGVwLnRvXSwgZnJvbSA9IF9hWzBdLCB0byA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBnZXRFZGl0b3JUb01kUG9zKGRvYywgZnJvbSwgdG8pLCBzdGFydFBvcyA9IF9iWzBdLCBlbmRQb3MgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBfdGhpcy5nZXRDaGFuZ2VkKHN0ZXAuc2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRQb3NbMF0gPT09IGVuZFBvc1swXSAmJiBzdGFydFBvc1sxXSA9PT0gZW5kUG9zWzFdICYmIGNoYW5nZWQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSBfdGhpcy50b2FzdE1hcmsuZWRpdE1hcmtkb3duKHN0YXJ0UG9zLCBlbmRQb3MsIGNoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndXBkYXRlUHJldmlldycsIGVkaXRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKCdlZGl0UmVzdWx0JywgZWRpdFJlc3VsdCkuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmdldENoYW5nZWQgPSBmdW5jdGlvbiAoc2xpY2UpIHtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSAnJztcbiAgICAgICAgdmFyIGZyb20gPSAwO1xuICAgICAgICB2YXIgdG8gPSBzbGljZS5jb250ZW50LnNpemU7XG4gICAgICAgIHNsaWNlLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkICs9IG5vZGUudGV4dC5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmlzQmxvY2sgJiYgcG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gc3RhcnQ7IH1cbiAgICAgICAgdmFyIHRyID0gdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICB2YXIgX2EgPSBnZXRNZFRvRWRpdG9yUG9zKHRyLmRvYywgc3RhcnQsIGVuZCksIGZyb20gPSBfYVswXSwgdG8gPSBfYVsxXTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBmcm9tLCB0bykpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLnJlcGxhY2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbmV3VHI7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgc2NoZW1hID0gX2Euc2NoZW1hLCBkb2MgPSBfYS5kb2M7XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSB0ZXh0LnNwbGl0KHJlTGluZUVuZGluZyQyKTtcbiAgICAgICAgdmFyIG5vZGVzID0gbGluZVRleHRzLm1hcChmdW5jdGlvbiAobGluZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQYXJhZ3JhcGgoc2NoZW1hLCBjcmVhdGVOb2Rlc1dpdGhXaWRnZXQobGluZVRleHQsIHNjaGVtYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZXMpLCAxLCAxKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRNZFRvRWRpdG9yUG9zKGRvYywgc3RhcnQsIGVuZCksIGZyb20gPSBfYlswXSwgdG8gPSBfYlsxXTtcbiAgICAgICAgICAgIG5ld1RyID0gdHIucmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdUciA9IHRyLnJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChuZXdUci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5kZWxldGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbmV3VHI7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jO1xuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRNZFRvRWRpdG9yUG9zKGRvYywgc3RhcnQsIGVuZCksIGZyb20gPSBfYlswXSwgdG8gPSBfYlsxXTtcbiAgICAgICAgICAgIG5ld1RyID0gdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VHIgPSB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2gobmV3VHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRUZXh0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCBkb2MgPSBfYS5kb2MsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG87XG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBnZXRNZFRvRWRpdG9yUG9zKGRvYywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICBmcm9tID0gcG9zWzBdO1xuICAgICAgICAgICAgdG8gPSBwb3NbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bywgJ1xcbicpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbiwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG87XG4gICAgICAgIHJldHVybiBnZXRFZGl0b3JUb01kUG9zKHRoaXMudmlldy5zdGF0ZS50ci5kb2MsIGZyb20sIHRvKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5zZXRNYXJrZG93biA9IGZ1bmN0aW9uIChtYXJrZG93biwgY3Vyc29yVG9FbmQpIHtcbiAgICAgICAgaWYgKGN1cnNvclRvRW5kID09PSB2b2lkIDApIHsgY3Vyc29yVG9FbmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSBtYXJrZG93bi5zcGxpdChyZUxpbmVFbmRpbmckMik7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgIHZhciBub2RlcyA9IGxpbmVUZXh0cy5tYXAoZnVuY3Rpb24gKGxpbmVUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUGFyYWdyYXBoKHNjaGVtYSwgY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KGxpbmVUZXh0LCBzY2hlbWEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5yZXBsYWNlV2l0aCgwLCBkb2MuY29udGVudC5zaXplLCBub2RlcykpO1xuICAgICAgICBpZiAoY3Vyc29yVG9FbmQpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvRW5kKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuYWRkV2lkZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIHN0eWxlLCBtZFBvcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYywgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgcG9zID0gbWRQb3MgPyBnZXRNZFRvRWRpdG9yUG9zKGRvYywgbWRQb3MsIG1kUG9zKVswXSA6IHNlbGVjdGlvbi50bztcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoJ3dpZGdldCcsIHsgcG9zOiBwb3MsIG5vZGU6IG5vZGUsIHN0eWxlOiBzdHlsZSB9KSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUucmVwbGFjZVdpdGhXaWRnZXQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYSwgZG9jID0gX2EuZG9jO1xuICAgICAgICB2YXIgcG9zID0gZ2V0TWRUb0VkaXRvclBvcyhkb2MsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB2YXIgbm9kZXMgPSBjcmVhdGVOb2Rlc1dpdGhXaWRnZXQodGV4dCwgc2NoZW1hKTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnJlcGxhY2VXaXRoKHBvc1swXSwgcG9zWzFdLCBub2RlcykpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmdldFJhbmdlSW5mb09mTm9kZSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCBkb2MgPSBfYS5kb2MsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIG1kUG9zID0gcG9zIHx8IGdldEVkaXRvclRvTWRQb3MoZG9jLCBzZWxlY3Rpb24uZnJvbSlbMF07XG4gICAgICAgIHZhciBtZE5vZGUgPSB0aGlzLnRvYXN0TWFyay5maW5kTm9kZUF0UG9zaXRpb24obWRQb3MpO1xuICAgICAgICBpZiAobWROb2RlLnR5cGUgPT09ICd0ZXh0JyAmJiBtZE5vZGUucGFyZW50LnR5cGUgIT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICBtZE5vZGUgPSBtZE5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCAxIHN5bmMgZm9yIHByb3NlbWlycm9yIHBvc2l0aW9uXG4gICAgICAgIG1kTm9kZS5zb3VyY2Vwb3NbMV1bMV0gKz0gMTtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IG1kTm9kZS5zb3VyY2Vwb3MsIHR5cGU6IG1kTm9kZS50eXBlIH07XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuZ2V0TWFya2Rvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0TWFya1xuICAgICAgICAgICAgLmdldExpbmVUZXh0cygpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsaW5lVGV4dCkgeyByZXR1cm4gdW53cmFwV2lkZ2V0U3ludGF4KGxpbmVUZXh0KTsgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5nZXRUb2FzdE1hcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0TWFyaztcbiAgICB9O1xuICAgIHJldHVybiBNZEVkaXRvcjtcbn0oRWRpdG9yQmFzZSkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgR2V0IGV2ZW50IGNvbGxlY3Rpb24gZm9yIHNwZWNpZmljIEhUTUwgZWxlbWVudFxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIEVWRU5UX0tFWSA9ICdfZmVFdmVudEtleSc7XG5cbi8qKlxuICogR2V0IGV2ZW50IGNvbGxlY3Rpb24gZm9yIHNwZWNpZmljIEhUTUwgZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEhUTUwgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlXG4gKiBAcmV0dXJucyB7YXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYWZlRXZlbnQkMihlbGVtZW50LCB0eXBlKSB7XG4gIHZhciBldmVudHMgPSBlbGVtZW50W0VWRU5UX0tFWV07XG4gIHZhciBoYW5kbGVycztcblxuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IGVsZW1lbnRbRVZFTlRfS0VZXSA9IHt9O1xuICB9XG5cbiAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcnMpIHtcbiAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXJzO1xufVxuXG52YXIgX3NhZmVFdmVudCA9IHNhZmVFdmVudCQyO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVW5iaW5kIERPTSBldmVudHNcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc1N0cmluZyQxID0gaXNTdHJpbmdfMTtcbnZhciBmb3JFYWNoJDEgPSBmb3JFYWNoXzE7XG5cbnZhciBzYWZlRXZlbnQkMSA9IF9zYWZlRXZlbnQ7XG5cbi8qKlxuICogVW5iaW5kIERPTSBldmVudHNcbiAqIElmIGEgaGFuZGxlciBmdW5jdGlvbiBpcyBub3QgcGFzc2VkLCByZW1vdmUgYWxsIGV2ZW50cyBvZiB0aGF0IHR5cGUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byB1bmJpbmQgZXZlbnRzXG4gKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgLSBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbUV2ZW50XG4gKiBAZXhhbXBsZVxuICogLy8gRm9sbG93aW5nIHRoZSBleGFtcGxlIG9mIGRvbUV2ZW50I29uXG4gKiBcbiAqIC8vIFVuYmluZCBvbmUgZXZlbnQgZnJvbSBhbiBlbGVtZW50LlxuICogb2ZmKGRpdiwgJ2NsaWNrJywgdG9nZ2xlKTtcbiAqIFxuICogLy8gVW5iaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGEgc2FtZSBoYW5kbGVyIGZyb20gbXVsdGlwbGUgZWxlbWVudHMgYXQgb25jZS5cbiAqIC8vIFVzZSBldmVudCBuYW1lcyBzcGxpdHRlZCBieSBhIHNwYWNlLlxuICogb2ZmKGVsZW1lbnQsICdtb3VzZWVudGVyIG1vdXNlbGVhdmUnLCBjaGFuZ2VDb2xvcik7XG4gKiBcbiAqIC8vIFVuYmluZCBtdWx0aXBsZSBldmVudHMgd2l0aCBkaWZmZXJlbnQgaGFuZGxlcnMgZnJvbSBhbiBlbGVtZW50IGF0IG9uY2UuXG4gKiAvLyBVc2UgYW4gb2JqZWN0IHdoaWNoIG9mIGtleSBpcyBhbiBldmVudCBuYW1lIGFuZCB2YWx1ZSBpcyBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gKiBvZmYoZGl2LCB7XG4gKiAgIGtleWRvd246IGhpZ2hsaWdodCxcbiAqICAga2V5dXA6IGRlaGlnaGxpZ2h0XG4gKiB9KTtcbiAqIFxuICogLy8gVW5iaW5kIGV2ZW50cyB3aXRob3V0IGhhbmRsZXJzLlxuICogb2ZmKGRpdiwgJ2RyYWcnKTtcbiAqL1xuZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGlmIChpc1N0cmluZyQxKHR5cGVzKSkge1xuICAgIGZvckVhY2gkMSh0eXBlcy5zcGxpdCgvXFxzKy9nKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgdW5iaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoJDEodHlwZXMsIGZ1bmN0aW9uKGZ1bmMsIHR5cGUpIHtcbiAgICB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBmdW5jKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVW5iaW5kIERPTSBldmVudHNcbiAqIElmIGEgaGFuZGxlciBmdW5jdGlvbiBpcyBub3QgcGFzc2VkLCByZW1vdmUgYWxsIGV2ZW50cyBvZiB0aGF0IHR5cGUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byB1bmJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBldmVudHMgPSBzYWZlRXZlbnQkMShlbGVtZW50LCB0eXBlKTtcbiAgdmFyIGluZGV4O1xuXG4gIGlmICghaGFuZGxlcikge1xuICAgIGZvckVhY2gkMShldmVudHMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaXRlbS53cmFwcGVkSGFuZGxlcik7XG4gICAgfSk7XG4gICAgZXZlbnRzLnNwbGljZSgwLCBldmVudHMubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoJDEoZXZlbnRzLCBmdW5jdGlvbihpdGVtLCBpZHgpIHtcbiAgICAgIGlmIChoYW5kbGVyID09PSBpdGVtLmhhbmRsZXIpIHtcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCB0eXBlLCBpdGVtLndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgaW5kZXggPSBpZHg7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gQW4gZWxlbWVudCB0byByZW1vdmUgYW4gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XG4gIH1cbn1cblxudmFyIG9mZl8xID0gb2ZmO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmluZCBET00gZXZlbnRzXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNTdHJpbmcgPSBpc1N0cmluZ18xO1xudmFyIGZvckVhY2ggPSBmb3JFYWNoXzE7XG5cbnZhciBzYWZlRXZlbnQgPSBfc2FmZUV2ZW50O1xuXG4vKipcbiAqIEJpbmQgRE9NIGV2ZW50cy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzXG4gKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgLSBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0XG4gKiBAcGFyYW0geyhmdW5jdGlvbnxvYmplY3QpfSBoYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZFxuICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSBjb250ZXh0IC0gY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbUV2ZW50XG4gKiBAZXhhbXBsZVxuICogY29uc3QgZGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gKiBcbiAqIC8vIEJpbmQgb25lIGV2ZW50IHRvIGFuIGVsZW1lbnQuXG4gKiBvbihkaXYsICdjbGljaycsIHRvZ2dsZSk7XG4gKiBcbiAqIC8vIEJpbmQgbXVsdGlwbGUgZXZlbnRzIHdpdGggYSBzYW1lIGhhbmRsZXIgdG8gbXVsdGlwbGUgZWxlbWVudHMgYXQgb25jZS5cbiAqIC8vIFVzZSBldmVudCBuYW1lcyBzcGxpdHRlZCBieSBhIHNwYWNlLlxuICogb24oZGl2LCAnbW91c2VlbnRlciBtb3VzZWxlYXZlJywgY2hhbmdlQ29sb3IpO1xuICogXG4gKiAvLyBCaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGRpZmZlcmVudCBoYW5kbGVycyB0byBhbiBlbGVtZW50IGF0IG9uY2UuXG4gKiAvLyBVc2UgYW4gb2JqZWN0IHdoaWNoIG9mIGtleSBpcyBhbiBldmVudCBuYW1lIGFuZCB2YWx1ZSBpcyBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gKiBvbihkaXYsIHtcbiAqICAga2V5ZG93bjogaGlnaGxpZ2h0LFxuICogICBrZXl1cDogZGVoaWdobGlnaHRcbiAqIH0pO1xuICogXG4gKiAvLyBTZXQgYSBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAqIGNvbnN0IG5hbWUgPSAnZ2xvYmFsJztcbiAqIGNvbnN0IHJlcG9zaXRvcnkgPSB7bmFtZTogJ0NvZGVTbmlwcGV0J307XG4gKiBvbihkaXYsICdkcmFnJywgZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKHRoaXMubmFtZSk7XG4gKiB9LCByZXBvc2l0b3J5KTtcbiAqIC8vIFJlc3VsdCB3aGVuIHlvdSBkcmFnIGEgZGl2OiBcIkNvZGVTbmlwcGV0XCJcbiAqL1xuZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgaWYgKGlzU3RyaW5nKHR5cGVzKSkge1xuICAgIGZvckVhY2godHlwZXMuc3BsaXQoL1xccysvZyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBjb250ZXh0KTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2godHlwZXMsIGZ1bmN0aW9uKGZ1bmMsIHR5cGUpIHtcbiAgICBiaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgZnVuYywgaGFuZGxlcik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEJpbmQgRE9NIGV2ZW50c1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnRzIG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBoYW5kbGVyIGZ1bmN0aW9uIG9yIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIGNvbnRleHQgLSBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIC0gZXZlbnQgb2JqZWN0XG4gICAgICovXG4gIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihlKSB7XG4gICAgaGFuZGxlci5jYWxsKGNvbnRleHQgfHwgZWxlbWVudCwgZSB8fCB3aW5kb3cuZXZlbnQpO1xuICB9XG5cbiAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGV2ZW50SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZXZlbnRIYW5kbGVyKTtcbiAgfVxuICBtZW1vcml6ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgZXZlbnRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBNZW1vcml6ZSBET00gZXZlbnQgaGFuZGxlciBmb3IgdW5iaW5kaW5nLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnRzIG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgdXNlciBwYXNzZWQgYXQgb24oKSB1c2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHdyYXBwZWRIYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHdyYXBwZWQgYnkgZG9tZXZlbnQgZm9yIGltcGxlbWVudGluZyBzb21lIGZlYXR1cmVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtZW1vcml6ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgd3JhcHBlZEhhbmRsZXIpIHtcbiAgdmFyIGV2ZW50cyA9IHNhZmVFdmVudChlbGVtZW50LCB0eXBlKTtcbiAgdmFyIGV4aXN0SW5FdmVudHMgPSBmYWxzZTtcblxuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICBleGlzdEluRXZlbnRzID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICBpZiAoIWV4aXN0SW5FdmVudHMpIHtcbiAgICBldmVudHMucHVzaCh7XG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgd3JhcHBlZEhhbmRsZXI6IHdyYXBwZWRIYW5kbGVyXG4gICAgfSk7XG4gIH1cbn1cblxudmFyIG9uXzEgPSBvbjtcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUkMShzdHJpbmcsIGV4Y2x1ZGUsIGtlZXBFc2NhcGVkKSB7XG4gIHZhciBpLCBsLCBjb2RlLCBuZXh0Q29kZSwgY2FjaGUsXG4gICAgICByZXN1bHQgPSAnJztcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZW5jb2RlKHN0cmluZywga2VlcEVzY2FwZWQpXG4gICAga2VlcEVzY2FwZWQgID0gZXhjbHVkZTtcbiAgICBleGNsdWRlID0gZW5jb2RlJDEuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBrZWVwRXNjYXBlZCA9IHRydWU7XG4gIH1cblxuICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUgPT09IDB4MjUgLyogJSAqLyAmJiBpICsgMiA8IGwpIHtcbiAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoaSwgaSArIDMpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICByZXN1bHQgKz0gY2FjaGVbY29kZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcbiAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REJGRiAmJiBpICsgMSA8IGwpIHtcbiAgICAgICAgbmV4dENvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgIGlmIChuZXh0Q29kZSA+PSAweERDMDAgJiYgbmV4dENvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0gKyBzdHJpbmdbaSArIDFdKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmVuY29kZSQxLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlJDEuY29tcG9uZW50Q2hhcnMgPSBcIi1fLiF+KicoKVwiO1xuXG5cbnZhciBlbmNvZGVfMSA9IGVuY29kZSQxO1xuXG52YXIgbGliID0ge307XG5cbnZhciBkZWNvZGUgPSB7fTtcblxudmFyIEFhY3V0ZSQxID0gXCLDgVwiO1xudmFyIGFhY3V0ZSQxID0gXCLDoVwiO1xudmFyIEFicmV2ZSA9IFwixIJcIjtcbnZhciBhYnJldmUgPSBcIsSDXCI7XG52YXIgYWMgPSBcIuKIvlwiO1xudmFyIGFjZCA9IFwi4oi/XCI7XG52YXIgYWNFID0gXCLiiL7Ms1wiO1xudmFyIEFjaXJjJDEgPSBcIsOCXCI7XG52YXIgYWNpcmMkMSA9IFwiw6JcIjtcbnZhciBhY3V0ZSQxID0gXCLCtFwiO1xudmFyIEFjeSA9IFwi0JBcIjtcbnZhciBhY3kgPSBcItCwXCI7XG52YXIgQUVsaWckMSA9IFwiw4ZcIjtcbnZhciBhZWxpZyQxID0gXCLDplwiO1xudmFyIGFmID0gXCLigaFcIjtcbnZhciBBZnIgPSBcIvCdlIRcIjtcbnZhciBhZnIgPSBcIvCdlJ5cIjtcbnZhciBBZ3JhdmUkMSA9IFwiw4BcIjtcbnZhciBhZ3JhdmUkMSA9IFwiw6BcIjtcbnZhciBhbGVmc3ltID0gXCLihLVcIjtcbnZhciBhbGVwaCA9IFwi4oS1XCI7XG52YXIgQWxwaGEgPSBcIs6RXCI7XG52YXIgYWxwaGEgPSBcIs6xXCI7XG52YXIgQW1hY3IgPSBcIsSAXCI7XG52YXIgYW1hY3IgPSBcIsSBXCI7XG52YXIgYW1hbGcgPSBcIuKov1wiO1xudmFyIGFtcCQyID0gXCImXCI7XG52YXIgQU1QJDEgPSBcIiZcIjtcbnZhciBhbmRhbmQgPSBcIuKplVwiO1xudmFyIEFuZCA9IFwi4qmTXCI7XG52YXIgYW5kID0gXCLiiKdcIjtcbnZhciBhbmRkID0gXCLiqZxcIjtcbnZhciBhbmRzbG9wZSA9IFwi4qmYXCI7XG52YXIgYW5kdiA9IFwi4qmaXCI7XG52YXIgYW5nID0gXCLiiKBcIjtcbnZhciBhbmdlID0gXCLipqRcIjtcbnZhciBhbmdsZSA9IFwi4oigXCI7XG52YXIgYW5nbXNkYWEgPSBcIuKmqFwiO1xudmFyIGFuZ21zZGFiID0gXCLipqlcIjtcbnZhciBhbmdtc2RhYyA9IFwi4qaqXCI7XG52YXIgYW5nbXNkYWQgPSBcIuKmq1wiO1xudmFyIGFuZ21zZGFlID0gXCLipqxcIjtcbnZhciBhbmdtc2RhZiA9IFwi4qatXCI7XG52YXIgYW5nbXNkYWcgPSBcIuKmrlwiO1xudmFyIGFuZ21zZGFoID0gXCLipq9cIjtcbnZhciBhbmdtc2QgPSBcIuKIoVwiO1xudmFyIGFuZ3J0ID0gXCLiiJ9cIjtcbnZhciBhbmdydHZiID0gXCLiir5cIjtcbnZhciBhbmdydHZiZCA9IFwi4qadXCI7XG52YXIgYW5nc3BoID0gXCLiiKJcIjtcbnZhciBhbmdzdCA9IFwiw4VcIjtcbnZhciBhbmd6YXJyID0gXCLijbxcIjtcbnZhciBBb2dvbiA9IFwixIRcIjtcbnZhciBhb2dvbiA9IFwixIVcIjtcbnZhciBBb3BmID0gXCLwnZS4XCI7XG52YXIgYW9wZiA9IFwi8J2VklwiO1xudmFyIGFwYWNpciA9IFwi4qmvXCI7XG52YXIgYXAgPSBcIuKJiFwiO1xudmFyIGFwRSA9IFwi4qmwXCI7XG52YXIgYXBlID0gXCLiiYpcIjtcbnZhciBhcGlkID0gXCLiiYtcIjtcbnZhciBhcG9zJDEgPSBcIidcIjtcbnZhciBBcHBseUZ1bmN0aW9uID0gXCLigaFcIjtcbnZhciBhcHByb3ggPSBcIuKJiFwiO1xudmFyIGFwcHJveGVxID0gXCLiiYpcIjtcbnZhciBBcmluZyQxID0gXCLDhVwiO1xudmFyIGFyaW5nJDEgPSBcIsOlXCI7XG52YXIgQXNjciA9IFwi8J2SnFwiO1xudmFyIGFzY3IgPSBcIvCdkrZcIjtcbnZhciBBc3NpZ24gPSBcIuKJlFwiO1xudmFyIGFzdCA9IFwiKlwiO1xudmFyIGFzeW1wID0gXCLiiYhcIjtcbnZhciBhc3ltcGVxID0gXCLiiY1cIjtcbnZhciBBdGlsZGUkMSA9IFwiw4NcIjtcbnZhciBhdGlsZGUkMSA9IFwiw6NcIjtcbnZhciBBdW1sJDEgPSBcIsOEXCI7XG52YXIgYXVtbCQxID0gXCLDpFwiO1xudmFyIGF3Y29uaW50ID0gXCLiiLNcIjtcbnZhciBhd2ludCA9IFwi4qiRXCI7XG52YXIgYmFja2NvbmcgPSBcIuKJjFwiO1xudmFyIGJhY2tlcHNpbG9uID0gXCLPtlwiO1xudmFyIGJhY2twcmltZSA9IFwi4oC1XCI7XG52YXIgYmFja3NpbSA9IFwi4oi9XCI7XG52YXIgYmFja3NpbWVxID0gXCLii41cIjtcbnZhciBCYWNrc2xhc2ggPSBcIuKIllwiO1xudmFyIEJhcnYgPSBcIuKrp1wiO1xudmFyIGJhcnZlZSA9IFwi4oq9XCI7XG52YXIgYmFyd2VkID0gXCLijIVcIjtcbnZhciBCYXJ3ZWQgPSBcIuKMhlwiO1xudmFyIGJhcndlZGdlID0gXCLijIVcIjtcbnZhciBiYnJrID0gXCLijrVcIjtcbnZhciBiYnJrdGJyayA9IFwi4o62XCI7XG52YXIgYmNvbmcgPSBcIuKJjFwiO1xudmFyIEJjeSA9IFwi0JFcIjtcbnZhciBiY3kgPSBcItCxXCI7XG52YXIgYmRxdW8gPSBcIuKAnlwiO1xudmFyIGJlY2F1cyA9IFwi4oi1XCI7XG52YXIgYmVjYXVzZSA9IFwi4oi1XCI7XG52YXIgQmVjYXVzZSA9IFwi4oi1XCI7XG52YXIgYmVtcHR5diA9IFwi4qawXCI7XG52YXIgYmVwc2kgPSBcIs+2XCI7XG52YXIgYmVybm91ID0gXCLihKxcIjtcbnZhciBCZXJub3VsbGlzID0gXCLihKxcIjtcbnZhciBCZXRhID0gXCLOklwiO1xudmFyIGJldGEgPSBcIs6yXCI7XG52YXIgYmV0aCA9IFwi4oS2XCI7XG52YXIgYmV0d2VlbiA9IFwi4omsXCI7XG52YXIgQmZyID0gXCLwnZSFXCI7XG52YXIgYmZyID0gXCLwnZSfXCI7XG52YXIgYmlnY2FwID0gXCLii4JcIjtcbnZhciBiaWdjaXJjID0gXCLil69cIjtcbnZhciBiaWdjdXAgPSBcIuKLg1wiO1xudmFyIGJpZ29kb3QgPSBcIuKogFwiO1xudmFyIGJpZ29wbHVzID0gXCLiqIFcIjtcbnZhciBiaWdvdGltZXMgPSBcIuKoglwiO1xudmFyIGJpZ3NxY3VwID0gXCLiqIZcIjtcbnZhciBiaWdzdGFyID0gXCLimIVcIjtcbnZhciBiaWd0cmlhbmdsZWRvd24gPSBcIuKWvVwiO1xudmFyIGJpZ3RyaWFuZ2xldXAgPSBcIuKWs1wiO1xudmFyIGJpZ3VwbHVzID0gXCLiqIRcIjtcbnZhciBiaWd2ZWUgPSBcIuKLgVwiO1xudmFyIGJpZ3dlZGdlID0gXCLii4BcIjtcbnZhciBia2Fyb3cgPSBcIuKkjVwiO1xudmFyIGJsYWNrbG96ZW5nZSA9IFwi4qerXCI7XG52YXIgYmxhY2tzcXVhcmUgPSBcIuKWqlwiO1xudmFyIGJsYWNrdHJpYW5nbGUgPSBcIuKWtFwiO1xudmFyIGJsYWNrdHJpYW5nbGVkb3duID0gXCLilr5cIjtcbnZhciBibGFja3RyaWFuZ2xlbGVmdCA9IFwi4peCXCI7XG52YXIgYmxhY2t0cmlhbmdsZXJpZ2h0ID0gXCLilrhcIjtcbnZhciBibGFuayA9IFwi4pCjXCI7XG52YXIgYmxrMTIgPSBcIuKWklwiO1xudmFyIGJsazE0ID0gXCLilpFcIjtcbnZhciBibGszNCA9IFwi4paTXCI7XG52YXIgYmxvY2sgPSBcIuKWiFwiO1xudmFyIGJuZSA9IFwiPeKDpVwiO1xudmFyIGJuZXF1aXYgPSBcIuKJoeKDpVwiO1xudmFyIGJOb3QgPSBcIuKrrVwiO1xudmFyIGJub3QgPSBcIuKMkFwiO1xudmFyIEJvcGYgPSBcIvCdlLlcIjtcbnZhciBib3BmID0gXCLwnZWTXCI7XG52YXIgYm90ID0gXCLiiqVcIjtcbnZhciBib3R0b20gPSBcIuKKpVwiO1xudmFyIGJvd3RpZSA9IFwi4ouIXCI7XG52YXIgYm94Ym94ID0gXCLip4lcIjtcbnZhciBib3hkbCA9IFwi4pSQXCI7XG52YXIgYm94ZEwgPSBcIuKVlVwiO1xudmFyIGJveERsID0gXCLilZZcIjtcbnZhciBib3hETCA9IFwi4pWXXCI7XG52YXIgYm94ZHIgPSBcIuKUjFwiO1xudmFyIGJveGRSID0gXCLilZJcIjtcbnZhciBib3hEciA9IFwi4pWTXCI7XG52YXIgYm94RFIgPSBcIuKVlFwiO1xudmFyIGJveGggPSBcIuKUgFwiO1xudmFyIGJveEggPSBcIuKVkFwiO1xudmFyIGJveGhkID0gXCLilKxcIjtcbnZhciBib3hIZCA9IFwi4pWkXCI7XG52YXIgYm94aEQgPSBcIuKVpVwiO1xudmFyIGJveEhEID0gXCLilaZcIjtcbnZhciBib3hodSA9IFwi4pS0XCI7XG52YXIgYm94SHUgPSBcIuKVp1wiO1xudmFyIGJveGhVID0gXCLilahcIjtcbnZhciBib3hIVSA9IFwi4pWpXCI7XG52YXIgYm94bWludXMgPSBcIuKKn1wiO1xudmFyIGJveHBsdXMgPSBcIuKKnlwiO1xudmFyIGJveHRpbWVzID0gXCLiiqBcIjtcbnZhciBib3h1bCA9IFwi4pSYXCI7XG52YXIgYm94dUwgPSBcIuKVm1wiO1xudmFyIGJveFVsID0gXCLilZxcIjtcbnZhciBib3hVTCA9IFwi4pWdXCI7XG52YXIgYm94dXIgPSBcIuKUlFwiO1xudmFyIGJveHVSID0gXCLilZhcIjtcbnZhciBib3hVciA9IFwi4pWZXCI7XG52YXIgYm94VVIgPSBcIuKVmlwiO1xudmFyIGJveHYgPSBcIuKUglwiO1xudmFyIGJveFYgPSBcIuKVkVwiO1xudmFyIGJveHZoID0gXCLilLxcIjtcbnZhciBib3h2SCA9IFwi4pWqXCI7XG52YXIgYm94VmggPSBcIuKVq1wiO1xudmFyIGJveFZIID0gXCLilaxcIjtcbnZhciBib3h2bCA9IFwi4pSkXCI7XG52YXIgYm94dkwgPSBcIuKVoVwiO1xudmFyIGJveFZsID0gXCLilaJcIjtcbnZhciBib3hWTCA9IFwi4pWjXCI7XG52YXIgYm94dnIgPSBcIuKUnFwiO1xudmFyIGJveHZSID0gXCLilZ5cIjtcbnZhciBib3hWciA9IFwi4pWfXCI7XG52YXIgYm94VlIgPSBcIuKVoFwiO1xudmFyIGJwcmltZSA9IFwi4oC1XCI7XG52YXIgYnJldmUgPSBcIsuYXCI7XG52YXIgQnJldmUgPSBcIsuYXCI7XG52YXIgYnJ2YmFyJDEgPSBcIsKmXCI7XG52YXIgYnNjciA9IFwi8J2St1wiO1xudmFyIEJzY3IgPSBcIuKErFwiO1xudmFyIGJzZW1pID0gXCLigY9cIjtcbnZhciBic2ltID0gXCLiiL1cIjtcbnZhciBic2ltZSA9IFwi4ouNXCI7XG52YXIgYnNvbGIgPSBcIuKnhVwiO1xudmFyIGJzb2wgPSBcIlxcXFxcIjtcbnZhciBic29saHN1YiA9IFwi4p+IXCI7XG52YXIgYnVsbCA9IFwi4oCiXCI7XG52YXIgYnVsbGV0ID0gXCLigKJcIjtcbnZhciBidW1wID0gXCLiiY5cIjtcbnZhciBidW1wRSA9IFwi4qquXCI7XG52YXIgYnVtcGUgPSBcIuKJj1wiO1xudmFyIEJ1bXBlcSA9IFwi4omOXCI7XG52YXIgYnVtcGVxID0gXCLiiY9cIjtcbnZhciBDYWN1dGUgPSBcIsSGXCI7XG52YXIgY2FjdXRlID0gXCLEh1wiO1xudmFyIGNhcGFuZCA9IFwi4qmEXCI7XG52YXIgY2FwYnJjdXAgPSBcIuKpiVwiO1xudmFyIGNhcGNhcCA9IFwi4qmLXCI7XG52YXIgY2FwID0gXCLiiKlcIjtcbnZhciBDYXAgPSBcIuKLklwiO1xudmFyIGNhcGN1cCA9IFwi4qmHXCI7XG52YXIgY2FwZG90ID0gXCLiqYBcIjtcbnZhciBDYXBpdGFsRGlmZmVyZW50aWFsRCA9IFwi4oWFXCI7XG52YXIgY2FwcyA9IFwi4oip77iAXCI7XG52YXIgY2FyZXQgPSBcIuKBgVwiO1xudmFyIGNhcm9uID0gXCLLh1wiO1xudmFyIENheWxleXMgPSBcIuKErVwiO1xudmFyIGNjYXBzID0gXCLiqY1cIjtcbnZhciBDY2Fyb24gPSBcIsSMXCI7XG52YXIgY2Nhcm9uID0gXCLEjVwiO1xudmFyIENjZWRpbCQxID0gXCLDh1wiO1xudmFyIGNjZWRpbCQxID0gXCLDp1wiO1xudmFyIENjaXJjID0gXCLEiFwiO1xudmFyIGNjaXJjID0gXCLEiVwiO1xudmFyIENjb25pbnQgPSBcIuKIsFwiO1xudmFyIGNjdXBzID0gXCLiqYxcIjtcbnZhciBjY3Vwc3NtID0gXCLiqZBcIjtcbnZhciBDZG90ID0gXCLEilwiO1xudmFyIGNkb3QgPSBcIsSLXCI7XG52YXIgY2VkaWwkMSA9IFwiwrhcIjtcbnZhciBDZWRpbGxhID0gXCLCuFwiO1xudmFyIGNlbXB0eXYgPSBcIuKmslwiO1xudmFyIGNlbnQkMSA9IFwiwqJcIjtcbnZhciBjZW50ZXJkb3QgPSBcIsK3XCI7XG52YXIgQ2VudGVyRG90ID0gXCLCt1wiO1xudmFyIGNmciA9IFwi8J2UoFwiO1xudmFyIENmciA9IFwi4oStXCI7XG52YXIgQ0hjeSA9IFwi0KdcIjtcbnZhciBjaGN5ID0gXCLRh1wiO1xudmFyIGNoZWNrID0gXCLinJNcIjtcbnZhciBjaGVja21hcmsgPSBcIuKck1wiO1xudmFyIENoaSA9IFwizqdcIjtcbnZhciBjaGkgPSBcIs+HXCI7XG52YXIgY2lyYyA9IFwiy4ZcIjtcbnZhciBjaXJjZXEgPSBcIuKJl1wiO1xudmFyIGNpcmNsZWFycm93bGVmdCA9IFwi4oa6XCI7XG52YXIgY2lyY2xlYXJyb3dyaWdodCA9IFwi4oa7XCI7XG52YXIgY2lyY2xlZGFzdCA9IFwi4oqbXCI7XG52YXIgY2lyY2xlZGNpcmMgPSBcIuKKmlwiO1xudmFyIGNpcmNsZWRkYXNoID0gXCLiip1cIjtcbnZhciBDaXJjbGVEb3QgPSBcIuKKmVwiO1xudmFyIGNpcmNsZWRSID0gXCLCrlwiO1xudmFyIGNpcmNsZWRTID0gXCLik4hcIjtcbnZhciBDaXJjbGVNaW51cyA9IFwi4oqWXCI7XG52YXIgQ2lyY2xlUGx1cyA9IFwi4oqVXCI7XG52YXIgQ2lyY2xlVGltZXMgPSBcIuKKl1wiO1xudmFyIGNpciA9IFwi4peLXCI7XG52YXIgY2lyRSA9IFwi4qeDXCI7XG52YXIgY2lyZSA9IFwi4omXXCI7XG52YXIgY2lyZm5pbnQgPSBcIuKokFwiO1xudmFyIGNpcm1pZCA9IFwi4quvXCI7XG52YXIgY2lyc2NpciA9IFwi4qeCXCI7XG52YXIgQ2xvY2t3aXNlQ29udG91ckludGVncmFsID0gXCLiiLJcIjtcbnZhciBDbG9zZUN1cmx5RG91YmxlUXVvdGUgPSBcIuKAnVwiO1xudmFyIENsb3NlQ3VybHlRdW90ZSA9IFwi4oCZXCI7XG52YXIgY2x1YnMgPSBcIuKZo1wiO1xudmFyIGNsdWJzdWl0ID0gXCLimaNcIjtcbnZhciBjb2xvbiA9IFwiOlwiO1xudmFyIENvbG9uID0gXCLiiLdcIjtcbnZhciBDb2xvbmUgPSBcIuKptFwiO1xudmFyIGNvbG9uZSA9IFwi4omUXCI7XG52YXIgY29sb25lcSA9IFwi4omUXCI7XG52YXIgY29tbWEgPSBcIixcIjtcbnZhciBjb21tYXQgPSBcIkBcIjtcbnZhciBjb21wID0gXCLiiIFcIjtcbnZhciBjb21wZm4gPSBcIuKImFwiO1xudmFyIGNvbXBsZW1lbnQgPSBcIuKIgVwiO1xudmFyIGNvbXBsZXhlcyA9IFwi4oSCXCI7XG52YXIgY29uZyA9IFwi4omFXCI7XG52YXIgY29uZ2RvdCA9IFwi4qmtXCI7XG52YXIgQ29uZ3J1ZW50ID0gXCLiiaFcIjtcbnZhciBjb25pbnQgPSBcIuKIrlwiO1xudmFyIENvbmludCA9IFwi4oivXCI7XG52YXIgQ29udG91ckludGVncmFsID0gXCLiiK5cIjtcbnZhciBjb3BmID0gXCLwnZWUXCI7XG52YXIgQ29wZiA9IFwi4oSCXCI7XG52YXIgY29wcm9kID0gXCLiiJBcIjtcbnZhciBDb3Byb2R1Y3QgPSBcIuKIkFwiO1xudmFyIGNvcHkkMSA9IFwiwqlcIjtcbnZhciBDT1BZJDEgPSBcIsKpXCI7XG52YXIgY29weXNyID0gXCLihJdcIjtcbnZhciBDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsID0gXCLiiLNcIjtcbnZhciBjcmFyciA9IFwi4oa1XCI7XG52YXIgY3Jvc3MgPSBcIuKcl1wiO1xudmFyIENyb3NzID0gXCLiqK9cIjtcbnZhciBDc2NyID0gXCLwnZKeXCI7XG52YXIgY3NjciA9IFwi8J2SuFwiO1xudmFyIGNzdWIgPSBcIuKrj1wiO1xudmFyIGNzdWJlID0gXCLiq5FcIjtcbnZhciBjc3VwID0gXCLiq5BcIjtcbnZhciBjc3VwZSA9IFwi4quSXCI7XG52YXIgY3Rkb3QgPSBcIuKLr1wiO1xudmFyIGN1ZGFycmwgPSBcIuKkuFwiO1xudmFyIGN1ZGFycnIgPSBcIuKktVwiO1xudmFyIGN1ZXByID0gXCLii55cIjtcbnZhciBjdWVzYyA9IFwi4oufXCI7XG52YXIgY3VsYXJyID0gXCLihrZcIjtcbnZhciBjdWxhcnJwID0gXCLipL1cIjtcbnZhciBjdXBicmNhcCA9IFwi4qmIXCI7XG52YXIgY3VwY2FwID0gXCLiqYZcIjtcbnZhciBDdXBDYXAgPSBcIuKJjVwiO1xudmFyIGN1cCA9IFwi4oiqXCI7XG52YXIgQ3VwID0gXCLii5NcIjtcbnZhciBjdXBjdXAgPSBcIuKpilwiO1xudmFyIGN1cGRvdCA9IFwi4oqNXCI7XG52YXIgY3Vwb3IgPSBcIuKphVwiO1xudmFyIGN1cHMgPSBcIuKIqu+4gFwiO1xudmFyIGN1cmFyciA9IFwi4oa3XCI7XG52YXIgY3VyYXJybSA9IFwi4qS8XCI7XG52YXIgY3VybHllcXByZWMgPSBcIuKLnlwiO1xudmFyIGN1cmx5ZXFzdWNjID0gXCLii59cIjtcbnZhciBjdXJseXZlZSA9IFwi4ouOXCI7XG52YXIgY3VybHl3ZWRnZSA9IFwi4ouPXCI7XG52YXIgY3VycmVuJDEgPSBcIsKkXCI7XG52YXIgY3VydmVhcnJvd2xlZnQgPSBcIuKGtlwiO1xudmFyIGN1cnZlYXJyb3dyaWdodCA9IFwi4oa3XCI7XG52YXIgY3V2ZWUgPSBcIuKLjlwiO1xudmFyIGN1d2VkID0gXCLii49cIjtcbnZhciBjd2NvbmludCA9IFwi4oiyXCI7XG52YXIgY3dpbnQgPSBcIuKIsVwiO1xudmFyIGN5bGN0eSA9IFwi4oytXCI7XG52YXIgZGFnZ2VyID0gXCLigKBcIjtcbnZhciBEYWdnZXIgPSBcIuKAoVwiO1xudmFyIGRhbGV0aCA9IFwi4oS4XCI7XG52YXIgZGFyciA9IFwi4oaTXCI7XG52YXIgRGFyciA9IFwi4oahXCI7XG52YXIgZEFyciA9IFwi4oeTXCI7XG52YXIgZGFzaCA9IFwi4oCQXCI7XG52YXIgRGFzaHYgPSBcIuKrpFwiO1xudmFyIGRhc2h2ID0gXCLiiqNcIjtcbnZhciBkYmthcm93ID0gXCLipI9cIjtcbnZhciBkYmxhYyA9IFwiy51cIjtcbnZhciBEY2Fyb24gPSBcIsSOXCI7XG52YXIgZGNhcm9uID0gXCLEj1wiO1xudmFyIERjeSA9IFwi0JRcIjtcbnZhciBkY3kgPSBcItC0XCI7XG52YXIgZGRhZ2dlciA9IFwi4oChXCI7XG52YXIgZGRhcnIgPSBcIuKHilwiO1xudmFyIEREID0gXCLihYVcIjtcbnZhciBkZCA9IFwi4oWGXCI7XG52YXIgRERvdHJhaGQgPSBcIuKkkVwiO1xudmFyIGRkb3RzZXEgPSBcIuKpt1wiO1xudmFyIGRlZyQxID0gXCLCsFwiO1xudmFyIERlbCA9IFwi4oiHXCI7XG52YXIgRGVsdGEgPSBcIs6UXCI7XG52YXIgZGVsdGEgPSBcIs60XCI7XG52YXIgZGVtcHR5diA9IFwi4qaxXCI7XG52YXIgZGZpc2h0ID0gXCLipb9cIjtcbnZhciBEZnIgPSBcIvCdlIdcIjtcbnZhciBkZnIgPSBcIvCdlKFcIjtcbnZhciBkSGFyID0gXCLipaVcIjtcbnZhciBkaGFybCA9IFwi4oeDXCI7XG52YXIgZGhhcnIgPSBcIuKHglwiO1xudmFyIERpYWNyaXRpY2FsQWN1dGUgPSBcIsK0XCI7XG52YXIgRGlhY3JpdGljYWxEb3QgPSBcIsuZXCI7XG52YXIgRGlhY3JpdGljYWxEb3VibGVBY3V0ZSA9IFwiy51cIjtcbnZhciBEaWFjcml0aWNhbEdyYXZlID0gXCJgXCI7XG52YXIgRGlhY3JpdGljYWxUaWxkZSA9IFwiy5xcIjtcbnZhciBkaWFtID0gXCLii4RcIjtcbnZhciBkaWFtb25kID0gXCLii4RcIjtcbnZhciBEaWFtb25kID0gXCLii4RcIjtcbnZhciBkaWFtb25kc3VpdCA9IFwi4pmmXCI7XG52YXIgZGlhbXMgPSBcIuKZplwiO1xudmFyIGRpZSA9IFwiwqhcIjtcbnZhciBEaWZmZXJlbnRpYWxEID0gXCLihYZcIjtcbnZhciBkaWdhbW1hID0gXCLPnVwiO1xudmFyIGRpc2luID0gXCLii7JcIjtcbnZhciBkaXYgPSBcIsO3XCI7XG52YXIgZGl2aWRlJDEgPSBcIsO3XCI7XG52YXIgZGl2aWRlb250aW1lcyA9IFwi4ouHXCI7XG52YXIgZGl2b254ID0gXCLii4dcIjtcbnZhciBESmN5ID0gXCLQglwiO1xudmFyIGRqY3kgPSBcItGSXCI7XG52YXIgZGxjb3JuID0gXCLijJ5cIjtcbnZhciBkbGNyb3AgPSBcIuKMjVwiO1xudmFyIGRvbGxhciA9IFwiJFwiO1xudmFyIERvcGYgPSBcIvCdlLtcIjtcbnZhciBkb3BmID0gXCLwnZWVXCI7XG52YXIgRG90ID0gXCLCqFwiO1xudmFyIGRvdCA9IFwiy5lcIjtcbnZhciBEb3REb3QgPSBcIuKDnFwiO1xudmFyIGRvdGVxID0gXCLiiZBcIjtcbnZhciBkb3RlcWRvdCA9IFwi4omRXCI7XG52YXIgRG90RXF1YWwgPSBcIuKJkFwiO1xudmFyIGRvdG1pbnVzID0gXCLiiLhcIjtcbnZhciBkb3RwbHVzID0gXCLiiJRcIjtcbnZhciBkb3RzcXVhcmUgPSBcIuKKoVwiO1xudmFyIGRvdWJsZWJhcndlZGdlID0gXCLijIZcIjtcbnZhciBEb3VibGVDb250b3VySW50ZWdyYWwgPSBcIuKIr1wiO1xudmFyIERvdWJsZURvdCA9IFwiwqhcIjtcbnZhciBEb3VibGVEb3duQXJyb3cgPSBcIuKHk1wiO1xudmFyIERvdWJsZUxlZnRBcnJvdyA9IFwi4oeQXCI7XG52YXIgRG91YmxlTGVmdFJpZ2h0QXJyb3cgPSBcIuKHlFwiO1xudmFyIERvdWJsZUxlZnRUZWUgPSBcIuKrpFwiO1xudmFyIERvdWJsZUxvbmdMZWZ0QXJyb3cgPSBcIuKfuFwiO1xudmFyIERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyA9IFwi4p+6XCI7XG52YXIgRG91YmxlTG9uZ1JpZ2h0QXJyb3cgPSBcIuKfuVwiO1xudmFyIERvdWJsZVJpZ2h0QXJyb3cgPSBcIuKHklwiO1xudmFyIERvdWJsZVJpZ2h0VGVlID0gXCLiiqhcIjtcbnZhciBEb3VibGVVcEFycm93ID0gXCLih5FcIjtcbnZhciBEb3VibGVVcERvd25BcnJvdyA9IFwi4oeVXCI7XG52YXIgRG91YmxlVmVydGljYWxCYXIgPSBcIuKIpVwiO1xudmFyIERvd25BcnJvd0JhciA9IFwi4qSTXCI7XG52YXIgZG93bmFycm93ID0gXCLihpNcIjtcbnZhciBEb3duQXJyb3cgPSBcIuKGk1wiO1xudmFyIERvd25hcnJvdyA9IFwi4oeTXCI7XG52YXIgRG93bkFycm93VXBBcnJvdyA9IFwi4oe1XCI7XG52YXIgRG93bkJyZXZlID0gXCLMkVwiO1xudmFyIGRvd25kb3duYXJyb3dzID0gXCLih4pcIjtcbnZhciBkb3duaGFycG9vbmxlZnQgPSBcIuKHg1wiO1xudmFyIGRvd25oYXJwb29ucmlnaHQgPSBcIuKHglwiO1xudmFyIERvd25MZWZ0UmlnaHRWZWN0b3IgPSBcIuKlkFwiO1xudmFyIERvd25MZWZ0VGVlVmVjdG9yID0gXCLipZ5cIjtcbnZhciBEb3duTGVmdFZlY3RvckJhciA9IFwi4qWWXCI7XG52YXIgRG93bkxlZnRWZWN0b3IgPSBcIuKGvVwiO1xudmFyIERvd25SaWdodFRlZVZlY3RvciA9IFwi4qWfXCI7XG52YXIgRG93blJpZ2h0VmVjdG9yQmFyID0gXCLipZdcIjtcbnZhciBEb3duUmlnaHRWZWN0b3IgPSBcIuKHgVwiO1xudmFyIERvd25UZWVBcnJvdyA9IFwi4oanXCI7XG52YXIgRG93blRlZSA9IFwi4oqkXCI7XG52YXIgZHJia2Fyb3cgPSBcIuKkkFwiO1xudmFyIGRyY29ybiA9IFwi4oyfXCI7XG52YXIgZHJjcm9wID0gXCLijIxcIjtcbnZhciBEc2NyID0gXCLwnZKfXCI7XG52YXIgZHNjciA9IFwi8J2SuVwiO1xudmFyIERTY3kgPSBcItCFXCI7XG52YXIgZHNjeSA9IFwi0ZVcIjtcbnZhciBkc29sID0gXCLip7ZcIjtcbnZhciBEc3Ryb2sgPSBcIsSQXCI7XG52YXIgZHN0cm9rID0gXCLEkVwiO1xudmFyIGR0ZG90ID0gXCLii7FcIjtcbnZhciBkdHJpID0gXCLilr9cIjtcbnZhciBkdHJpZiA9IFwi4pa+XCI7XG52YXIgZHVhcnIgPSBcIuKHtVwiO1xudmFyIGR1aGFyID0gXCLipa9cIjtcbnZhciBkd2FuZ2xlID0gXCLipqZcIjtcbnZhciBEWmN5ID0gXCLQj1wiO1xudmFyIGR6Y3kgPSBcItGfXCI7XG52YXIgZHppZ3JhcnIgPSBcIuKfv1wiO1xudmFyIEVhY3V0ZSQxID0gXCLDiVwiO1xudmFyIGVhY3V0ZSQxID0gXCLDqVwiO1xudmFyIGVhc3RlciA9IFwi4qmuXCI7XG52YXIgRWNhcm9uID0gXCLEmlwiO1xudmFyIGVjYXJvbiA9IFwixJtcIjtcbnZhciBFY2lyYyQxID0gXCLDilwiO1xudmFyIGVjaXJjJDEgPSBcIsOqXCI7XG52YXIgZWNpciA9IFwi4omWXCI7XG52YXIgZWNvbG9uID0gXCLiiZVcIjtcbnZhciBFY3kgPSBcItCtXCI7XG52YXIgZWN5ID0gXCLRjVwiO1xudmFyIGVERG90ID0gXCLiqbdcIjtcbnZhciBFZG90ID0gXCLEllwiO1xudmFyIGVkb3QgPSBcIsSXXCI7XG52YXIgZURvdCA9IFwi4omRXCI7XG52YXIgZWUgPSBcIuKFh1wiO1xudmFyIGVmRG90ID0gXCLiiZJcIjtcbnZhciBFZnIgPSBcIvCdlIhcIjtcbnZhciBlZnIgPSBcIvCdlKJcIjtcbnZhciBlZyA9IFwi4qqaXCI7XG52YXIgRWdyYXZlJDEgPSBcIsOIXCI7XG52YXIgZWdyYXZlJDEgPSBcIsOoXCI7XG52YXIgZWdzID0gXCLiqpZcIjtcbnZhciBlZ3Nkb3QgPSBcIuKqmFwiO1xudmFyIGVsID0gXCLiqplcIjtcbnZhciBFbGVtZW50JDEgPSBcIuKIiFwiO1xudmFyIGVsaW50ZXJzID0gXCLij6dcIjtcbnZhciBlbGwgPSBcIuKEk1wiO1xudmFyIGVscyA9IFwi4qqVXCI7XG52YXIgZWxzZG90ID0gXCLiqpdcIjtcbnZhciBFbWFjciA9IFwixJJcIjtcbnZhciBlbWFjciA9IFwixJNcIjtcbnZhciBlbXB0eSA9IFwi4oiFXCI7XG52YXIgZW1wdHlzZXQgPSBcIuKIhVwiO1xudmFyIEVtcHR5U21hbGxTcXVhcmUgPSBcIuKXu1wiO1xudmFyIGVtcHR5diA9IFwi4oiFXCI7XG52YXIgRW1wdHlWZXJ5U21hbGxTcXVhcmUgPSBcIuKWq1wiO1xudmFyIGVtc3AxMyA9IFwi4oCEXCI7XG52YXIgZW1zcDE0ID0gXCLigIVcIjtcbnZhciBlbXNwID0gXCLigINcIjtcbnZhciBFTkcgPSBcIsWKXCI7XG52YXIgZW5nID0gXCLFi1wiO1xudmFyIGVuc3AgPSBcIuKAglwiO1xudmFyIEVvZ29uID0gXCLEmFwiO1xudmFyIGVvZ29uID0gXCLEmVwiO1xudmFyIEVvcGYgPSBcIvCdlLxcIjtcbnZhciBlb3BmID0gXCLwnZWWXCI7XG52YXIgZXBhciA9IFwi4ouVXCI7XG52YXIgZXBhcnNsID0gXCLip6NcIjtcbnZhciBlcGx1cyA9IFwi4qmxXCI7XG52YXIgZXBzaSA9IFwizrVcIjtcbnZhciBFcHNpbG9uID0gXCLOlVwiO1xudmFyIGVwc2lsb24gPSBcIs61XCI7XG52YXIgZXBzaXYgPSBcIs+1XCI7XG52YXIgZXFjaXJjID0gXCLiiZZcIjtcbnZhciBlcWNvbG9uID0gXCLiiZVcIjtcbnZhciBlcXNpbSA9IFwi4omCXCI7XG52YXIgZXFzbGFudGd0ciA9IFwi4qqWXCI7XG52YXIgZXFzbGFudGxlc3MgPSBcIuKqlVwiO1xudmFyIEVxdWFsID0gXCLiqbVcIjtcbnZhciBlcXVhbHMgPSBcIj1cIjtcbnZhciBFcXVhbFRpbGRlID0gXCLiiYJcIjtcbnZhciBlcXVlc3QgPSBcIuKJn1wiO1xudmFyIEVxdWlsaWJyaXVtID0gXCLih4xcIjtcbnZhciBlcXVpdiA9IFwi4omhXCI7XG52YXIgZXF1aXZERCA9IFwi4qm4XCI7XG52YXIgZXF2cGFyc2wgPSBcIuKnpVwiO1xudmFyIGVyYXJyID0gXCLipbFcIjtcbnZhciBlckRvdCA9IFwi4omTXCI7XG52YXIgZXNjciA9IFwi4oSvXCI7XG52YXIgRXNjciA9IFwi4oSwXCI7XG52YXIgZXNkb3QgPSBcIuKJkFwiO1xudmFyIEVzaW0gPSBcIuKps1wiO1xudmFyIGVzaW0gPSBcIuKJglwiO1xudmFyIEV0YSA9IFwizpdcIjtcbnZhciBldGEgPSBcIs63XCI7XG52YXIgRVRIJDEgPSBcIsOQXCI7XG52YXIgZXRoJDEgPSBcIsOwXCI7XG52YXIgRXVtbCQxID0gXCLDi1wiO1xudmFyIGV1bWwkMSA9IFwiw6tcIjtcbnZhciBldXJvID0gXCLigqxcIjtcbnZhciBleGNsID0gXCIhXCI7XG52YXIgZXhpc3QgPSBcIuKIg1wiO1xudmFyIEV4aXN0cyA9IFwi4oiDXCI7XG52YXIgZXhwZWN0YXRpb24gPSBcIuKEsFwiO1xudmFyIGV4cG9uZW50aWFsZSA9IFwi4oWHXCI7XG52YXIgRXhwb25lbnRpYWxFID0gXCLihYdcIjtcbnZhciBmYWxsaW5nZG90c2VxID0gXCLiiZJcIjtcbnZhciBGY3kgPSBcItCkXCI7XG52YXIgZmN5ID0gXCLRhFwiO1xudmFyIGZlbWFsZSA9IFwi4pmAXCI7XG52YXIgZmZpbGlnID0gXCLvrINcIjtcbnZhciBmZmxpZyA9IFwi76yAXCI7XG52YXIgZmZsbGlnID0gXCLvrIRcIjtcbnZhciBGZnIgPSBcIvCdlIlcIjtcbnZhciBmZnIgPSBcIvCdlKNcIjtcbnZhciBmaWxpZyA9IFwi76yBXCI7XG52YXIgRmlsbGVkU21hbGxTcXVhcmUgPSBcIuKXvFwiO1xudmFyIEZpbGxlZFZlcnlTbWFsbFNxdWFyZSA9IFwi4paqXCI7XG52YXIgZmpsaWcgPSBcImZqXCI7XG52YXIgZmxhdCA9IFwi4pmtXCI7XG52YXIgZmxsaWcgPSBcIu+sglwiO1xudmFyIGZsdG5zID0gXCLilrFcIjtcbnZhciBmbm9mID0gXCLGklwiO1xudmFyIEZvcGYgPSBcIvCdlL1cIjtcbnZhciBmb3BmID0gXCLwnZWXXCI7XG52YXIgZm9yYWxsID0gXCLiiIBcIjtcbnZhciBGb3JBbGwgPSBcIuKIgFwiO1xudmFyIGZvcmsgPSBcIuKLlFwiO1xudmFyIGZvcmt2ID0gXCLiq5lcIjtcbnZhciBGb3VyaWVydHJmID0gXCLihLFcIjtcbnZhciBmcGFydGludCA9IFwi4qiNXCI7XG52YXIgZnJhYzEyJDEgPSBcIsK9XCI7XG52YXIgZnJhYzEzID0gXCLihZNcIjtcbnZhciBmcmFjMTQkMSA9IFwiwrxcIjtcbnZhciBmcmFjMTUgPSBcIuKFlVwiO1xudmFyIGZyYWMxNiA9IFwi4oWZXCI7XG52YXIgZnJhYzE4ID0gXCLihZtcIjtcbnZhciBmcmFjMjMgPSBcIuKFlFwiO1xudmFyIGZyYWMyNSA9IFwi4oWWXCI7XG52YXIgZnJhYzM0JDEgPSBcIsK+XCI7XG52YXIgZnJhYzM1ID0gXCLihZdcIjtcbnZhciBmcmFjMzggPSBcIuKFnFwiO1xudmFyIGZyYWM0NSA9IFwi4oWYXCI7XG52YXIgZnJhYzU2ID0gXCLihZpcIjtcbnZhciBmcmFjNTggPSBcIuKFnVwiO1xudmFyIGZyYWM3OCA9IFwi4oWeXCI7XG52YXIgZnJhc2wgPSBcIuKBhFwiO1xudmFyIGZyb3duID0gXCLijKJcIjtcbnZhciBmc2NyID0gXCLwnZK7XCI7XG52YXIgRnNjciA9IFwi4oSxXCI7XG52YXIgZ2FjdXRlID0gXCLHtVwiO1xudmFyIEdhbW1hID0gXCLOk1wiO1xudmFyIGdhbW1hID0gXCLOs1wiO1xudmFyIEdhbW1hZCA9IFwiz5xcIjtcbnZhciBnYW1tYWQgPSBcIs+dXCI7XG52YXIgZ2FwID0gXCLiqoZcIjtcbnZhciBHYnJldmUgPSBcIsSeXCI7XG52YXIgZ2JyZXZlID0gXCLEn1wiO1xudmFyIEdjZWRpbCA9IFwixKJcIjtcbnZhciBHY2lyYyA9IFwixJxcIjtcbnZhciBnY2lyYyA9IFwixJ1cIjtcbnZhciBHY3kgPSBcItCTXCI7XG52YXIgZ2N5ID0gXCLQs1wiO1xudmFyIEdkb3QgPSBcIsSgXCI7XG52YXIgZ2RvdCA9IFwixKFcIjtcbnZhciBnZSA9IFwi4omlXCI7XG52YXIgZ0UgPSBcIuKJp1wiO1xudmFyIGdFbCA9IFwi4qqMXCI7XG52YXIgZ2VsID0gXCLii5tcIjtcbnZhciBnZXEgPSBcIuKJpVwiO1xudmFyIGdlcXEgPSBcIuKJp1wiO1xudmFyIGdlcXNsYW50ID0gXCLiqb5cIjtcbnZhciBnZXNjYyA9IFwi4qqpXCI7XG52YXIgZ2VzID0gXCLiqb5cIjtcbnZhciBnZXNkb3QgPSBcIuKqgFwiO1xudmFyIGdlc2RvdG8gPSBcIuKqglwiO1xudmFyIGdlc2RvdG9sID0gXCLiqoRcIjtcbnZhciBnZXNsID0gXCLii5vvuIBcIjtcbnZhciBnZXNsZXMgPSBcIuKqlFwiO1xudmFyIEdmciA9IFwi8J2UilwiO1xudmFyIGdmciA9IFwi8J2UpFwiO1xudmFyIGdnID0gXCLiiatcIjtcbnZhciBHZyA9IFwi4ouZXCI7XG52YXIgZ2dnID0gXCLii5lcIjtcbnZhciBnaW1lbCA9IFwi4oS3XCI7XG52YXIgR0pjeSA9IFwi0INcIjtcbnZhciBnamN5ID0gXCLRk1wiO1xudmFyIGdsYSA9IFwi4qqlXCI7XG52YXIgZ2wgPSBcIuKJt1wiO1xudmFyIGdsRSA9IFwi4qqSXCI7XG52YXIgZ2xqID0gXCLiqqRcIjtcbnZhciBnbmFwID0gXCLiqopcIjtcbnZhciBnbmFwcHJveCA9IFwi4qqKXCI7XG52YXIgZ25lID0gXCLiqohcIjtcbnZhciBnbkUgPSBcIuKJqVwiO1xudmFyIGduZXEgPSBcIuKqiFwiO1xudmFyIGduZXFxID0gXCLiialcIjtcbnZhciBnbnNpbSA9IFwi4ounXCI7XG52YXIgR29wZiA9IFwi8J2UvlwiO1xudmFyIGdvcGYgPSBcIvCdlZhcIjtcbnZhciBncmF2ZSA9IFwiYFwiO1xudmFyIEdyZWF0ZXJFcXVhbCA9IFwi4omlXCI7XG52YXIgR3JlYXRlckVxdWFsTGVzcyA9IFwi4oubXCI7XG52YXIgR3JlYXRlckZ1bGxFcXVhbCA9IFwi4omnXCI7XG52YXIgR3JlYXRlckdyZWF0ZXIgPSBcIuKqolwiO1xudmFyIEdyZWF0ZXJMZXNzID0gXCLiibdcIjtcbnZhciBHcmVhdGVyU2xhbnRFcXVhbCA9IFwi4qm+XCI7XG52YXIgR3JlYXRlclRpbGRlID0gXCLiibNcIjtcbnZhciBHc2NyID0gXCLwnZKiXCI7XG52YXIgZ3NjciA9IFwi4oSKXCI7XG52YXIgZ3NpbSA9IFwi4omzXCI7XG52YXIgZ3NpbWUgPSBcIuKqjlwiO1xudmFyIGdzaW1sID0gXCLiqpBcIjtcbnZhciBndGNjID0gXCLiqqdcIjtcbnZhciBndGNpciA9IFwi4qm6XCI7XG52YXIgZ3QkMiA9IFwiPlwiO1xudmFyIEdUJDEgPSBcIj5cIjtcbnZhciBHdCA9IFwi4omrXCI7XG52YXIgZ3Rkb3QgPSBcIuKLl1wiO1xudmFyIGd0bFBhciA9IFwi4qaVXCI7XG52YXIgZ3RxdWVzdCA9IFwi4qm8XCI7XG52YXIgZ3RyYXBwcm94ID0gXCLiqoZcIjtcbnZhciBndHJhcnIgPSBcIuKluFwiO1xudmFyIGd0cmRvdCA9IFwi4ouXXCI7XG52YXIgZ3RyZXFsZXNzID0gXCLii5tcIjtcbnZhciBndHJlcXFsZXNzID0gXCLiqoxcIjtcbnZhciBndHJsZXNzID0gXCLiibdcIjtcbnZhciBndHJzaW0gPSBcIuKJs1wiO1xudmFyIGd2ZXJ0bmVxcSA9IFwi4omp77iAXCI7XG52YXIgZ3ZuRSA9IFwi4omp77iAXCI7XG52YXIgSGFjZWsgPSBcIsuHXCI7XG52YXIgaGFpcnNwID0gXCLigIpcIjtcbnZhciBoYWxmID0gXCLCvVwiO1xudmFyIGhhbWlsdCA9IFwi4oSLXCI7XG52YXIgSEFSRGN5ID0gXCLQqlwiO1xudmFyIGhhcmRjeSA9IFwi0YpcIjtcbnZhciBoYXJyY2lyID0gXCLipYhcIjtcbnZhciBoYXJyID0gXCLihpRcIjtcbnZhciBoQXJyID0gXCLih5RcIjtcbnZhciBoYXJydyA9IFwi4oatXCI7XG52YXIgSGF0ID0gXCJeXCI7XG52YXIgaGJhciA9IFwi4oSPXCI7XG52YXIgSGNpcmMgPSBcIsSkXCI7XG52YXIgaGNpcmMgPSBcIsSlXCI7XG52YXIgaGVhcnRzID0gXCLimaVcIjtcbnZhciBoZWFydHN1aXQgPSBcIuKZpVwiO1xudmFyIGhlbGxpcCA9IFwi4oCmXCI7XG52YXIgaGVyY29uID0gXCLiirlcIjtcbnZhciBoZnIgPSBcIvCdlKVcIjtcbnZhciBIZnIgPSBcIuKEjFwiO1xudmFyIEhpbGJlcnRTcGFjZSA9IFwi4oSLXCI7XG52YXIgaGtzZWFyb3cgPSBcIuKkpVwiO1xudmFyIGhrc3dhcm93ID0gXCLipKZcIjtcbnZhciBob2FyciA9IFwi4oe/XCI7XG52YXIgaG9tdGh0ID0gXCLiiLtcIjtcbnZhciBob29rbGVmdGFycm93ID0gXCLihqlcIjtcbnZhciBob29rcmlnaHRhcnJvdyA9IFwi4oaqXCI7XG52YXIgaG9wZiA9IFwi8J2VmVwiO1xudmFyIEhvcGYgPSBcIuKEjVwiO1xudmFyIGhvcmJhciA9IFwi4oCVXCI7XG52YXIgSG9yaXpvbnRhbExpbmUgPSBcIuKUgFwiO1xudmFyIGhzY3IgPSBcIvCdkr1cIjtcbnZhciBIc2NyID0gXCLihItcIjtcbnZhciBoc2xhc2ggPSBcIuKEj1wiO1xudmFyIEhzdHJvayA9IFwixKZcIjtcbnZhciBoc3Ryb2sgPSBcIsSnXCI7XG52YXIgSHVtcERvd25IdW1wID0gXCLiiY5cIjtcbnZhciBIdW1wRXF1YWwgPSBcIuKJj1wiO1xudmFyIGh5YnVsbCA9IFwi4oGDXCI7XG52YXIgaHlwaGVuID0gXCLigJBcIjtcbnZhciBJYWN1dGUkMSA9IFwiw41cIjtcbnZhciBpYWN1dGUkMSA9IFwiw61cIjtcbnZhciBpYyA9IFwi4oGjXCI7XG52YXIgSWNpcmMkMSA9IFwiw45cIjtcbnZhciBpY2lyYyQxID0gXCLDrlwiO1xudmFyIEljeSA9IFwi0JhcIjtcbnZhciBpY3kgPSBcItC4XCI7XG52YXIgSWRvdCA9IFwixLBcIjtcbnZhciBJRWN5ID0gXCLQlVwiO1xudmFyIGllY3kgPSBcItC1XCI7XG52YXIgaWV4Y2wkMSA9IFwiwqFcIjtcbnZhciBpZmYgPSBcIuKHlFwiO1xudmFyIGlmciA9IFwi8J2UplwiO1xudmFyIElmciA9IFwi4oSRXCI7XG52YXIgSWdyYXZlJDEgPSBcIsOMXCI7XG52YXIgaWdyYXZlJDEgPSBcIsOsXCI7XG52YXIgaWkgPSBcIuKFiFwiO1xudmFyIGlpaWludCA9IFwi4qiMXCI7XG52YXIgaWlpbnQgPSBcIuKIrVwiO1xudmFyIGlpbmZpbiA9IFwi4qecXCI7XG52YXIgaWlvdGEgPSBcIuKEqVwiO1xudmFyIElKbGlnID0gXCLEslwiO1xudmFyIGlqbGlnID0gXCLEs1wiO1xudmFyIEltYWNyID0gXCLEqlwiO1xudmFyIGltYWNyID0gXCLEq1wiO1xudmFyIGltYWdlID0gXCLihJFcIjtcbnZhciBJbWFnaW5hcnlJID0gXCLihYhcIjtcbnZhciBpbWFnbGluZSA9IFwi4oSQXCI7XG52YXIgaW1hZ3BhcnQgPSBcIuKEkVwiO1xudmFyIGltYXRoID0gXCLEsVwiO1xudmFyIEltID0gXCLihJFcIjtcbnZhciBpbW9mID0gXCLiirdcIjtcbnZhciBpbXBlZCA9IFwixrVcIjtcbnZhciBJbXBsaWVzID0gXCLih5JcIjtcbnZhciBpbmNhcmUgPSBcIuKEhVwiO1xudmFyIGluZmluID0gXCLiiJ5cIjtcbnZhciBpbmZpbnRpZSA9IFwi4qedXCI7XG52YXIgaW5vZG90ID0gXCLEsVwiO1xudmFyIGludGNhbCA9IFwi4oq6XCI7XG52YXIgaW50ID0gXCLiiKtcIjtcbnZhciBJbnQgPSBcIuKIrFwiO1xudmFyIGludGVnZXJzID0gXCLihKRcIjtcbnZhciBJbnRlZ3JhbCA9IFwi4oirXCI7XG52YXIgaW50ZXJjYWwgPSBcIuKKulwiO1xudmFyIEludGVyc2VjdGlvbiA9IFwi4ouCXCI7XG52YXIgaW50bGFyaGsgPSBcIuKol1wiO1xudmFyIGludHByb2QgPSBcIuKovFwiO1xudmFyIEludmlzaWJsZUNvbW1hID0gXCLigaNcIjtcbnZhciBJbnZpc2libGVUaW1lcyA9IFwi4oGiXCI7XG52YXIgSU9jeSA9IFwi0IFcIjtcbnZhciBpb2N5ID0gXCLRkVwiO1xudmFyIElvZ29uID0gXCLErlwiO1xudmFyIGlvZ29uID0gXCLEr1wiO1xudmFyIElvcGYgPSBcIvCdlYBcIjtcbnZhciBpb3BmID0gXCLwnZWaXCI7XG52YXIgSW90YSA9IFwizplcIjtcbnZhciBpb3RhID0gXCLOuVwiO1xudmFyIGlwcm9kID0gXCLiqLxcIjtcbnZhciBpcXVlc3QkMSA9IFwiwr9cIjtcbnZhciBpc2NyID0gXCLwnZK+XCI7XG52YXIgSXNjciA9IFwi4oSQXCI7XG52YXIgaXNpbiA9IFwi4oiIXCI7XG52YXIgaXNpbmRvdCA9IFwi4ou1XCI7XG52YXIgaXNpbkUgPSBcIuKLuVwiO1xudmFyIGlzaW5zID0gXCLii7RcIjtcbnZhciBpc2luc3YgPSBcIuKLs1wiO1xudmFyIGlzaW52ID0gXCLiiIhcIjtcbnZhciBpdCA9IFwi4oGiXCI7XG52YXIgSXRpbGRlID0gXCLEqFwiO1xudmFyIGl0aWxkZSA9IFwixKlcIjtcbnZhciBJdWtjeSA9IFwi0IZcIjtcbnZhciBpdWtjeSA9IFwi0ZZcIjtcbnZhciBJdW1sJDEgPSBcIsOPXCI7XG52YXIgaXVtbCQxID0gXCLDr1wiO1xudmFyIEpjaXJjID0gXCLEtFwiO1xudmFyIGpjaXJjID0gXCLEtVwiO1xudmFyIEpjeSA9IFwi0JlcIjtcbnZhciBqY3kgPSBcItC5XCI7XG52YXIgSmZyID0gXCLwnZSNXCI7XG52YXIgamZyID0gXCLwnZSnXCI7XG52YXIgam1hdGggPSBcIsi3XCI7XG52YXIgSm9wZiA9IFwi8J2VgVwiO1xudmFyIGpvcGYgPSBcIvCdlZtcIjtcbnZhciBKc2NyID0gXCLwnZKlXCI7XG52YXIganNjciA9IFwi8J2Sv1wiO1xudmFyIEpzZXJjeSA9IFwi0IhcIjtcbnZhciBqc2VyY3kgPSBcItGYXCI7XG52YXIgSnVrY3kgPSBcItCEXCI7XG52YXIganVrY3kgPSBcItGUXCI7XG52YXIgS2FwcGEgPSBcIs6aXCI7XG52YXIga2FwcGEgPSBcIs66XCI7XG52YXIga2FwcGF2ID0gXCLPsFwiO1xudmFyIEtjZWRpbCA9IFwixLZcIjtcbnZhciBrY2VkaWwgPSBcIsS3XCI7XG52YXIgS2N5ID0gXCLQmlwiO1xudmFyIGtjeSA9IFwi0LpcIjtcbnZhciBLZnIgPSBcIvCdlI5cIjtcbnZhciBrZnIgPSBcIvCdlKhcIjtcbnZhciBrZ3JlZW4gPSBcIsS4XCI7XG52YXIgS0hjeSA9IFwi0KVcIjtcbnZhciBraGN5ID0gXCLRhVwiO1xudmFyIEtKY3kgPSBcItCMXCI7XG52YXIga2pjeSA9IFwi0ZxcIjtcbnZhciBLb3BmID0gXCLwnZWCXCI7XG52YXIga29wZiA9IFwi8J2VnFwiO1xudmFyIEtzY3IgPSBcIvCdkqZcIjtcbnZhciBrc2NyID0gXCLwnZOAXCI7XG52YXIgbEFhcnIgPSBcIuKHmlwiO1xudmFyIExhY3V0ZSA9IFwixLlcIjtcbnZhciBsYWN1dGUgPSBcIsS6XCI7XG52YXIgbGFlbXB0eXYgPSBcIuKmtFwiO1xudmFyIGxhZ3JhbiA9IFwi4oSSXCI7XG52YXIgTGFtYmRhID0gXCLOm1wiO1xudmFyIGxhbWJkYSA9IFwizrtcIjtcbnZhciBsYW5nID0gXCLin6hcIjtcbnZhciBMYW5nID0gXCLin6pcIjtcbnZhciBsYW5nZCA9IFwi4qaRXCI7XG52YXIgbGFuZ2xlID0gXCLin6hcIjtcbnZhciBsYXAgPSBcIuKqhVwiO1xudmFyIExhcGxhY2V0cmYgPSBcIuKEklwiO1xudmFyIGxhcXVvJDEgPSBcIsKrXCI7XG52YXIgbGFycmIgPSBcIuKHpFwiO1xudmFyIGxhcnJiZnMgPSBcIuKkn1wiO1xudmFyIGxhcnIgPSBcIuKGkFwiO1xudmFyIExhcnIgPSBcIuKGnlwiO1xudmFyIGxBcnIgPSBcIuKHkFwiO1xudmFyIGxhcnJmcyA9IFwi4qSdXCI7XG52YXIgbGFycmhrID0gXCLihqlcIjtcbnZhciBsYXJybHAgPSBcIuKGq1wiO1xudmFyIGxhcnJwbCA9IFwi4qS5XCI7XG52YXIgbGFycnNpbSA9IFwi4qWzXCI7XG52YXIgbGFycnRsID0gXCLihqJcIjtcbnZhciBsYXRhaWwgPSBcIuKkmVwiO1xudmFyIGxBdGFpbCA9IFwi4qSbXCI7XG52YXIgbGF0ID0gXCLiqqtcIjtcbnZhciBsYXRlID0gXCLiqq1cIjtcbnZhciBsYXRlcyA9IFwi4qqt77iAXCI7XG52YXIgbGJhcnIgPSBcIuKkjFwiO1xudmFyIGxCYXJyID0gXCLipI5cIjtcbnZhciBsYmJyayA9IFwi4p2yXCI7XG52YXIgbGJyYWNlID0gXCJ7XCI7XG52YXIgbGJyYWNrID0gXCJbXCI7XG52YXIgbGJya2UgPSBcIuKmi1wiO1xudmFyIGxicmtzbGQgPSBcIuKmj1wiO1xudmFyIGxicmtzbHUgPSBcIuKmjVwiO1xudmFyIExjYXJvbiA9IFwixL1cIjtcbnZhciBsY2Fyb24gPSBcIsS+XCI7XG52YXIgTGNlZGlsID0gXCLEu1wiO1xudmFyIGxjZWRpbCA9IFwixLxcIjtcbnZhciBsY2VpbCA9IFwi4oyIXCI7XG52YXIgbGN1YiA9IFwie1wiO1xudmFyIExjeSA9IFwi0JtcIjtcbnZhciBsY3kgPSBcItC7XCI7XG52YXIgbGRjYSA9IFwi4qS2XCI7XG52YXIgbGRxdW8gPSBcIuKAnFwiO1xudmFyIGxkcXVvciA9IFwi4oCeXCI7XG52YXIgbGRyZGhhciA9IFwi4qWnXCI7XG52YXIgbGRydXNoYXIgPSBcIuKli1wiO1xudmFyIGxkc2ggPSBcIuKGslwiO1xudmFyIGxlID0gXCLiiaRcIjtcbnZhciBsRSA9IFwi4ommXCI7XG52YXIgTGVmdEFuZ2xlQnJhY2tldCA9IFwi4p+oXCI7XG52YXIgTGVmdEFycm93QmFyID0gXCLih6RcIjtcbnZhciBsZWZ0YXJyb3cgPSBcIuKGkFwiO1xudmFyIExlZnRBcnJvdyA9IFwi4oaQXCI7XG52YXIgTGVmdGFycm93ID0gXCLih5BcIjtcbnZhciBMZWZ0QXJyb3dSaWdodEFycm93ID0gXCLih4ZcIjtcbnZhciBsZWZ0YXJyb3d0YWlsID0gXCLihqJcIjtcbnZhciBMZWZ0Q2VpbGluZyA9IFwi4oyIXCI7XG52YXIgTGVmdERvdWJsZUJyYWNrZXQgPSBcIuKfplwiO1xudmFyIExlZnREb3duVGVlVmVjdG9yID0gXCLipaFcIjtcbnZhciBMZWZ0RG93blZlY3RvckJhciA9IFwi4qWZXCI7XG52YXIgTGVmdERvd25WZWN0b3IgPSBcIuKHg1wiO1xudmFyIExlZnRGbG9vciA9IFwi4oyKXCI7XG52YXIgbGVmdGhhcnBvb25kb3duID0gXCLihr1cIjtcbnZhciBsZWZ0aGFycG9vbnVwID0gXCLihrxcIjtcbnZhciBsZWZ0bGVmdGFycm93cyA9IFwi4oeHXCI7XG52YXIgbGVmdHJpZ2h0YXJyb3cgPSBcIuKGlFwiO1xudmFyIExlZnRSaWdodEFycm93ID0gXCLihpRcIjtcbnZhciBMZWZ0cmlnaHRhcnJvdyA9IFwi4oeUXCI7XG52YXIgbGVmdHJpZ2h0YXJyb3dzID0gXCLih4ZcIjtcbnZhciBsZWZ0cmlnaHRoYXJwb29ucyA9IFwi4oeLXCI7XG52YXIgbGVmdHJpZ2h0c3F1aWdhcnJvdyA9IFwi4oatXCI7XG52YXIgTGVmdFJpZ2h0VmVjdG9yID0gXCLipY5cIjtcbnZhciBMZWZ0VGVlQXJyb3cgPSBcIuKGpFwiO1xudmFyIExlZnRUZWUgPSBcIuKKo1wiO1xudmFyIExlZnRUZWVWZWN0b3IgPSBcIuKlmlwiO1xudmFyIGxlZnR0aHJlZXRpbWVzID0gXCLii4tcIjtcbnZhciBMZWZ0VHJpYW5nbGVCYXIgPSBcIuKnj1wiO1xudmFyIExlZnRUcmlhbmdsZSA9IFwi4oqyXCI7XG52YXIgTGVmdFRyaWFuZ2xlRXF1YWwgPSBcIuKKtFwiO1xudmFyIExlZnRVcERvd25WZWN0b3IgPSBcIuKlkVwiO1xudmFyIExlZnRVcFRlZVZlY3RvciA9IFwi4qWgXCI7XG52YXIgTGVmdFVwVmVjdG9yQmFyID0gXCLipZhcIjtcbnZhciBMZWZ0VXBWZWN0b3IgPSBcIuKGv1wiO1xudmFyIExlZnRWZWN0b3JCYXIgPSBcIuKlklwiO1xudmFyIExlZnRWZWN0b3IgPSBcIuKGvFwiO1xudmFyIGxFZyA9IFwi4qqLXCI7XG52YXIgbGVnID0gXCLii5pcIjtcbnZhciBsZXEgPSBcIuKJpFwiO1xudmFyIGxlcXEgPSBcIuKJplwiO1xudmFyIGxlcXNsYW50ID0gXCLiqb1cIjtcbnZhciBsZXNjYyA9IFwi4qqoXCI7XG52YXIgbGVzID0gXCLiqb1cIjtcbnZhciBsZXNkb3QgPSBcIuKpv1wiO1xudmFyIGxlc2RvdG8gPSBcIuKqgVwiO1xudmFyIGxlc2RvdG9yID0gXCLiqoNcIjtcbnZhciBsZXNnID0gXCLii5rvuIBcIjtcbnZhciBsZXNnZXMgPSBcIuKqk1wiO1xudmFyIGxlc3NhcHByb3ggPSBcIuKqhVwiO1xudmFyIGxlc3Nkb3QgPSBcIuKLllwiO1xudmFyIGxlc3NlcWd0ciA9IFwi4ouaXCI7XG52YXIgbGVzc2VxcWd0ciA9IFwi4qqLXCI7XG52YXIgTGVzc0VxdWFsR3JlYXRlciA9IFwi4ouaXCI7XG52YXIgTGVzc0Z1bGxFcXVhbCA9IFwi4ommXCI7XG52YXIgTGVzc0dyZWF0ZXIgPSBcIuKJtlwiO1xudmFyIGxlc3NndHIgPSBcIuKJtlwiO1xudmFyIExlc3NMZXNzID0gXCLiqqFcIjtcbnZhciBsZXNzc2ltID0gXCLiibJcIjtcbnZhciBMZXNzU2xhbnRFcXVhbCA9IFwi4qm9XCI7XG52YXIgTGVzc1RpbGRlID0gXCLiibJcIjtcbnZhciBsZmlzaHQgPSBcIuKlvFwiO1xudmFyIGxmbG9vciA9IFwi4oyKXCI7XG52YXIgTGZyID0gXCLwnZSPXCI7XG52YXIgbGZyID0gXCLwnZSpXCI7XG52YXIgbGcgPSBcIuKJtlwiO1xudmFyIGxnRSA9IFwi4qqRXCI7XG52YXIgbEhhciA9IFwi4qWiXCI7XG52YXIgbGhhcmQgPSBcIuKGvVwiO1xudmFyIGxoYXJ1ID0gXCLihrxcIjtcbnZhciBsaGFydWwgPSBcIuKlqlwiO1xudmFyIGxoYmxrID0gXCLiloRcIjtcbnZhciBMSmN5ID0gXCLQiVwiO1xudmFyIGxqY3kgPSBcItGZXCI7XG52YXIgbGxhcnIgPSBcIuKHh1wiO1xudmFyIGxsID0gXCLiiapcIjtcbnZhciBMbCA9IFwi4ouYXCI7XG52YXIgbGxjb3JuZXIgPSBcIuKMnlwiO1xudmFyIExsZWZ0YXJyb3cgPSBcIuKHmlwiO1xudmFyIGxsaGFyZCA9IFwi4qWrXCI7XG52YXIgbGx0cmkgPSBcIuKXulwiO1xudmFyIExtaWRvdCA9IFwixL9cIjtcbnZhciBsbWlkb3QgPSBcIsWAXCI7XG52YXIgbG1vdXN0YWNoZSA9IFwi4o6wXCI7XG52YXIgbG1vdXN0ID0gXCLijrBcIjtcbnZhciBsbmFwID0gXCLiqolcIjtcbnZhciBsbmFwcHJveCA9IFwi4qqJXCI7XG52YXIgbG5lID0gXCLiqodcIjtcbnZhciBsbkUgPSBcIuKJqFwiO1xudmFyIGxuZXEgPSBcIuKqh1wiO1xudmFyIGxuZXFxID0gXCLiiahcIjtcbnZhciBsbnNpbSA9IFwi4oumXCI7XG52YXIgbG9hbmcgPSBcIuKfrFwiO1xudmFyIGxvYXJyID0gXCLih71cIjtcbnZhciBsb2JyayA9IFwi4p+mXCI7XG52YXIgbG9uZ2xlZnRhcnJvdyA9IFwi4p+1XCI7XG52YXIgTG9uZ0xlZnRBcnJvdyA9IFwi4p+1XCI7XG52YXIgTG9uZ2xlZnRhcnJvdyA9IFwi4p+4XCI7XG52YXIgbG9uZ2xlZnRyaWdodGFycm93ID0gXCLin7dcIjtcbnZhciBMb25nTGVmdFJpZ2h0QXJyb3cgPSBcIuKft1wiO1xudmFyIExvbmdsZWZ0cmlnaHRhcnJvdyA9IFwi4p+6XCI7XG52YXIgbG9uZ21hcHN0byA9IFwi4p+8XCI7XG52YXIgbG9uZ3JpZ2h0YXJyb3cgPSBcIuKftlwiO1xudmFyIExvbmdSaWdodEFycm93ID0gXCLin7ZcIjtcbnZhciBMb25ncmlnaHRhcnJvdyA9IFwi4p+5XCI7XG52YXIgbG9vcGFycm93bGVmdCA9IFwi4oarXCI7XG52YXIgbG9vcGFycm93cmlnaHQgPSBcIuKGrFwiO1xudmFyIGxvcGFyID0gXCLipoVcIjtcbnZhciBMb3BmID0gXCLwnZWDXCI7XG52YXIgbG9wZiA9IFwi8J2VnVwiO1xudmFyIGxvcGx1cyA9IFwi4qitXCI7XG52YXIgbG90aW1lcyA9IFwi4qi0XCI7XG52YXIgbG93YXN0ID0gXCLiiJdcIjtcbnZhciBsb3diYXIgPSBcIl9cIjtcbnZhciBMb3dlckxlZnRBcnJvdyA9IFwi4oaZXCI7XG52YXIgTG93ZXJSaWdodEFycm93ID0gXCLihphcIjtcbnZhciBsb3ogPSBcIuKXilwiO1xudmFyIGxvemVuZ2UgPSBcIuKXilwiO1xudmFyIGxvemYgPSBcIuKnq1wiO1xudmFyIGxwYXIgPSBcIihcIjtcbnZhciBscGFybHQgPSBcIuKmk1wiO1xudmFyIGxyYXJyID0gXCLih4ZcIjtcbnZhciBscmNvcm5lciA9IFwi4oyfXCI7XG52YXIgbHJoYXIgPSBcIuKHi1wiO1xudmFyIGxyaGFyZCA9IFwi4qWtXCI7XG52YXIgbHJtID0gXCLigI5cIjtcbnZhciBscnRyaSA9IFwi4oq/XCI7XG52YXIgbHNhcXVvID0gXCLigLlcIjtcbnZhciBsc2NyID0gXCLwnZOBXCI7XG52YXIgTHNjciA9IFwi4oSSXCI7XG52YXIgbHNoID0gXCLihrBcIjtcbnZhciBMc2ggPSBcIuKGsFwiO1xudmFyIGxzaW0gPSBcIuKJslwiO1xudmFyIGxzaW1lID0gXCLiqo1cIjtcbnZhciBsc2ltZyA9IFwi4qqPXCI7XG52YXIgbHNxYiA9IFwiW1wiO1xudmFyIGxzcXVvID0gXCLigJhcIjtcbnZhciBsc3F1b3IgPSBcIuKAmlwiO1xudmFyIExzdHJvayA9IFwixYFcIjtcbnZhciBsc3Ryb2sgPSBcIsWCXCI7XG52YXIgbHRjYyA9IFwi4qqmXCI7XG52YXIgbHRjaXIgPSBcIuKpuVwiO1xudmFyIGx0JDIgPSBcIjxcIjtcbnZhciBMVCQxID0gXCI8XCI7XG52YXIgTHQgPSBcIuKJqlwiO1xudmFyIGx0ZG90ID0gXCLii5ZcIjtcbnZhciBsdGhyZWUgPSBcIuKLi1wiO1xudmFyIGx0aW1lcyA9IFwi4ouJXCI7XG52YXIgbHRsYXJyID0gXCLipbZcIjtcbnZhciBsdHF1ZXN0ID0gXCLiqbtcIjtcbnZhciBsdHJpID0gXCLil4NcIjtcbnZhciBsdHJpZSA9IFwi4oq0XCI7XG52YXIgbHRyaWYgPSBcIuKXglwiO1xudmFyIGx0clBhciA9IFwi4qaWXCI7XG52YXIgbHVyZHNoYXIgPSBcIuKlilwiO1xudmFyIGx1cnVoYXIgPSBcIuKlplwiO1xudmFyIGx2ZXJ0bmVxcSA9IFwi4omo77iAXCI7XG52YXIgbHZuRSA9IFwi4omo77iAXCI7XG52YXIgbWFjciQxID0gXCLCr1wiO1xudmFyIG1hbGUgPSBcIuKZglwiO1xudmFyIG1hbHQgPSBcIuKcoFwiO1xudmFyIG1hbHRlc2UgPSBcIuKcoFwiO1xudmFyIG1hcCA9IFwi4oamXCI7XG52YXIgbWFwc3RvID0gXCLihqZcIjtcbnZhciBtYXBzdG9kb3duID0gXCLihqdcIjtcbnZhciBtYXBzdG9sZWZ0ID0gXCLihqRcIjtcbnZhciBtYXBzdG91cCA9IFwi4oalXCI7XG52YXIgbWFya2VyID0gXCLilq5cIjtcbnZhciBtY29tbWEgPSBcIuKoqVwiO1xudmFyIE1jeSA9IFwi0JxcIjtcbnZhciBtY3kgPSBcItC8XCI7XG52YXIgbWRhc2ggPSBcIuKAlFwiO1xudmFyIG1ERG90ID0gXCLiiLpcIjtcbnZhciBtZWFzdXJlZGFuZ2xlID0gXCLiiKFcIjtcbnZhciBNZWRpdW1TcGFjZSA9IFwi4oGfXCI7XG52YXIgTWVsbGludHJmID0gXCLihLNcIjtcbnZhciBNZnIgPSBcIvCdlJBcIjtcbnZhciBtZnIgPSBcIvCdlKpcIjtcbnZhciBtaG8gPSBcIuKEp1wiO1xudmFyIG1pY3JvJDEgPSBcIsK1XCI7XG52YXIgbWlkYXN0ID0gXCIqXCI7XG52YXIgbWlkY2lyID0gXCLiq7BcIjtcbnZhciBtaWQgPSBcIuKIo1wiO1xudmFyIG1pZGRvdCQxID0gXCLCt1wiO1xudmFyIG1pbnVzYiA9IFwi4oqfXCI7XG52YXIgbWludXMgPSBcIuKIklwiO1xudmFyIG1pbnVzZCA9IFwi4oi4XCI7XG52YXIgbWludXNkdSA9IFwi4qiqXCI7XG52YXIgTWludXNQbHVzID0gXCLiiJNcIjtcbnZhciBtbGNwID0gXCLiq5tcIjtcbnZhciBtbGRyID0gXCLigKZcIjtcbnZhciBtbnBsdXMgPSBcIuKIk1wiO1xudmFyIG1vZGVscyA9IFwi4oqnXCI7XG52YXIgTW9wZiA9IFwi8J2VhFwiO1xudmFyIG1vcGYgPSBcIvCdlZ5cIjtcbnZhciBtcCA9IFwi4oiTXCI7XG52YXIgbXNjciA9IFwi8J2TglwiO1xudmFyIE1zY3IgPSBcIuKEs1wiO1xudmFyIG1zdHBvcyA9IFwi4oi+XCI7XG52YXIgTXUgPSBcIs6cXCI7XG52YXIgbXUgPSBcIs68XCI7XG52YXIgbXVsdGltYXAgPSBcIuKKuFwiO1xudmFyIG11bWFwID0gXCLiirhcIjtcbnZhciBuYWJsYSA9IFwi4oiHXCI7XG52YXIgTmFjdXRlID0gXCLFg1wiO1xudmFyIG5hY3V0ZSA9IFwixYRcIjtcbnZhciBuYW5nID0gXCLiiKDig5JcIjtcbnZhciBuYXAgPSBcIuKJiVwiO1xudmFyIG5hcEUgPSBcIuKpsMy4XCI7XG52YXIgbmFwaWQgPSBcIuKJi8y4XCI7XG52YXIgbmFwb3MgPSBcIsWJXCI7XG52YXIgbmFwcHJveCA9IFwi4omJXCI7XG52YXIgbmF0dXJhbCA9IFwi4pmuXCI7XG52YXIgbmF0dXJhbHMgPSBcIuKElVwiO1xudmFyIG5hdHVyID0gXCLima5cIjtcbnZhciBuYnNwJDEgPSBcIsKgXCI7XG52YXIgbmJ1bXAgPSBcIuKJjsy4XCI7XG52YXIgbmJ1bXBlID0gXCLiiY/MuFwiO1xudmFyIG5jYXAgPSBcIuKpg1wiO1xudmFyIE5jYXJvbiA9IFwixYdcIjtcbnZhciBuY2Fyb24gPSBcIsWIXCI7XG52YXIgTmNlZGlsID0gXCLFhVwiO1xudmFyIG5jZWRpbCA9IFwixYZcIjtcbnZhciBuY29uZyA9IFwi4omHXCI7XG52YXIgbmNvbmdkb3QgPSBcIuKprcy4XCI7XG52YXIgbmN1cCA9IFwi4qmCXCI7XG52YXIgTmN5ID0gXCLQnVwiO1xudmFyIG5jeSA9IFwi0L1cIjtcbnZhciBuZGFzaCA9IFwi4oCTXCI7XG52YXIgbmVhcmhrID0gXCLipKRcIjtcbnZhciBuZWFyciA9IFwi4oaXXCI7XG52YXIgbmVBcnIgPSBcIuKHl1wiO1xudmFyIG5lYXJyb3cgPSBcIuKGl1wiO1xudmFyIG5lID0gXCLiiaBcIjtcbnZhciBuZWRvdCA9IFwi4omQzLhcIjtcbnZhciBOZWdhdGl2ZU1lZGl1bVNwYWNlID0gXCLigItcIjtcbnZhciBOZWdhdGl2ZVRoaWNrU3BhY2UgPSBcIuKAi1wiO1xudmFyIE5lZ2F0aXZlVGhpblNwYWNlID0gXCLigItcIjtcbnZhciBOZWdhdGl2ZVZlcnlUaGluU3BhY2UgPSBcIuKAi1wiO1xudmFyIG5lcXVpdiA9IFwi4omiXCI7XG52YXIgbmVzZWFyID0gXCLipKhcIjtcbnZhciBuZXNpbSA9IFwi4omCzLhcIjtcbnZhciBOZXN0ZWRHcmVhdGVyR3JlYXRlciA9IFwi4omrXCI7XG52YXIgTmVzdGVkTGVzc0xlc3MgPSBcIuKJqlwiO1xudmFyIE5ld0xpbmUgPSBcIlxcblwiO1xudmFyIG5leGlzdCA9IFwi4oiEXCI7XG52YXIgbmV4aXN0cyA9IFwi4oiEXCI7XG52YXIgTmZyID0gXCLwnZSRXCI7XG52YXIgbmZyID0gXCLwnZSrXCI7XG52YXIgbmdFID0gXCLiiafMuFwiO1xudmFyIG5nZSA9IFwi4omxXCI7XG52YXIgbmdlcSA9IFwi4omxXCI7XG52YXIgbmdlcXEgPSBcIuKJp8y4XCI7XG52YXIgbmdlcXNsYW50ID0gXCLiqb7MuFwiO1xudmFyIG5nZXMgPSBcIuKpvsy4XCI7XG52YXIgbkdnID0gXCLii5nMuFwiO1xudmFyIG5nc2ltID0gXCLiibVcIjtcbnZhciBuR3QgPSBcIuKJq+KDklwiO1xudmFyIG5ndCA9IFwi4omvXCI7XG52YXIgbmd0ciA9IFwi4omvXCI7XG52YXIgbkd0diA9IFwi4omrzLhcIjtcbnZhciBuaGFyciA9IFwi4oauXCI7XG52YXIgbmhBcnIgPSBcIuKHjlwiO1xudmFyIG5ocGFyID0gXCLiq7JcIjtcbnZhciBuaSA9IFwi4oiLXCI7XG52YXIgbmlzID0gXCLii7xcIjtcbnZhciBuaXNkID0gXCLii7pcIjtcbnZhciBuaXYgPSBcIuKIi1wiO1xudmFyIE5KY3kgPSBcItCKXCI7XG52YXIgbmpjeSA9IFwi0ZpcIjtcbnZhciBubGFyciA9IFwi4oaaXCI7XG52YXIgbmxBcnIgPSBcIuKHjVwiO1xudmFyIG5sZHIgPSBcIuKApVwiO1xudmFyIG5sRSA9IFwi4ommzLhcIjtcbnZhciBubGUgPSBcIuKJsFwiO1xudmFyIG5sZWZ0YXJyb3cgPSBcIuKGmlwiO1xudmFyIG5MZWZ0YXJyb3cgPSBcIuKHjVwiO1xudmFyIG5sZWZ0cmlnaHRhcnJvdyA9IFwi4oauXCI7XG52YXIgbkxlZnRyaWdodGFycm93ID0gXCLih45cIjtcbnZhciBubGVxID0gXCLiibBcIjtcbnZhciBubGVxcSA9IFwi4ommzLhcIjtcbnZhciBubGVxc2xhbnQgPSBcIuKpvcy4XCI7XG52YXIgbmxlcyA9IFwi4qm9zLhcIjtcbnZhciBubGVzcyA9IFwi4omuXCI7XG52YXIgbkxsID0gXCLii5jMuFwiO1xudmFyIG5sc2ltID0gXCLiibRcIjtcbnZhciBuTHQgPSBcIuKJquKDklwiO1xudmFyIG5sdCA9IFwi4omuXCI7XG52YXIgbmx0cmkgPSBcIuKLqlwiO1xudmFyIG5sdHJpZSA9IFwi4ousXCI7XG52YXIgbkx0diA9IFwi4omqzLhcIjtcbnZhciBubWlkID0gXCLiiKRcIjtcbnZhciBOb0JyZWFrID0gXCLigaBcIjtcbnZhciBOb25CcmVha2luZ1NwYWNlID0gXCLCoFwiO1xudmFyIG5vcGYgPSBcIvCdlZ9cIjtcbnZhciBOb3BmID0gXCLihJVcIjtcbnZhciBOb3QgPSBcIuKrrFwiO1xudmFyIG5vdCQxID0gXCLCrFwiO1xudmFyIE5vdENvbmdydWVudCA9IFwi4omiXCI7XG52YXIgTm90Q3VwQ2FwID0gXCLiia1cIjtcbnZhciBOb3REb3VibGVWZXJ0aWNhbEJhciA9IFwi4oimXCI7XG52YXIgTm90RWxlbWVudCA9IFwi4oiJXCI7XG52YXIgTm90RXF1YWwgPSBcIuKJoFwiO1xudmFyIE5vdEVxdWFsVGlsZGUgPSBcIuKJgsy4XCI7XG52YXIgTm90RXhpc3RzID0gXCLiiIRcIjtcbnZhciBOb3RHcmVhdGVyID0gXCLiia9cIjtcbnZhciBOb3RHcmVhdGVyRXF1YWwgPSBcIuKJsVwiO1xudmFyIE5vdEdyZWF0ZXJGdWxsRXF1YWwgPSBcIuKJp8y4XCI7XG52YXIgTm90R3JlYXRlckdyZWF0ZXIgPSBcIuKJq8y4XCI7XG52YXIgTm90R3JlYXRlckxlc3MgPSBcIuKJuVwiO1xudmFyIE5vdEdyZWF0ZXJTbGFudEVxdWFsID0gXCLiqb7MuFwiO1xudmFyIE5vdEdyZWF0ZXJUaWxkZSA9IFwi4om1XCI7XG52YXIgTm90SHVtcERvd25IdW1wID0gXCLiiY7MuFwiO1xudmFyIE5vdEh1bXBFcXVhbCA9IFwi4omPzLhcIjtcbnZhciBub3RpbiA9IFwi4oiJXCI7XG52YXIgbm90aW5kb3QgPSBcIuKLtcy4XCI7XG52YXIgbm90aW5FID0gXCLii7nMuFwiO1xudmFyIG5vdGludmEgPSBcIuKIiVwiO1xudmFyIG5vdGludmIgPSBcIuKLt1wiO1xudmFyIG5vdGludmMgPSBcIuKLtlwiO1xudmFyIE5vdExlZnRUcmlhbmdsZUJhciA9IFwi4qePzLhcIjtcbnZhciBOb3RMZWZ0VHJpYW5nbGUgPSBcIuKLqlwiO1xudmFyIE5vdExlZnRUcmlhbmdsZUVxdWFsID0gXCLii6xcIjtcbnZhciBOb3RMZXNzID0gXCLiia5cIjtcbnZhciBOb3RMZXNzRXF1YWwgPSBcIuKJsFwiO1xudmFyIE5vdExlc3NHcmVhdGVyID0gXCLiibhcIjtcbnZhciBOb3RMZXNzTGVzcyA9IFwi4omqzLhcIjtcbnZhciBOb3RMZXNzU2xhbnRFcXVhbCA9IFwi4qm9zLhcIjtcbnZhciBOb3RMZXNzVGlsZGUgPSBcIuKJtFwiO1xudmFyIE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyID0gXCLiqqLMuFwiO1xudmFyIE5vdE5lc3RlZExlc3NMZXNzID0gXCLiqqHMuFwiO1xudmFyIG5vdG5pID0gXCLiiIxcIjtcbnZhciBub3RuaXZhID0gXCLiiIxcIjtcbnZhciBub3RuaXZiID0gXCLii75cIjtcbnZhciBub3RuaXZjID0gXCLii71cIjtcbnZhciBOb3RQcmVjZWRlcyA9IFwi4oqAXCI7XG52YXIgTm90UHJlY2VkZXNFcXVhbCA9IFwi4qqvzLhcIjtcbnZhciBOb3RQcmVjZWRlc1NsYW50RXF1YWwgPSBcIuKLoFwiO1xudmFyIE5vdFJldmVyc2VFbGVtZW50ID0gXCLiiIxcIjtcbnZhciBOb3RSaWdodFRyaWFuZ2xlQmFyID0gXCLip5DMuFwiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGUgPSBcIuKLq1wiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGVFcXVhbCA9IFwi4outXCI7XG52YXIgTm90U3F1YXJlU3Vic2V0ID0gXCLiio/MuFwiO1xudmFyIE5vdFNxdWFyZVN1YnNldEVxdWFsID0gXCLii6JcIjtcbnZhciBOb3RTcXVhcmVTdXBlcnNldCA9IFwi4oqQzLhcIjtcbnZhciBOb3RTcXVhcmVTdXBlcnNldEVxdWFsID0gXCLii6NcIjtcbnZhciBOb3RTdWJzZXQgPSBcIuKKguKDklwiO1xudmFyIE5vdFN1YnNldEVxdWFsID0gXCLiiohcIjtcbnZhciBOb3RTdWNjZWVkcyA9IFwi4oqBXCI7XG52YXIgTm90U3VjY2VlZHNFcXVhbCA9IFwi4qqwzLhcIjtcbnZhciBOb3RTdWNjZWVkc1NsYW50RXF1YWwgPSBcIuKLoVwiO1xudmFyIE5vdFN1Y2NlZWRzVGlsZGUgPSBcIuKJv8y4XCI7XG52YXIgTm90U3VwZXJzZXQgPSBcIuKKg+KDklwiO1xudmFyIE5vdFN1cGVyc2V0RXF1YWwgPSBcIuKKiVwiO1xudmFyIE5vdFRpbGRlID0gXCLiiYFcIjtcbnZhciBOb3RUaWxkZUVxdWFsID0gXCLiiYRcIjtcbnZhciBOb3RUaWxkZUZ1bGxFcXVhbCA9IFwi4omHXCI7XG52YXIgTm90VGlsZGVUaWxkZSA9IFwi4omJXCI7XG52YXIgTm90VmVydGljYWxCYXIgPSBcIuKIpFwiO1xudmFyIG5wYXJhbGxlbCA9IFwi4oimXCI7XG52YXIgbnBhciA9IFwi4oimXCI7XG52YXIgbnBhcnNsID0gXCLiq73ig6VcIjtcbnZhciBucGFydCA9IFwi4oiCzLhcIjtcbnZhciBucG9saW50ID0gXCLiqJRcIjtcbnZhciBucHIgPSBcIuKKgFwiO1xudmFyIG5wcmN1ZSA9IFwi4ougXCI7XG52YXIgbnByZWMgPSBcIuKKgFwiO1xudmFyIG5wcmVjZXEgPSBcIuKqr8y4XCI7XG52YXIgbnByZSA9IFwi4qqvzLhcIjtcbnZhciBucmFycmMgPSBcIuKks8y4XCI7XG52YXIgbnJhcnIgPSBcIuKGm1wiO1xudmFyIG5yQXJyID0gXCLih49cIjtcbnZhciBucmFycncgPSBcIuKGncy4XCI7XG52YXIgbnJpZ2h0YXJyb3cgPSBcIuKGm1wiO1xudmFyIG5SaWdodGFycm93ID0gXCLih49cIjtcbnZhciBucnRyaSA9IFwi4ourXCI7XG52YXIgbnJ0cmllID0gXCLii61cIjtcbnZhciBuc2MgPSBcIuKKgVwiO1xudmFyIG5zY2N1ZSA9IFwi4ouhXCI7XG52YXIgbnNjZSA9IFwi4qqwzLhcIjtcbnZhciBOc2NyID0gXCLwnZKpXCI7XG52YXIgbnNjciA9IFwi8J2Tg1wiO1xudmFyIG5zaG9ydG1pZCA9IFwi4oikXCI7XG52YXIgbnNob3J0cGFyYWxsZWwgPSBcIuKIplwiO1xudmFyIG5zaW0gPSBcIuKJgVwiO1xudmFyIG5zaW1lID0gXCLiiYRcIjtcbnZhciBuc2ltZXEgPSBcIuKJhFwiO1xudmFyIG5zbWlkID0gXCLiiKRcIjtcbnZhciBuc3BhciA9IFwi4oimXCI7XG52YXIgbnNxc3ViZSA9IFwi4ouiXCI7XG52YXIgbnNxc3VwZSA9IFwi4oujXCI7XG52YXIgbnN1YiA9IFwi4oqEXCI7XG52YXIgbnN1YkUgPSBcIuKrhcy4XCI7XG52YXIgbnN1YmUgPSBcIuKKiFwiO1xudmFyIG5zdWJzZXQgPSBcIuKKguKDklwiO1xudmFyIG5zdWJzZXRlcSA9IFwi4oqIXCI7XG52YXIgbnN1YnNldGVxcSA9IFwi4quFzLhcIjtcbnZhciBuc3VjYyA9IFwi4oqBXCI7XG52YXIgbnN1Y2NlcSA9IFwi4qqwzLhcIjtcbnZhciBuc3VwID0gXCLiioVcIjtcbnZhciBuc3VwRSA9IFwi4quGzLhcIjtcbnZhciBuc3VwZSA9IFwi4oqJXCI7XG52YXIgbnN1cHNldCA9IFwi4oqD4oOSXCI7XG52YXIgbnN1cHNldGVxID0gXCLiiolcIjtcbnZhciBuc3Vwc2V0ZXFxID0gXCLiq4bMuFwiO1xudmFyIG50Z2wgPSBcIuKJuVwiO1xudmFyIE50aWxkZSQxID0gXCLDkVwiO1xudmFyIG50aWxkZSQxID0gXCLDsVwiO1xudmFyIG50bGcgPSBcIuKJuFwiO1xudmFyIG50cmlhbmdsZWxlZnQgPSBcIuKLqlwiO1xudmFyIG50cmlhbmdsZWxlZnRlcSA9IFwi4ousXCI7XG52YXIgbnRyaWFuZ2xlcmlnaHQgPSBcIuKLq1wiO1xudmFyIG50cmlhbmdsZXJpZ2h0ZXEgPSBcIuKLrVwiO1xudmFyIE51ID0gXCLOnVwiO1xudmFyIG51ID0gXCLOvVwiO1xudmFyIG51bSA9IFwiI1wiO1xudmFyIG51bWVybyA9IFwi4oSWXCI7XG52YXIgbnVtc3AgPSBcIuKAh1wiO1xudmFyIG52YXAgPSBcIuKJjeKDklwiO1xudmFyIG52ZGFzaCA9IFwi4oqsXCI7XG52YXIgbnZEYXNoID0gXCLiiq1cIjtcbnZhciBuVmRhc2ggPSBcIuKKrlwiO1xudmFyIG5WRGFzaCA9IFwi4oqvXCI7XG52YXIgbnZnZSA9IFwi4oml4oOSXCI7XG52YXIgbnZndCA9IFwiPuKDklwiO1xudmFyIG52SGFyciA9IFwi4qSEXCI7XG52YXIgbnZpbmZpbiA9IFwi4qeeXCI7XG52YXIgbnZsQXJyID0gXCLipIJcIjtcbnZhciBudmxlID0gXCLiiaTig5JcIjtcbnZhciBudmx0ID0gXCI84oOSXCI7XG52YXIgbnZsdHJpZSA9IFwi4oq04oOSXCI7XG52YXIgbnZyQXJyID0gXCLipINcIjtcbnZhciBudnJ0cmllID0gXCLiirXig5JcIjtcbnZhciBudnNpbSA9IFwi4oi84oOSXCI7XG52YXIgbndhcmhrID0gXCLipKNcIjtcbnZhciBud2FyciA9IFwi4oaWXCI7XG52YXIgbndBcnIgPSBcIuKHllwiO1xudmFyIG53YXJyb3cgPSBcIuKGllwiO1xudmFyIG53bmVhciA9IFwi4qSnXCI7XG52YXIgT2FjdXRlJDEgPSBcIsOTXCI7XG52YXIgb2FjdXRlJDEgPSBcIsOzXCI7XG52YXIgb2FzdCA9IFwi4oqbXCI7XG52YXIgT2NpcmMkMSA9IFwiw5RcIjtcbnZhciBvY2lyYyQxID0gXCLDtFwiO1xudmFyIG9jaXIgPSBcIuKKmlwiO1xudmFyIE9jeSA9IFwi0J5cIjtcbnZhciBvY3kgPSBcItC+XCI7XG52YXIgb2Rhc2ggPSBcIuKKnVwiO1xudmFyIE9kYmxhYyA9IFwixZBcIjtcbnZhciBvZGJsYWMgPSBcIsWRXCI7XG52YXIgb2RpdiA9IFwi4qi4XCI7XG52YXIgb2RvdCA9IFwi4oqZXCI7XG52YXIgb2Rzb2xkID0gXCLiprxcIjtcbnZhciBPRWxpZyA9IFwixZJcIjtcbnZhciBvZWxpZyA9IFwixZNcIjtcbnZhciBvZmNpciA9IFwi4qa/XCI7XG52YXIgT2ZyID0gXCLwnZSSXCI7XG52YXIgb2ZyID0gXCLwnZSsXCI7XG52YXIgb2dvbiA9IFwiy5tcIjtcbnZhciBPZ3JhdmUkMSA9IFwiw5JcIjtcbnZhciBvZ3JhdmUkMSA9IFwiw7JcIjtcbnZhciBvZ3QgPSBcIuKngVwiO1xudmFyIG9oYmFyID0gXCLiprVcIjtcbnZhciBvaG0gPSBcIs6pXCI7XG52YXIgb2ludCA9IFwi4oiuXCI7XG52YXIgb2xhcnIgPSBcIuKGulwiO1xudmFyIG9sY2lyID0gXCLipr5cIjtcbnZhciBvbGNyb3NzID0gXCLiprtcIjtcbnZhciBvbGluZSA9IFwi4oC+XCI7XG52YXIgb2x0ID0gXCLip4BcIjtcbnZhciBPbWFjciA9IFwixYxcIjtcbnZhciBvbWFjciA9IFwixY1cIjtcbnZhciBPbWVnYSA9IFwizqlcIjtcbnZhciBvbWVnYSA9IFwiz4lcIjtcbnZhciBPbWljcm9uID0gXCLOn1wiO1xudmFyIG9taWNyb24gPSBcIs6/XCI7XG52YXIgb21pZCA9IFwi4qa2XCI7XG52YXIgb21pbnVzID0gXCLiipZcIjtcbnZhciBPb3BmID0gXCLwnZWGXCI7XG52YXIgb29wZiA9IFwi8J2VoFwiO1xudmFyIG9wYXIgPSBcIuKmt1wiO1xudmFyIE9wZW5DdXJseURvdWJsZVF1b3RlID0gXCLigJxcIjtcbnZhciBPcGVuQ3VybHlRdW90ZSA9IFwi4oCYXCI7XG52YXIgb3BlcnAgPSBcIuKmuVwiO1xudmFyIG9wbHVzID0gXCLiipVcIjtcbnZhciBvcmFyciA9IFwi4oa7XCI7XG52YXIgT3IgPSBcIuKplFwiO1xudmFyIG9yID0gXCLiiKhcIjtcbnZhciBvcmQgPSBcIuKpnVwiO1xudmFyIG9yZGVyID0gXCLihLRcIjtcbnZhciBvcmRlcm9mID0gXCLihLRcIjtcbnZhciBvcmRmJDEgPSBcIsKqXCI7XG52YXIgb3JkbSQxID0gXCLCulwiO1xudmFyIG9yaWdvZiA9IFwi4oq2XCI7XG52YXIgb3JvciA9IFwi4qmWXCI7XG52YXIgb3JzbG9wZSA9IFwi4qmXXCI7XG52YXIgb3J2ID0gXCLiqZtcIjtcbnZhciBvUyA9IFwi4pOIXCI7XG52YXIgT3NjciA9IFwi8J2SqlwiO1xudmFyIG9zY3IgPSBcIuKEtFwiO1xudmFyIE9zbGFzaCQxID0gXCLDmFwiO1xudmFyIG9zbGFzaCQxID0gXCLDuFwiO1xudmFyIG9zb2wgPSBcIuKKmFwiO1xudmFyIE90aWxkZSQxID0gXCLDlVwiO1xudmFyIG90aWxkZSQxID0gXCLDtVwiO1xudmFyIG90aW1lc2FzID0gXCLiqLZcIjtcbnZhciBPdGltZXMgPSBcIuKot1wiO1xudmFyIG90aW1lcyA9IFwi4oqXXCI7XG52YXIgT3VtbCQxID0gXCLDllwiO1xudmFyIG91bWwkMSA9IFwiw7ZcIjtcbnZhciBvdmJhciA9IFwi4oy9XCI7XG52YXIgT3ZlckJhciA9IFwi4oC+XCI7XG52YXIgT3ZlckJyYWNlID0gXCLij55cIjtcbnZhciBPdmVyQnJhY2tldCA9IFwi4o60XCI7XG52YXIgT3ZlclBhcmVudGhlc2lzID0gXCLij5xcIjtcbnZhciBwYXJhJDEgPSBcIsK2XCI7XG52YXIgcGFyYWxsZWwgPSBcIuKIpVwiO1xudmFyIHBhciA9IFwi4oilXCI7XG52YXIgcGFyc2ltID0gXCLiq7NcIjtcbnZhciBwYXJzbCA9IFwi4qu9XCI7XG52YXIgcGFydCA9IFwi4oiCXCI7XG52YXIgUGFydGlhbEQgPSBcIuKIglwiO1xudmFyIFBjeSA9IFwi0J9cIjtcbnZhciBwY3kgPSBcItC/XCI7XG52YXIgcGVyY250ID0gXCIlXCI7XG52YXIgcGVyaW9kID0gXCIuXCI7XG52YXIgcGVybWlsID0gXCLigLBcIjtcbnZhciBwZXJwID0gXCLiiqVcIjtcbnZhciBwZXJ0ZW5rID0gXCLigLFcIjtcbnZhciBQZnIgPSBcIvCdlJNcIjtcbnZhciBwZnIgPSBcIvCdlK1cIjtcbnZhciBQaGkgPSBcIs6mXCI7XG52YXIgcGhpID0gXCLPhlwiO1xudmFyIHBoaXYgPSBcIs+VXCI7XG52YXIgcGhtbWF0ID0gXCLihLNcIjtcbnZhciBwaG9uZSA9IFwi4piOXCI7XG52YXIgUGkgPSBcIs6gXCI7XG52YXIgcGkgPSBcIs+AXCI7XG52YXIgcGl0Y2hmb3JrID0gXCLii5RcIjtcbnZhciBwaXYgPSBcIs+WXCI7XG52YXIgcGxhbmNrID0gXCLihI9cIjtcbnZhciBwbGFuY2toID0gXCLihI5cIjtcbnZhciBwbGFua3YgPSBcIuKEj1wiO1xudmFyIHBsdXNhY2lyID0gXCLiqKNcIjtcbnZhciBwbHVzYiA9IFwi4oqeXCI7XG52YXIgcGx1c2NpciA9IFwi4qiiXCI7XG52YXIgcGx1cyA9IFwiK1wiO1xudmFyIHBsdXNkbyA9IFwi4oiUXCI7XG52YXIgcGx1c2R1ID0gXCLiqKVcIjtcbnZhciBwbHVzZSA9IFwi4qmyXCI7XG52YXIgUGx1c01pbnVzID0gXCLCsVwiO1xudmFyIHBsdXNtbiQxID0gXCLCsVwiO1xudmFyIHBsdXNzaW0gPSBcIuKoplwiO1xudmFyIHBsdXN0d28gPSBcIuKop1wiO1xudmFyIHBtID0gXCLCsVwiO1xudmFyIFBvaW5jYXJlcGxhbmUgPSBcIuKEjFwiO1xudmFyIHBvaW50aW50ID0gXCLiqJVcIjtcbnZhciBwb3BmID0gXCLwnZWhXCI7XG52YXIgUG9wZiA9IFwi4oSZXCI7XG52YXIgcG91bmQkMSA9IFwiwqNcIjtcbnZhciBwcmFwID0gXCLiqrdcIjtcbnZhciBQciA9IFwi4qq7XCI7XG52YXIgcHIgPSBcIuKJulwiO1xudmFyIHByY3VlID0gXCLiibxcIjtcbnZhciBwcmVjYXBwcm94ID0gXCLiqrdcIjtcbnZhciBwcmVjID0gXCLiibpcIjtcbnZhciBwcmVjY3VybHllcSA9IFwi4om8XCI7XG52YXIgUHJlY2VkZXMgPSBcIuKJulwiO1xudmFyIFByZWNlZGVzRXF1YWwgPSBcIuKqr1wiO1xudmFyIFByZWNlZGVzU2xhbnRFcXVhbCA9IFwi4om8XCI7XG52YXIgUHJlY2VkZXNUaWxkZSA9IFwi4om+XCI7XG52YXIgcHJlY2VxID0gXCLiqq9cIjtcbnZhciBwcmVjbmFwcHJveCA9IFwi4qq5XCI7XG52YXIgcHJlY25lcXEgPSBcIuKqtVwiO1xudmFyIHByZWNuc2ltID0gXCLii6hcIjtcbnZhciBwcmUgPSBcIuKqr1wiO1xudmFyIHByRSA9IFwi4qqzXCI7XG52YXIgcHJlY3NpbSA9IFwi4om+XCI7XG52YXIgcHJpbWUgPSBcIuKAslwiO1xudmFyIFByaW1lID0gXCLigLNcIjtcbnZhciBwcmltZXMgPSBcIuKEmVwiO1xudmFyIHBybmFwID0gXCLiqrlcIjtcbnZhciBwcm5FID0gXCLiqrVcIjtcbnZhciBwcm5zaW0gPSBcIuKLqFwiO1xudmFyIHByb2QgPSBcIuKIj1wiO1xudmFyIFByb2R1Y3QgPSBcIuKIj1wiO1xudmFyIHByb2ZhbGFyID0gXCLijK5cIjtcbnZhciBwcm9mbGluZSA9IFwi4oySXCI7XG52YXIgcHJvZnN1cmYgPSBcIuKMk1wiO1xudmFyIHByb3AgPSBcIuKInVwiO1xudmFyIFByb3BvcnRpb25hbCA9IFwi4oidXCI7XG52YXIgUHJvcG9ydGlvbiA9IFwi4oi3XCI7XG52YXIgcHJvcHRvID0gXCLiiJ1cIjtcbnZhciBwcnNpbSA9IFwi4om+XCI7XG52YXIgcHJ1cmVsID0gXCLiirBcIjtcbnZhciBQc2NyID0gXCLwnZKrXCI7XG52YXIgcHNjciA9IFwi8J2ThVwiO1xudmFyIFBzaSA9IFwizqhcIjtcbnZhciBwc2kgPSBcIs+IXCI7XG52YXIgcHVuY3NwID0gXCLigIhcIjtcbnZhciBRZnIgPSBcIvCdlJRcIjtcbnZhciBxZnIgPSBcIvCdlK5cIjtcbnZhciBxaW50ID0gXCLiqIxcIjtcbnZhciBxb3BmID0gXCLwnZWiXCI7XG52YXIgUW9wZiA9IFwi4oSaXCI7XG52YXIgcXByaW1lID0gXCLigZdcIjtcbnZhciBRc2NyID0gXCLwnZKsXCI7XG52YXIgcXNjciA9IFwi8J2ThlwiO1xudmFyIHF1YXRlcm5pb25zID0gXCLihI1cIjtcbnZhciBxdWF0aW50ID0gXCLiqJZcIjtcbnZhciBxdWVzdCA9IFwiP1wiO1xudmFyIHF1ZXN0ZXEgPSBcIuKJn1wiO1xudmFyIHF1b3QkMiA9IFwiXFxcIlwiO1xudmFyIFFVT1QkMSA9IFwiXFxcIlwiO1xudmFyIHJBYXJyID0gXCLih5tcIjtcbnZhciByYWNlID0gXCLiiL3MsVwiO1xudmFyIFJhY3V0ZSA9IFwixZRcIjtcbnZhciByYWN1dGUgPSBcIsWVXCI7XG52YXIgcmFkaWMgPSBcIuKImlwiO1xudmFyIHJhZW1wdHl2ID0gXCLiprNcIjtcbnZhciByYW5nID0gXCLin6lcIjtcbnZhciBSYW5nID0gXCLin6tcIjtcbnZhciByYW5nZCA9IFwi4qaSXCI7XG52YXIgcmFuZ2UgPSBcIuKmpVwiO1xudmFyIHJhbmdsZSA9IFwi4p+pXCI7XG52YXIgcmFxdW8kMSA9IFwiwrtcIjtcbnZhciByYXJyYXAgPSBcIuKltVwiO1xudmFyIHJhcnJiID0gXCLih6VcIjtcbnZhciByYXJyYmZzID0gXCLipKBcIjtcbnZhciByYXJyYyA9IFwi4qSzXCI7XG52YXIgcmFyciA9IFwi4oaSXCI7XG52YXIgUmFyciA9IFwi4oagXCI7XG52YXIgckFyciA9IFwi4oeSXCI7XG52YXIgcmFycmZzID0gXCLipJ5cIjtcbnZhciByYXJyaGsgPSBcIuKGqlwiO1xudmFyIHJhcnJscCA9IFwi4oasXCI7XG52YXIgcmFycnBsID0gXCLipYVcIjtcbnZhciByYXJyc2ltID0gXCLipbRcIjtcbnZhciBSYXJydGwgPSBcIuKkllwiO1xudmFyIHJhcnJ0bCA9IFwi4oajXCI7XG52YXIgcmFycncgPSBcIuKGnVwiO1xudmFyIHJhdGFpbCA9IFwi4qSaXCI7XG52YXIgckF0YWlsID0gXCLipJxcIjtcbnZhciByYXRpbyA9IFwi4oi2XCI7XG52YXIgcmF0aW9uYWxzID0gXCLihJpcIjtcbnZhciByYmFyciA9IFwi4qSNXCI7XG52YXIgckJhcnIgPSBcIuKkj1wiO1xudmFyIFJCYXJyID0gXCLipJBcIjtcbnZhciByYmJyayA9IFwi4p2zXCI7XG52YXIgcmJyYWNlID0gXCJ9XCI7XG52YXIgcmJyYWNrID0gXCJdXCI7XG52YXIgcmJya2UgPSBcIuKmjFwiO1xudmFyIHJicmtzbGQgPSBcIuKmjlwiO1xudmFyIHJicmtzbHUgPSBcIuKmkFwiO1xudmFyIFJjYXJvbiA9IFwixZhcIjtcbnZhciByY2Fyb24gPSBcIsWZXCI7XG52YXIgUmNlZGlsID0gXCLFllwiO1xudmFyIHJjZWRpbCA9IFwixZdcIjtcbnZhciByY2VpbCA9IFwi4oyJXCI7XG52YXIgcmN1YiA9IFwifVwiO1xudmFyIFJjeSA9IFwi0KBcIjtcbnZhciByY3kgPSBcItGAXCI7XG52YXIgcmRjYSA9IFwi4qS3XCI7XG52YXIgcmRsZGhhciA9IFwi4qWpXCI7XG52YXIgcmRxdW8gPSBcIuKAnVwiO1xudmFyIHJkcXVvciA9IFwi4oCdXCI7XG52YXIgcmRzaCA9IFwi4oazXCI7XG52YXIgcmVhbCA9IFwi4oScXCI7XG52YXIgcmVhbGluZSA9IFwi4oSbXCI7XG52YXIgcmVhbHBhcnQgPSBcIuKEnFwiO1xudmFyIHJlYWxzID0gXCLihJ1cIjtcbnZhciBSZSA9IFwi4oScXCI7XG52YXIgcmVjdCA9IFwi4patXCI7XG52YXIgcmVnJDEgPSBcIsKuXCI7XG52YXIgUkVHJDEgPSBcIsKuXCI7XG52YXIgUmV2ZXJzZUVsZW1lbnQgPSBcIuKIi1wiO1xudmFyIFJldmVyc2VFcXVpbGlicml1bSA9IFwi4oeLXCI7XG52YXIgUmV2ZXJzZVVwRXF1aWxpYnJpdW0gPSBcIuKlr1wiO1xudmFyIHJmaXNodCA9IFwi4qW9XCI7XG52YXIgcmZsb29yID0gXCLijItcIjtcbnZhciByZnIgPSBcIvCdlK9cIjtcbnZhciBSZnIgPSBcIuKEnFwiO1xudmFyIHJIYXIgPSBcIuKlpFwiO1xudmFyIHJoYXJkID0gXCLih4FcIjtcbnZhciByaGFydSA9IFwi4oeAXCI7XG52YXIgcmhhcnVsID0gXCLipaxcIjtcbnZhciBSaG8gPSBcIs6hXCI7XG52YXIgcmhvID0gXCLPgVwiO1xudmFyIHJob3YgPSBcIs+xXCI7XG52YXIgUmlnaHRBbmdsZUJyYWNrZXQgPSBcIuKfqVwiO1xudmFyIFJpZ2h0QXJyb3dCYXIgPSBcIuKHpVwiO1xudmFyIHJpZ2h0YXJyb3cgPSBcIuKGklwiO1xudmFyIFJpZ2h0QXJyb3cgPSBcIuKGklwiO1xudmFyIFJpZ2h0YXJyb3cgPSBcIuKHklwiO1xudmFyIFJpZ2h0QXJyb3dMZWZ0QXJyb3cgPSBcIuKHhFwiO1xudmFyIHJpZ2h0YXJyb3d0YWlsID0gXCLihqNcIjtcbnZhciBSaWdodENlaWxpbmcgPSBcIuKMiVwiO1xudmFyIFJpZ2h0RG91YmxlQnJhY2tldCA9IFwi4p+nXCI7XG52YXIgUmlnaHREb3duVGVlVmVjdG9yID0gXCLipZ1cIjtcbnZhciBSaWdodERvd25WZWN0b3JCYXIgPSBcIuKllVwiO1xudmFyIFJpZ2h0RG93blZlY3RvciA9IFwi4oeCXCI7XG52YXIgUmlnaHRGbG9vciA9IFwi4oyLXCI7XG52YXIgcmlnaHRoYXJwb29uZG93biA9IFwi4oeBXCI7XG52YXIgcmlnaHRoYXJwb29udXAgPSBcIuKHgFwiO1xudmFyIHJpZ2h0bGVmdGFycm93cyA9IFwi4oeEXCI7XG52YXIgcmlnaHRsZWZ0aGFycG9vbnMgPSBcIuKHjFwiO1xudmFyIHJpZ2h0cmlnaHRhcnJvd3MgPSBcIuKHiVwiO1xudmFyIHJpZ2h0c3F1aWdhcnJvdyA9IFwi4oadXCI7XG52YXIgUmlnaHRUZWVBcnJvdyA9IFwi4oamXCI7XG52YXIgUmlnaHRUZWUgPSBcIuKKolwiO1xudmFyIFJpZ2h0VGVlVmVjdG9yID0gXCLipZtcIjtcbnZhciByaWdodHRocmVldGltZXMgPSBcIuKLjFwiO1xudmFyIFJpZ2h0VHJpYW5nbGVCYXIgPSBcIuKnkFwiO1xudmFyIFJpZ2h0VHJpYW5nbGUgPSBcIuKKs1wiO1xudmFyIFJpZ2h0VHJpYW5nbGVFcXVhbCA9IFwi4oq1XCI7XG52YXIgUmlnaHRVcERvd25WZWN0b3IgPSBcIuKlj1wiO1xudmFyIFJpZ2h0VXBUZWVWZWN0b3IgPSBcIuKlnFwiO1xudmFyIFJpZ2h0VXBWZWN0b3JCYXIgPSBcIuKllFwiO1xudmFyIFJpZ2h0VXBWZWN0b3IgPSBcIuKGvlwiO1xudmFyIFJpZ2h0VmVjdG9yQmFyID0gXCLipZNcIjtcbnZhciBSaWdodFZlY3RvciA9IFwi4oeAXCI7XG52YXIgcmluZyA9IFwiy5pcIjtcbnZhciByaXNpbmdkb3RzZXEgPSBcIuKJk1wiO1xudmFyIHJsYXJyID0gXCLih4RcIjtcbnZhciBybGhhciA9IFwi4oeMXCI7XG52YXIgcmxtID0gXCLigI9cIjtcbnZhciBybW91c3RhY2hlID0gXCLijrFcIjtcbnZhciBybW91c3QgPSBcIuKOsVwiO1xudmFyIHJubWlkID0gXCLiq65cIjtcbnZhciByb2FuZyA9IFwi4p+tXCI7XG52YXIgcm9hcnIgPSBcIuKHvlwiO1xudmFyIHJvYnJrID0gXCLin6dcIjtcbnZhciByb3BhciA9IFwi4qaGXCI7XG52YXIgcm9wZiA9IFwi8J2Vo1wiO1xudmFyIFJvcGYgPSBcIuKEnVwiO1xudmFyIHJvcGx1cyA9IFwi4qiuXCI7XG52YXIgcm90aW1lcyA9IFwi4qi1XCI7XG52YXIgUm91bmRJbXBsaWVzID0gXCLipbBcIjtcbnZhciBycGFyID0gXCIpXCI7XG52YXIgcnBhcmd0ID0gXCLippRcIjtcbnZhciBycHBvbGludCA9IFwi4qiSXCI7XG52YXIgcnJhcnIgPSBcIuKHiVwiO1xudmFyIFJyaWdodGFycm93ID0gXCLih5tcIjtcbnZhciByc2FxdW8gPSBcIuKAulwiO1xudmFyIHJzY3IgPSBcIvCdk4dcIjtcbnZhciBSc2NyID0gXCLihJtcIjtcbnZhciByc2ggPSBcIuKGsVwiO1xudmFyIFJzaCA9IFwi4oaxXCI7XG52YXIgcnNxYiA9IFwiXVwiO1xudmFyIHJzcXVvID0gXCLigJlcIjtcbnZhciByc3F1b3IgPSBcIuKAmVwiO1xudmFyIHJ0aHJlZSA9IFwi4ouMXCI7XG52YXIgcnRpbWVzID0gXCLii4pcIjtcbnZhciBydHJpID0gXCLilrlcIjtcbnZhciBydHJpZSA9IFwi4oq1XCI7XG52YXIgcnRyaWYgPSBcIuKWuFwiO1xudmFyIHJ0cmlsdHJpID0gXCLip45cIjtcbnZhciBSdWxlRGVsYXllZCA9IFwi4qe0XCI7XG52YXIgcnVsdWhhciA9IFwi4qWoXCI7XG52YXIgcnggPSBcIuKEnlwiO1xudmFyIFNhY3V0ZSA9IFwixZpcIjtcbnZhciBzYWN1dGUgPSBcIsWbXCI7XG52YXIgc2JxdW8gPSBcIuKAmlwiO1xudmFyIHNjYXAgPSBcIuKquFwiO1xudmFyIFNjYXJvbiA9IFwixaBcIjtcbnZhciBzY2Fyb24gPSBcIsWhXCI7XG52YXIgU2MgPSBcIuKqvFwiO1xudmFyIHNjID0gXCLiibtcIjtcbnZhciBzY2N1ZSA9IFwi4om9XCI7XG52YXIgc2NlID0gXCLiqrBcIjtcbnZhciBzY0UgPSBcIuKqtFwiO1xudmFyIFNjZWRpbCA9IFwixZ5cIjtcbnZhciBzY2VkaWwgPSBcIsWfXCI7XG52YXIgU2NpcmMgPSBcIsWcXCI7XG52YXIgc2NpcmMgPSBcIsWdXCI7XG52YXIgc2NuYXAgPSBcIuKqulwiO1xudmFyIHNjbkUgPSBcIuKqtlwiO1xudmFyIHNjbnNpbSA9IFwi4oupXCI7XG52YXIgc2Nwb2xpbnQgPSBcIuKok1wiO1xudmFyIHNjc2ltID0gXCLiib9cIjtcbnZhciBTY3kgPSBcItChXCI7XG52YXIgc2N5ID0gXCLRgVwiO1xudmFyIHNkb3RiID0gXCLiiqFcIjtcbnZhciBzZG90ID0gXCLii4VcIjtcbnZhciBzZG90ZSA9IFwi4qmmXCI7XG52YXIgc2VhcmhrID0gXCLipKVcIjtcbnZhciBzZWFyciA9IFwi4oaYXCI7XG52YXIgc2VBcnIgPSBcIuKHmFwiO1xudmFyIHNlYXJyb3cgPSBcIuKGmFwiO1xudmFyIHNlY3QkMSA9IFwiwqdcIjtcbnZhciBzZW1pID0gXCI7XCI7XG52YXIgc2Vzd2FyID0gXCLipKlcIjtcbnZhciBzZXRtaW51cyA9IFwi4oiWXCI7XG52YXIgc2V0bW4gPSBcIuKIllwiO1xudmFyIHNleHQgPSBcIuKctlwiO1xudmFyIFNmciA9IFwi8J2UllwiO1xudmFyIHNmciA9IFwi8J2UsFwiO1xudmFyIHNmcm93biA9IFwi4oyiXCI7XG52YXIgc2hhcnAgPSBcIuKZr1wiO1xudmFyIFNIQ0hjeSA9IFwi0KlcIjtcbnZhciBzaGNoY3kgPSBcItGJXCI7XG52YXIgU0hjeSA9IFwi0KhcIjtcbnZhciBzaGN5ID0gXCLRiFwiO1xudmFyIFNob3J0RG93bkFycm93ID0gXCLihpNcIjtcbnZhciBTaG9ydExlZnRBcnJvdyA9IFwi4oaQXCI7XG52YXIgc2hvcnRtaWQgPSBcIuKIo1wiO1xudmFyIHNob3J0cGFyYWxsZWwgPSBcIuKIpVwiO1xudmFyIFNob3J0UmlnaHRBcnJvdyA9IFwi4oaSXCI7XG52YXIgU2hvcnRVcEFycm93ID0gXCLihpFcIjtcbnZhciBzaHkkMSA9IFwiwq1cIjtcbnZhciBTaWdtYSA9IFwizqNcIjtcbnZhciBzaWdtYSA9IFwiz4NcIjtcbnZhciBzaWdtYWYgPSBcIs+CXCI7XG52YXIgc2lnbWF2ID0gXCLPglwiO1xudmFyIHNpbSA9IFwi4oi8XCI7XG52YXIgc2ltZG90ID0gXCLiqapcIjtcbnZhciBzaW1lID0gXCLiiYNcIjtcbnZhciBzaW1lcSA9IFwi4omDXCI7XG52YXIgc2ltZyA9IFwi4qqeXCI7XG52YXIgc2ltZ0UgPSBcIuKqoFwiO1xudmFyIHNpbWwgPSBcIuKqnVwiO1xudmFyIHNpbWxFID0gXCLiqp9cIjtcbnZhciBzaW1uZSA9IFwi4omGXCI7XG52YXIgc2ltcGx1cyA9IFwi4qikXCI7XG52YXIgc2ltcmFyciA9IFwi4qWyXCI7XG52YXIgc2xhcnIgPSBcIuKGkFwiO1xudmFyIFNtYWxsQ2lyY2xlID0gXCLiiJhcIjtcbnZhciBzbWFsbHNldG1pbnVzID0gXCLiiJZcIjtcbnZhciBzbWFzaHAgPSBcIuKos1wiO1xudmFyIHNtZXBhcnNsID0gXCLip6RcIjtcbnZhciBzbWlkID0gXCLiiKNcIjtcbnZhciBzbWlsZSA9IFwi4oyjXCI7XG52YXIgc210ID0gXCLiqqpcIjtcbnZhciBzbXRlID0gXCLiqqxcIjtcbnZhciBzbXRlcyA9IFwi4qqs77iAXCI7XG52YXIgU09GVGN5ID0gXCLQrFwiO1xudmFyIHNvZnRjeSA9IFwi0YxcIjtcbnZhciBzb2xiYXIgPSBcIuKMv1wiO1xudmFyIHNvbGIgPSBcIuKnhFwiO1xudmFyIHNvbCA9IFwiL1wiO1xudmFyIFNvcGYgPSBcIvCdlYpcIjtcbnZhciBzb3BmID0gXCLwnZWkXCI7XG52YXIgc3BhZGVzID0gXCLimaBcIjtcbnZhciBzcGFkZXN1aXQgPSBcIuKZoFwiO1xudmFyIHNwYXIgPSBcIuKIpVwiO1xudmFyIHNxY2FwID0gXCLiipNcIjtcbnZhciBzcWNhcHMgPSBcIuKKk++4gFwiO1xudmFyIHNxY3VwID0gXCLiipRcIjtcbnZhciBzcWN1cHMgPSBcIuKKlO+4gFwiO1xudmFyIFNxcnQgPSBcIuKImlwiO1xudmFyIHNxc3ViID0gXCLiio9cIjtcbnZhciBzcXN1YmUgPSBcIuKKkVwiO1xudmFyIHNxc3Vic2V0ID0gXCLiio9cIjtcbnZhciBzcXN1YnNldGVxID0gXCLiipFcIjtcbnZhciBzcXN1cCA9IFwi4oqQXCI7XG52YXIgc3FzdXBlID0gXCLiipJcIjtcbnZhciBzcXN1cHNldCA9IFwi4oqQXCI7XG52YXIgc3FzdXBzZXRlcSA9IFwi4oqSXCI7XG52YXIgc3F1YXJlID0gXCLilqFcIjtcbnZhciBTcXVhcmUgPSBcIuKWoVwiO1xudmFyIFNxdWFyZUludGVyc2VjdGlvbiA9IFwi4oqTXCI7XG52YXIgU3F1YXJlU3Vic2V0ID0gXCLiio9cIjtcbnZhciBTcXVhcmVTdWJzZXRFcXVhbCA9IFwi4oqRXCI7XG52YXIgU3F1YXJlU3VwZXJzZXQgPSBcIuKKkFwiO1xudmFyIFNxdWFyZVN1cGVyc2V0RXF1YWwgPSBcIuKKklwiO1xudmFyIFNxdWFyZVVuaW9uID0gXCLiipRcIjtcbnZhciBzcXVhcmYgPSBcIuKWqlwiO1xudmFyIHNxdSA9IFwi4pahXCI7XG52YXIgc3F1ZiA9IFwi4paqXCI7XG52YXIgc3JhcnIgPSBcIuKGklwiO1xudmFyIFNzY3IgPSBcIvCdkq5cIjtcbnZhciBzc2NyID0gXCLwnZOIXCI7XG52YXIgc3NldG1uID0gXCLiiJZcIjtcbnZhciBzc21pbGUgPSBcIuKMo1wiO1xudmFyIHNzdGFyZiA9IFwi4ouGXCI7XG52YXIgU3RhciA9IFwi4ouGXCI7XG52YXIgc3RhciA9IFwi4piGXCI7XG52YXIgc3RhcmYgPSBcIuKYhVwiO1xudmFyIHN0cmFpZ2h0ZXBzaWxvbiA9IFwiz7VcIjtcbnZhciBzdHJhaWdodHBoaSA9IFwiz5VcIjtcbnZhciBzdHJucyA9IFwiwq9cIjtcbnZhciBzdWIgPSBcIuKKglwiO1xudmFyIFN1YiA9IFwi4ouQXCI7XG52YXIgc3ViZG90ID0gXCLiqr1cIjtcbnZhciBzdWJFID0gXCLiq4VcIjtcbnZhciBzdWJlID0gXCLiioZcIjtcbnZhciBzdWJlZG90ID0gXCLiq4NcIjtcbnZhciBzdWJtdWx0ID0gXCLiq4FcIjtcbnZhciBzdWJuRSA9IFwi4quLXCI7XG52YXIgc3VibmUgPSBcIuKKilwiO1xudmFyIHN1YnBsdXMgPSBcIuKqv1wiO1xudmFyIHN1YnJhcnIgPSBcIuKluVwiO1xudmFyIHN1YnNldCA9IFwi4oqCXCI7XG52YXIgU3Vic2V0ID0gXCLii5BcIjtcbnZhciBzdWJzZXRlcSA9IFwi4oqGXCI7XG52YXIgc3Vic2V0ZXFxID0gXCLiq4VcIjtcbnZhciBTdWJzZXRFcXVhbCA9IFwi4oqGXCI7XG52YXIgc3Vic2V0bmVxID0gXCLiiopcIjtcbnZhciBzdWJzZXRuZXFxID0gXCLiq4tcIjtcbnZhciBzdWJzaW0gPSBcIuKrh1wiO1xudmFyIHN1YnN1YiA9IFwi4quVXCI7XG52YXIgc3Vic3VwID0gXCLiq5NcIjtcbnZhciBzdWNjYXBwcm94ID0gXCLiqrhcIjtcbnZhciBzdWNjID0gXCLiibtcIjtcbnZhciBzdWNjY3VybHllcSA9IFwi4om9XCI7XG52YXIgU3VjY2VlZHMgPSBcIuKJu1wiO1xudmFyIFN1Y2NlZWRzRXF1YWwgPSBcIuKqsFwiO1xudmFyIFN1Y2NlZWRzU2xhbnRFcXVhbCA9IFwi4om9XCI7XG52YXIgU3VjY2VlZHNUaWxkZSA9IFwi4om/XCI7XG52YXIgc3VjY2VxID0gXCLiqrBcIjtcbnZhciBzdWNjbmFwcHJveCA9IFwi4qq6XCI7XG52YXIgc3VjY25lcXEgPSBcIuKqtlwiO1xudmFyIHN1Y2Nuc2ltID0gXCLii6lcIjtcbnZhciBzdWNjc2ltID0gXCLiib9cIjtcbnZhciBTdWNoVGhhdCA9IFwi4oiLXCI7XG52YXIgc3VtID0gXCLiiJFcIjtcbnZhciBTdW0gPSBcIuKIkVwiO1xudmFyIHN1bmcgPSBcIuKZqlwiO1xudmFyIHN1cDEkMSA9IFwiwrlcIjtcbnZhciBzdXAyJDEgPSBcIsKyXCI7XG52YXIgc3VwMyQxID0gXCLCs1wiO1xudmFyIHN1cCA9IFwi4oqDXCI7XG52YXIgU3VwID0gXCLii5FcIjtcbnZhciBzdXBkb3QgPSBcIuKqvlwiO1xudmFyIHN1cGRzdWIgPSBcIuKrmFwiO1xudmFyIHN1cEUgPSBcIuKrhlwiO1xudmFyIHN1cGUgPSBcIuKKh1wiO1xudmFyIHN1cGVkb3QgPSBcIuKrhFwiO1xudmFyIFN1cGVyc2V0ID0gXCLiioNcIjtcbnZhciBTdXBlcnNldEVxdWFsID0gXCLiiodcIjtcbnZhciBzdXBoc29sID0gXCLin4lcIjtcbnZhciBzdXBoc3ViID0gXCLiq5dcIjtcbnZhciBzdXBsYXJyID0gXCLipbtcIjtcbnZhciBzdXBtdWx0ID0gXCLiq4JcIjtcbnZhciBzdXBuRSA9IFwi4quMXCI7XG52YXIgc3VwbmUgPSBcIuKKi1wiO1xudmFyIHN1cHBsdXMgPSBcIuKrgFwiO1xudmFyIHN1cHNldCA9IFwi4oqDXCI7XG52YXIgU3Vwc2V0ID0gXCLii5FcIjtcbnZhciBzdXBzZXRlcSA9IFwi4oqHXCI7XG52YXIgc3Vwc2V0ZXFxID0gXCLiq4ZcIjtcbnZhciBzdXBzZXRuZXEgPSBcIuKKi1wiO1xudmFyIHN1cHNldG5lcXEgPSBcIuKrjFwiO1xudmFyIHN1cHNpbSA9IFwi4quIXCI7XG52YXIgc3Vwc3ViID0gXCLiq5RcIjtcbnZhciBzdXBzdXAgPSBcIuKrllwiO1xudmFyIHN3YXJoayA9IFwi4qSmXCI7XG52YXIgc3dhcnIgPSBcIuKGmVwiO1xudmFyIHN3QXJyID0gXCLih5lcIjtcbnZhciBzd2Fycm93ID0gXCLihplcIjtcbnZhciBzd253YXIgPSBcIuKkqlwiO1xudmFyIHN6bGlnJDEgPSBcIsOfXCI7XG52YXIgVGFiID0gXCJcXHRcIjtcbnZhciB0YXJnZXQgPSBcIuKMllwiO1xudmFyIFRhdSA9IFwizqRcIjtcbnZhciB0YXUgPSBcIs+EXCI7XG52YXIgdGJyayA9IFwi4o60XCI7XG52YXIgVGNhcm9uID0gXCLFpFwiO1xudmFyIHRjYXJvbiA9IFwixaVcIjtcbnZhciBUY2VkaWwgPSBcIsWiXCI7XG52YXIgdGNlZGlsID0gXCLFo1wiO1xudmFyIFRjeSA9IFwi0KJcIjtcbnZhciB0Y3kgPSBcItGCXCI7XG52YXIgdGRvdCA9IFwi4oObXCI7XG52YXIgdGVscmVjID0gXCLijJVcIjtcbnZhciBUZnIgPSBcIvCdlJdcIjtcbnZhciB0ZnIgPSBcIvCdlLFcIjtcbnZhciB0aGVyZTQgPSBcIuKItFwiO1xudmFyIHRoZXJlZm9yZSA9IFwi4oi0XCI7XG52YXIgVGhlcmVmb3JlID0gXCLiiLRcIjtcbnZhciBUaGV0YSA9IFwizphcIjtcbnZhciB0aGV0YSA9IFwizrhcIjtcbnZhciB0aGV0YXN5bSA9IFwiz5FcIjtcbnZhciB0aGV0YXYgPSBcIs+RXCI7XG52YXIgdGhpY2thcHByb3ggPSBcIuKJiFwiO1xudmFyIHRoaWNrc2ltID0gXCLiiLxcIjtcbnZhciBUaGlja1NwYWNlID0gXCLigZ/igIpcIjtcbnZhciBUaGluU3BhY2UgPSBcIuKAiVwiO1xudmFyIHRoaW5zcCA9IFwi4oCJXCI7XG52YXIgdGhrYXAgPSBcIuKJiFwiO1xudmFyIHRoa3NpbSA9IFwi4oi8XCI7XG52YXIgVEhPUk4kMSA9IFwiw55cIjtcbnZhciB0aG9ybiQxID0gXCLDvlwiO1xudmFyIHRpbGRlID0gXCLLnFwiO1xudmFyIFRpbGRlID0gXCLiiLxcIjtcbnZhciBUaWxkZUVxdWFsID0gXCLiiYNcIjtcbnZhciBUaWxkZUZ1bGxFcXVhbCA9IFwi4omFXCI7XG52YXIgVGlsZGVUaWxkZSA9IFwi4omIXCI7XG52YXIgdGltZXNiYXIgPSBcIuKosVwiO1xudmFyIHRpbWVzYiA9IFwi4oqgXCI7XG52YXIgdGltZXMkMSA9IFwiw5dcIjtcbnZhciB0aW1lc2QgPSBcIuKosFwiO1xudmFyIHRpbnQgPSBcIuKIrVwiO1xudmFyIHRvZWEgPSBcIuKkqFwiO1xudmFyIHRvcGJvdCA9IFwi4oy2XCI7XG52YXIgdG9wY2lyID0gXCLiq7FcIjtcbnZhciB0b3AgPSBcIuKKpFwiO1xudmFyIFRvcGYgPSBcIvCdlYtcIjtcbnZhciB0b3BmID0gXCLwnZWlXCI7XG52YXIgdG9wZm9yayA9IFwi4quaXCI7XG52YXIgdG9zYSA9IFwi4qSpXCI7XG52YXIgdHByaW1lID0gXCLigLRcIjtcbnZhciB0cmFkZSA9IFwi4oSiXCI7XG52YXIgVFJBREUgPSBcIuKEolwiO1xudmFyIHRyaWFuZ2xlID0gXCLilrVcIjtcbnZhciB0cmlhbmdsZWRvd24gPSBcIuKWv1wiO1xudmFyIHRyaWFuZ2xlbGVmdCA9IFwi4peDXCI7XG52YXIgdHJpYW5nbGVsZWZ0ZXEgPSBcIuKKtFwiO1xudmFyIHRyaWFuZ2xlcSA9IFwi4omcXCI7XG52YXIgdHJpYW5nbGVyaWdodCA9IFwi4pa5XCI7XG52YXIgdHJpYW5nbGVyaWdodGVxID0gXCLiirVcIjtcbnZhciB0cmlkb3QgPSBcIuKXrFwiO1xudmFyIHRyaWUgPSBcIuKJnFwiO1xudmFyIHRyaW1pbnVzID0gXCLiqLpcIjtcbnZhciBUcmlwbGVEb3QgPSBcIuKDm1wiO1xudmFyIHRyaXBsdXMgPSBcIuKouVwiO1xudmFyIHRyaXNiID0gXCLip41cIjtcbnZhciB0cml0aW1lID0gXCLiqLtcIjtcbnZhciB0cnBleml1bSA9IFwi4o+iXCI7XG52YXIgVHNjciA9IFwi8J2Sr1wiO1xudmFyIHRzY3IgPSBcIvCdk4lcIjtcbnZhciBUU2N5ID0gXCLQplwiO1xudmFyIHRzY3kgPSBcItGGXCI7XG52YXIgVFNIY3kgPSBcItCLXCI7XG52YXIgdHNoY3kgPSBcItGbXCI7XG52YXIgVHN0cm9rID0gXCLFplwiO1xudmFyIHRzdHJvayA9IFwixadcIjtcbnZhciB0d2l4dCA9IFwi4omsXCI7XG52YXIgdHdvaGVhZGxlZnRhcnJvdyA9IFwi4oaeXCI7XG52YXIgdHdvaGVhZHJpZ2h0YXJyb3cgPSBcIuKGoFwiO1xudmFyIFVhY3V0ZSQxID0gXCLDmlwiO1xudmFyIHVhY3V0ZSQxID0gXCLDulwiO1xudmFyIHVhcnIgPSBcIuKGkVwiO1xudmFyIFVhcnIgPSBcIuKGn1wiO1xudmFyIHVBcnIgPSBcIuKHkVwiO1xudmFyIFVhcnJvY2lyID0gXCLipYlcIjtcbnZhciBVYnJjeSA9IFwi0I5cIjtcbnZhciB1YnJjeSA9IFwi0Z5cIjtcbnZhciBVYnJldmUgPSBcIsWsXCI7XG52YXIgdWJyZXZlID0gXCLFrVwiO1xudmFyIFVjaXJjJDEgPSBcIsObXCI7XG52YXIgdWNpcmMkMSA9IFwiw7tcIjtcbnZhciBVY3kgPSBcItCjXCI7XG52YXIgdWN5ID0gXCLRg1wiO1xudmFyIHVkYXJyID0gXCLih4VcIjtcbnZhciBVZGJsYWMgPSBcIsWwXCI7XG52YXIgdWRibGFjID0gXCLFsVwiO1xudmFyIHVkaGFyID0gXCLipa5cIjtcbnZhciB1ZmlzaHQgPSBcIuKlvlwiO1xudmFyIFVmciA9IFwi8J2UmFwiO1xudmFyIHVmciA9IFwi8J2UslwiO1xudmFyIFVncmF2ZSQxID0gXCLDmVwiO1xudmFyIHVncmF2ZSQxID0gXCLDuVwiO1xudmFyIHVIYXIgPSBcIuKlo1wiO1xudmFyIHVoYXJsID0gXCLihr9cIjtcbnZhciB1aGFyciA9IFwi4oa+XCI7XG52YXIgdWhibGsgPSBcIuKWgFwiO1xudmFyIHVsY29ybiA9IFwi4oycXCI7XG52YXIgdWxjb3JuZXIgPSBcIuKMnFwiO1xudmFyIHVsY3JvcCA9IFwi4oyPXCI7XG52YXIgdWx0cmkgPSBcIuKXuFwiO1xudmFyIFVtYWNyID0gXCLFqlwiO1xudmFyIHVtYWNyID0gXCLFq1wiO1xudmFyIHVtbCQxID0gXCLCqFwiO1xudmFyIFVuZGVyQmFyID0gXCJfXCI7XG52YXIgVW5kZXJCcmFjZSA9IFwi4o+fXCI7XG52YXIgVW5kZXJCcmFja2V0ID0gXCLijrVcIjtcbnZhciBVbmRlclBhcmVudGhlc2lzID0gXCLij51cIjtcbnZhciBVbmlvbiA9IFwi4ouDXCI7XG52YXIgVW5pb25QbHVzID0gXCLiio5cIjtcbnZhciBVb2dvbiA9IFwixbJcIjtcbnZhciB1b2dvbiA9IFwixbNcIjtcbnZhciBVb3BmID0gXCLwnZWMXCI7XG52YXIgdW9wZiA9IFwi8J2VplwiO1xudmFyIFVwQXJyb3dCYXIgPSBcIuKkklwiO1xudmFyIHVwYXJyb3cgPSBcIuKGkVwiO1xudmFyIFVwQXJyb3cgPSBcIuKGkVwiO1xudmFyIFVwYXJyb3cgPSBcIuKHkVwiO1xudmFyIFVwQXJyb3dEb3duQXJyb3cgPSBcIuKHhVwiO1xudmFyIHVwZG93bmFycm93ID0gXCLihpVcIjtcbnZhciBVcERvd25BcnJvdyA9IFwi4oaVXCI7XG52YXIgVXBkb3duYXJyb3cgPSBcIuKHlVwiO1xudmFyIFVwRXF1aWxpYnJpdW0gPSBcIuKlrlwiO1xudmFyIHVwaGFycG9vbmxlZnQgPSBcIuKGv1wiO1xudmFyIHVwaGFycG9vbnJpZ2h0ID0gXCLihr5cIjtcbnZhciB1cGx1cyA9IFwi4oqOXCI7XG52YXIgVXBwZXJMZWZ0QXJyb3cgPSBcIuKGllwiO1xudmFyIFVwcGVyUmlnaHRBcnJvdyA9IFwi4oaXXCI7XG52YXIgdXBzaSA9IFwiz4VcIjtcbnZhciBVcHNpID0gXCLPklwiO1xudmFyIHVwc2loID0gXCLPklwiO1xudmFyIFVwc2lsb24gPSBcIs6lXCI7XG52YXIgdXBzaWxvbiA9IFwiz4VcIjtcbnZhciBVcFRlZUFycm93ID0gXCLihqVcIjtcbnZhciBVcFRlZSA9IFwi4oqlXCI7XG52YXIgdXB1cGFycm93cyA9IFwi4oeIXCI7XG52YXIgdXJjb3JuID0gXCLijJ1cIjtcbnZhciB1cmNvcm5lciA9IFwi4oydXCI7XG52YXIgdXJjcm9wID0gXCLijI5cIjtcbnZhciBVcmluZyA9IFwixa5cIjtcbnZhciB1cmluZyA9IFwixa9cIjtcbnZhciB1cnRyaSA9IFwi4pe5XCI7XG52YXIgVXNjciA9IFwi8J2SsFwiO1xudmFyIHVzY3IgPSBcIvCdk4pcIjtcbnZhciB1dGRvdCA9IFwi4ouwXCI7XG52YXIgVXRpbGRlID0gXCLFqFwiO1xudmFyIHV0aWxkZSA9IFwixalcIjtcbnZhciB1dHJpID0gXCLilrVcIjtcbnZhciB1dHJpZiA9IFwi4pa0XCI7XG52YXIgdXVhcnIgPSBcIuKHiFwiO1xudmFyIFV1bWwkMSA9IFwiw5xcIjtcbnZhciB1dW1sJDEgPSBcIsO8XCI7XG52YXIgdXdhbmdsZSA9IFwi4qanXCI7XG52YXIgdmFuZ3J0ID0gXCLippxcIjtcbnZhciB2YXJlcHNpbG9uID0gXCLPtVwiO1xudmFyIHZhcmthcHBhID0gXCLPsFwiO1xudmFyIHZhcm5vdGhpbmcgPSBcIuKIhVwiO1xudmFyIHZhcnBoaSA9IFwiz5VcIjtcbnZhciB2YXJwaSA9IFwiz5ZcIjtcbnZhciB2YXJwcm9wdG8gPSBcIuKInVwiO1xudmFyIHZhcnIgPSBcIuKGlVwiO1xudmFyIHZBcnIgPSBcIuKHlVwiO1xudmFyIHZhcnJobyA9IFwiz7FcIjtcbnZhciB2YXJzaWdtYSA9IFwiz4JcIjtcbnZhciB2YXJzdWJzZXRuZXEgPSBcIuKKiu+4gFwiO1xudmFyIHZhcnN1YnNldG5lcXEgPSBcIuKri++4gFwiO1xudmFyIHZhcnN1cHNldG5lcSA9IFwi4oqL77iAXCI7XG52YXIgdmFyc3Vwc2V0bmVxcSA9IFwi4quM77iAXCI7XG52YXIgdmFydGhldGEgPSBcIs+RXCI7XG52YXIgdmFydHJpYW5nbGVsZWZ0ID0gXCLiirJcIjtcbnZhciB2YXJ0cmlhbmdsZXJpZ2h0ID0gXCLiirNcIjtcbnZhciB2QmFyID0gXCLiq6hcIjtcbnZhciBWYmFyID0gXCLiq6tcIjtcbnZhciB2QmFydiA9IFwi4qupXCI7XG52YXIgVmN5ID0gXCLQklwiO1xudmFyIHZjeSA9IFwi0LJcIjtcbnZhciB2ZGFzaCA9IFwi4oqiXCI7XG52YXIgdkRhc2ggPSBcIuKKqFwiO1xudmFyIFZkYXNoID0gXCLiiqlcIjtcbnZhciBWRGFzaCA9IFwi4oqrXCI7XG52YXIgVmRhc2hsID0gXCLiq6ZcIjtcbnZhciB2ZWViYXIgPSBcIuKKu1wiO1xudmFyIHZlZSA9IFwi4oioXCI7XG52YXIgVmVlID0gXCLii4FcIjtcbnZhciB2ZWVlcSA9IFwi4omaXCI7XG52YXIgdmVsbGlwID0gXCLii65cIjtcbnZhciB2ZXJiYXIgPSBcInxcIjtcbnZhciBWZXJiYXIgPSBcIuKAllwiO1xudmFyIHZlcnQgPSBcInxcIjtcbnZhciBWZXJ0ID0gXCLigJZcIjtcbnZhciBWZXJ0aWNhbEJhciA9IFwi4oijXCI7XG52YXIgVmVydGljYWxMaW5lID0gXCJ8XCI7XG52YXIgVmVydGljYWxTZXBhcmF0b3IgPSBcIuKdmFwiO1xudmFyIFZlcnRpY2FsVGlsZGUgPSBcIuKJgFwiO1xudmFyIFZlcnlUaGluU3BhY2UgPSBcIuKAilwiO1xudmFyIFZmciA9IFwi8J2UmVwiO1xudmFyIHZmciA9IFwi8J2Us1wiO1xudmFyIHZsdHJpID0gXCLiirJcIjtcbnZhciB2bnN1YiA9IFwi4oqC4oOSXCI7XG52YXIgdm5zdXAgPSBcIuKKg+KDklwiO1xudmFyIFZvcGYgPSBcIvCdlY1cIjtcbnZhciB2b3BmID0gXCLwnZWnXCI7XG52YXIgdnByb3AgPSBcIuKInVwiO1xudmFyIHZydHJpID0gXCLiirNcIjtcbnZhciBWc2NyID0gXCLwnZKxXCI7XG52YXIgdnNjciA9IFwi8J2Ti1wiO1xudmFyIHZzdWJuRSA9IFwi4quL77iAXCI7XG52YXIgdnN1Ym5lID0gXCLiiorvuIBcIjtcbnZhciB2c3VwbkUgPSBcIuKrjO+4gFwiO1xudmFyIHZzdXBuZSA9IFwi4oqL77iAXCI7XG52YXIgVnZkYXNoID0gXCLiiqpcIjtcbnZhciB2emlnemFnID0gXCLipppcIjtcbnZhciBXY2lyYyA9IFwixbRcIjtcbnZhciB3Y2lyYyA9IFwixbVcIjtcbnZhciB3ZWRiYXIgPSBcIuKpn1wiO1xudmFyIHdlZGdlID0gXCLiiKdcIjtcbnZhciBXZWRnZSA9IFwi4ouAXCI7XG52YXIgd2VkZ2VxID0gXCLiiZlcIjtcbnZhciB3ZWllcnAgPSBcIuKEmFwiO1xudmFyIFdmciA9IFwi8J2UmlwiO1xudmFyIHdmciA9IFwi8J2UtFwiO1xudmFyIFdvcGYgPSBcIvCdlY5cIjtcbnZhciB3b3BmID0gXCLwnZWoXCI7XG52YXIgd3AgPSBcIuKEmFwiO1xudmFyIHdyID0gXCLiiYBcIjtcbnZhciB3cmVhdGggPSBcIuKJgFwiO1xudmFyIFdzY3IgPSBcIvCdkrJcIjtcbnZhciB3c2NyID0gXCLwnZOMXCI7XG52YXIgeGNhcCA9IFwi4ouCXCI7XG52YXIgeGNpcmMgPSBcIuKXr1wiO1xudmFyIHhjdXAgPSBcIuKLg1wiO1xudmFyIHhkdHJpID0gXCLilr1cIjtcbnZhciBYZnIgPSBcIvCdlJtcIjtcbnZhciB4ZnIgPSBcIvCdlLVcIjtcbnZhciB4aGFyciA9IFwi4p+3XCI7XG52YXIgeGhBcnIgPSBcIuKfulwiO1xudmFyIFhpID0gXCLOnlwiO1xudmFyIHhpID0gXCLOvlwiO1xudmFyIHhsYXJyID0gXCLin7VcIjtcbnZhciB4bEFyciA9IFwi4p+4XCI7XG52YXIgeG1hcCA9IFwi4p+8XCI7XG52YXIgeG5pcyA9IFwi4ou7XCI7XG52YXIgeG9kb3QgPSBcIuKogFwiO1xudmFyIFhvcGYgPSBcIvCdlY9cIjtcbnZhciB4b3BmID0gXCLwnZWpXCI7XG52YXIgeG9wbHVzID0gXCLiqIFcIjtcbnZhciB4b3RpbWUgPSBcIuKoglwiO1xudmFyIHhyYXJyID0gXCLin7ZcIjtcbnZhciB4ckFyciA9IFwi4p+5XCI7XG52YXIgWHNjciA9IFwi8J2Ss1wiO1xudmFyIHhzY3IgPSBcIvCdk41cIjtcbnZhciB4c3FjdXAgPSBcIuKohlwiO1xudmFyIHh1cGx1cyA9IFwi4qiEXCI7XG52YXIgeHV0cmkgPSBcIuKWs1wiO1xudmFyIHh2ZWUgPSBcIuKLgVwiO1xudmFyIHh3ZWRnZSA9IFwi4ouAXCI7XG52YXIgWWFjdXRlJDEgPSBcIsOdXCI7XG52YXIgeWFjdXRlJDEgPSBcIsO9XCI7XG52YXIgWUFjeSA9IFwi0K9cIjtcbnZhciB5YWN5ID0gXCLRj1wiO1xudmFyIFljaXJjID0gXCLFtlwiO1xudmFyIHljaXJjID0gXCLFt1wiO1xudmFyIFljeSA9IFwi0KtcIjtcbnZhciB5Y3kgPSBcItGLXCI7XG52YXIgeWVuJDEgPSBcIsKlXCI7XG52YXIgWWZyID0gXCLwnZScXCI7XG52YXIgeWZyID0gXCLwnZS2XCI7XG52YXIgWUljeSA9IFwi0IdcIjtcbnZhciB5aWN5ID0gXCLRl1wiO1xudmFyIFlvcGYgPSBcIvCdlZBcIjtcbnZhciB5b3BmID0gXCLwnZWqXCI7XG52YXIgWXNjciA9IFwi8J2StFwiO1xudmFyIHlzY3IgPSBcIvCdk45cIjtcbnZhciBZVWN5ID0gXCLQrlwiO1xudmFyIHl1Y3kgPSBcItGOXCI7XG52YXIgeXVtbCQxID0gXCLDv1wiO1xudmFyIFl1bWwgPSBcIsW4XCI7XG52YXIgWmFjdXRlID0gXCLFuVwiO1xudmFyIHphY3V0ZSA9IFwixbpcIjtcbnZhciBaY2Fyb24gPSBcIsW9XCI7XG52YXIgemNhcm9uID0gXCLFvlwiO1xudmFyIFpjeSA9IFwi0JdcIjtcbnZhciB6Y3kgPSBcItC3XCI7XG52YXIgWmRvdCA9IFwixbtcIjtcbnZhciB6ZG90ID0gXCLFvFwiO1xudmFyIHplZXRyZiA9IFwi4oSoXCI7XG52YXIgWmVyb1dpZHRoU3BhY2UgPSBcIuKAi1wiO1xudmFyIFpldGEgPSBcIs6WXCI7XG52YXIgemV0YSA9IFwizrZcIjtcbnZhciB6ZnIgPSBcIvCdlLdcIjtcbnZhciBaZnIgPSBcIuKEqFwiO1xudmFyIFpIY3kgPSBcItCWXCI7XG52YXIgemhjeSA9IFwi0LZcIjtcbnZhciB6aWdyYXJyID0gXCLih51cIjtcbnZhciB6b3BmID0gXCLwnZWrXCI7XG52YXIgWm9wZiA9IFwi4oSkXCI7XG52YXIgWnNjciA9IFwi8J2StVwiO1xudmFyIHpzY3IgPSBcIvCdk49cIjtcbnZhciB6d2ogPSBcIuKAjVwiO1xudmFyIHp3bmogPSBcIuKAjFwiO1xudmFyIHJlcXVpcmUkJDEkMSA9IHtcblx0QWFjdXRlOiBBYWN1dGUkMSxcblx0YWFjdXRlOiBhYWN1dGUkMSxcblx0QWJyZXZlOiBBYnJldmUsXG5cdGFicmV2ZTogYWJyZXZlLFxuXHRhYzogYWMsXG5cdGFjZDogYWNkLFxuXHRhY0U6IGFjRSxcblx0QWNpcmM6IEFjaXJjJDEsXG5cdGFjaXJjOiBhY2lyYyQxLFxuXHRhY3V0ZTogYWN1dGUkMSxcblx0QWN5OiBBY3ksXG5cdGFjeTogYWN5LFxuXHRBRWxpZzogQUVsaWckMSxcblx0YWVsaWc6IGFlbGlnJDEsXG5cdGFmOiBhZixcblx0QWZyOiBBZnIsXG5cdGFmcjogYWZyLFxuXHRBZ3JhdmU6IEFncmF2ZSQxLFxuXHRhZ3JhdmU6IGFncmF2ZSQxLFxuXHRhbGVmc3ltOiBhbGVmc3ltLFxuXHRhbGVwaDogYWxlcGgsXG5cdEFscGhhOiBBbHBoYSxcblx0YWxwaGE6IGFscGhhLFxuXHRBbWFjcjogQW1hY3IsXG5cdGFtYWNyOiBhbWFjcixcblx0YW1hbGc6IGFtYWxnLFxuXHRhbXA6IGFtcCQyLFxuXHRBTVA6IEFNUCQxLFxuXHRhbmRhbmQ6IGFuZGFuZCxcblx0QW5kOiBBbmQsXG5cdGFuZDogYW5kLFxuXHRhbmRkOiBhbmRkLFxuXHRhbmRzbG9wZTogYW5kc2xvcGUsXG5cdGFuZHY6IGFuZHYsXG5cdGFuZzogYW5nLFxuXHRhbmdlOiBhbmdlLFxuXHRhbmdsZTogYW5nbGUsXG5cdGFuZ21zZGFhOiBhbmdtc2RhYSxcblx0YW5nbXNkYWI6IGFuZ21zZGFiLFxuXHRhbmdtc2RhYzogYW5nbXNkYWMsXG5cdGFuZ21zZGFkOiBhbmdtc2RhZCxcblx0YW5nbXNkYWU6IGFuZ21zZGFlLFxuXHRhbmdtc2RhZjogYW5nbXNkYWYsXG5cdGFuZ21zZGFnOiBhbmdtc2RhZyxcblx0YW5nbXNkYWg6IGFuZ21zZGFoLFxuXHRhbmdtc2Q6IGFuZ21zZCxcblx0YW5ncnQ6IGFuZ3J0LFxuXHRhbmdydHZiOiBhbmdydHZiLFxuXHRhbmdydHZiZDogYW5ncnR2YmQsXG5cdGFuZ3NwaDogYW5nc3BoLFxuXHRhbmdzdDogYW5nc3QsXG5cdGFuZ3phcnI6IGFuZ3phcnIsXG5cdEFvZ29uOiBBb2dvbixcblx0YW9nb246IGFvZ29uLFxuXHRBb3BmOiBBb3BmLFxuXHRhb3BmOiBhb3BmLFxuXHRhcGFjaXI6IGFwYWNpcixcblx0YXA6IGFwLFxuXHRhcEU6IGFwRSxcblx0YXBlOiBhcGUsXG5cdGFwaWQ6IGFwaWQsXG5cdGFwb3M6IGFwb3MkMSxcblx0QXBwbHlGdW5jdGlvbjogQXBwbHlGdW5jdGlvbixcblx0YXBwcm94OiBhcHByb3gsXG5cdGFwcHJveGVxOiBhcHByb3hlcSxcblx0QXJpbmc6IEFyaW5nJDEsXG5cdGFyaW5nOiBhcmluZyQxLFxuXHRBc2NyOiBBc2NyLFxuXHRhc2NyOiBhc2NyLFxuXHRBc3NpZ246IEFzc2lnbixcblx0YXN0OiBhc3QsXG5cdGFzeW1wOiBhc3ltcCxcblx0YXN5bXBlcTogYXN5bXBlcSxcblx0QXRpbGRlOiBBdGlsZGUkMSxcblx0YXRpbGRlOiBhdGlsZGUkMSxcblx0QXVtbDogQXVtbCQxLFxuXHRhdW1sOiBhdW1sJDEsXG5cdGF3Y29uaW50OiBhd2NvbmludCxcblx0YXdpbnQ6IGF3aW50LFxuXHRiYWNrY29uZzogYmFja2NvbmcsXG5cdGJhY2tlcHNpbG9uOiBiYWNrZXBzaWxvbixcblx0YmFja3ByaW1lOiBiYWNrcHJpbWUsXG5cdGJhY2tzaW06IGJhY2tzaW0sXG5cdGJhY2tzaW1lcTogYmFja3NpbWVxLFxuXHRCYWNrc2xhc2g6IEJhY2tzbGFzaCxcblx0QmFydjogQmFydixcblx0YmFydmVlOiBiYXJ2ZWUsXG5cdGJhcndlZDogYmFyd2VkLFxuXHRCYXJ3ZWQ6IEJhcndlZCxcblx0YmFyd2VkZ2U6IGJhcndlZGdlLFxuXHRiYnJrOiBiYnJrLFxuXHRiYnJrdGJyazogYmJya3RicmssXG5cdGJjb25nOiBiY29uZyxcblx0QmN5OiBCY3ksXG5cdGJjeTogYmN5LFxuXHRiZHF1bzogYmRxdW8sXG5cdGJlY2F1czogYmVjYXVzLFxuXHRiZWNhdXNlOiBiZWNhdXNlLFxuXHRCZWNhdXNlOiBCZWNhdXNlLFxuXHRiZW1wdHl2OiBiZW1wdHl2LFxuXHRiZXBzaTogYmVwc2ksXG5cdGJlcm5vdTogYmVybm91LFxuXHRCZXJub3VsbGlzOiBCZXJub3VsbGlzLFxuXHRCZXRhOiBCZXRhLFxuXHRiZXRhOiBiZXRhLFxuXHRiZXRoOiBiZXRoLFxuXHRiZXR3ZWVuOiBiZXR3ZWVuLFxuXHRCZnI6IEJmcixcblx0YmZyOiBiZnIsXG5cdGJpZ2NhcDogYmlnY2FwLFxuXHRiaWdjaXJjOiBiaWdjaXJjLFxuXHRiaWdjdXA6IGJpZ2N1cCxcblx0Ymlnb2RvdDogYmlnb2RvdCxcblx0Ymlnb3BsdXM6IGJpZ29wbHVzLFxuXHRiaWdvdGltZXM6IGJpZ290aW1lcyxcblx0Ymlnc3FjdXA6IGJpZ3NxY3VwLFxuXHRiaWdzdGFyOiBiaWdzdGFyLFxuXHRiaWd0cmlhbmdsZWRvd246IGJpZ3RyaWFuZ2xlZG93bixcblx0YmlndHJpYW5nbGV1cDogYmlndHJpYW5nbGV1cCxcblx0YmlndXBsdXM6IGJpZ3VwbHVzLFxuXHRiaWd2ZWU6IGJpZ3ZlZSxcblx0Ymlnd2VkZ2U6IGJpZ3dlZGdlLFxuXHRia2Fyb3c6IGJrYXJvdyxcblx0YmxhY2tsb3plbmdlOiBibGFja2xvemVuZ2UsXG5cdGJsYWNrc3F1YXJlOiBibGFja3NxdWFyZSxcblx0YmxhY2t0cmlhbmdsZTogYmxhY2t0cmlhbmdsZSxcblx0YmxhY2t0cmlhbmdsZWRvd246IGJsYWNrdHJpYW5nbGVkb3duLFxuXHRibGFja3RyaWFuZ2xlbGVmdDogYmxhY2t0cmlhbmdsZWxlZnQsXG5cdGJsYWNrdHJpYW5nbGVyaWdodDogYmxhY2t0cmlhbmdsZXJpZ2h0LFxuXHRibGFuazogYmxhbmssXG5cdGJsazEyOiBibGsxMixcblx0YmxrMTQ6IGJsazE0LFxuXHRibGszNDogYmxrMzQsXG5cdGJsb2NrOiBibG9jayxcblx0Ym5lOiBibmUsXG5cdGJuZXF1aXY6IGJuZXF1aXYsXG5cdGJOb3Q6IGJOb3QsXG5cdGJub3Q6IGJub3QsXG5cdEJvcGY6IEJvcGYsXG5cdGJvcGY6IGJvcGYsXG5cdGJvdDogYm90LFxuXHRib3R0b206IGJvdHRvbSxcblx0Ym93dGllOiBib3d0aWUsXG5cdGJveGJveDogYm94Ym94LFxuXHRib3hkbDogYm94ZGwsXG5cdGJveGRMOiBib3hkTCxcblx0Ym94RGw6IGJveERsLFxuXHRib3hETDogYm94REwsXG5cdGJveGRyOiBib3hkcixcblx0Ym94ZFI6IGJveGRSLFxuXHRib3hEcjogYm94RHIsXG5cdGJveERSOiBib3hEUixcblx0Ym94aDogYm94aCxcblx0Ym94SDogYm94SCxcblx0Ym94aGQ6IGJveGhkLFxuXHRib3hIZDogYm94SGQsXG5cdGJveGhEOiBib3hoRCxcblx0Ym94SEQ6IGJveEhELFxuXHRib3hodTogYm94aHUsXG5cdGJveEh1OiBib3hIdSxcblx0Ym94aFU6IGJveGhVLFxuXHRib3hIVTogYm94SFUsXG5cdGJveG1pbnVzOiBib3htaW51cyxcblx0Ym94cGx1czogYm94cGx1cyxcblx0Ym94dGltZXM6IGJveHRpbWVzLFxuXHRib3h1bDogYm94dWwsXG5cdGJveHVMOiBib3h1TCxcblx0Ym94VWw6IGJveFVsLFxuXHRib3hVTDogYm94VUwsXG5cdGJveHVyOiBib3h1cixcblx0Ym94dVI6IGJveHVSLFxuXHRib3hVcjogYm94VXIsXG5cdGJveFVSOiBib3hVUixcblx0Ym94djogYm94dixcblx0Ym94VjogYm94Vixcblx0Ym94dmg6IGJveHZoLFxuXHRib3h2SDogYm94dkgsXG5cdGJveFZoOiBib3hWaCxcblx0Ym94Vkg6IGJveFZILFxuXHRib3h2bDogYm94dmwsXG5cdGJveHZMOiBib3h2TCxcblx0Ym94Vmw6IGJveFZsLFxuXHRib3hWTDogYm94VkwsXG5cdGJveHZyOiBib3h2cixcblx0Ym94dlI6IGJveHZSLFxuXHRib3hWcjogYm94VnIsXG5cdGJveFZSOiBib3hWUixcblx0YnByaW1lOiBicHJpbWUsXG5cdGJyZXZlOiBicmV2ZSxcblx0QnJldmU6IEJyZXZlLFxuXHRicnZiYXI6IGJydmJhciQxLFxuXHRic2NyOiBic2NyLFxuXHRCc2NyOiBCc2NyLFxuXHRic2VtaTogYnNlbWksXG5cdGJzaW06IGJzaW0sXG5cdGJzaW1lOiBic2ltZSxcblx0YnNvbGI6IGJzb2xiLFxuXHRic29sOiBic29sLFxuXHRic29saHN1YjogYnNvbGhzdWIsXG5cdGJ1bGw6IGJ1bGwsXG5cdGJ1bGxldDogYnVsbGV0LFxuXHRidW1wOiBidW1wLFxuXHRidW1wRTogYnVtcEUsXG5cdGJ1bXBlOiBidW1wZSxcblx0QnVtcGVxOiBCdW1wZXEsXG5cdGJ1bXBlcTogYnVtcGVxLFxuXHRDYWN1dGU6IENhY3V0ZSxcblx0Y2FjdXRlOiBjYWN1dGUsXG5cdGNhcGFuZDogY2FwYW5kLFxuXHRjYXBicmN1cDogY2FwYnJjdXAsXG5cdGNhcGNhcDogY2FwY2FwLFxuXHRjYXA6IGNhcCxcblx0Q2FwOiBDYXAsXG5cdGNhcGN1cDogY2FwY3VwLFxuXHRjYXBkb3Q6IGNhcGRvdCxcblx0Q2FwaXRhbERpZmZlcmVudGlhbEQ6IENhcGl0YWxEaWZmZXJlbnRpYWxELFxuXHRjYXBzOiBjYXBzLFxuXHRjYXJldDogY2FyZXQsXG5cdGNhcm9uOiBjYXJvbixcblx0Q2F5bGV5czogQ2F5bGV5cyxcblx0Y2NhcHM6IGNjYXBzLFxuXHRDY2Fyb246IENjYXJvbixcblx0Y2Nhcm9uOiBjY2Fyb24sXG5cdENjZWRpbDogQ2NlZGlsJDEsXG5cdGNjZWRpbDogY2NlZGlsJDEsXG5cdENjaXJjOiBDY2lyYyxcblx0Y2NpcmM6IGNjaXJjLFxuXHRDY29uaW50OiBDY29uaW50LFxuXHRjY3VwczogY2N1cHMsXG5cdGNjdXBzc206IGNjdXBzc20sXG5cdENkb3Q6IENkb3QsXG5cdGNkb3Q6IGNkb3QsXG5cdGNlZGlsOiBjZWRpbCQxLFxuXHRDZWRpbGxhOiBDZWRpbGxhLFxuXHRjZW1wdHl2OiBjZW1wdHl2LFxuXHRjZW50OiBjZW50JDEsXG5cdGNlbnRlcmRvdDogY2VudGVyZG90LFxuXHRDZW50ZXJEb3Q6IENlbnRlckRvdCxcblx0Y2ZyOiBjZnIsXG5cdENmcjogQ2ZyLFxuXHRDSGN5OiBDSGN5LFxuXHRjaGN5OiBjaGN5LFxuXHRjaGVjazogY2hlY2ssXG5cdGNoZWNrbWFyazogY2hlY2ttYXJrLFxuXHRDaGk6IENoaSxcblx0Y2hpOiBjaGksXG5cdGNpcmM6IGNpcmMsXG5cdGNpcmNlcTogY2lyY2VxLFxuXHRjaXJjbGVhcnJvd2xlZnQ6IGNpcmNsZWFycm93bGVmdCxcblx0Y2lyY2xlYXJyb3dyaWdodDogY2lyY2xlYXJyb3dyaWdodCxcblx0Y2lyY2xlZGFzdDogY2lyY2xlZGFzdCxcblx0Y2lyY2xlZGNpcmM6IGNpcmNsZWRjaXJjLFxuXHRjaXJjbGVkZGFzaDogY2lyY2xlZGRhc2gsXG5cdENpcmNsZURvdDogQ2lyY2xlRG90LFxuXHRjaXJjbGVkUjogY2lyY2xlZFIsXG5cdGNpcmNsZWRTOiBjaXJjbGVkUyxcblx0Q2lyY2xlTWludXM6IENpcmNsZU1pbnVzLFxuXHRDaXJjbGVQbHVzOiBDaXJjbGVQbHVzLFxuXHRDaXJjbGVUaW1lczogQ2lyY2xlVGltZXMsXG5cdGNpcjogY2lyLFxuXHRjaXJFOiBjaXJFLFxuXHRjaXJlOiBjaXJlLFxuXHRjaXJmbmludDogY2lyZm5pbnQsXG5cdGNpcm1pZDogY2lybWlkLFxuXHRjaXJzY2lyOiBjaXJzY2lyLFxuXHRDbG9ja3dpc2VDb250b3VySW50ZWdyYWw6IENsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCxcblx0Q2xvc2VDdXJseURvdWJsZVF1b3RlOiBDbG9zZUN1cmx5RG91YmxlUXVvdGUsXG5cdENsb3NlQ3VybHlRdW90ZTogQ2xvc2VDdXJseVF1b3RlLFxuXHRjbHViczogY2x1YnMsXG5cdGNsdWJzdWl0OiBjbHVic3VpdCxcblx0Y29sb246IGNvbG9uLFxuXHRDb2xvbjogQ29sb24sXG5cdENvbG9uZTogQ29sb25lLFxuXHRjb2xvbmU6IGNvbG9uZSxcblx0Y29sb25lcTogY29sb25lcSxcblx0Y29tbWE6IGNvbW1hLFxuXHRjb21tYXQ6IGNvbW1hdCxcblx0Y29tcDogY29tcCxcblx0Y29tcGZuOiBjb21wZm4sXG5cdGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQsXG5cdGNvbXBsZXhlczogY29tcGxleGVzLFxuXHRjb25nOiBjb25nLFxuXHRjb25nZG90OiBjb25nZG90LFxuXHRDb25ncnVlbnQ6IENvbmdydWVudCxcblx0Y29uaW50OiBjb25pbnQsXG5cdENvbmludDogQ29uaW50LFxuXHRDb250b3VySW50ZWdyYWw6IENvbnRvdXJJbnRlZ3JhbCxcblx0Y29wZjogY29wZixcblx0Q29wZjogQ29wZixcblx0Y29wcm9kOiBjb3Byb2QsXG5cdENvcHJvZHVjdDogQ29wcm9kdWN0LFxuXHRjb3B5OiBjb3B5JDEsXG5cdENPUFk6IENPUFkkMSxcblx0Y29weXNyOiBjb3B5c3IsXG5cdENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw6IENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwsXG5cdGNyYXJyOiBjcmFycixcblx0Y3Jvc3M6IGNyb3NzLFxuXHRDcm9zczogQ3Jvc3MsXG5cdENzY3I6IENzY3IsXG5cdGNzY3I6IGNzY3IsXG5cdGNzdWI6IGNzdWIsXG5cdGNzdWJlOiBjc3ViZSxcblx0Y3N1cDogY3N1cCxcblx0Y3N1cGU6IGNzdXBlLFxuXHRjdGRvdDogY3Rkb3QsXG5cdGN1ZGFycmw6IGN1ZGFycmwsXG5cdGN1ZGFycnI6IGN1ZGFycnIsXG5cdGN1ZXByOiBjdWVwcixcblx0Y3Vlc2M6IGN1ZXNjLFxuXHRjdWxhcnI6IGN1bGFycixcblx0Y3VsYXJycDogY3VsYXJycCxcblx0Y3VwYnJjYXA6IGN1cGJyY2FwLFxuXHRjdXBjYXA6IGN1cGNhcCxcblx0Q3VwQ2FwOiBDdXBDYXAsXG5cdGN1cDogY3VwLFxuXHRDdXA6IEN1cCxcblx0Y3VwY3VwOiBjdXBjdXAsXG5cdGN1cGRvdDogY3VwZG90LFxuXHRjdXBvcjogY3Vwb3IsXG5cdGN1cHM6IGN1cHMsXG5cdGN1cmFycjogY3VyYXJyLFxuXHRjdXJhcnJtOiBjdXJhcnJtLFxuXHRjdXJseWVxcHJlYzogY3VybHllcXByZWMsXG5cdGN1cmx5ZXFzdWNjOiBjdXJseWVxc3VjYyxcblx0Y3VybHl2ZWU6IGN1cmx5dmVlLFxuXHRjdXJseXdlZGdlOiBjdXJseXdlZGdlLFxuXHRjdXJyZW46IGN1cnJlbiQxLFxuXHRjdXJ2ZWFycm93bGVmdDogY3VydmVhcnJvd2xlZnQsXG5cdGN1cnZlYXJyb3dyaWdodDogY3VydmVhcnJvd3JpZ2h0LFxuXHRjdXZlZTogY3V2ZWUsXG5cdGN1d2VkOiBjdXdlZCxcblx0Y3djb25pbnQ6IGN3Y29uaW50LFxuXHRjd2ludDogY3dpbnQsXG5cdGN5bGN0eTogY3lsY3R5LFxuXHRkYWdnZXI6IGRhZ2dlcixcblx0RGFnZ2VyOiBEYWdnZXIsXG5cdGRhbGV0aDogZGFsZXRoLFxuXHRkYXJyOiBkYXJyLFxuXHREYXJyOiBEYXJyLFxuXHRkQXJyOiBkQXJyLFxuXHRkYXNoOiBkYXNoLFxuXHREYXNodjogRGFzaHYsXG5cdGRhc2h2OiBkYXNodixcblx0ZGJrYXJvdzogZGJrYXJvdyxcblx0ZGJsYWM6IGRibGFjLFxuXHREY2Fyb246IERjYXJvbixcblx0ZGNhcm9uOiBkY2Fyb24sXG5cdERjeTogRGN5LFxuXHRkY3k6IGRjeSxcblx0ZGRhZ2dlcjogZGRhZ2dlcixcblx0ZGRhcnI6IGRkYXJyLFxuXHRERDogREQsXG5cdGRkOiBkZCxcblx0RERvdHJhaGQ6IEREb3RyYWhkLFxuXHRkZG90c2VxOiBkZG90c2VxLFxuXHRkZWc6IGRlZyQxLFxuXHREZWw6IERlbCxcblx0RGVsdGE6IERlbHRhLFxuXHRkZWx0YTogZGVsdGEsXG5cdGRlbXB0eXY6IGRlbXB0eXYsXG5cdGRmaXNodDogZGZpc2h0LFxuXHREZnI6IERmcixcblx0ZGZyOiBkZnIsXG5cdGRIYXI6IGRIYXIsXG5cdGRoYXJsOiBkaGFybCxcblx0ZGhhcnI6IGRoYXJyLFxuXHREaWFjcml0aWNhbEFjdXRlOiBEaWFjcml0aWNhbEFjdXRlLFxuXHREaWFjcml0aWNhbERvdDogRGlhY3JpdGljYWxEb3QsXG5cdERpYWNyaXRpY2FsRG91YmxlQWN1dGU6IERpYWNyaXRpY2FsRG91YmxlQWN1dGUsXG5cdERpYWNyaXRpY2FsR3JhdmU6IERpYWNyaXRpY2FsR3JhdmUsXG5cdERpYWNyaXRpY2FsVGlsZGU6IERpYWNyaXRpY2FsVGlsZGUsXG5cdGRpYW06IGRpYW0sXG5cdGRpYW1vbmQ6IGRpYW1vbmQsXG5cdERpYW1vbmQ6IERpYW1vbmQsXG5cdGRpYW1vbmRzdWl0OiBkaWFtb25kc3VpdCxcblx0ZGlhbXM6IGRpYW1zLFxuXHRkaWU6IGRpZSxcblx0RGlmZmVyZW50aWFsRDogRGlmZmVyZW50aWFsRCxcblx0ZGlnYW1tYTogZGlnYW1tYSxcblx0ZGlzaW46IGRpc2luLFxuXHRkaXY6IGRpdixcblx0ZGl2aWRlOiBkaXZpZGUkMSxcblx0ZGl2aWRlb250aW1lczogZGl2aWRlb250aW1lcyxcblx0ZGl2b254OiBkaXZvbngsXG5cdERKY3k6IERKY3ksXG5cdGRqY3k6IGRqY3ksXG5cdGRsY29ybjogZGxjb3JuLFxuXHRkbGNyb3A6IGRsY3JvcCxcblx0ZG9sbGFyOiBkb2xsYXIsXG5cdERvcGY6IERvcGYsXG5cdGRvcGY6IGRvcGYsXG5cdERvdDogRG90LFxuXHRkb3Q6IGRvdCxcblx0RG90RG90OiBEb3REb3QsXG5cdGRvdGVxOiBkb3RlcSxcblx0ZG90ZXFkb3Q6IGRvdGVxZG90LFxuXHREb3RFcXVhbDogRG90RXF1YWwsXG5cdGRvdG1pbnVzOiBkb3RtaW51cyxcblx0ZG90cGx1czogZG90cGx1cyxcblx0ZG90c3F1YXJlOiBkb3RzcXVhcmUsXG5cdGRvdWJsZWJhcndlZGdlOiBkb3VibGViYXJ3ZWRnZSxcblx0RG91YmxlQ29udG91ckludGVncmFsOiBEb3VibGVDb250b3VySW50ZWdyYWwsXG5cdERvdWJsZURvdDogRG91YmxlRG90LFxuXHREb3VibGVEb3duQXJyb3c6IERvdWJsZURvd25BcnJvdyxcblx0RG91YmxlTGVmdEFycm93OiBEb3VibGVMZWZ0QXJyb3csXG5cdERvdWJsZUxlZnRSaWdodEFycm93OiBEb3VibGVMZWZ0UmlnaHRBcnJvdyxcblx0RG91YmxlTGVmdFRlZTogRG91YmxlTGVmdFRlZSxcblx0RG91YmxlTG9uZ0xlZnRBcnJvdzogRG91YmxlTG9uZ0xlZnRBcnJvdyxcblx0RG91YmxlTG9uZ0xlZnRSaWdodEFycm93OiBEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3csXG5cdERvdWJsZUxvbmdSaWdodEFycm93OiBEb3VibGVMb25nUmlnaHRBcnJvdyxcblx0RG91YmxlUmlnaHRBcnJvdzogRG91YmxlUmlnaHRBcnJvdyxcblx0RG91YmxlUmlnaHRUZWU6IERvdWJsZVJpZ2h0VGVlLFxuXHREb3VibGVVcEFycm93OiBEb3VibGVVcEFycm93LFxuXHREb3VibGVVcERvd25BcnJvdzogRG91YmxlVXBEb3duQXJyb3csXG5cdERvdWJsZVZlcnRpY2FsQmFyOiBEb3VibGVWZXJ0aWNhbEJhcixcblx0RG93bkFycm93QmFyOiBEb3duQXJyb3dCYXIsXG5cdGRvd25hcnJvdzogZG93bmFycm93LFxuXHREb3duQXJyb3c6IERvd25BcnJvdyxcblx0RG93bmFycm93OiBEb3duYXJyb3csXG5cdERvd25BcnJvd1VwQXJyb3c6IERvd25BcnJvd1VwQXJyb3csXG5cdERvd25CcmV2ZTogRG93bkJyZXZlLFxuXHRkb3duZG93bmFycm93czogZG93bmRvd25hcnJvd3MsXG5cdGRvd25oYXJwb29ubGVmdDogZG93bmhhcnBvb25sZWZ0LFxuXHRkb3duaGFycG9vbnJpZ2h0OiBkb3duaGFycG9vbnJpZ2h0LFxuXHREb3duTGVmdFJpZ2h0VmVjdG9yOiBEb3duTGVmdFJpZ2h0VmVjdG9yLFxuXHREb3duTGVmdFRlZVZlY3RvcjogRG93bkxlZnRUZWVWZWN0b3IsXG5cdERvd25MZWZ0VmVjdG9yQmFyOiBEb3duTGVmdFZlY3RvckJhcixcblx0RG93bkxlZnRWZWN0b3I6IERvd25MZWZ0VmVjdG9yLFxuXHREb3duUmlnaHRUZWVWZWN0b3I6IERvd25SaWdodFRlZVZlY3Rvcixcblx0RG93blJpZ2h0VmVjdG9yQmFyOiBEb3duUmlnaHRWZWN0b3JCYXIsXG5cdERvd25SaWdodFZlY3RvcjogRG93blJpZ2h0VmVjdG9yLFxuXHREb3duVGVlQXJyb3c6IERvd25UZWVBcnJvdyxcblx0RG93blRlZTogRG93blRlZSxcblx0ZHJia2Fyb3c6IGRyYmthcm93LFxuXHRkcmNvcm46IGRyY29ybixcblx0ZHJjcm9wOiBkcmNyb3AsXG5cdERzY3I6IERzY3IsXG5cdGRzY3I6IGRzY3IsXG5cdERTY3k6IERTY3ksXG5cdGRzY3k6IGRzY3ksXG5cdGRzb2w6IGRzb2wsXG5cdERzdHJvazogRHN0cm9rLFxuXHRkc3Ryb2s6IGRzdHJvayxcblx0ZHRkb3Q6IGR0ZG90LFxuXHRkdHJpOiBkdHJpLFxuXHRkdHJpZjogZHRyaWYsXG5cdGR1YXJyOiBkdWFycixcblx0ZHVoYXI6IGR1aGFyLFxuXHRkd2FuZ2xlOiBkd2FuZ2xlLFxuXHREWmN5OiBEWmN5LFxuXHRkemN5OiBkemN5LFxuXHRkemlncmFycjogZHppZ3JhcnIsXG5cdEVhY3V0ZTogRWFjdXRlJDEsXG5cdGVhY3V0ZTogZWFjdXRlJDEsXG5cdGVhc3RlcjogZWFzdGVyLFxuXHRFY2Fyb246IEVjYXJvbixcblx0ZWNhcm9uOiBlY2Fyb24sXG5cdEVjaXJjOiBFY2lyYyQxLFxuXHRlY2lyYzogZWNpcmMkMSxcblx0ZWNpcjogZWNpcixcblx0ZWNvbG9uOiBlY29sb24sXG5cdEVjeTogRWN5LFxuXHRlY3k6IGVjeSxcblx0ZUREb3Q6IGVERG90LFxuXHRFZG90OiBFZG90LFxuXHRlZG90OiBlZG90LFxuXHRlRG90OiBlRG90LFxuXHRlZTogZWUsXG5cdGVmRG90OiBlZkRvdCxcblx0RWZyOiBFZnIsXG5cdGVmcjogZWZyLFxuXHRlZzogZWcsXG5cdEVncmF2ZTogRWdyYXZlJDEsXG5cdGVncmF2ZTogZWdyYXZlJDEsXG5cdGVnczogZWdzLFxuXHRlZ3Nkb3Q6IGVnc2RvdCxcblx0ZWw6IGVsLFxuXHRFbGVtZW50OiBFbGVtZW50JDEsXG5cdGVsaW50ZXJzOiBlbGludGVycyxcblx0ZWxsOiBlbGwsXG5cdGVsczogZWxzLFxuXHRlbHNkb3Q6IGVsc2RvdCxcblx0RW1hY3I6IEVtYWNyLFxuXHRlbWFjcjogZW1hY3IsXG5cdGVtcHR5OiBlbXB0eSxcblx0ZW1wdHlzZXQ6IGVtcHR5c2V0LFxuXHRFbXB0eVNtYWxsU3F1YXJlOiBFbXB0eVNtYWxsU3F1YXJlLFxuXHRlbXB0eXY6IGVtcHR5dixcblx0RW1wdHlWZXJ5U21hbGxTcXVhcmU6IEVtcHR5VmVyeVNtYWxsU3F1YXJlLFxuXHRlbXNwMTM6IGVtc3AxMyxcblx0ZW1zcDE0OiBlbXNwMTQsXG5cdGVtc3A6IGVtc3AsXG5cdEVORzogRU5HLFxuXHRlbmc6IGVuZyxcblx0ZW5zcDogZW5zcCxcblx0RW9nb246IEVvZ29uLFxuXHRlb2dvbjogZW9nb24sXG5cdEVvcGY6IEVvcGYsXG5cdGVvcGY6IGVvcGYsXG5cdGVwYXI6IGVwYXIsXG5cdGVwYXJzbDogZXBhcnNsLFxuXHRlcGx1czogZXBsdXMsXG5cdGVwc2k6IGVwc2ksXG5cdEVwc2lsb246IEVwc2lsb24sXG5cdGVwc2lsb246IGVwc2lsb24sXG5cdGVwc2l2OiBlcHNpdixcblx0ZXFjaXJjOiBlcWNpcmMsXG5cdGVxY29sb246IGVxY29sb24sXG5cdGVxc2ltOiBlcXNpbSxcblx0ZXFzbGFudGd0cjogZXFzbGFudGd0cixcblx0ZXFzbGFudGxlc3M6IGVxc2xhbnRsZXNzLFxuXHRFcXVhbDogRXF1YWwsXG5cdGVxdWFsczogZXF1YWxzLFxuXHRFcXVhbFRpbGRlOiBFcXVhbFRpbGRlLFxuXHRlcXVlc3Q6IGVxdWVzdCxcblx0RXF1aWxpYnJpdW06IEVxdWlsaWJyaXVtLFxuXHRlcXVpdjogZXF1aXYsXG5cdGVxdWl2REQ6IGVxdWl2REQsXG5cdGVxdnBhcnNsOiBlcXZwYXJzbCxcblx0ZXJhcnI6IGVyYXJyLFxuXHRlckRvdDogZXJEb3QsXG5cdGVzY3I6IGVzY3IsXG5cdEVzY3I6IEVzY3IsXG5cdGVzZG90OiBlc2RvdCxcblx0RXNpbTogRXNpbSxcblx0ZXNpbTogZXNpbSxcblx0RXRhOiBFdGEsXG5cdGV0YTogZXRhLFxuXHRFVEg6IEVUSCQxLFxuXHRldGg6IGV0aCQxLFxuXHRFdW1sOiBFdW1sJDEsXG5cdGV1bWw6IGV1bWwkMSxcblx0ZXVybzogZXVybyxcblx0ZXhjbDogZXhjbCxcblx0ZXhpc3Q6IGV4aXN0LFxuXHRFeGlzdHM6IEV4aXN0cyxcblx0ZXhwZWN0YXRpb246IGV4cGVjdGF0aW9uLFxuXHRleHBvbmVudGlhbGU6IGV4cG9uZW50aWFsZSxcblx0RXhwb25lbnRpYWxFOiBFeHBvbmVudGlhbEUsXG5cdGZhbGxpbmdkb3RzZXE6IGZhbGxpbmdkb3RzZXEsXG5cdEZjeTogRmN5LFxuXHRmY3k6IGZjeSxcblx0ZmVtYWxlOiBmZW1hbGUsXG5cdGZmaWxpZzogZmZpbGlnLFxuXHRmZmxpZzogZmZsaWcsXG5cdGZmbGxpZzogZmZsbGlnLFxuXHRGZnI6IEZmcixcblx0ZmZyOiBmZnIsXG5cdGZpbGlnOiBmaWxpZyxcblx0RmlsbGVkU21hbGxTcXVhcmU6IEZpbGxlZFNtYWxsU3F1YXJlLFxuXHRGaWxsZWRWZXJ5U21hbGxTcXVhcmU6IEZpbGxlZFZlcnlTbWFsbFNxdWFyZSxcblx0ZmpsaWc6IGZqbGlnLFxuXHRmbGF0OiBmbGF0LFxuXHRmbGxpZzogZmxsaWcsXG5cdGZsdG5zOiBmbHRucyxcblx0Zm5vZjogZm5vZixcblx0Rm9wZjogRm9wZixcblx0Zm9wZjogZm9wZixcblx0Zm9yYWxsOiBmb3JhbGwsXG5cdEZvckFsbDogRm9yQWxsLFxuXHRmb3JrOiBmb3JrLFxuXHRmb3JrdjogZm9ya3YsXG5cdEZvdXJpZXJ0cmY6IEZvdXJpZXJ0cmYsXG5cdGZwYXJ0aW50OiBmcGFydGludCxcblx0ZnJhYzEyOiBmcmFjMTIkMSxcblx0ZnJhYzEzOiBmcmFjMTMsXG5cdGZyYWMxNDogZnJhYzE0JDEsXG5cdGZyYWMxNTogZnJhYzE1LFxuXHRmcmFjMTY6IGZyYWMxNixcblx0ZnJhYzE4OiBmcmFjMTgsXG5cdGZyYWMyMzogZnJhYzIzLFxuXHRmcmFjMjU6IGZyYWMyNSxcblx0ZnJhYzM0OiBmcmFjMzQkMSxcblx0ZnJhYzM1OiBmcmFjMzUsXG5cdGZyYWMzODogZnJhYzM4LFxuXHRmcmFjNDU6IGZyYWM0NSxcblx0ZnJhYzU2OiBmcmFjNTYsXG5cdGZyYWM1ODogZnJhYzU4LFxuXHRmcmFjNzg6IGZyYWM3OCxcblx0ZnJhc2w6IGZyYXNsLFxuXHRmcm93bjogZnJvd24sXG5cdGZzY3I6IGZzY3IsXG5cdEZzY3I6IEZzY3IsXG5cdGdhY3V0ZTogZ2FjdXRlLFxuXHRHYW1tYTogR2FtbWEsXG5cdGdhbW1hOiBnYW1tYSxcblx0R2FtbWFkOiBHYW1tYWQsXG5cdGdhbW1hZDogZ2FtbWFkLFxuXHRnYXA6IGdhcCxcblx0R2JyZXZlOiBHYnJldmUsXG5cdGdicmV2ZTogZ2JyZXZlLFxuXHRHY2VkaWw6IEdjZWRpbCxcblx0R2NpcmM6IEdjaXJjLFxuXHRnY2lyYzogZ2NpcmMsXG5cdEdjeTogR2N5LFxuXHRnY3k6IGdjeSxcblx0R2RvdDogR2RvdCxcblx0Z2RvdDogZ2RvdCxcblx0Z2U6IGdlLFxuXHRnRTogZ0UsXG5cdGdFbDogZ0VsLFxuXHRnZWw6IGdlbCxcblx0Z2VxOiBnZXEsXG5cdGdlcXE6IGdlcXEsXG5cdGdlcXNsYW50OiBnZXFzbGFudCxcblx0Z2VzY2M6IGdlc2NjLFxuXHRnZXM6IGdlcyxcblx0Z2VzZG90OiBnZXNkb3QsXG5cdGdlc2RvdG86IGdlc2RvdG8sXG5cdGdlc2RvdG9sOiBnZXNkb3RvbCxcblx0Z2VzbDogZ2VzbCxcblx0Z2VzbGVzOiBnZXNsZXMsXG5cdEdmcjogR2ZyLFxuXHRnZnI6IGdmcixcblx0Z2c6IGdnLFxuXHRHZzogR2csXG5cdGdnZzogZ2dnLFxuXHRnaW1lbDogZ2ltZWwsXG5cdEdKY3k6IEdKY3ksXG5cdGdqY3k6IGdqY3ksXG5cdGdsYTogZ2xhLFxuXHRnbDogZ2wsXG5cdGdsRTogZ2xFLFxuXHRnbGo6IGdsaixcblx0Z25hcDogZ25hcCxcblx0Z25hcHByb3g6IGduYXBwcm94LFxuXHRnbmU6IGduZSxcblx0Z25FOiBnbkUsXG5cdGduZXE6IGduZXEsXG5cdGduZXFxOiBnbmVxcSxcblx0Z25zaW06IGduc2ltLFxuXHRHb3BmOiBHb3BmLFxuXHRnb3BmOiBnb3BmLFxuXHRncmF2ZTogZ3JhdmUsXG5cdEdyZWF0ZXJFcXVhbDogR3JlYXRlckVxdWFsLFxuXHRHcmVhdGVyRXF1YWxMZXNzOiBHcmVhdGVyRXF1YWxMZXNzLFxuXHRHcmVhdGVyRnVsbEVxdWFsOiBHcmVhdGVyRnVsbEVxdWFsLFxuXHRHcmVhdGVyR3JlYXRlcjogR3JlYXRlckdyZWF0ZXIsXG5cdEdyZWF0ZXJMZXNzOiBHcmVhdGVyTGVzcyxcblx0R3JlYXRlclNsYW50RXF1YWw6IEdyZWF0ZXJTbGFudEVxdWFsLFxuXHRHcmVhdGVyVGlsZGU6IEdyZWF0ZXJUaWxkZSxcblx0R3NjcjogR3Njcixcblx0Z3NjcjogZ3Njcixcblx0Z3NpbTogZ3NpbSxcblx0Z3NpbWU6IGdzaW1lLFxuXHRnc2ltbDogZ3NpbWwsXG5cdGd0Y2M6IGd0Y2MsXG5cdGd0Y2lyOiBndGNpcixcblx0Z3Q6IGd0JDIsXG5cdEdUOiBHVCQxLFxuXHRHdDogR3QsXG5cdGd0ZG90OiBndGRvdCxcblx0Z3RsUGFyOiBndGxQYXIsXG5cdGd0cXVlc3Q6IGd0cXVlc3QsXG5cdGd0cmFwcHJveDogZ3RyYXBwcm94LFxuXHRndHJhcnI6IGd0cmFycixcblx0Z3RyZG90OiBndHJkb3QsXG5cdGd0cmVxbGVzczogZ3RyZXFsZXNzLFxuXHRndHJlcXFsZXNzOiBndHJlcXFsZXNzLFxuXHRndHJsZXNzOiBndHJsZXNzLFxuXHRndHJzaW06IGd0cnNpbSxcblx0Z3ZlcnRuZXFxOiBndmVydG5lcXEsXG5cdGd2bkU6IGd2bkUsXG5cdEhhY2VrOiBIYWNlayxcblx0aGFpcnNwOiBoYWlyc3AsXG5cdGhhbGY6IGhhbGYsXG5cdGhhbWlsdDogaGFtaWx0LFxuXHRIQVJEY3k6IEhBUkRjeSxcblx0aGFyZGN5OiBoYXJkY3ksXG5cdGhhcnJjaXI6IGhhcnJjaXIsXG5cdGhhcnI6IGhhcnIsXG5cdGhBcnI6IGhBcnIsXG5cdGhhcnJ3OiBoYXJydyxcblx0SGF0OiBIYXQsXG5cdGhiYXI6IGhiYXIsXG5cdEhjaXJjOiBIY2lyYyxcblx0aGNpcmM6IGhjaXJjLFxuXHRoZWFydHM6IGhlYXJ0cyxcblx0aGVhcnRzdWl0OiBoZWFydHN1aXQsXG5cdGhlbGxpcDogaGVsbGlwLFxuXHRoZXJjb246IGhlcmNvbixcblx0aGZyOiBoZnIsXG5cdEhmcjogSGZyLFxuXHRIaWxiZXJ0U3BhY2U6IEhpbGJlcnRTcGFjZSxcblx0aGtzZWFyb3c6IGhrc2Vhcm93LFxuXHRoa3N3YXJvdzogaGtzd2Fyb3csXG5cdGhvYXJyOiBob2Fycixcblx0aG9tdGh0OiBob210aHQsXG5cdGhvb2tsZWZ0YXJyb3c6IGhvb2tsZWZ0YXJyb3csXG5cdGhvb2tyaWdodGFycm93OiBob29rcmlnaHRhcnJvdyxcblx0aG9wZjogaG9wZixcblx0SG9wZjogSG9wZixcblx0aG9yYmFyOiBob3JiYXIsXG5cdEhvcml6b250YWxMaW5lOiBIb3Jpem9udGFsTGluZSxcblx0aHNjcjogaHNjcixcblx0SHNjcjogSHNjcixcblx0aHNsYXNoOiBoc2xhc2gsXG5cdEhzdHJvazogSHN0cm9rLFxuXHRoc3Ryb2s6IGhzdHJvayxcblx0SHVtcERvd25IdW1wOiBIdW1wRG93bkh1bXAsXG5cdEh1bXBFcXVhbDogSHVtcEVxdWFsLFxuXHRoeWJ1bGw6IGh5YnVsbCxcblx0aHlwaGVuOiBoeXBoZW4sXG5cdElhY3V0ZTogSWFjdXRlJDEsXG5cdGlhY3V0ZTogaWFjdXRlJDEsXG5cdGljOiBpYyxcblx0SWNpcmM6IEljaXJjJDEsXG5cdGljaXJjOiBpY2lyYyQxLFxuXHRJY3k6IEljeSxcblx0aWN5OiBpY3ksXG5cdElkb3Q6IElkb3QsXG5cdElFY3k6IElFY3ksXG5cdGllY3k6IGllY3ksXG5cdGlleGNsOiBpZXhjbCQxLFxuXHRpZmY6IGlmZixcblx0aWZyOiBpZnIsXG5cdElmcjogSWZyLFxuXHRJZ3JhdmU6IElncmF2ZSQxLFxuXHRpZ3JhdmU6IGlncmF2ZSQxLFxuXHRpaTogaWksXG5cdGlpaWludDogaWlpaW50LFxuXHRpaWludDogaWlpbnQsXG5cdGlpbmZpbjogaWluZmluLFxuXHRpaW90YTogaWlvdGEsXG5cdElKbGlnOiBJSmxpZyxcblx0aWpsaWc6IGlqbGlnLFxuXHRJbWFjcjogSW1hY3IsXG5cdGltYWNyOiBpbWFjcixcblx0aW1hZ2U6IGltYWdlLFxuXHRJbWFnaW5hcnlJOiBJbWFnaW5hcnlJLFxuXHRpbWFnbGluZTogaW1hZ2xpbmUsXG5cdGltYWdwYXJ0OiBpbWFncGFydCxcblx0aW1hdGg6IGltYXRoLFxuXHRJbTogSW0sXG5cdGltb2Y6IGltb2YsXG5cdGltcGVkOiBpbXBlZCxcblx0SW1wbGllczogSW1wbGllcyxcblx0aW5jYXJlOiBpbmNhcmUsXG5cdFwiaW5cIjogXCLiiIhcIixcblx0aW5maW46IGluZmluLFxuXHRpbmZpbnRpZTogaW5maW50aWUsXG5cdGlub2RvdDogaW5vZG90LFxuXHRpbnRjYWw6IGludGNhbCxcblx0aW50OiBpbnQsXG5cdEludDogSW50LFxuXHRpbnRlZ2VyczogaW50ZWdlcnMsXG5cdEludGVncmFsOiBJbnRlZ3JhbCxcblx0aW50ZXJjYWw6IGludGVyY2FsLFxuXHRJbnRlcnNlY3Rpb246IEludGVyc2VjdGlvbixcblx0aW50bGFyaGs6IGludGxhcmhrLFxuXHRpbnRwcm9kOiBpbnRwcm9kLFxuXHRJbnZpc2libGVDb21tYTogSW52aXNpYmxlQ29tbWEsXG5cdEludmlzaWJsZVRpbWVzOiBJbnZpc2libGVUaW1lcyxcblx0SU9jeTogSU9jeSxcblx0aW9jeTogaW9jeSxcblx0SW9nb246IElvZ29uLFxuXHRpb2dvbjogaW9nb24sXG5cdElvcGY6IElvcGYsXG5cdGlvcGY6IGlvcGYsXG5cdElvdGE6IElvdGEsXG5cdGlvdGE6IGlvdGEsXG5cdGlwcm9kOiBpcHJvZCxcblx0aXF1ZXN0OiBpcXVlc3QkMSxcblx0aXNjcjogaXNjcixcblx0SXNjcjogSXNjcixcblx0aXNpbjogaXNpbixcblx0aXNpbmRvdDogaXNpbmRvdCxcblx0aXNpbkU6IGlzaW5FLFxuXHRpc2luczogaXNpbnMsXG5cdGlzaW5zdjogaXNpbnN2LFxuXHRpc2ludjogaXNpbnYsXG5cdGl0OiBpdCxcblx0SXRpbGRlOiBJdGlsZGUsXG5cdGl0aWxkZTogaXRpbGRlLFxuXHRJdWtjeTogSXVrY3ksXG5cdGl1a2N5OiBpdWtjeSxcblx0SXVtbDogSXVtbCQxLFxuXHRpdW1sOiBpdW1sJDEsXG5cdEpjaXJjOiBKY2lyYyxcblx0amNpcmM6IGpjaXJjLFxuXHRKY3k6IEpjeSxcblx0amN5OiBqY3ksXG5cdEpmcjogSmZyLFxuXHRqZnI6IGpmcixcblx0am1hdGg6IGptYXRoLFxuXHRKb3BmOiBKb3BmLFxuXHRqb3BmOiBqb3BmLFxuXHRKc2NyOiBKc2NyLFxuXHRqc2NyOiBqc2NyLFxuXHRKc2VyY3k6IEpzZXJjeSxcblx0anNlcmN5OiBqc2VyY3ksXG5cdEp1a2N5OiBKdWtjeSxcblx0anVrY3k6IGp1a2N5LFxuXHRLYXBwYTogS2FwcGEsXG5cdGthcHBhOiBrYXBwYSxcblx0a2FwcGF2OiBrYXBwYXYsXG5cdEtjZWRpbDogS2NlZGlsLFxuXHRrY2VkaWw6IGtjZWRpbCxcblx0S2N5OiBLY3ksXG5cdGtjeToga2N5LFxuXHRLZnI6IEtmcixcblx0a2ZyOiBrZnIsXG5cdGtncmVlbjoga2dyZWVuLFxuXHRLSGN5OiBLSGN5LFxuXHRraGN5OiBraGN5LFxuXHRLSmN5OiBLSmN5LFxuXHRramN5OiBramN5LFxuXHRLb3BmOiBLb3BmLFxuXHRrb3BmOiBrb3BmLFxuXHRLc2NyOiBLc2NyLFxuXHRrc2NyOiBrc2NyLFxuXHRsQWFycjogbEFhcnIsXG5cdExhY3V0ZTogTGFjdXRlLFxuXHRsYWN1dGU6IGxhY3V0ZSxcblx0bGFlbXB0eXY6IGxhZW1wdHl2LFxuXHRsYWdyYW46IGxhZ3Jhbixcblx0TGFtYmRhOiBMYW1iZGEsXG5cdGxhbWJkYTogbGFtYmRhLFxuXHRsYW5nOiBsYW5nLFxuXHRMYW5nOiBMYW5nLFxuXHRsYW5nZDogbGFuZ2QsXG5cdGxhbmdsZTogbGFuZ2xlLFxuXHRsYXA6IGxhcCxcblx0TGFwbGFjZXRyZjogTGFwbGFjZXRyZixcblx0bGFxdW86IGxhcXVvJDEsXG5cdGxhcnJiOiBsYXJyYixcblx0bGFycmJmczogbGFycmJmcyxcblx0bGFycjogbGFycixcblx0TGFycjogTGFycixcblx0bEFycjogbEFycixcblx0bGFycmZzOiBsYXJyZnMsXG5cdGxhcnJoazogbGFycmhrLFxuXHRsYXJybHA6IGxhcnJscCxcblx0bGFycnBsOiBsYXJycGwsXG5cdGxhcnJzaW06IGxhcnJzaW0sXG5cdGxhcnJ0bDogbGFycnRsLFxuXHRsYXRhaWw6IGxhdGFpbCxcblx0bEF0YWlsOiBsQXRhaWwsXG5cdGxhdDogbGF0LFxuXHRsYXRlOiBsYXRlLFxuXHRsYXRlczogbGF0ZXMsXG5cdGxiYXJyOiBsYmFycixcblx0bEJhcnI6IGxCYXJyLFxuXHRsYmJyazogbGJicmssXG5cdGxicmFjZTogbGJyYWNlLFxuXHRsYnJhY2s6IGxicmFjayxcblx0bGJya2U6IGxicmtlLFxuXHRsYnJrc2xkOiBsYnJrc2xkLFxuXHRsYnJrc2x1OiBsYnJrc2x1LFxuXHRMY2Fyb246IExjYXJvbixcblx0bGNhcm9uOiBsY2Fyb24sXG5cdExjZWRpbDogTGNlZGlsLFxuXHRsY2VkaWw6IGxjZWRpbCxcblx0bGNlaWw6IGxjZWlsLFxuXHRsY3ViOiBsY3ViLFxuXHRMY3k6IExjeSxcblx0bGN5OiBsY3ksXG5cdGxkY2E6IGxkY2EsXG5cdGxkcXVvOiBsZHF1byxcblx0bGRxdW9yOiBsZHF1b3IsXG5cdGxkcmRoYXI6IGxkcmRoYXIsXG5cdGxkcnVzaGFyOiBsZHJ1c2hhcixcblx0bGRzaDogbGRzaCxcblx0bGU6IGxlLFxuXHRsRTogbEUsXG5cdExlZnRBbmdsZUJyYWNrZXQ6IExlZnRBbmdsZUJyYWNrZXQsXG5cdExlZnRBcnJvd0JhcjogTGVmdEFycm93QmFyLFxuXHRsZWZ0YXJyb3c6IGxlZnRhcnJvdyxcblx0TGVmdEFycm93OiBMZWZ0QXJyb3csXG5cdExlZnRhcnJvdzogTGVmdGFycm93LFxuXHRMZWZ0QXJyb3dSaWdodEFycm93OiBMZWZ0QXJyb3dSaWdodEFycm93LFxuXHRsZWZ0YXJyb3d0YWlsOiBsZWZ0YXJyb3d0YWlsLFxuXHRMZWZ0Q2VpbGluZzogTGVmdENlaWxpbmcsXG5cdExlZnREb3VibGVCcmFja2V0OiBMZWZ0RG91YmxlQnJhY2tldCxcblx0TGVmdERvd25UZWVWZWN0b3I6IExlZnREb3duVGVlVmVjdG9yLFxuXHRMZWZ0RG93blZlY3RvckJhcjogTGVmdERvd25WZWN0b3JCYXIsXG5cdExlZnREb3duVmVjdG9yOiBMZWZ0RG93blZlY3Rvcixcblx0TGVmdEZsb29yOiBMZWZ0Rmxvb3IsXG5cdGxlZnRoYXJwb29uZG93bjogbGVmdGhhcnBvb25kb3duLFxuXHRsZWZ0aGFycG9vbnVwOiBsZWZ0aGFycG9vbnVwLFxuXHRsZWZ0bGVmdGFycm93czogbGVmdGxlZnRhcnJvd3MsXG5cdGxlZnRyaWdodGFycm93OiBsZWZ0cmlnaHRhcnJvdyxcblx0TGVmdFJpZ2h0QXJyb3c6IExlZnRSaWdodEFycm93LFxuXHRMZWZ0cmlnaHRhcnJvdzogTGVmdHJpZ2h0YXJyb3csXG5cdGxlZnRyaWdodGFycm93czogbGVmdHJpZ2h0YXJyb3dzLFxuXHRsZWZ0cmlnaHRoYXJwb29uczogbGVmdHJpZ2h0aGFycG9vbnMsXG5cdGxlZnRyaWdodHNxdWlnYXJyb3c6IGxlZnRyaWdodHNxdWlnYXJyb3csXG5cdExlZnRSaWdodFZlY3RvcjogTGVmdFJpZ2h0VmVjdG9yLFxuXHRMZWZ0VGVlQXJyb3c6IExlZnRUZWVBcnJvdyxcblx0TGVmdFRlZTogTGVmdFRlZSxcblx0TGVmdFRlZVZlY3RvcjogTGVmdFRlZVZlY3Rvcixcblx0bGVmdHRocmVldGltZXM6IGxlZnR0aHJlZXRpbWVzLFxuXHRMZWZ0VHJpYW5nbGVCYXI6IExlZnRUcmlhbmdsZUJhcixcblx0TGVmdFRyaWFuZ2xlOiBMZWZ0VHJpYW5nbGUsXG5cdExlZnRUcmlhbmdsZUVxdWFsOiBMZWZ0VHJpYW5nbGVFcXVhbCxcblx0TGVmdFVwRG93blZlY3RvcjogTGVmdFVwRG93blZlY3Rvcixcblx0TGVmdFVwVGVlVmVjdG9yOiBMZWZ0VXBUZWVWZWN0b3IsXG5cdExlZnRVcFZlY3RvckJhcjogTGVmdFVwVmVjdG9yQmFyLFxuXHRMZWZ0VXBWZWN0b3I6IExlZnRVcFZlY3Rvcixcblx0TGVmdFZlY3RvckJhcjogTGVmdFZlY3RvckJhcixcblx0TGVmdFZlY3RvcjogTGVmdFZlY3Rvcixcblx0bEVnOiBsRWcsXG5cdGxlZzogbGVnLFxuXHRsZXE6IGxlcSxcblx0bGVxcTogbGVxcSxcblx0bGVxc2xhbnQ6IGxlcXNsYW50LFxuXHRsZXNjYzogbGVzY2MsXG5cdGxlczogbGVzLFxuXHRsZXNkb3Q6IGxlc2RvdCxcblx0bGVzZG90bzogbGVzZG90byxcblx0bGVzZG90b3I6IGxlc2RvdG9yLFxuXHRsZXNnOiBsZXNnLFxuXHRsZXNnZXM6IGxlc2dlcyxcblx0bGVzc2FwcHJveDogbGVzc2FwcHJveCxcblx0bGVzc2RvdDogbGVzc2RvdCxcblx0bGVzc2VxZ3RyOiBsZXNzZXFndHIsXG5cdGxlc3NlcXFndHI6IGxlc3NlcXFndHIsXG5cdExlc3NFcXVhbEdyZWF0ZXI6IExlc3NFcXVhbEdyZWF0ZXIsXG5cdExlc3NGdWxsRXF1YWw6IExlc3NGdWxsRXF1YWwsXG5cdExlc3NHcmVhdGVyOiBMZXNzR3JlYXRlcixcblx0bGVzc2d0cjogbGVzc2d0cixcblx0TGVzc0xlc3M6IExlc3NMZXNzLFxuXHRsZXNzc2ltOiBsZXNzc2ltLFxuXHRMZXNzU2xhbnRFcXVhbDogTGVzc1NsYW50RXF1YWwsXG5cdExlc3NUaWxkZTogTGVzc1RpbGRlLFxuXHRsZmlzaHQ6IGxmaXNodCxcblx0bGZsb29yOiBsZmxvb3IsXG5cdExmcjogTGZyLFxuXHRsZnI6IGxmcixcblx0bGc6IGxnLFxuXHRsZ0U6IGxnRSxcblx0bEhhcjogbEhhcixcblx0bGhhcmQ6IGxoYXJkLFxuXHRsaGFydTogbGhhcnUsXG5cdGxoYXJ1bDogbGhhcnVsLFxuXHRsaGJsazogbGhibGssXG5cdExKY3k6IExKY3ksXG5cdGxqY3k6IGxqY3ksXG5cdGxsYXJyOiBsbGFycixcblx0bGw6IGxsLFxuXHRMbDogTGwsXG5cdGxsY29ybmVyOiBsbGNvcm5lcixcblx0TGxlZnRhcnJvdzogTGxlZnRhcnJvdyxcblx0bGxoYXJkOiBsbGhhcmQsXG5cdGxsdHJpOiBsbHRyaSxcblx0TG1pZG90OiBMbWlkb3QsXG5cdGxtaWRvdDogbG1pZG90LFxuXHRsbW91c3RhY2hlOiBsbW91c3RhY2hlLFxuXHRsbW91c3Q6IGxtb3VzdCxcblx0bG5hcDogbG5hcCxcblx0bG5hcHByb3g6IGxuYXBwcm94LFxuXHRsbmU6IGxuZSxcblx0bG5FOiBsbkUsXG5cdGxuZXE6IGxuZXEsXG5cdGxuZXFxOiBsbmVxcSxcblx0bG5zaW06IGxuc2ltLFxuXHRsb2FuZzogbG9hbmcsXG5cdGxvYXJyOiBsb2Fycixcblx0bG9icms6IGxvYnJrLFxuXHRsb25nbGVmdGFycm93OiBsb25nbGVmdGFycm93LFxuXHRMb25nTGVmdEFycm93OiBMb25nTGVmdEFycm93LFxuXHRMb25nbGVmdGFycm93OiBMb25nbGVmdGFycm93LFxuXHRsb25nbGVmdHJpZ2h0YXJyb3c6IGxvbmdsZWZ0cmlnaHRhcnJvdyxcblx0TG9uZ0xlZnRSaWdodEFycm93OiBMb25nTGVmdFJpZ2h0QXJyb3csXG5cdExvbmdsZWZ0cmlnaHRhcnJvdzogTG9uZ2xlZnRyaWdodGFycm93LFxuXHRsb25nbWFwc3RvOiBsb25nbWFwc3RvLFxuXHRsb25ncmlnaHRhcnJvdzogbG9uZ3JpZ2h0YXJyb3csXG5cdExvbmdSaWdodEFycm93OiBMb25nUmlnaHRBcnJvdyxcblx0TG9uZ3JpZ2h0YXJyb3c6IExvbmdyaWdodGFycm93LFxuXHRsb29wYXJyb3dsZWZ0OiBsb29wYXJyb3dsZWZ0LFxuXHRsb29wYXJyb3dyaWdodDogbG9vcGFycm93cmlnaHQsXG5cdGxvcGFyOiBsb3Bhcixcblx0TG9wZjogTG9wZixcblx0bG9wZjogbG9wZixcblx0bG9wbHVzOiBsb3BsdXMsXG5cdGxvdGltZXM6IGxvdGltZXMsXG5cdGxvd2FzdDogbG93YXN0LFxuXHRsb3diYXI6IGxvd2Jhcixcblx0TG93ZXJMZWZ0QXJyb3c6IExvd2VyTGVmdEFycm93LFxuXHRMb3dlclJpZ2h0QXJyb3c6IExvd2VyUmlnaHRBcnJvdyxcblx0bG96OiBsb3osXG5cdGxvemVuZ2U6IGxvemVuZ2UsXG5cdGxvemY6IGxvemYsXG5cdGxwYXI6IGxwYXIsXG5cdGxwYXJsdDogbHBhcmx0LFxuXHRscmFycjogbHJhcnIsXG5cdGxyY29ybmVyOiBscmNvcm5lcixcblx0bHJoYXI6IGxyaGFyLFxuXHRscmhhcmQ6IGxyaGFyZCxcblx0bHJtOiBscm0sXG5cdGxydHJpOiBscnRyaSxcblx0bHNhcXVvOiBsc2FxdW8sXG5cdGxzY3I6IGxzY3IsXG5cdExzY3I6IExzY3IsXG5cdGxzaDogbHNoLFxuXHRMc2g6IExzaCxcblx0bHNpbTogbHNpbSxcblx0bHNpbWU6IGxzaW1lLFxuXHRsc2ltZzogbHNpbWcsXG5cdGxzcWI6IGxzcWIsXG5cdGxzcXVvOiBsc3F1byxcblx0bHNxdW9yOiBsc3F1b3IsXG5cdExzdHJvazogTHN0cm9rLFxuXHRsc3Ryb2s6IGxzdHJvayxcblx0bHRjYzogbHRjYyxcblx0bHRjaXI6IGx0Y2lyLFxuXHRsdDogbHQkMixcblx0TFQ6IExUJDEsXG5cdEx0OiBMdCxcblx0bHRkb3Q6IGx0ZG90LFxuXHRsdGhyZWU6IGx0aHJlZSxcblx0bHRpbWVzOiBsdGltZXMsXG5cdGx0bGFycjogbHRsYXJyLFxuXHRsdHF1ZXN0OiBsdHF1ZXN0LFxuXHRsdHJpOiBsdHJpLFxuXHRsdHJpZTogbHRyaWUsXG5cdGx0cmlmOiBsdHJpZixcblx0bHRyUGFyOiBsdHJQYXIsXG5cdGx1cmRzaGFyOiBsdXJkc2hhcixcblx0bHVydWhhcjogbHVydWhhcixcblx0bHZlcnRuZXFxOiBsdmVydG5lcXEsXG5cdGx2bkU6IGx2bkUsXG5cdG1hY3I6IG1hY3IkMSxcblx0bWFsZTogbWFsZSxcblx0bWFsdDogbWFsdCxcblx0bWFsdGVzZTogbWFsdGVzZSxcblx0XCJNYXBcIjogXCLipIVcIixcblx0bWFwOiBtYXAsXG5cdG1hcHN0bzogbWFwc3RvLFxuXHRtYXBzdG9kb3duOiBtYXBzdG9kb3duLFxuXHRtYXBzdG9sZWZ0OiBtYXBzdG9sZWZ0LFxuXHRtYXBzdG91cDogbWFwc3RvdXAsXG5cdG1hcmtlcjogbWFya2VyLFxuXHRtY29tbWE6IG1jb21tYSxcblx0TWN5OiBNY3ksXG5cdG1jeTogbWN5LFxuXHRtZGFzaDogbWRhc2gsXG5cdG1ERG90OiBtRERvdCxcblx0bWVhc3VyZWRhbmdsZTogbWVhc3VyZWRhbmdsZSxcblx0TWVkaXVtU3BhY2U6IE1lZGl1bVNwYWNlLFxuXHRNZWxsaW50cmY6IE1lbGxpbnRyZixcblx0TWZyOiBNZnIsXG5cdG1mcjogbWZyLFxuXHRtaG86IG1obyxcblx0bWljcm86IG1pY3JvJDEsXG5cdG1pZGFzdDogbWlkYXN0LFxuXHRtaWRjaXI6IG1pZGNpcixcblx0bWlkOiBtaWQsXG5cdG1pZGRvdDogbWlkZG90JDEsXG5cdG1pbnVzYjogbWludXNiLFxuXHRtaW51czogbWludXMsXG5cdG1pbnVzZDogbWludXNkLFxuXHRtaW51c2R1OiBtaW51c2R1LFxuXHRNaW51c1BsdXM6IE1pbnVzUGx1cyxcblx0bWxjcDogbWxjcCxcblx0bWxkcjogbWxkcixcblx0bW5wbHVzOiBtbnBsdXMsXG5cdG1vZGVsczogbW9kZWxzLFxuXHRNb3BmOiBNb3BmLFxuXHRtb3BmOiBtb3BmLFxuXHRtcDogbXAsXG5cdG1zY3I6IG1zY3IsXG5cdE1zY3I6IE1zY3IsXG5cdG1zdHBvczogbXN0cG9zLFxuXHRNdTogTXUsXG5cdG11OiBtdSxcblx0bXVsdGltYXA6IG11bHRpbWFwLFxuXHRtdW1hcDogbXVtYXAsXG5cdG5hYmxhOiBuYWJsYSxcblx0TmFjdXRlOiBOYWN1dGUsXG5cdG5hY3V0ZTogbmFjdXRlLFxuXHRuYW5nOiBuYW5nLFxuXHRuYXA6IG5hcCxcblx0bmFwRTogbmFwRSxcblx0bmFwaWQ6IG5hcGlkLFxuXHRuYXBvczogbmFwb3MsXG5cdG5hcHByb3g6IG5hcHByb3gsXG5cdG5hdHVyYWw6IG5hdHVyYWwsXG5cdG5hdHVyYWxzOiBuYXR1cmFscyxcblx0bmF0dXI6IG5hdHVyLFxuXHRuYnNwOiBuYnNwJDEsXG5cdG5idW1wOiBuYnVtcCxcblx0bmJ1bXBlOiBuYnVtcGUsXG5cdG5jYXA6IG5jYXAsXG5cdE5jYXJvbjogTmNhcm9uLFxuXHRuY2Fyb246IG5jYXJvbixcblx0TmNlZGlsOiBOY2VkaWwsXG5cdG5jZWRpbDogbmNlZGlsLFxuXHRuY29uZzogbmNvbmcsXG5cdG5jb25nZG90OiBuY29uZ2RvdCxcblx0bmN1cDogbmN1cCxcblx0TmN5OiBOY3ksXG5cdG5jeTogbmN5LFxuXHRuZGFzaDogbmRhc2gsXG5cdG5lYXJoazogbmVhcmhrLFxuXHRuZWFycjogbmVhcnIsXG5cdG5lQXJyOiBuZUFycixcblx0bmVhcnJvdzogbmVhcnJvdyxcblx0bmU6IG5lLFxuXHRuZWRvdDogbmVkb3QsXG5cdE5lZ2F0aXZlTWVkaXVtU3BhY2U6IE5lZ2F0aXZlTWVkaXVtU3BhY2UsXG5cdE5lZ2F0aXZlVGhpY2tTcGFjZTogTmVnYXRpdmVUaGlja1NwYWNlLFxuXHROZWdhdGl2ZVRoaW5TcGFjZTogTmVnYXRpdmVUaGluU3BhY2UsXG5cdE5lZ2F0aXZlVmVyeVRoaW5TcGFjZTogTmVnYXRpdmVWZXJ5VGhpblNwYWNlLFxuXHRuZXF1aXY6IG5lcXVpdixcblx0bmVzZWFyOiBuZXNlYXIsXG5cdG5lc2ltOiBuZXNpbSxcblx0TmVzdGVkR3JlYXRlckdyZWF0ZXI6IE5lc3RlZEdyZWF0ZXJHcmVhdGVyLFxuXHROZXN0ZWRMZXNzTGVzczogTmVzdGVkTGVzc0xlc3MsXG5cdE5ld0xpbmU6IE5ld0xpbmUsXG5cdG5leGlzdDogbmV4aXN0LFxuXHRuZXhpc3RzOiBuZXhpc3RzLFxuXHROZnI6IE5mcixcblx0bmZyOiBuZnIsXG5cdG5nRTogbmdFLFxuXHRuZ2U6IG5nZSxcblx0bmdlcTogbmdlcSxcblx0bmdlcXE6IG5nZXFxLFxuXHRuZ2Vxc2xhbnQ6IG5nZXFzbGFudCxcblx0bmdlczogbmdlcyxcblx0bkdnOiBuR2csXG5cdG5nc2ltOiBuZ3NpbSxcblx0bkd0OiBuR3QsXG5cdG5ndDogbmd0LFxuXHRuZ3RyOiBuZ3RyLFxuXHRuR3R2OiBuR3R2LFxuXHRuaGFycjogbmhhcnIsXG5cdG5oQXJyOiBuaEFycixcblx0bmhwYXI6IG5ocGFyLFxuXHRuaTogbmksXG5cdG5pczogbmlzLFxuXHRuaXNkOiBuaXNkLFxuXHRuaXY6IG5pdixcblx0TkpjeTogTkpjeSxcblx0bmpjeTogbmpjeSxcblx0bmxhcnI6IG5sYXJyLFxuXHRubEFycjogbmxBcnIsXG5cdG5sZHI6IG5sZHIsXG5cdG5sRTogbmxFLFxuXHRubGU6IG5sZSxcblx0bmxlZnRhcnJvdzogbmxlZnRhcnJvdyxcblx0bkxlZnRhcnJvdzogbkxlZnRhcnJvdyxcblx0bmxlZnRyaWdodGFycm93OiBubGVmdHJpZ2h0YXJyb3csXG5cdG5MZWZ0cmlnaHRhcnJvdzogbkxlZnRyaWdodGFycm93LFxuXHRubGVxOiBubGVxLFxuXHRubGVxcTogbmxlcXEsXG5cdG5sZXFzbGFudDogbmxlcXNsYW50LFxuXHRubGVzOiBubGVzLFxuXHRubGVzczogbmxlc3MsXG5cdG5MbDogbkxsLFxuXHRubHNpbTogbmxzaW0sXG5cdG5MdDogbkx0LFxuXHRubHQ6IG5sdCxcblx0bmx0cmk6IG5sdHJpLFxuXHRubHRyaWU6IG5sdHJpZSxcblx0bkx0djogbkx0dixcblx0bm1pZDogbm1pZCxcblx0Tm9CcmVhazogTm9CcmVhayxcblx0Tm9uQnJlYWtpbmdTcGFjZTogTm9uQnJlYWtpbmdTcGFjZSxcblx0bm9wZjogbm9wZixcblx0Tm9wZjogTm9wZixcblx0Tm90OiBOb3QsXG5cdG5vdDogbm90JDEsXG5cdE5vdENvbmdydWVudDogTm90Q29uZ3J1ZW50LFxuXHROb3RDdXBDYXA6IE5vdEN1cENhcCxcblx0Tm90RG91YmxlVmVydGljYWxCYXI6IE5vdERvdWJsZVZlcnRpY2FsQmFyLFxuXHROb3RFbGVtZW50OiBOb3RFbGVtZW50LFxuXHROb3RFcXVhbDogTm90RXF1YWwsXG5cdE5vdEVxdWFsVGlsZGU6IE5vdEVxdWFsVGlsZGUsXG5cdE5vdEV4aXN0czogTm90RXhpc3RzLFxuXHROb3RHcmVhdGVyOiBOb3RHcmVhdGVyLFxuXHROb3RHcmVhdGVyRXF1YWw6IE5vdEdyZWF0ZXJFcXVhbCxcblx0Tm90R3JlYXRlckZ1bGxFcXVhbDogTm90R3JlYXRlckZ1bGxFcXVhbCxcblx0Tm90R3JlYXRlckdyZWF0ZXI6IE5vdEdyZWF0ZXJHcmVhdGVyLFxuXHROb3RHcmVhdGVyTGVzczogTm90R3JlYXRlckxlc3MsXG5cdE5vdEdyZWF0ZXJTbGFudEVxdWFsOiBOb3RHcmVhdGVyU2xhbnRFcXVhbCxcblx0Tm90R3JlYXRlclRpbGRlOiBOb3RHcmVhdGVyVGlsZGUsXG5cdE5vdEh1bXBEb3duSHVtcDogTm90SHVtcERvd25IdW1wLFxuXHROb3RIdW1wRXF1YWw6IE5vdEh1bXBFcXVhbCxcblx0bm90aW46IG5vdGluLFxuXHRub3RpbmRvdDogbm90aW5kb3QsXG5cdG5vdGluRTogbm90aW5FLFxuXHRub3RpbnZhOiBub3RpbnZhLFxuXHRub3RpbnZiOiBub3RpbnZiLFxuXHRub3RpbnZjOiBub3RpbnZjLFxuXHROb3RMZWZ0VHJpYW5nbGVCYXI6IE5vdExlZnRUcmlhbmdsZUJhcixcblx0Tm90TGVmdFRyaWFuZ2xlOiBOb3RMZWZ0VHJpYW5nbGUsXG5cdE5vdExlZnRUcmlhbmdsZUVxdWFsOiBOb3RMZWZ0VHJpYW5nbGVFcXVhbCxcblx0Tm90TGVzczogTm90TGVzcyxcblx0Tm90TGVzc0VxdWFsOiBOb3RMZXNzRXF1YWwsXG5cdE5vdExlc3NHcmVhdGVyOiBOb3RMZXNzR3JlYXRlcixcblx0Tm90TGVzc0xlc3M6IE5vdExlc3NMZXNzLFxuXHROb3RMZXNzU2xhbnRFcXVhbDogTm90TGVzc1NsYW50RXF1YWwsXG5cdE5vdExlc3NUaWxkZTogTm90TGVzc1RpbGRlLFxuXHROb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjogTm90TmVzdGVkR3JlYXRlckdyZWF0ZXIsXG5cdE5vdE5lc3RlZExlc3NMZXNzOiBOb3ROZXN0ZWRMZXNzTGVzcyxcblx0bm90bmk6IG5vdG5pLFxuXHRub3RuaXZhOiBub3RuaXZhLFxuXHRub3RuaXZiOiBub3RuaXZiLFxuXHRub3RuaXZjOiBub3RuaXZjLFxuXHROb3RQcmVjZWRlczogTm90UHJlY2VkZXMsXG5cdE5vdFByZWNlZGVzRXF1YWw6IE5vdFByZWNlZGVzRXF1YWwsXG5cdE5vdFByZWNlZGVzU2xhbnRFcXVhbDogTm90UHJlY2VkZXNTbGFudEVxdWFsLFxuXHROb3RSZXZlcnNlRWxlbWVudDogTm90UmV2ZXJzZUVsZW1lbnQsXG5cdE5vdFJpZ2h0VHJpYW5nbGVCYXI6IE5vdFJpZ2h0VHJpYW5nbGVCYXIsXG5cdE5vdFJpZ2h0VHJpYW5nbGU6IE5vdFJpZ2h0VHJpYW5nbGUsXG5cdE5vdFJpZ2h0VHJpYW5nbGVFcXVhbDogTm90UmlnaHRUcmlhbmdsZUVxdWFsLFxuXHROb3RTcXVhcmVTdWJzZXQ6IE5vdFNxdWFyZVN1YnNldCxcblx0Tm90U3F1YXJlU3Vic2V0RXF1YWw6IE5vdFNxdWFyZVN1YnNldEVxdWFsLFxuXHROb3RTcXVhcmVTdXBlcnNldDogTm90U3F1YXJlU3VwZXJzZXQsXG5cdE5vdFNxdWFyZVN1cGVyc2V0RXF1YWw6IE5vdFNxdWFyZVN1cGVyc2V0RXF1YWwsXG5cdE5vdFN1YnNldDogTm90U3Vic2V0LFxuXHROb3RTdWJzZXRFcXVhbDogTm90U3Vic2V0RXF1YWwsXG5cdE5vdFN1Y2NlZWRzOiBOb3RTdWNjZWVkcyxcblx0Tm90U3VjY2VlZHNFcXVhbDogTm90U3VjY2VlZHNFcXVhbCxcblx0Tm90U3VjY2VlZHNTbGFudEVxdWFsOiBOb3RTdWNjZWVkc1NsYW50RXF1YWwsXG5cdE5vdFN1Y2NlZWRzVGlsZGU6IE5vdFN1Y2NlZWRzVGlsZGUsXG5cdE5vdFN1cGVyc2V0OiBOb3RTdXBlcnNldCxcblx0Tm90U3VwZXJzZXRFcXVhbDogTm90U3VwZXJzZXRFcXVhbCxcblx0Tm90VGlsZGU6IE5vdFRpbGRlLFxuXHROb3RUaWxkZUVxdWFsOiBOb3RUaWxkZUVxdWFsLFxuXHROb3RUaWxkZUZ1bGxFcXVhbDogTm90VGlsZGVGdWxsRXF1YWwsXG5cdE5vdFRpbGRlVGlsZGU6IE5vdFRpbGRlVGlsZGUsXG5cdE5vdFZlcnRpY2FsQmFyOiBOb3RWZXJ0aWNhbEJhcixcblx0bnBhcmFsbGVsOiBucGFyYWxsZWwsXG5cdG5wYXI6IG5wYXIsXG5cdG5wYXJzbDogbnBhcnNsLFxuXHRucGFydDogbnBhcnQsXG5cdG5wb2xpbnQ6IG5wb2xpbnQsXG5cdG5wcjogbnByLFxuXHRucHJjdWU6IG5wcmN1ZSxcblx0bnByZWM6IG5wcmVjLFxuXHRucHJlY2VxOiBucHJlY2VxLFxuXHRucHJlOiBucHJlLFxuXHRucmFycmM6IG5yYXJyYyxcblx0bnJhcnI6IG5yYXJyLFxuXHRuckFycjogbnJBcnIsXG5cdG5yYXJydzogbnJhcnJ3LFxuXHRucmlnaHRhcnJvdzogbnJpZ2h0YXJyb3csXG5cdG5SaWdodGFycm93OiBuUmlnaHRhcnJvdyxcblx0bnJ0cmk6IG5ydHJpLFxuXHRucnRyaWU6IG5ydHJpZSxcblx0bnNjOiBuc2MsXG5cdG5zY2N1ZTogbnNjY3VlLFxuXHRuc2NlOiBuc2NlLFxuXHROc2NyOiBOc2NyLFxuXHRuc2NyOiBuc2NyLFxuXHRuc2hvcnRtaWQ6IG5zaG9ydG1pZCxcblx0bnNob3J0cGFyYWxsZWw6IG5zaG9ydHBhcmFsbGVsLFxuXHRuc2ltOiBuc2ltLFxuXHRuc2ltZTogbnNpbWUsXG5cdG5zaW1lcTogbnNpbWVxLFxuXHRuc21pZDogbnNtaWQsXG5cdG5zcGFyOiBuc3Bhcixcblx0bnNxc3ViZTogbnNxc3ViZSxcblx0bnNxc3VwZTogbnNxc3VwZSxcblx0bnN1YjogbnN1Yixcblx0bnN1YkU6IG5zdWJFLFxuXHRuc3ViZTogbnN1YmUsXG5cdG5zdWJzZXQ6IG5zdWJzZXQsXG5cdG5zdWJzZXRlcTogbnN1YnNldGVxLFxuXHRuc3Vic2V0ZXFxOiBuc3Vic2V0ZXFxLFxuXHRuc3VjYzogbnN1Y2MsXG5cdG5zdWNjZXE6IG5zdWNjZXEsXG5cdG5zdXA6IG5zdXAsXG5cdG5zdXBFOiBuc3VwRSxcblx0bnN1cGU6IG5zdXBlLFxuXHRuc3Vwc2V0OiBuc3Vwc2V0LFxuXHRuc3Vwc2V0ZXE6IG5zdXBzZXRlcSxcblx0bnN1cHNldGVxcTogbnN1cHNldGVxcSxcblx0bnRnbDogbnRnbCxcblx0TnRpbGRlOiBOdGlsZGUkMSxcblx0bnRpbGRlOiBudGlsZGUkMSxcblx0bnRsZzogbnRsZyxcblx0bnRyaWFuZ2xlbGVmdDogbnRyaWFuZ2xlbGVmdCxcblx0bnRyaWFuZ2xlbGVmdGVxOiBudHJpYW5nbGVsZWZ0ZXEsXG5cdG50cmlhbmdsZXJpZ2h0OiBudHJpYW5nbGVyaWdodCxcblx0bnRyaWFuZ2xlcmlnaHRlcTogbnRyaWFuZ2xlcmlnaHRlcSxcblx0TnU6IE51LFxuXHRudTogbnUsXG5cdG51bTogbnVtLFxuXHRudW1lcm86IG51bWVybyxcblx0bnVtc3A6IG51bXNwLFxuXHRudmFwOiBudmFwLFxuXHRudmRhc2g6IG52ZGFzaCxcblx0bnZEYXNoOiBudkRhc2gsXG5cdG5WZGFzaDogblZkYXNoLFxuXHRuVkRhc2g6IG5WRGFzaCxcblx0bnZnZTogbnZnZSxcblx0bnZndDogbnZndCxcblx0bnZIYXJyOiBudkhhcnIsXG5cdG52aW5maW46IG52aW5maW4sXG5cdG52bEFycjogbnZsQXJyLFxuXHRudmxlOiBudmxlLFxuXHRudmx0OiBudmx0LFxuXHRudmx0cmllOiBudmx0cmllLFxuXHRudnJBcnI6IG52ckFycixcblx0bnZydHJpZTogbnZydHJpZSxcblx0bnZzaW06IG52c2ltLFxuXHRud2FyaGs6IG53YXJoayxcblx0bndhcnI6IG53YXJyLFxuXHRud0FycjogbndBcnIsXG5cdG53YXJyb3c6IG53YXJyb3csXG5cdG53bmVhcjogbnduZWFyLFxuXHRPYWN1dGU6IE9hY3V0ZSQxLFxuXHRvYWN1dGU6IG9hY3V0ZSQxLFxuXHRvYXN0OiBvYXN0LFxuXHRPY2lyYzogT2NpcmMkMSxcblx0b2NpcmM6IG9jaXJjJDEsXG5cdG9jaXI6IG9jaXIsXG5cdE9jeTogT2N5LFxuXHRvY3k6IG9jeSxcblx0b2Rhc2g6IG9kYXNoLFxuXHRPZGJsYWM6IE9kYmxhYyxcblx0b2RibGFjOiBvZGJsYWMsXG5cdG9kaXY6IG9kaXYsXG5cdG9kb3Q6IG9kb3QsXG5cdG9kc29sZDogb2Rzb2xkLFxuXHRPRWxpZzogT0VsaWcsXG5cdG9lbGlnOiBvZWxpZyxcblx0b2ZjaXI6IG9mY2lyLFxuXHRPZnI6IE9mcixcblx0b2ZyOiBvZnIsXG5cdG9nb246IG9nb24sXG5cdE9ncmF2ZTogT2dyYXZlJDEsXG5cdG9ncmF2ZTogb2dyYXZlJDEsXG5cdG9ndDogb2d0LFxuXHRvaGJhcjogb2hiYXIsXG5cdG9obTogb2htLFxuXHRvaW50OiBvaW50LFxuXHRvbGFycjogb2xhcnIsXG5cdG9sY2lyOiBvbGNpcixcblx0b2xjcm9zczogb2xjcm9zcyxcblx0b2xpbmU6IG9saW5lLFxuXHRvbHQ6IG9sdCxcblx0T21hY3I6IE9tYWNyLFxuXHRvbWFjcjogb21hY3IsXG5cdE9tZWdhOiBPbWVnYSxcblx0b21lZ2E6IG9tZWdhLFxuXHRPbWljcm9uOiBPbWljcm9uLFxuXHRvbWljcm9uOiBvbWljcm9uLFxuXHRvbWlkOiBvbWlkLFxuXHRvbWludXM6IG9taW51cyxcblx0T29wZjogT29wZixcblx0b29wZjogb29wZixcblx0b3Bhcjogb3Bhcixcblx0T3BlbkN1cmx5RG91YmxlUXVvdGU6IE9wZW5DdXJseURvdWJsZVF1b3RlLFxuXHRPcGVuQ3VybHlRdW90ZTogT3BlbkN1cmx5UXVvdGUsXG5cdG9wZXJwOiBvcGVycCxcblx0b3BsdXM6IG9wbHVzLFxuXHRvcmFycjogb3JhcnIsXG5cdE9yOiBPcixcblx0b3I6IG9yLFxuXHRvcmQ6IG9yZCxcblx0b3JkZXI6IG9yZGVyLFxuXHRvcmRlcm9mOiBvcmRlcm9mLFxuXHRvcmRmOiBvcmRmJDEsXG5cdG9yZG06IG9yZG0kMSxcblx0b3JpZ29mOiBvcmlnb2YsXG5cdG9yb3I6IG9yb3IsXG5cdG9yc2xvcGU6IG9yc2xvcGUsXG5cdG9ydjogb3J2LFxuXHRvUzogb1MsXG5cdE9zY3I6IE9zY3IsXG5cdG9zY3I6IG9zY3IsXG5cdE9zbGFzaDogT3NsYXNoJDEsXG5cdG9zbGFzaDogb3NsYXNoJDEsXG5cdG9zb2w6IG9zb2wsXG5cdE90aWxkZTogT3RpbGRlJDEsXG5cdG90aWxkZTogb3RpbGRlJDEsXG5cdG90aW1lc2FzOiBvdGltZXNhcyxcblx0T3RpbWVzOiBPdGltZXMsXG5cdG90aW1lczogb3RpbWVzLFxuXHRPdW1sOiBPdW1sJDEsXG5cdG91bWw6IG91bWwkMSxcblx0b3ZiYXI6IG92YmFyLFxuXHRPdmVyQmFyOiBPdmVyQmFyLFxuXHRPdmVyQnJhY2U6IE92ZXJCcmFjZSxcblx0T3ZlckJyYWNrZXQ6IE92ZXJCcmFja2V0LFxuXHRPdmVyUGFyZW50aGVzaXM6IE92ZXJQYXJlbnRoZXNpcyxcblx0cGFyYTogcGFyYSQxLFxuXHRwYXJhbGxlbDogcGFyYWxsZWwsXG5cdHBhcjogcGFyLFxuXHRwYXJzaW06IHBhcnNpbSxcblx0cGFyc2w6IHBhcnNsLFxuXHRwYXJ0OiBwYXJ0LFxuXHRQYXJ0aWFsRDogUGFydGlhbEQsXG5cdFBjeTogUGN5LFxuXHRwY3k6IHBjeSxcblx0cGVyY250OiBwZXJjbnQsXG5cdHBlcmlvZDogcGVyaW9kLFxuXHRwZXJtaWw6IHBlcm1pbCxcblx0cGVycDogcGVycCxcblx0cGVydGVuazogcGVydGVuayxcblx0UGZyOiBQZnIsXG5cdHBmcjogcGZyLFxuXHRQaGk6IFBoaSxcblx0cGhpOiBwaGksXG5cdHBoaXY6IHBoaXYsXG5cdHBobW1hdDogcGhtbWF0LFxuXHRwaG9uZTogcGhvbmUsXG5cdFBpOiBQaSxcblx0cGk6IHBpLFxuXHRwaXRjaGZvcms6IHBpdGNoZm9yayxcblx0cGl2OiBwaXYsXG5cdHBsYW5jazogcGxhbmNrLFxuXHRwbGFuY2toOiBwbGFuY2toLFxuXHRwbGFua3Y6IHBsYW5rdixcblx0cGx1c2FjaXI6IHBsdXNhY2lyLFxuXHRwbHVzYjogcGx1c2IsXG5cdHBsdXNjaXI6IHBsdXNjaXIsXG5cdHBsdXM6IHBsdXMsXG5cdHBsdXNkbzogcGx1c2RvLFxuXHRwbHVzZHU6IHBsdXNkdSxcblx0cGx1c2U6IHBsdXNlLFxuXHRQbHVzTWludXM6IFBsdXNNaW51cyxcblx0cGx1c21uOiBwbHVzbW4kMSxcblx0cGx1c3NpbTogcGx1c3NpbSxcblx0cGx1c3R3bzogcGx1c3R3byxcblx0cG06IHBtLFxuXHRQb2luY2FyZXBsYW5lOiBQb2luY2FyZXBsYW5lLFxuXHRwb2ludGludDogcG9pbnRpbnQsXG5cdHBvcGY6IHBvcGYsXG5cdFBvcGY6IFBvcGYsXG5cdHBvdW5kOiBwb3VuZCQxLFxuXHRwcmFwOiBwcmFwLFxuXHRQcjogUHIsXG5cdHByOiBwcixcblx0cHJjdWU6IHByY3VlLFxuXHRwcmVjYXBwcm94OiBwcmVjYXBwcm94LFxuXHRwcmVjOiBwcmVjLFxuXHRwcmVjY3VybHllcTogcHJlY2N1cmx5ZXEsXG5cdFByZWNlZGVzOiBQcmVjZWRlcyxcblx0UHJlY2VkZXNFcXVhbDogUHJlY2VkZXNFcXVhbCxcblx0UHJlY2VkZXNTbGFudEVxdWFsOiBQcmVjZWRlc1NsYW50RXF1YWwsXG5cdFByZWNlZGVzVGlsZGU6IFByZWNlZGVzVGlsZGUsXG5cdHByZWNlcTogcHJlY2VxLFxuXHRwcmVjbmFwcHJveDogcHJlY25hcHByb3gsXG5cdHByZWNuZXFxOiBwcmVjbmVxcSxcblx0cHJlY25zaW06IHByZWNuc2ltLFxuXHRwcmU6IHByZSxcblx0cHJFOiBwckUsXG5cdHByZWNzaW06IHByZWNzaW0sXG5cdHByaW1lOiBwcmltZSxcblx0UHJpbWU6IFByaW1lLFxuXHRwcmltZXM6IHByaW1lcyxcblx0cHJuYXA6IHBybmFwLFxuXHRwcm5FOiBwcm5FLFxuXHRwcm5zaW06IHBybnNpbSxcblx0cHJvZDogcHJvZCxcblx0UHJvZHVjdDogUHJvZHVjdCxcblx0cHJvZmFsYXI6IHByb2ZhbGFyLFxuXHRwcm9mbGluZTogcHJvZmxpbmUsXG5cdHByb2ZzdXJmOiBwcm9mc3VyZixcblx0cHJvcDogcHJvcCxcblx0UHJvcG9ydGlvbmFsOiBQcm9wb3J0aW9uYWwsXG5cdFByb3BvcnRpb246IFByb3BvcnRpb24sXG5cdHByb3B0bzogcHJvcHRvLFxuXHRwcnNpbTogcHJzaW0sXG5cdHBydXJlbDogcHJ1cmVsLFxuXHRQc2NyOiBQc2NyLFxuXHRwc2NyOiBwc2NyLFxuXHRQc2k6IFBzaSxcblx0cHNpOiBwc2ksXG5cdHB1bmNzcDogcHVuY3NwLFxuXHRRZnI6IFFmcixcblx0cWZyOiBxZnIsXG5cdHFpbnQ6IHFpbnQsXG5cdHFvcGY6IHFvcGYsXG5cdFFvcGY6IFFvcGYsXG5cdHFwcmltZTogcXByaW1lLFxuXHRRc2NyOiBRc2NyLFxuXHRxc2NyOiBxc2NyLFxuXHRxdWF0ZXJuaW9uczogcXVhdGVybmlvbnMsXG5cdHF1YXRpbnQ6IHF1YXRpbnQsXG5cdHF1ZXN0OiBxdWVzdCxcblx0cXVlc3RlcTogcXVlc3RlcSxcblx0cXVvdDogcXVvdCQyLFxuXHRRVU9UOiBRVU9UJDEsXG5cdHJBYXJyOiByQWFycixcblx0cmFjZTogcmFjZSxcblx0UmFjdXRlOiBSYWN1dGUsXG5cdHJhY3V0ZTogcmFjdXRlLFxuXHRyYWRpYzogcmFkaWMsXG5cdHJhZW1wdHl2OiByYWVtcHR5dixcblx0cmFuZzogcmFuZyxcblx0UmFuZzogUmFuZyxcblx0cmFuZ2Q6IHJhbmdkLFxuXHRyYW5nZTogcmFuZ2UsXG5cdHJhbmdsZTogcmFuZ2xlLFxuXHRyYXF1bzogcmFxdW8kMSxcblx0cmFycmFwOiByYXJyYXAsXG5cdHJhcnJiOiByYXJyYixcblx0cmFycmJmczogcmFycmJmcyxcblx0cmFycmM6IHJhcnJjLFxuXHRyYXJyOiByYXJyLFxuXHRSYXJyOiBSYXJyLFxuXHRyQXJyOiByQXJyLFxuXHRyYXJyZnM6IHJhcnJmcyxcblx0cmFycmhrOiByYXJyaGssXG5cdHJhcnJscDogcmFycmxwLFxuXHRyYXJycGw6IHJhcnJwbCxcblx0cmFycnNpbTogcmFycnNpbSxcblx0UmFycnRsOiBSYXJydGwsXG5cdHJhcnJ0bDogcmFycnRsLFxuXHRyYXJydzogcmFycncsXG5cdHJhdGFpbDogcmF0YWlsLFxuXHRyQXRhaWw6IHJBdGFpbCxcblx0cmF0aW86IHJhdGlvLFxuXHRyYXRpb25hbHM6IHJhdGlvbmFscyxcblx0cmJhcnI6IHJiYXJyLFxuXHRyQmFycjogckJhcnIsXG5cdFJCYXJyOiBSQmFycixcblx0cmJicms6IHJiYnJrLFxuXHRyYnJhY2U6IHJicmFjZSxcblx0cmJyYWNrOiByYnJhY2ssXG5cdHJicmtlOiByYnJrZSxcblx0cmJya3NsZDogcmJya3NsZCxcblx0cmJya3NsdTogcmJya3NsdSxcblx0UmNhcm9uOiBSY2Fyb24sXG5cdHJjYXJvbjogcmNhcm9uLFxuXHRSY2VkaWw6IFJjZWRpbCxcblx0cmNlZGlsOiByY2VkaWwsXG5cdHJjZWlsOiByY2VpbCxcblx0cmN1YjogcmN1Yixcblx0UmN5OiBSY3ksXG5cdHJjeTogcmN5LFxuXHRyZGNhOiByZGNhLFxuXHRyZGxkaGFyOiByZGxkaGFyLFxuXHRyZHF1bzogcmRxdW8sXG5cdHJkcXVvcjogcmRxdW9yLFxuXHRyZHNoOiByZHNoLFxuXHRyZWFsOiByZWFsLFxuXHRyZWFsaW5lOiByZWFsaW5lLFxuXHRyZWFscGFydDogcmVhbHBhcnQsXG5cdHJlYWxzOiByZWFscyxcblx0UmU6IFJlLFxuXHRyZWN0OiByZWN0LFxuXHRyZWc6IHJlZyQxLFxuXHRSRUc6IFJFRyQxLFxuXHRSZXZlcnNlRWxlbWVudDogUmV2ZXJzZUVsZW1lbnQsXG5cdFJldmVyc2VFcXVpbGlicml1bTogUmV2ZXJzZUVxdWlsaWJyaXVtLFxuXHRSZXZlcnNlVXBFcXVpbGlicml1bTogUmV2ZXJzZVVwRXF1aWxpYnJpdW0sXG5cdHJmaXNodDogcmZpc2h0LFxuXHRyZmxvb3I6IHJmbG9vcixcblx0cmZyOiByZnIsXG5cdFJmcjogUmZyLFxuXHRySGFyOiBySGFyLFxuXHRyaGFyZDogcmhhcmQsXG5cdHJoYXJ1OiByaGFydSxcblx0cmhhcnVsOiByaGFydWwsXG5cdFJobzogUmhvLFxuXHRyaG86IHJobyxcblx0cmhvdjogcmhvdixcblx0UmlnaHRBbmdsZUJyYWNrZXQ6IFJpZ2h0QW5nbGVCcmFja2V0LFxuXHRSaWdodEFycm93QmFyOiBSaWdodEFycm93QmFyLFxuXHRyaWdodGFycm93OiByaWdodGFycm93LFxuXHRSaWdodEFycm93OiBSaWdodEFycm93LFxuXHRSaWdodGFycm93OiBSaWdodGFycm93LFxuXHRSaWdodEFycm93TGVmdEFycm93OiBSaWdodEFycm93TGVmdEFycm93LFxuXHRyaWdodGFycm93dGFpbDogcmlnaHRhcnJvd3RhaWwsXG5cdFJpZ2h0Q2VpbGluZzogUmlnaHRDZWlsaW5nLFxuXHRSaWdodERvdWJsZUJyYWNrZXQ6IFJpZ2h0RG91YmxlQnJhY2tldCxcblx0UmlnaHREb3duVGVlVmVjdG9yOiBSaWdodERvd25UZWVWZWN0b3IsXG5cdFJpZ2h0RG93blZlY3RvckJhcjogUmlnaHREb3duVmVjdG9yQmFyLFxuXHRSaWdodERvd25WZWN0b3I6IFJpZ2h0RG93blZlY3Rvcixcblx0UmlnaHRGbG9vcjogUmlnaHRGbG9vcixcblx0cmlnaHRoYXJwb29uZG93bjogcmlnaHRoYXJwb29uZG93bixcblx0cmlnaHRoYXJwb29udXA6IHJpZ2h0aGFycG9vbnVwLFxuXHRyaWdodGxlZnRhcnJvd3M6IHJpZ2h0bGVmdGFycm93cyxcblx0cmlnaHRsZWZ0aGFycG9vbnM6IHJpZ2h0bGVmdGhhcnBvb25zLFxuXHRyaWdodHJpZ2h0YXJyb3dzOiByaWdodHJpZ2h0YXJyb3dzLFxuXHRyaWdodHNxdWlnYXJyb3c6IHJpZ2h0c3F1aWdhcnJvdyxcblx0UmlnaHRUZWVBcnJvdzogUmlnaHRUZWVBcnJvdyxcblx0UmlnaHRUZWU6IFJpZ2h0VGVlLFxuXHRSaWdodFRlZVZlY3RvcjogUmlnaHRUZWVWZWN0b3IsXG5cdHJpZ2h0dGhyZWV0aW1lczogcmlnaHR0aHJlZXRpbWVzLFxuXHRSaWdodFRyaWFuZ2xlQmFyOiBSaWdodFRyaWFuZ2xlQmFyLFxuXHRSaWdodFRyaWFuZ2xlOiBSaWdodFRyaWFuZ2xlLFxuXHRSaWdodFRyaWFuZ2xlRXF1YWw6IFJpZ2h0VHJpYW5nbGVFcXVhbCxcblx0UmlnaHRVcERvd25WZWN0b3I6IFJpZ2h0VXBEb3duVmVjdG9yLFxuXHRSaWdodFVwVGVlVmVjdG9yOiBSaWdodFVwVGVlVmVjdG9yLFxuXHRSaWdodFVwVmVjdG9yQmFyOiBSaWdodFVwVmVjdG9yQmFyLFxuXHRSaWdodFVwVmVjdG9yOiBSaWdodFVwVmVjdG9yLFxuXHRSaWdodFZlY3RvckJhcjogUmlnaHRWZWN0b3JCYXIsXG5cdFJpZ2h0VmVjdG9yOiBSaWdodFZlY3Rvcixcblx0cmluZzogcmluZyxcblx0cmlzaW5nZG90c2VxOiByaXNpbmdkb3RzZXEsXG5cdHJsYXJyOiBybGFycixcblx0cmxoYXI6IHJsaGFyLFxuXHRybG06IHJsbSxcblx0cm1vdXN0YWNoZTogcm1vdXN0YWNoZSxcblx0cm1vdXN0OiBybW91c3QsXG5cdHJubWlkOiBybm1pZCxcblx0cm9hbmc6IHJvYW5nLFxuXHRyb2Fycjogcm9hcnIsXG5cdHJvYnJrOiByb2Jyayxcblx0cm9wYXI6IHJvcGFyLFxuXHRyb3BmOiByb3BmLFxuXHRSb3BmOiBSb3BmLFxuXHRyb3BsdXM6IHJvcGx1cyxcblx0cm90aW1lczogcm90aW1lcyxcblx0Um91bmRJbXBsaWVzOiBSb3VuZEltcGxpZXMsXG5cdHJwYXI6IHJwYXIsXG5cdHJwYXJndDogcnBhcmd0LFxuXHRycHBvbGludDogcnBwb2xpbnQsXG5cdHJyYXJyOiBycmFycixcblx0UnJpZ2h0YXJyb3c6IFJyaWdodGFycm93LFxuXHRyc2FxdW86IHJzYXF1byxcblx0cnNjcjogcnNjcixcblx0UnNjcjogUnNjcixcblx0cnNoOiByc2gsXG5cdFJzaDogUnNoLFxuXHRyc3FiOiByc3FiLFxuXHRyc3F1bzogcnNxdW8sXG5cdHJzcXVvcjogcnNxdW9yLFxuXHRydGhyZWU6IHJ0aHJlZSxcblx0cnRpbWVzOiBydGltZXMsXG5cdHJ0cmk6IHJ0cmksXG5cdHJ0cmllOiBydHJpZSxcblx0cnRyaWY6IHJ0cmlmLFxuXHRydHJpbHRyaTogcnRyaWx0cmksXG5cdFJ1bGVEZWxheWVkOiBSdWxlRGVsYXllZCxcblx0cnVsdWhhcjogcnVsdWhhcixcblx0cng6IHJ4LFxuXHRTYWN1dGU6IFNhY3V0ZSxcblx0c2FjdXRlOiBzYWN1dGUsXG5cdHNicXVvOiBzYnF1byxcblx0c2NhcDogc2NhcCxcblx0U2Nhcm9uOiBTY2Fyb24sXG5cdHNjYXJvbjogc2Nhcm9uLFxuXHRTYzogU2MsXG5cdHNjOiBzYyxcblx0c2NjdWU6IHNjY3VlLFxuXHRzY2U6IHNjZSxcblx0c2NFOiBzY0UsXG5cdFNjZWRpbDogU2NlZGlsLFxuXHRzY2VkaWw6IHNjZWRpbCxcblx0U2NpcmM6IFNjaXJjLFxuXHRzY2lyYzogc2NpcmMsXG5cdHNjbmFwOiBzY25hcCxcblx0c2NuRTogc2NuRSxcblx0c2Nuc2ltOiBzY25zaW0sXG5cdHNjcG9saW50OiBzY3BvbGludCxcblx0c2NzaW06IHNjc2ltLFxuXHRTY3k6IFNjeSxcblx0c2N5OiBzY3ksXG5cdHNkb3RiOiBzZG90Yixcblx0c2RvdDogc2RvdCxcblx0c2RvdGU6IHNkb3RlLFxuXHRzZWFyaGs6IHNlYXJoayxcblx0c2VhcnI6IHNlYXJyLFxuXHRzZUFycjogc2VBcnIsXG5cdHNlYXJyb3c6IHNlYXJyb3csXG5cdHNlY3Q6IHNlY3QkMSxcblx0c2VtaTogc2VtaSxcblx0c2Vzd2FyOiBzZXN3YXIsXG5cdHNldG1pbnVzOiBzZXRtaW51cyxcblx0c2V0bW46IHNldG1uLFxuXHRzZXh0OiBzZXh0LFxuXHRTZnI6IFNmcixcblx0c2ZyOiBzZnIsXG5cdHNmcm93bjogc2Zyb3duLFxuXHRzaGFycDogc2hhcnAsXG5cdFNIQ0hjeTogU0hDSGN5LFxuXHRzaGNoY3k6IHNoY2hjeSxcblx0U0hjeTogU0hjeSxcblx0c2hjeTogc2hjeSxcblx0U2hvcnREb3duQXJyb3c6IFNob3J0RG93bkFycm93LFxuXHRTaG9ydExlZnRBcnJvdzogU2hvcnRMZWZ0QXJyb3csXG5cdHNob3J0bWlkOiBzaG9ydG1pZCxcblx0c2hvcnRwYXJhbGxlbDogc2hvcnRwYXJhbGxlbCxcblx0U2hvcnRSaWdodEFycm93OiBTaG9ydFJpZ2h0QXJyb3csXG5cdFNob3J0VXBBcnJvdzogU2hvcnRVcEFycm93LFxuXHRzaHk6IHNoeSQxLFxuXHRTaWdtYTogU2lnbWEsXG5cdHNpZ21hOiBzaWdtYSxcblx0c2lnbWFmOiBzaWdtYWYsXG5cdHNpZ21hdjogc2lnbWF2LFxuXHRzaW06IHNpbSxcblx0c2ltZG90OiBzaW1kb3QsXG5cdHNpbWU6IHNpbWUsXG5cdHNpbWVxOiBzaW1lcSxcblx0c2ltZzogc2ltZyxcblx0c2ltZ0U6IHNpbWdFLFxuXHRzaW1sOiBzaW1sLFxuXHRzaW1sRTogc2ltbEUsXG5cdHNpbW5lOiBzaW1uZSxcblx0c2ltcGx1czogc2ltcGx1cyxcblx0c2ltcmFycjogc2ltcmFycixcblx0c2xhcnI6IHNsYXJyLFxuXHRTbWFsbENpcmNsZTogU21hbGxDaXJjbGUsXG5cdHNtYWxsc2V0bWludXM6IHNtYWxsc2V0bWludXMsXG5cdHNtYXNocDogc21hc2hwLFxuXHRzbWVwYXJzbDogc21lcGFyc2wsXG5cdHNtaWQ6IHNtaWQsXG5cdHNtaWxlOiBzbWlsZSxcblx0c210OiBzbXQsXG5cdHNtdGU6IHNtdGUsXG5cdHNtdGVzOiBzbXRlcyxcblx0U09GVGN5OiBTT0ZUY3ksXG5cdHNvZnRjeTogc29mdGN5LFxuXHRzb2xiYXI6IHNvbGJhcixcblx0c29sYjogc29sYixcblx0c29sOiBzb2wsXG5cdFNvcGY6IFNvcGYsXG5cdHNvcGY6IHNvcGYsXG5cdHNwYWRlczogc3BhZGVzLFxuXHRzcGFkZXN1aXQ6IHNwYWRlc3VpdCxcblx0c3Bhcjogc3Bhcixcblx0c3FjYXA6IHNxY2FwLFxuXHRzcWNhcHM6IHNxY2Fwcyxcblx0c3FjdXA6IHNxY3VwLFxuXHRzcWN1cHM6IHNxY3Vwcyxcblx0U3FydDogU3FydCxcblx0c3FzdWI6IHNxc3ViLFxuXHRzcXN1YmU6IHNxc3ViZSxcblx0c3FzdWJzZXQ6IHNxc3Vic2V0LFxuXHRzcXN1YnNldGVxOiBzcXN1YnNldGVxLFxuXHRzcXN1cDogc3FzdXAsXG5cdHNxc3VwZTogc3FzdXBlLFxuXHRzcXN1cHNldDogc3FzdXBzZXQsXG5cdHNxc3Vwc2V0ZXE6IHNxc3Vwc2V0ZXEsXG5cdHNxdWFyZTogc3F1YXJlLFxuXHRTcXVhcmU6IFNxdWFyZSxcblx0U3F1YXJlSW50ZXJzZWN0aW9uOiBTcXVhcmVJbnRlcnNlY3Rpb24sXG5cdFNxdWFyZVN1YnNldDogU3F1YXJlU3Vic2V0LFxuXHRTcXVhcmVTdWJzZXRFcXVhbDogU3F1YXJlU3Vic2V0RXF1YWwsXG5cdFNxdWFyZVN1cGVyc2V0OiBTcXVhcmVTdXBlcnNldCxcblx0U3F1YXJlU3VwZXJzZXRFcXVhbDogU3F1YXJlU3VwZXJzZXRFcXVhbCxcblx0U3F1YXJlVW5pb246IFNxdWFyZVVuaW9uLFxuXHRzcXVhcmY6IHNxdWFyZixcblx0c3F1OiBzcXUsXG5cdHNxdWY6IHNxdWYsXG5cdHNyYXJyOiBzcmFycixcblx0U3NjcjogU3Njcixcblx0c3Njcjogc3Njcixcblx0c3NldG1uOiBzc2V0bW4sXG5cdHNzbWlsZTogc3NtaWxlLFxuXHRzc3RhcmY6IHNzdGFyZixcblx0U3RhcjogU3Rhcixcblx0c3Rhcjogc3Rhcixcblx0c3RhcmY6IHN0YXJmLFxuXHRzdHJhaWdodGVwc2lsb246IHN0cmFpZ2h0ZXBzaWxvbixcblx0c3RyYWlnaHRwaGk6IHN0cmFpZ2h0cGhpLFxuXHRzdHJuczogc3RybnMsXG5cdHN1Yjogc3ViLFxuXHRTdWI6IFN1Yixcblx0c3ViZG90OiBzdWJkb3QsXG5cdHN1YkU6IHN1YkUsXG5cdHN1YmU6IHN1YmUsXG5cdHN1YmVkb3Q6IHN1YmVkb3QsXG5cdHN1Ym11bHQ6IHN1Ym11bHQsXG5cdHN1Ym5FOiBzdWJuRSxcblx0c3VibmU6IHN1Ym5lLFxuXHRzdWJwbHVzOiBzdWJwbHVzLFxuXHRzdWJyYXJyOiBzdWJyYXJyLFxuXHRzdWJzZXQ6IHN1YnNldCxcblx0U3Vic2V0OiBTdWJzZXQsXG5cdHN1YnNldGVxOiBzdWJzZXRlcSxcblx0c3Vic2V0ZXFxOiBzdWJzZXRlcXEsXG5cdFN1YnNldEVxdWFsOiBTdWJzZXRFcXVhbCxcblx0c3Vic2V0bmVxOiBzdWJzZXRuZXEsXG5cdHN1YnNldG5lcXE6IHN1YnNldG5lcXEsXG5cdHN1YnNpbTogc3Vic2ltLFxuXHRzdWJzdWI6IHN1YnN1Yixcblx0c3Vic3VwOiBzdWJzdXAsXG5cdHN1Y2NhcHByb3g6IHN1Y2NhcHByb3gsXG5cdHN1Y2M6IHN1Y2MsXG5cdHN1Y2NjdXJseWVxOiBzdWNjY3VybHllcSxcblx0U3VjY2VlZHM6IFN1Y2NlZWRzLFxuXHRTdWNjZWVkc0VxdWFsOiBTdWNjZWVkc0VxdWFsLFxuXHRTdWNjZWVkc1NsYW50RXF1YWw6IFN1Y2NlZWRzU2xhbnRFcXVhbCxcblx0U3VjY2VlZHNUaWxkZTogU3VjY2VlZHNUaWxkZSxcblx0c3VjY2VxOiBzdWNjZXEsXG5cdHN1Y2NuYXBwcm94OiBzdWNjbmFwcHJveCxcblx0c3VjY25lcXE6IHN1Y2NuZXFxLFxuXHRzdWNjbnNpbTogc3VjY25zaW0sXG5cdHN1Y2NzaW06IHN1Y2NzaW0sXG5cdFN1Y2hUaGF0OiBTdWNoVGhhdCxcblx0c3VtOiBzdW0sXG5cdFN1bTogU3VtLFxuXHRzdW5nOiBzdW5nLFxuXHRzdXAxOiBzdXAxJDEsXG5cdHN1cDI6IHN1cDIkMSxcblx0c3VwMzogc3VwMyQxLFxuXHRzdXA6IHN1cCxcblx0U3VwOiBTdXAsXG5cdHN1cGRvdDogc3VwZG90LFxuXHRzdXBkc3ViOiBzdXBkc3ViLFxuXHRzdXBFOiBzdXBFLFxuXHRzdXBlOiBzdXBlLFxuXHRzdXBlZG90OiBzdXBlZG90LFxuXHRTdXBlcnNldDogU3VwZXJzZXQsXG5cdFN1cGVyc2V0RXF1YWw6IFN1cGVyc2V0RXF1YWwsXG5cdHN1cGhzb2w6IHN1cGhzb2wsXG5cdHN1cGhzdWI6IHN1cGhzdWIsXG5cdHN1cGxhcnI6IHN1cGxhcnIsXG5cdHN1cG11bHQ6IHN1cG11bHQsXG5cdHN1cG5FOiBzdXBuRSxcblx0c3VwbmU6IHN1cG5lLFxuXHRzdXBwbHVzOiBzdXBwbHVzLFxuXHRzdXBzZXQ6IHN1cHNldCxcblx0U3Vwc2V0OiBTdXBzZXQsXG5cdHN1cHNldGVxOiBzdXBzZXRlcSxcblx0c3Vwc2V0ZXFxOiBzdXBzZXRlcXEsXG5cdHN1cHNldG5lcTogc3Vwc2V0bmVxLFxuXHRzdXBzZXRuZXFxOiBzdXBzZXRuZXFxLFxuXHRzdXBzaW06IHN1cHNpbSxcblx0c3Vwc3ViOiBzdXBzdWIsXG5cdHN1cHN1cDogc3Vwc3VwLFxuXHRzd2FyaGs6IHN3YXJoayxcblx0c3dhcnI6IHN3YXJyLFxuXHRzd0Fycjogc3dBcnIsXG5cdHN3YXJyb3c6IHN3YXJyb3csXG5cdHN3bndhcjogc3dud2FyLFxuXHRzemxpZzogc3psaWckMSxcblx0VGFiOiBUYWIsXG5cdHRhcmdldDogdGFyZ2V0LFxuXHRUYXU6IFRhdSxcblx0dGF1OiB0YXUsXG5cdHRicms6IHRicmssXG5cdFRjYXJvbjogVGNhcm9uLFxuXHR0Y2Fyb246IHRjYXJvbixcblx0VGNlZGlsOiBUY2VkaWwsXG5cdHRjZWRpbDogdGNlZGlsLFxuXHRUY3k6IFRjeSxcblx0dGN5OiB0Y3ksXG5cdHRkb3Q6IHRkb3QsXG5cdHRlbHJlYzogdGVscmVjLFxuXHRUZnI6IFRmcixcblx0dGZyOiB0ZnIsXG5cdHRoZXJlNDogdGhlcmU0LFxuXHR0aGVyZWZvcmU6IHRoZXJlZm9yZSxcblx0VGhlcmVmb3JlOiBUaGVyZWZvcmUsXG5cdFRoZXRhOiBUaGV0YSxcblx0dGhldGE6IHRoZXRhLFxuXHR0aGV0YXN5bTogdGhldGFzeW0sXG5cdHRoZXRhdjogdGhldGF2LFxuXHR0aGlja2FwcHJveDogdGhpY2thcHByb3gsXG5cdHRoaWNrc2ltOiB0aGlja3NpbSxcblx0VGhpY2tTcGFjZTogVGhpY2tTcGFjZSxcblx0VGhpblNwYWNlOiBUaGluU3BhY2UsXG5cdHRoaW5zcDogdGhpbnNwLFxuXHR0aGthcDogdGhrYXAsXG5cdHRoa3NpbTogdGhrc2ltLFxuXHRUSE9STjogVEhPUk4kMSxcblx0dGhvcm46IHRob3JuJDEsXG5cdHRpbGRlOiB0aWxkZSxcblx0VGlsZGU6IFRpbGRlLFxuXHRUaWxkZUVxdWFsOiBUaWxkZUVxdWFsLFxuXHRUaWxkZUZ1bGxFcXVhbDogVGlsZGVGdWxsRXF1YWwsXG5cdFRpbGRlVGlsZGU6IFRpbGRlVGlsZGUsXG5cdHRpbWVzYmFyOiB0aW1lc2Jhcixcblx0dGltZXNiOiB0aW1lc2IsXG5cdHRpbWVzOiB0aW1lcyQxLFxuXHR0aW1lc2Q6IHRpbWVzZCxcblx0dGludDogdGludCxcblx0dG9lYTogdG9lYSxcblx0dG9wYm90OiB0b3Bib3QsXG5cdHRvcGNpcjogdG9wY2lyLFxuXHR0b3A6IHRvcCxcblx0VG9wZjogVG9wZixcblx0dG9wZjogdG9wZixcblx0dG9wZm9yazogdG9wZm9yayxcblx0dG9zYTogdG9zYSxcblx0dHByaW1lOiB0cHJpbWUsXG5cdHRyYWRlOiB0cmFkZSxcblx0VFJBREU6IFRSQURFLFxuXHR0cmlhbmdsZTogdHJpYW5nbGUsXG5cdHRyaWFuZ2xlZG93bjogdHJpYW5nbGVkb3duLFxuXHR0cmlhbmdsZWxlZnQ6IHRyaWFuZ2xlbGVmdCxcblx0dHJpYW5nbGVsZWZ0ZXE6IHRyaWFuZ2xlbGVmdGVxLFxuXHR0cmlhbmdsZXE6IHRyaWFuZ2xlcSxcblx0dHJpYW5nbGVyaWdodDogdHJpYW5nbGVyaWdodCxcblx0dHJpYW5nbGVyaWdodGVxOiB0cmlhbmdsZXJpZ2h0ZXEsXG5cdHRyaWRvdDogdHJpZG90LFxuXHR0cmllOiB0cmllLFxuXHR0cmltaW51czogdHJpbWludXMsXG5cdFRyaXBsZURvdDogVHJpcGxlRG90LFxuXHR0cmlwbHVzOiB0cmlwbHVzLFxuXHR0cmlzYjogdHJpc2IsXG5cdHRyaXRpbWU6IHRyaXRpbWUsXG5cdHRycGV6aXVtOiB0cnBleml1bSxcblx0VHNjcjogVHNjcixcblx0dHNjcjogdHNjcixcblx0VFNjeTogVFNjeSxcblx0dHNjeTogdHNjeSxcblx0VFNIY3k6IFRTSGN5LFxuXHR0c2hjeTogdHNoY3ksXG5cdFRzdHJvazogVHN0cm9rLFxuXHR0c3Ryb2s6IHRzdHJvayxcblx0dHdpeHQ6IHR3aXh0LFxuXHR0d29oZWFkbGVmdGFycm93OiB0d29oZWFkbGVmdGFycm93LFxuXHR0d29oZWFkcmlnaHRhcnJvdzogdHdvaGVhZHJpZ2h0YXJyb3csXG5cdFVhY3V0ZTogVWFjdXRlJDEsXG5cdHVhY3V0ZTogdWFjdXRlJDEsXG5cdHVhcnI6IHVhcnIsXG5cdFVhcnI6IFVhcnIsXG5cdHVBcnI6IHVBcnIsXG5cdFVhcnJvY2lyOiBVYXJyb2Npcixcblx0VWJyY3k6IFVicmN5LFxuXHR1YnJjeTogdWJyY3ksXG5cdFVicmV2ZTogVWJyZXZlLFxuXHR1YnJldmU6IHVicmV2ZSxcblx0VWNpcmM6IFVjaXJjJDEsXG5cdHVjaXJjOiB1Y2lyYyQxLFxuXHRVY3k6IFVjeSxcblx0dWN5OiB1Y3ksXG5cdHVkYXJyOiB1ZGFycixcblx0VWRibGFjOiBVZGJsYWMsXG5cdHVkYmxhYzogdWRibGFjLFxuXHR1ZGhhcjogdWRoYXIsXG5cdHVmaXNodDogdWZpc2h0LFxuXHRVZnI6IFVmcixcblx0dWZyOiB1ZnIsXG5cdFVncmF2ZTogVWdyYXZlJDEsXG5cdHVncmF2ZTogdWdyYXZlJDEsXG5cdHVIYXI6IHVIYXIsXG5cdHVoYXJsOiB1aGFybCxcblx0dWhhcnI6IHVoYXJyLFxuXHR1aGJsazogdWhibGssXG5cdHVsY29ybjogdWxjb3JuLFxuXHR1bGNvcm5lcjogdWxjb3JuZXIsXG5cdHVsY3JvcDogdWxjcm9wLFxuXHR1bHRyaTogdWx0cmksXG5cdFVtYWNyOiBVbWFjcixcblx0dW1hY3I6IHVtYWNyLFxuXHR1bWw6IHVtbCQxLFxuXHRVbmRlckJhcjogVW5kZXJCYXIsXG5cdFVuZGVyQnJhY2U6IFVuZGVyQnJhY2UsXG5cdFVuZGVyQnJhY2tldDogVW5kZXJCcmFja2V0LFxuXHRVbmRlclBhcmVudGhlc2lzOiBVbmRlclBhcmVudGhlc2lzLFxuXHRVbmlvbjogVW5pb24sXG5cdFVuaW9uUGx1czogVW5pb25QbHVzLFxuXHRVb2dvbjogVW9nb24sXG5cdHVvZ29uOiB1b2dvbixcblx0VW9wZjogVW9wZixcblx0dW9wZjogdW9wZixcblx0VXBBcnJvd0JhcjogVXBBcnJvd0Jhcixcblx0dXBhcnJvdzogdXBhcnJvdyxcblx0VXBBcnJvdzogVXBBcnJvdyxcblx0VXBhcnJvdzogVXBhcnJvdyxcblx0VXBBcnJvd0Rvd25BcnJvdzogVXBBcnJvd0Rvd25BcnJvdyxcblx0dXBkb3duYXJyb3c6IHVwZG93bmFycm93LFxuXHRVcERvd25BcnJvdzogVXBEb3duQXJyb3csXG5cdFVwZG93bmFycm93OiBVcGRvd25hcnJvdyxcblx0VXBFcXVpbGlicml1bTogVXBFcXVpbGlicml1bSxcblx0dXBoYXJwb29ubGVmdDogdXBoYXJwb29ubGVmdCxcblx0dXBoYXJwb29ucmlnaHQ6IHVwaGFycG9vbnJpZ2h0LFxuXHR1cGx1czogdXBsdXMsXG5cdFVwcGVyTGVmdEFycm93OiBVcHBlckxlZnRBcnJvdyxcblx0VXBwZXJSaWdodEFycm93OiBVcHBlclJpZ2h0QXJyb3csXG5cdHVwc2k6IHVwc2ksXG5cdFVwc2k6IFVwc2ksXG5cdHVwc2loOiB1cHNpaCxcblx0VXBzaWxvbjogVXBzaWxvbixcblx0dXBzaWxvbjogdXBzaWxvbixcblx0VXBUZWVBcnJvdzogVXBUZWVBcnJvdyxcblx0VXBUZWU6IFVwVGVlLFxuXHR1cHVwYXJyb3dzOiB1cHVwYXJyb3dzLFxuXHR1cmNvcm46IHVyY29ybixcblx0dXJjb3JuZXI6IHVyY29ybmVyLFxuXHR1cmNyb3A6IHVyY3JvcCxcblx0VXJpbmc6IFVyaW5nLFxuXHR1cmluZzogdXJpbmcsXG5cdHVydHJpOiB1cnRyaSxcblx0VXNjcjogVXNjcixcblx0dXNjcjogdXNjcixcblx0dXRkb3Q6IHV0ZG90LFxuXHRVdGlsZGU6IFV0aWxkZSxcblx0dXRpbGRlOiB1dGlsZGUsXG5cdHV0cmk6IHV0cmksXG5cdHV0cmlmOiB1dHJpZixcblx0dXVhcnI6IHV1YXJyLFxuXHRVdW1sOiBVdW1sJDEsXG5cdHV1bWw6IHV1bWwkMSxcblx0dXdhbmdsZTogdXdhbmdsZSxcblx0dmFuZ3J0OiB2YW5ncnQsXG5cdHZhcmVwc2lsb246IHZhcmVwc2lsb24sXG5cdHZhcmthcHBhOiB2YXJrYXBwYSxcblx0dmFybm90aGluZzogdmFybm90aGluZyxcblx0dmFycGhpOiB2YXJwaGksXG5cdHZhcnBpOiB2YXJwaSxcblx0dmFycHJvcHRvOiB2YXJwcm9wdG8sXG5cdHZhcnI6IHZhcnIsXG5cdHZBcnI6IHZBcnIsXG5cdHZhcnJobzogdmFycmhvLFxuXHR2YXJzaWdtYTogdmFyc2lnbWEsXG5cdHZhcnN1YnNldG5lcTogdmFyc3Vic2V0bmVxLFxuXHR2YXJzdWJzZXRuZXFxOiB2YXJzdWJzZXRuZXFxLFxuXHR2YXJzdXBzZXRuZXE6IHZhcnN1cHNldG5lcSxcblx0dmFyc3Vwc2V0bmVxcTogdmFyc3Vwc2V0bmVxcSxcblx0dmFydGhldGE6IHZhcnRoZXRhLFxuXHR2YXJ0cmlhbmdsZWxlZnQ6IHZhcnRyaWFuZ2xlbGVmdCxcblx0dmFydHJpYW5nbGVyaWdodDogdmFydHJpYW5nbGVyaWdodCxcblx0dkJhcjogdkJhcixcblx0VmJhcjogVmJhcixcblx0dkJhcnY6IHZCYXJ2LFxuXHRWY3k6IFZjeSxcblx0dmN5OiB2Y3ksXG5cdHZkYXNoOiB2ZGFzaCxcblx0dkRhc2g6IHZEYXNoLFxuXHRWZGFzaDogVmRhc2gsXG5cdFZEYXNoOiBWRGFzaCxcblx0VmRhc2hsOiBWZGFzaGwsXG5cdHZlZWJhcjogdmVlYmFyLFxuXHR2ZWU6IHZlZSxcblx0VmVlOiBWZWUsXG5cdHZlZWVxOiB2ZWVlcSxcblx0dmVsbGlwOiB2ZWxsaXAsXG5cdHZlcmJhcjogdmVyYmFyLFxuXHRWZXJiYXI6IFZlcmJhcixcblx0dmVydDogdmVydCxcblx0VmVydDogVmVydCxcblx0VmVydGljYWxCYXI6IFZlcnRpY2FsQmFyLFxuXHRWZXJ0aWNhbExpbmU6IFZlcnRpY2FsTGluZSxcblx0VmVydGljYWxTZXBhcmF0b3I6IFZlcnRpY2FsU2VwYXJhdG9yLFxuXHRWZXJ0aWNhbFRpbGRlOiBWZXJ0aWNhbFRpbGRlLFxuXHRWZXJ5VGhpblNwYWNlOiBWZXJ5VGhpblNwYWNlLFxuXHRWZnI6IFZmcixcblx0dmZyOiB2ZnIsXG5cdHZsdHJpOiB2bHRyaSxcblx0dm5zdWI6IHZuc3ViLFxuXHR2bnN1cDogdm5zdXAsXG5cdFZvcGY6IFZvcGYsXG5cdHZvcGY6IHZvcGYsXG5cdHZwcm9wOiB2cHJvcCxcblx0dnJ0cmk6IHZydHJpLFxuXHRWc2NyOiBWc2NyLFxuXHR2c2NyOiB2c2NyLFxuXHR2c3VibkU6IHZzdWJuRSxcblx0dnN1Ym5lOiB2c3VibmUsXG5cdHZzdXBuRTogdnN1cG5FLFxuXHR2c3VwbmU6IHZzdXBuZSxcblx0VnZkYXNoOiBWdmRhc2gsXG5cdHZ6aWd6YWc6IHZ6aWd6YWcsXG5cdFdjaXJjOiBXY2lyYyxcblx0d2NpcmM6IHdjaXJjLFxuXHR3ZWRiYXI6IHdlZGJhcixcblx0d2VkZ2U6IHdlZGdlLFxuXHRXZWRnZTogV2VkZ2UsXG5cdHdlZGdlcTogd2VkZ2VxLFxuXHR3ZWllcnA6IHdlaWVycCxcblx0V2ZyOiBXZnIsXG5cdHdmcjogd2ZyLFxuXHRXb3BmOiBXb3BmLFxuXHR3b3BmOiB3b3BmLFxuXHR3cDogd3AsXG5cdHdyOiB3cixcblx0d3JlYXRoOiB3cmVhdGgsXG5cdFdzY3I6IFdzY3IsXG5cdHdzY3I6IHdzY3IsXG5cdHhjYXA6IHhjYXAsXG5cdHhjaXJjOiB4Y2lyYyxcblx0eGN1cDogeGN1cCxcblx0eGR0cmk6IHhkdHJpLFxuXHRYZnI6IFhmcixcblx0eGZyOiB4ZnIsXG5cdHhoYXJyOiB4aGFycixcblx0eGhBcnI6IHhoQXJyLFxuXHRYaTogWGksXG5cdHhpOiB4aSxcblx0eGxhcnI6IHhsYXJyLFxuXHR4bEFycjogeGxBcnIsXG5cdHhtYXA6IHhtYXAsXG5cdHhuaXM6IHhuaXMsXG5cdHhvZG90OiB4b2RvdCxcblx0WG9wZjogWG9wZixcblx0eG9wZjogeG9wZixcblx0eG9wbHVzOiB4b3BsdXMsXG5cdHhvdGltZTogeG90aW1lLFxuXHR4cmFycjogeHJhcnIsXG5cdHhyQXJyOiB4ckFycixcblx0WHNjcjogWHNjcixcblx0eHNjcjogeHNjcixcblx0eHNxY3VwOiB4c3FjdXAsXG5cdHh1cGx1czogeHVwbHVzLFxuXHR4dXRyaTogeHV0cmksXG5cdHh2ZWU6IHh2ZWUsXG5cdHh3ZWRnZTogeHdlZGdlLFxuXHRZYWN1dGU6IFlhY3V0ZSQxLFxuXHR5YWN1dGU6IHlhY3V0ZSQxLFxuXHRZQWN5OiBZQWN5LFxuXHR5YWN5OiB5YWN5LFxuXHRZY2lyYzogWWNpcmMsXG5cdHljaXJjOiB5Y2lyYyxcblx0WWN5OiBZY3ksXG5cdHljeTogeWN5LFxuXHR5ZW46IHllbiQxLFxuXHRZZnI6IFlmcixcblx0eWZyOiB5ZnIsXG5cdFlJY3k6IFlJY3ksXG5cdHlpY3k6IHlpY3ksXG5cdFlvcGY6IFlvcGYsXG5cdHlvcGY6IHlvcGYsXG5cdFlzY3I6IFlzY3IsXG5cdHlzY3I6IHlzY3IsXG5cdFlVY3k6IFlVY3ksXG5cdHl1Y3k6IHl1Y3ksXG5cdHl1bWw6IHl1bWwkMSxcblx0WXVtbDogWXVtbCxcblx0WmFjdXRlOiBaYWN1dGUsXG5cdHphY3V0ZTogemFjdXRlLFxuXHRaY2Fyb246IFpjYXJvbixcblx0emNhcm9uOiB6Y2Fyb24sXG5cdFpjeTogWmN5LFxuXHR6Y3k6IHpjeSxcblx0WmRvdDogWmRvdCxcblx0emRvdDogemRvdCxcblx0emVldHJmOiB6ZWV0cmYsXG5cdFplcm9XaWR0aFNwYWNlOiBaZXJvV2lkdGhTcGFjZSxcblx0WmV0YTogWmV0YSxcblx0emV0YTogemV0YSxcblx0emZyOiB6ZnIsXG5cdFpmcjogWmZyLFxuXHRaSGN5OiBaSGN5LFxuXHR6aGN5OiB6aGN5LFxuXHR6aWdyYXJyOiB6aWdyYXJyLFxuXHR6b3BmOiB6b3BmLFxuXHRab3BmOiBab3BmLFxuXHRac2NyOiBac2NyLFxuXHR6c2NyOiB6c2NyLFxuXHR6d2o6IHp3aixcblx0enduajogendualxufTtcblxudmFyIEFhY3V0ZSA9IFwiw4FcIjtcbnZhciBhYWN1dGUgPSBcIsOhXCI7XG52YXIgQWNpcmMgPSBcIsOCXCI7XG52YXIgYWNpcmMgPSBcIsOiXCI7XG52YXIgYWN1dGUgPSBcIsK0XCI7XG52YXIgQUVsaWcgPSBcIsOGXCI7XG52YXIgYWVsaWcgPSBcIsOmXCI7XG52YXIgQWdyYXZlID0gXCLDgFwiO1xudmFyIGFncmF2ZSA9IFwiw6BcIjtcbnZhciBhbXAkMSA9IFwiJlwiO1xudmFyIEFNUCA9IFwiJlwiO1xudmFyIEFyaW5nID0gXCLDhVwiO1xudmFyIGFyaW5nID0gXCLDpVwiO1xudmFyIEF0aWxkZSA9IFwiw4NcIjtcbnZhciBhdGlsZGUgPSBcIsOjXCI7XG52YXIgQXVtbCA9IFwiw4RcIjtcbnZhciBhdW1sID0gXCLDpFwiO1xudmFyIGJydmJhciA9IFwiwqZcIjtcbnZhciBDY2VkaWwgPSBcIsOHXCI7XG52YXIgY2NlZGlsID0gXCLDp1wiO1xudmFyIGNlZGlsID0gXCLCuFwiO1xudmFyIGNlbnQgPSBcIsKiXCI7XG52YXIgY29weSA9IFwiwqlcIjtcbnZhciBDT1BZID0gXCLCqVwiO1xudmFyIGN1cnJlbiA9IFwiwqRcIjtcbnZhciBkZWcgPSBcIsKwXCI7XG52YXIgZGl2aWRlID0gXCLDt1wiO1xudmFyIEVhY3V0ZSA9IFwiw4lcIjtcbnZhciBlYWN1dGUgPSBcIsOpXCI7XG52YXIgRWNpcmMgPSBcIsOKXCI7XG52YXIgZWNpcmMgPSBcIsOqXCI7XG52YXIgRWdyYXZlID0gXCLDiFwiO1xudmFyIGVncmF2ZSA9IFwiw6hcIjtcbnZhciBFVEggPSBcIsOQXCI7XG52YXIgZXRoID0gXCLDsFwiO1xudmFyIEV1bWwgPSBcIsOLXCI7XG52YXIgZXVtbCA9IFwiw6tcIjtcbnZhciBmcmFjMTIgPSBcIsK9XCI7XG52YXIgZnJhYzE0ID0gXCLCvFwiO1xudmFyIGZyYWMzNCA9IFwiwr5cIjtcbnZhciBndCQxID0gXCI+XCI7XG52YXIgR1QgPSBcIj5cIjtcbnZhciBJYWN1dGUgPSBcIsONXCI7XG52YXIgaWFjdXRlID0gXCLDrVwiO1xudmFyIEljaXJjID0gXCLDjlwiO1xudmFyIGljaXJjID0gXCLDrlwiO1xudmFyIGlleGNsID0gXCLCoVwiO1xudmFyIElncmF2ZSA9IFwiw4xcIjtcbnZhciBpZ3JhdmUgPSBcIsOsXCI7XG52YXIgaXF1ZXN0ID0gXCLCv1wiO1xudmFyIEl1bWwgPSBcIsOPXCI7XG52YXIgaXVtbCA9IFwiw69cIjtcbnZhciBsYXF1byA9IFwiwqtcIjtcbnZhciBsdCQxID0gXCI8XCI7XG52YXIgTFQgPSBcIjxcIjtcbnZhciBtYWNyID0gXCLCr1wiO1xudmFyIG1pY3JvID0gXCLCtVwiO1xudmFyIG1pZGRvdCA9IFwiwrdcIjtcbnZhciBuYnNwID0gXCLCoFwiO1xudmFyIG5vdCA9IFwiwqxcIjtcbnZhciBOdGlsZGUgPSBcIsORXCI7XG52YXIgbnRpbGRlID0gXCLDsVwiO1xudmFyIE9hY3V0ZSA9IFwiw5NcIjtcbnZhciBvYWN1dGUgPSBcIsOzXCI7XG52YXIgT2NpcmMgPSBcIsOUXCI7XG52YXIgb2NpcmMgPSBcIsO0XCI7XG52YXIgT2dyYXZlID0gXCLDklwiO1xudmFyIG9ncmF2ZSA9IFwiw7JcIjtcbnZhciBvcmRmID0gXCLCqlwiO1xudmFyIG9yZG0gPSBcIsK6XCI7XG52YXIgT3NsYXNoID0gXCLDmFwiO1xudmFyIG9zbGFzaCA9IFwiw7hcIjtcbnZhciBPdGlsZGUgPSBcIsOVXCI7XG52YXIgb3RpbGRlID0gXCLDtVwiO1xudmFyIE91bWwgPSBcIsOWXCI7XG52YXIgb3VtbCA9IFwiw7ZcIjtcbnZhciBwYXJhID0gXCLCtlwiO1xudmFyIHBsdXNtbiA9IFwiwrFcIjtcbnZhciBwb3VuZCA9IFwiwqNcIjtcbnZhciBxdW90JDEgPSBcIlxcXCJcIjtcbnZhciBRVU9UID0gXCJcXFwiXCI7XG52YXIgcmFxdW8gPSBcIsK7XCI7XG52YXIgcmVnID0gXCLCrlwiO1xudmFyIFJFRyA9IFwiwq5cIjtcbnZhciBzZWN0ID0gXCLCp1wiO1xudmFyIHNoeSA9IFwiwq1cIjtcbnZhciBzdXAxID0gXCLCuVwiO1xudmFyIHN1cDIgPSBcIsKyXCI7XG52YXIgc3VwMyA9IFwiwrNcIjtcbnZhciBzemxpZyA9IFwiw59cIjtcbnZhciBUSE9STiA9IFwiw55cIjtcbnZhciB0aG9ybiA9IFwiw75cIjtcbnZhciB0aW1lcyA9IFwiw5dcIjtcbnZhciBVYWN1dGUgPSBcIsOaXCI7XG52YXIgdWFjdXRlID0gXCLDulwiO1xudmFyIFVjaXJjID0gXCLDm1wiO1xudmFyIHVjaXJjID0gXCLDu1wiO1xudmFyIFVncmF2ZSA9IFwiw5lcIjtcbnZhciB1Z3JhdmUgPSBcIsO5XCI7XG52YXIgdW1sID0gXCLCqFwiO1xudmFyIFV1bWwgPSBcIsOcXCI7XG52YXIgdXVtbCA9IFwiw7xcIjtcbnZhciBZYWN1dGUgPSBcIsOdXCI7XG52YXIgeWFjdXRlID0gXCLDvVwiO1xudmFyIHllbiA9IFwiwqVcIjtcbnZhciB5dW1sID0gXCLDv1wiO1xudmFyIHJlcXVpcmUkJDEgPSB7XG5cdEFhY3V0ZTogQWFjdXRlLFxuXHRhYWN1dGU6IGFhY3V0ZSxcblx0QWNpcmM6IEFjaXJjLFxuXHRhY2lyYzogYWNpcmMsXG5cdGFjdXRlOiBhY3V0ZSxcblx0QUVsaWc6IEFFbGlnLFxuXHRhZWxpZzogYWVsaWcsXG5cdEFncmF2ZTogQWdyYXZlLFxuXHRhZ3JhdmU6IGFncmF2ZSxcblx0YW1wOiBhbXAkMSxcblx0QU1QOiBBTVAsXG5cdEFyaW5nOiBBcmluZyxcblx0YXJpbmc6IGFyaW5nLFxuXHRBdGlsZGU6IEF0aWxkZSxcblx0YXRpbGRlOiBhdGlsZGUsXG5cdEF1bWw6IEF1bWwsXG5cdGF1bWw6IGF1bWwsXG5cdGJydmJhcjogYnJ2YmFyLFxuXHRDY2VkaWw6IENjZWRpbCxcblx0Y2NlZGlsOiBjY2VkaWwsXG5cdGNlZGlsOiBjZWRpbCxcblx0Y2VudDogY2VudCxcblx0Y29weTogY29weSxcblx0Q09QWTogQ09QWSxcblx0Y3VycmVuOiBjdXJyZW4sXG5cdGRlZzogZGVnLFxuXHRkaXZpZGU6IGRpdmlkZSxcblx0RWFjdXRlOiBFYWN1dGUsXG5cdGVhY3V0ZTogZWFjdXRlLFxuXHRFY2lyYzogRWNpcmMsXG5cdGVjaXJjOiBlY2lyYyxcblx0RWdyYXZlOiBFZ3JhdmUsXG5cdGVncmF2ZTogZWdyYXZlLFxuXHRFVEg6IEVUSCxcblx0ZXRoOiBldGgsXG5cdEV1bWw6IEV1bWwsXG5cdGV1bWw6IGV1bWwsXG5cdGZyYWMxMjogZnJhYzEyLFxuXHRmcmFjMTQ6IGZyYWMxNCxcblx0ZnJhYzM0OiBmcmFjMzQsXG5cdGd0OiBndCQxLFxuXHRHVDogR1QsXG5cdElhY3V0ZTogSWFjdXRlLFxuXHRpYWN1dGU6IGlhY3V0ZSxcblx0SWNpcmM6IEljaXJjLFxuXHRpY2lyYzogaWNpcmMsXG5cdGlleGNsOiBpZXhjbCxcblx0SWdyYXZlOiBJZ3JhdmUsXG5cdGlncmF2ZTogaWdyYXZlLFxuXHRpcXVlc3Q6IGlxdWVzdCxcblx0SXVtbDogSXVtbCxcblx0aXVtbDogaXVtbCxcblx0bGFxdW86IGxhcXVvLFxuXHRsdDogbHQkMSxcblx0TFQ6IExULFxuXHRtYWNyOiBtYWNyLFxuXHRtaWNybzogbWljcm8sXG5cdG1pZGRvdDogbWlkZG90LFxuXHRuYnNwOiBuYnNwLFxuXHRub3Q6IG5vdCxcblx0TnRpbGRlOiBOdGlsZGUsXG5cdG50aWxkZTogbnRpbGRlLFxuXHRPYWN1dGU6IE9hY3V0ZSxcblx0b2FjdXRlOiBvYWN1dGUsXG5cdE9jaXJjOiBPY2lyYyxcblx0b2NpcmM6IG9jaXJjLFxuXHRPZ3JhdmU6IE9ncmF2ZSxcblx0b2dyYXZlOiBvZ3JhdmUsXG5cdG9yZGY6IG9yZGYsXG5cdG9yZG06IG9yZG0sXG5cdE9zbGFzaDogT3NsYXNoLFxuXHRvc2xhc2g6IG9zbGFzaCxcblx0T3RpbGRlOiBPdGlsZGUsXG5cdG90aWxkZTogb3RpbGRlLFxuXHRPdW1sOiBPdW1sLFxuXHRvdW1sOiBvdW1sLFxuXHRwYXJhOiBwYXJhLFxuXHRwbHVzbW46IHBsdXNtbixcblx0cG91bmQ6IHBvdW5kLFxuXHRxdW90OiBxdW90JDEsXG5cdFFVT1Q6IFFVT1QsXG5cdHJhcXVvOiByYXF1byxcblx0cmVnOiByZWcsXG5cdFJFRzogUkVHLFxuXHRzZWN0OiBzZWN0LFxuXHRzaHk6IHNoeSxcblx0c3VwMTogc3VwMSxcblx0c3VwMjogc3VwMixcblx0c3VwMzogc3VwMyxcblx0c3psaWc6IHN6bGlnLFxuXHRUSE9STjogVEhPUk4sXG5cdHRob3JuOiB0aG9ybixcblx0dGltZXM6IHRpbWVzLFxuXHRVYWN1dGU6IFVhY3V0ZSxcblx0dWFjdXRlOiB1YWN1dGUsXG5cdFVjaXJjOiBVY2lyYyxcblx0dWNpcmM6IHVjaXJjLFxuXHRVZ3JhdmU6IFVncmF2ZSxcblx0dWdyYXZlOiB1Z3JhdmUsXG5cdHVtbDogdW1sLFxuXHRVdW1sOiBVdW1sLFxuXHR1dW1sOiB1dW1sLFxuXHRZYWN1dGU6IFlhY3V0ZSxcblx0eWFjdXRlOiB5YWN1dGUsXG5cdHllbjogeWVuLFxuXHR5dW1sOiB5dW1sXG59O1xuXG52YXIgYW1wID0gXCImXCI7XG52YXIgYXBvcyA9IFwiJ1wiO1xudmFyIGd0ID0gXCI+XCI7XG52YXIgbHQgPSBcIjxcIjtcbnZhciBxdW90ID0gXCJcXFwiXCI7XG52YXIgcmVxdWlyZSQkMCQxID0ge1xuXHRhbXA6IGFtcCxcblx0YXBvczogYXBvcyxcblx0Z3Q6IGd0LFxuXHRsdDogbHQsXG5cdHF1b3Q6IHF1b3Rcbn07XG5cbnZhciBkZWNvZGVfY29kZXBvaW50ID0ge307XG5cbnZhciByZXF1aXJlJCQwID0ge1xuXHRcIjBcIjogNjU1MzMsXG5cdFwiMTI4XCI6IDgzNjQsXG5cdFwiMTMwXCI6IDgyMTgsXG5cdFwiMTMxXCI6IDQwMixcblx0XCIxMzJcIjogODIyMixcblx0XCIxMzNcIjogODIzMCxcblx0XCIxMzRcIjogODIyNCxcblx0XCIxMzVcIjogODIyNSxcblx0XCIxMzZcIjogNzEwLFxuXHRcIjEzN1wiOiA4MjQwLFxuXHRcIjEzOFwiOiAzNTIsXG5cdFwiMTM5XCI6IDgyNDksXG5cdFwiMTQwXCI6IDMzOCxcblx0XCIxNDJcIjogMzgxLFxuXHRcIjE0NVwiOiA4MjE2LFxuXHRcIjE0NlwiOiA4MjE3LFxuXHRcIjE0N1wiOiA4MjIwLFxuXHRcIjE0OFwiOiA4MjIxLFxuXHRcIjE0OVwiOiA4MjI2LFxuXHRcIjE1MFwiOiA4MjExLFxuXHRcIjE1MVwiOiA4MjEyLFxuXHRcIjE1MlwiOiA3MzIsXG5cdFwiMTUzXCI6IDg0ODIsXG5cdFwiMTU0XCI6IDM1Myxcblx0XCIxNTVcIjogODI1MCxcblx0XCIxNTZcIjogMzM5LFxuXHRcIjE1OFwiOiAzODIsXG5cdFwiMTU5XCI6IDM3NlxufTtcblxudmFyIF9faW1wb3J0RGVmYXVsdCQyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWNvZGVfY29kZXBvaW50LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZWNvZGVfanNvbl8xID0gX19pbXBvcnREZWZhdWx0JDIocmVxdWlyZSQkMCk7XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvaGUvYmxvYi9tYXN0ZXIvc3JjL2hlLmpzI0w5NC1MMTE5XG52YXIgZnJvbUNvZGVQb2ludCQyID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuU3RyaW5nLmZyb21Db2RlUG9pbnQgfHxcbiAgICBmdW5jdGlvbiAoY29kZVBvaW50KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhmZmZmKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+PiAxMCkgJiAweDNmZikgfCAweGQ4MDApO1xuICAgICAgICAgICAgY29kZVBvaW50ID0gMHhkYzAwIHwgKGNvZGVQb2ludCAmIDB4M2ZmKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG4gICAgaWYgKChjb2RlUG9pbnQgPj0gMHhkODAwICYmIGNvZGVQb2ludCA8PSAweGRmZmYpIHx8IGNvZGVQb2ludCA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHJldHVybiBcIlxcdUZGRkRcIjtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCBpbiBkZWNvZGVfanNvbl8xLmRlZmF1bHQpIHtcbiAgICAgICAgY29kZVBvaW50ID0gZGVjb2RlX2pzb25fMS5kZWZhdWx0W2NvZGVQb2ludF07XG4gICAgfVxuICAgIHJldHVybiBmcm9tQ29kZVBvaW50JDIoY29kZVBvaW50KTtcbn1cbmRlY29kZV9jb2RlcG9pbnQuZGVmYXVsdCA9IGRlY29kZUNvZGVQb2ludDtcblxudmFyIF9faW1wb3J0RGVmYXVsdCQxID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWNvZGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZGVjb2RlLmRlY29kZUhUTUwgPSBkZWNvZGUuZGVjb2RlSFRNTFN0cmljdCA9IGRlY29kZS5kZWNvZGVYTUwgPSB2b2lkIDA7XG52YXIgZW50aXRpZXNfanNvbl8xJDEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQxJDEpO1xudmFyIGxlZ2FjeV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQxKTtcbnZhciB4bWxfanNvbl8xJDEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQwJDEpO1xudmFyIGRlY29kZV9jb2RlcG9pbnRfMSA9IF9faW1wb3J0RGVmYXVsdCQxKGRlY29kZV9jb2RlcG9pbnQpO1xudmFyIHN0cmljdEVudGl0eVJlID0gLyYoPzpbYS16QS1aMC05XSt8I1t4WF1bXFxkYS1mQS1GXSt8I1xcZCspOy9nO1xuZGVjb2RlLmRlY29kZVhNTCA9IGdldFN0cmljdERlY29kZXIoeG1sX2pzb25fMSQxLmRlZmF1bHQpO1xuZGVjb2RlLmRlY29kZUhUTUxTdHJpY3QgPSBnZXRTdHJpY3REZWNvZGVyKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpO1xuZnVuY3Rpb24gZ2V0U3RyaWN0RGVjb2RlcihtYXApIHtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKG1hcCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2Uoc3RyaWN0RW50aXR5UmUsIHJlcGxhY2UpOyB9O1xufVxudmFyIHNvcnRlciA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYSA8IGIgPyAxIDogLTEpOyB9O1xuZGVjb2RlLmRlY29kZUhUTUwgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZWdhY3kgPSBPYmplY3Qua2V5cyhsZWdhY3lfanNvbl8xLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZWdhY3lbal0gPT09IGtleXNbaV0pIHtcbiAgICAgICAgICAgIGtleXNbaV0gKz0gXCI7P1wiO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5c1tpXSArPSBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cy5qb2luKFwifFwiKSArIFwifCNbeFhdW1xcXFxkYS1mQS1GXSs7P3wjXFxcXGQrOz8pXCIsIFwiZ1wiKTtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKHN0cikge1xuICAgICAgICBpZiAoc3RyLnN1YnN0cigtMSkgIT09IFwiO1wiKVxuICAgICAgICAgICAgc3RyICs9IFwiO1wiO1xuICAgICAgICByZXR1cm4gcmVwbGFjZShzdHIpO1xuICAgIH1cbiAgICAvLyBUT0RPIGNvbnNpZGVyIGNyZWF0aW5nIGEgbWVyZ2VkIG1hcFxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHJlLCByZXBsYWNlcik7IH07XG59KSgpO1xuZnVuY3Rpb24gZ2V0UmVwbGFjZXIobWFwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2Uoc3RyKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDEpID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIHNlY29uZENoYXIgPSBzdHIuY2hhckF0KDIpO1xuICAgICAgICAgICAgaWYgKHNlY29uZENoYXIgPT09IFwiWFwiIHx8IHNlY29uZENoYXIgPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZV9jb2RlcG9pbnRfMS5kZWZhdWx0KHBhcnNlSW50KHN0ci5zdWJzdHIoMyksIDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlX2NvZGVwb2ludF8xLmRlZmF1bHQocGFyc2VJbnQoc3RyLnN1YnN0cigyKSwgMTApKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgcmV0dXJuIG1hcFtzdHIuc2xpY2UoMSwgLTEpXSB8fCBzdHI7XG4gICAgfTtcbn1cblxudmFyIGVuY29kZSA9IHt9O1xuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbmNvZGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZW5jb2RlLmVzY2FwZVVURjggPSBlbmNvZGUuZXNjYXBlID0gZW5jb2RlLmVuY29kZU5vbkFzY2lpSFRNTCA9IGVuY29kZS5lbmNvZGVIVE1MID0gZW5jb2RlLmVuY29kZVhNTCA9IHZvaWQgMDtcbnZhciB4bWxfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUkJDAkMSk7XG52YXIgaW52ZXJzZVhNTCA9IGdldEludmVyc2VPYmooeG1sX2pzb25fMS5kZWZhdWx0KTtcbnZhciB4bWxSZXBsYWNlciA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlWE1MKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgWE1MIGVudGl0aWVzLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlWE1MID0gZ2V0QVNDSUlFbmNvZGVyKGludmVyc2VYTUwpO1xudmFyIGVudGl0aWVzX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlJCQxJDEpO1xudmFyIGludmVyc2VIVE1MID0gZ2V0SW52ZXJzZU9iaihlbnRpdGllc19qc29uXzEuZGVmYXVsdCk7XG52YXIgaHRtbFJlcGxhY2VyID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VIVE1MKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgZW50aXRpZXMgYW5kIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dC5cbiAqXG4gKiBUaGlzIGluY2x1ZGVzIGNoYXJhY3RlcnMgdGhhdCBhcmUgdmFsaWQgQVNDSUkgY2hhcmFjdGVycyBpbiBIVE1MIGRvY3VtZW50cy5cbiAqIEZvciBleGFtcGxlIGAjYCB3aWxsIGJlIGVuY29kZWQgYXMgYCZudW07YC4gVG8gZ2V0IGEgbW9yZSBjb21wYWN0IG91dHB1dCxcbiAqIGNvbnNpZGVyIHVzaW5nIHRoZSBgZW5jb2RlTm9uQXNjaWlIVE1MYCBmdW5jdGlvbi5cbiAqXG4gKiBJZiBhIGNoYXJhY3RlciBoYXMgbm8gZXF1aXZhbGVudCBlbnRpdHksIGFcbiAqIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApIHdpbGwgYmUgdXNlZC5cbiAqL1xuZW5jb2RlLmVuY29kZUhUTUwgPSBnZXRJbnZlcnNlKGludmVyc2VIVE1MLCBodG1sUmVwbGFjZXIpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBIVE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBJZiBhIGNoYXJhY3RlciBoYXMgbm8gZXF1aXZhbGVudCBlbnRpdHksIGFcbiAqIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApIHdpbGwgYmUgdXNlZC5cbiAqL1xuZW5jb2RlLmVuY29kZU5vbkFzY2lpSFRNTCA9IGdldEFTQ0lJRW5jb2RlcihpbnZlcnNlSFRNTCk7XG5mdW5jdGlvbiBnZXRJbnZlcnNlT2JqKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoaW52ZXJzZSwgbmFtZSkge1xuICAgICAgICBpbnZlcnNlW29ialtuYW1lXV0gPSBcIiZcIiArIG5hbWUgKyBcIjtcIjtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2UpIHtcbiAgICB2YXIgc2luZ2xlID0gW107XG4gICAgdmFyIG11bHRpcGxlID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKGludmVyc2UpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgayA9IF9hW19pXTtcbiAgICAgICAgaWYgKGsubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmFsdWUgdG8gc2luZ2xlIGFycmF5XG4gICAgICAgICAgICBzaW5nbGUucHVzaChcIlxcXFxcIiArIGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQWRkIHZhbHVlIHRvIG11bHRpcGxlIGFycmF5XG4gICAgICAgICAgICBtdWx0aXBsZS5wdXNoKGspO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCByYW5nZXMgdG8gc2luZ2xlIGNoYXJhY3RlcnMuXG4gICAgc2luZ2xlLnNvcnQoKTtcbiAgICBmb3IgKHZhciBzdGFydCA9IDA7IHN0YXJ0IDwgc2luZ2xlLmxlbmd0aCAtIDE7IHN0YXJ0KyspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZW5kIG9mIGEgcnVuIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSAoZW5kIDwgc2luZ2xlLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgIHNpbmdsZVtlbmRdLmNoYXJDb2RlQXQoMSkgKyAxID09PSBzaW5nbGVbZW5kICsgMV0uY2hhckNvZGVBdCgxKSkge1xuICAgICAgICAgICAgZW5kICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50ID0gMSArIGVuZCAtIHN0YXJ0O1xuICAgICAgICAvLyBXZSB3YW50IHRvIHJlcGxhY2UgYXQgbGVhc3QgdGhyZWUgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoY291bnQgPCAzKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHNpbmdsZS5zcGxpY2Uoc3RhcnQsIGNvdW50LCBzaW5nbGVbc3RhcnRdICsgXCItXCIgKyBzaW5nbGVbZW5kXSk7XG4gICAgfVxuICAgIG11bHRpcGxlLnVuc2hpZnQoXCJbXCIgKyBzaW5nbGUuam9pbihcIlwiKSArIFwiXVwiKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChtdWx0aXBsZS5qb2luKFwifFwiKSwgXCJnXCIpO1xufVxuLy8gL1teXFwwLVxceDdGXS9ndVxudmFyIHJlTm9uQVNDSUkgPSAvKD86W1xceDgwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pL2c7XG52YXIgZ2V0Q29kZVBvaW50ID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCAhPSBudWxsXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIuY29kZVBvaW50QXQoMCk7IH1cbiAgICA6IC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gKGMuY2hhckNvZGVBdCgwKSAtIDB4ZDgwMCkgKiAweDQwMCArXG4gICAgICAgICAgICAgICAgYy5jaGFyQ29kZUF0KDEpIC1cbiAgICAgICAgICAgICAgICAweGRjMDAgK1xuICAgICAgICAgICAgICAgIDB4MTAwMDA7XG4gICAgICAgIH07XG5mdW5jdGlvbiBzaW5nbGVDaGFyUmVwbGFjZXIoYykge1xuICAgIHJldHVybiBcIiYjeFwiICsgKGMubGVuZ3RoID4gMSA/IGdldENvZGVQb2ludChjKSA6IGMuY2hhckNvZGVBdCgwKSlcbiAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAudG9VcHBlckNhc2UoKSArIFwiO1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52ZXJzZShpbnZlcnNlLCByZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpbnZlcnNlW25hbWVdOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UocmVOb25BU0NJSSwgc2luZ2xlQ2hhclJlcGxhY2VyKTtcbiAgICB9O1xufVxudmFyIHJlRXNjYXBlQ2hhcnMgPSBuZXcgUmVnRXhwKHhtbFJlcGxhY2VyLnNvdXJjZSArIFwifFwiICsgcmVOb25BU0NJSS5zb3VyY2UsIFwiZ1wiKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkuXG4gKlxuICogSGF2ZSBhIGxvb2sgYXQgYGVzY2FwZVVURjhgIGlmIHlvdSB3YW50IGEgbW9yZSBjb25jaXNlIG91dHB1dCBhdCB0aGUgZXhwZW5zZVxuICogb2YgcmVkdWNlZCB0cmFuc3BvcnRhYmlsaXR5LlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBlc2NhcGUuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZShyZUVzY2FwZUNoYXJzLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xufVxuZW5jb2RlLmVzY2FwZSA9IGVzY2FwZTtcbi8qKlxuICogRW5jb2RlcyBhbGwgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MIGRvY3VtZW50cyB1c2luZyBudW1lcmljIGhleGFkZWNpbWFsXG4gKiByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBvdXRwdXQgd2lsbCBiZSBjaGFyYWN0ZXItc2V0IGRlcGVuZGVudC5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZXNjYXBlLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVVEY4KGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKHhtbFJlcGxhY2VyLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xufVxuZW5jb2RlLmVzY2FwZVVURjggPSBlc2NhcGVVVEY4O1xuZnVuY3Rpb24gZ2V0QVNDSUlFbmNvZGVyKG9iaikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5yZXBsYWNlKHJlRXNjYXBlQ2hhcnMsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBvYmpbY10gfHwgc2luZ2xlQ2hhclJlcGxhY2VyKGMpOyB9KTtcbiAgICB9O1xufVxuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlWE1MU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNVN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDRTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw1ID0gZXhwb3J0cy5kZWNvZGVIVE1MNCA9IGV4cG9ydHMuZGVjb2RlSFRNTFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTCA9IGV4cG9ydHMuZGVjb2RlWE1MID0gZXhwb3J0cy5lbmNvZGVIVE1MNSA9IGV4cG9ydHMuZW5jb2RlSFRNTDQgPSBleHBvcnRzLmVzY2FwZVVURjggPSBleHBvcnRzLmVzY2FwZSA9IGV4cG9ydHMuZW5jb2RlTm9uQXNjaWlIVE1MID0gZXhwb3J0cy5lbmNvZGVIVE1MID0gZXhwb3J0cy5lbmNvZGVYTUwgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG52YXIgZGVjb2RlXzEgPSBkZWNvZGU7XG52YXIgZW5jb2RlXzEgPSBlbmNvZGU7XG4vKipcbiAqIERlY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZGVjb2RlLlxuICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGRlY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlWE1MYCBvciBgZGVjb2RlSFRNTGAgZGlyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZSQxKGRhdGEsIGxldmVsKSB7XG4gICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGRlY29kZV8xLmRlY29kZVhNTCA6IGRlY29kZV8xLmRlY29kZUhUTUwpKGRhdGEpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGUkMTtcbi8qKlxuICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLiBEb2VzIG5vdCBhbGxvdyBtaXNzaW5nIHRyYWlsaW5nIHNlbWljb2xvbnMgZm9yIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICogQGRlcHJlY2F0ZWQgVXNlIGBkZWNvZGVIVE1MU3RyaWN0YCBvciBgZGVjb2RlWE1MYCBkaXJlY3RseS5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlU3RyaWN0KGRhdGEsIGxldmVsKSB7XG4gICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGRlY29kZV8xLmRlY29kZVhNTCA6IGRlY29kZV8xLmRlY29kZUhUTUxTdHJpY3QpKGRhdGEpO1xufVxuZXhwb3J0cy5kZWNvZGVTdHJpY3QgPSBkZWNvZGVTdHJpY3Q7XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGVuY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAqIEBkZXByZWNhdGVkIFVzZSBgZW5jb2RlSFRNTGAsIGBlbmNvZGVYTUxgIG9yIGBlbmNvZGVOb25Bc2NpaUhUTUxgIGRpcmVjdGx5LlxuICovXG5mdW5jdGlvbiBlbmNvZGUkMShkYXRhLCBsZXZlbCkge1xuICAgIHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBlbmNvZGVfMS5lbmNvZGVYTUwgOiBlbmNvZGVfMS5lbmNvZGVIVE1MKShkYXRhKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlJDE7XG52YXIgZW5jb2RlXzIgPSBlbmNvZGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVYTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZVhNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVOb25Bc2NpaUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZU5vbkFzY2lpSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZXNjYXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlVVRGOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZXNjYXBlVVRGODsgfSB9KTtcbi8vIExlZ2FjeSBhbGlhc2VzIChkZXByZWNhdGVkKVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlSFRNTDRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MNVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbnZhciBkZWNvZGVfMiA9IGRlY29kZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVhNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlWE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUxTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG4vLyBMZWdhY3kgYWxpYXNlcyAoZGVwcmVjYXRlZClcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTFN0cmljdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1U3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlWE1MU3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVYTUw7IH0gfSk7XG59KGxpYikpO1xuXG52YXIgRU5USVRZID0gJyYoPzojeFthLWYwLTldezEsNn18I1swLTldezEsN318W2Etel1bYS16MC05XXsxLDMxfSk7JztcbnZhciBDX0JBQ0tTTEFTSCQxID0gOTI7XG52YXIgcmVCYWNrc2xhc2hPckFtcCA9IC9bXFxcXCZdLztcbnZhciBFU0NBUEFCTEUgPSAnWyFcIiMkJSZcXCcoKSorLC4vOjs8PT4/QFtcXFxcXFxcXFxcXFxdXl9ge3x9fi1dJztcbnZhciByZUVudGl0eU9yRXNjYXBlZENoYXIgPSBuZXcgUmVnRXhwKFwiXFxcXFxcXFxcIiArIEVTQ0FQQUJMRSArIFwifFwiICsgRU5USVRZLCAnZ2knKTtcbnZhciBYTUxTUEVDSUFMID0gJ1smPD5cIl0nO1xudmFyIHJlWG1sU3BlY2lhbCA9IG5ldyBSZWdFeHAoWE1MU1BFQ0lBTCwgJ2cnKTtcbnZhciB1bmVzY2FwZUNoYXIgPSBmdW5jdGlvbiAocykge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoMCkgPT09IENfQkFDS1NMQVNIJDEpIHtcbiAgICAgICAgcmV0dXJuIHMuY2hhckF0KDEpO1xuICAgIH1cbiAgICByZXR1cm4gbGliLmRlY29kZUhUTUwocyk7XG59O1xuLy8gUmVwbGFjZSBlbnRpdGllcyBhbmQgYmFja3NsYXNoIGVzY2FwZXMgd2l0aCBsaXRlcmFsIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB1bmVzY2FwZVN0cmluZyhzKSB7XG4gICAgaWYgKHJlQmFja3NsYXNoT3JBbXAudGVzdChzKSkge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKHJlRW50aXR5T3JFc2NhcGVkQ2hhciwgdW5lc2NhcGVDaGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVVUkkodXJpKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZV8xKHVyaSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihzKSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICcmYW1wOyc7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuICcmbHQ7JztcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICByZXR1cm4gJyZndDsnO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJyZxdW90Oyc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICB9XG59XG5mdW5jdGlvbiBlc2NhcGVYbWwocykge1xuICAgIGlmIChyZVhtbFNwZWNpYWwudGVzdChzKSkge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKHJlWG1sU3BlY2lhbCwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBhcnIucHVzaChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gaXNFbXB0eShzdHIpIHtcbiAgICBpZiAoIXN0cikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICEvW14gXFx0XSsvLnRlc3Qoc3RyKTtcbn1cblxudmFyIE5vZGVXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZVdhbGtlcihyb290KSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHJvb3Q7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBOb2RlV2Fsa2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSB0aGlzLmVudGVyaW5nO1xuICAgICAgICBpZiAoY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGFpbmVyID0gaXNDb250YWluZXIkMShjdXIpO1xuICAgICAgICBpZiAoZW50ZXJpbmcgJiYgY29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoY3VyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0YXkgb24gbm9kZSBidXQgZXhpdFxuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIgPT09IHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5uZXh0O1xuICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZW50ZXJpbmc6IGVudGVyaW5nLCBub2RlOiBjdXIgfTtcbiAgICB9O1xuICAgIE5vZGVXYWxrZXIucHJvdG90eXBlLnJlc3VtZUF0ID0gZnVuY3Rpb24gKG5vZGUsIGVudGVyaW5nKSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGU7XG4gICAgICAgIHRoaXMuZW50ZXJpbmcgPSBlbnRlcmluZyA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlV2Fsa2VyO1xufSgpKTtcblxuZnVuY3Rpb24gaXNDb250YWluZXIkMShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICBjYXNlICdibG9ja1F1b3RlJzpcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgY2FzZSAnZW1waCc6XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgY2FzZSAndGFibGVIZWFkJzpcbiAgICAgICAgY2FzZSAndGFibGVCb2R5JzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUNlbGwnOlxuICAgICAgICBjYXNlICd0YWJsZURlbGltUm93JzpcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbnZhciBsYXN0Tm9kZUlkID0gMTtcbnZhciBub2RlTWFwID0ge307XG5mdW5jdGlvbiBnZXROb2RlQnlJZChpZCkge1xuICAgIHJldHVybiBub2RlTWFwW2lkXTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGVCeUlkKGlkKSB7XG4gICAgZGVsZXRlIG5vZGVNYXBbaWRdO1xufVxuZnVuY3Rpb24gcmVtb3ZlQWxsTm9kZSgpIHtcbiAgICBub2RlTWFwID0ge307XG59XG52YXIgTm9kZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUobm9kZVR5cGUsIHNvdXJjZXBvcykge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIC8vIG9ubHkgZm9yIGNvbnRhaW5lciBub2RlXG4gICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENoaWxkID0gbnVsbDtcbiAgICAgICAgLy8gb25seSBmb3IgbGVhZiBub2RlXG4gICAgICAgIHRoaXMubGl0ZXJhbCA9IG51bGw7XG4gICAgICAgIGlmIChub2RlVHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgdGhpcy5pZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGxhc3ROb2RlSWQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSBub2RlVHlwZTtcbiAgICAgICAgdGhpcy5zb3VyY2Vwb3MgPSBzb3VyY2Vwb3M7XG4gICAgICAgIG5vZGVNYXBbdGhpcy5pZF0gPSB0aGlzO1xuICAgIH1cbiAgICBOb2RlLnByb3RvdHlwZS5pc0NvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29udGFpbmVyJDEodGhpcyk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXYpIHtcbiAgICAgICAgICAgIHRoaXMucHJldi5uZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5maXJzdENoaWxkID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5wcmV2ID0gdGhpcy5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5sYXN0Q2hpbGQgPSB0aGlzLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgICAgdGhpcy51bmxpbmsoKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKHNpYmxpbmcpIHtcbiAgICAgICAgc2libGluZy51bmxpbmsoKTtcbiAgICAgICAgc2libGluZy5uZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoc2libGluZy5uZXh0KSB7XG4gICAgICAgICAgICBzaWJsaW5nLm5leHQucHJldiA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5wcmV2ID0gdGhpcztcbiAgICAgICAgdGhpcy5uZXh0ID0gc2libGluZztcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgaWYgKCFzaWJsaW5nLm5leHQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudC5sYXN0Q2hpbGQgPSBzaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoc2libGluZykge1xuICAgICAgICBzaWJsaW5nLnVubGluaygpO1xuICAgICAgICBzaWJsaW5nLnByZXYgPSB0aGlzLnByZXY7XG4gICAgICAgIGlmIChzaWJsaW5nLnByZXYpIHtcbiAgICAgICAgICAgIHNpYmxpbmcucHJldi5uZXh0ID0gc2libGluZztcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLm5leHQgPSB0aGlzO1xuICAgICAgICB0aGlzLnByZXYgPSBzaWJsaW5nO1xuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXNpYmxpbmcucHJldikge1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnQuZmlyc3RDaGlsZCA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnVubGluaygpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkLm5leHQgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLnByZXYgPSB0aGlzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnByZXBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC51bmxpbmsoKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkLnByZXYgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLm5leHQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUud2Fsa2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVXYWxrZXIodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZTtcbn0oKSk7XG52YXIgQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tOb2RlKG5vZGVUeXBlLCBzb3VyY2Vwb3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbm9kZVR5cGUsIHNvdXJjZXBvcykgfHwgdGhpcztcbiAgICAgICAgLy8gdGVtcG9yYWwgZGF0YSAoZm9yIHBhcnNpbmcpXG4gICAgICAgIF90aGlzLm9wZW4gPSB0cnVlO1xuICAgICAgICBfdGhpcy5saW5lT2Zmc2V0cyA9IG51bGw7XG4gICAgICAgIF90aGlzLnN0cmluZ0NvbnRlbnQgPSBudWxsO1xuICAgICAgICBfdGhpcy5sYXN0TGluZUJsYW5rID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxhc3RMaW5lQ2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy50eXBlID0gbm9kZVR5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJsb2NrTm9kZTtcbn0oTm9kZSQxKSk7XG52YXIgTGlzdE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpc3ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3ROb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGlzdERhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXN0Tm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgSGVhZGluZ05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRpbmdOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRpbmdOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGV2ZWwgPSAwO1xuICAgICAgICBfdGhpcy5oZWFkaW5nVHlwZSA9ICdhdHgnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkaW5nTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgQ29kZUJsb2NrTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29kZUJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlQmxvY2tOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNGZW5jZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuZmVuY2VDaGFyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZmVuY2VMZW5ndGggPSAwO1xuICAgICAgICBfdGhpcy5mZW5jZU9mZnNldCA9IC0xO1xuICAgICAgICBfdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaW5mb1BhZGRpbmcgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb2RlQmxvY2tOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBUYWJsZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgVGFibGVDZWxsTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVDZWxsTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGxOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhcnRJZHggPSAwO1xuICAgICAgICBfdGhpcy5lbmRJZHggPSAwO1xuICAgICAgICBfdGhpcy5wYWRkaW5nTGVmdCA9IDA7XG4gICAgICAgIF90aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgICAgIF90aGlzLmlnbm9yZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFibGVDZWxsTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgUmVmRGVmTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmRGVmTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZEZWZOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGl0bGUgPSAnJztcbiAgICAgICAgX3RoaXMuZGVzdCA9ICcnO1xuICAgICAgICBfdGhpcy5sYWJlbCA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWZEZWZOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBDdXN0b21CbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN1c3RvbUJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21CbG9ja05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeW50YXhMZW5ndGggPSAwO1xuICAgICAgICBfdGhpcy5vZmZzZXQgPSAtMTtcbiAgICAgICAgX3RoaXMuaW5mbyA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDdXN0b21CbG9ja05vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIEh0bWxCbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEh0bWxCbG9ja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHRtbEJsb2NrTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmh0bWxCbG9ja1R5cGUgPSAtMTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSHRtbEJsb2NrTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgTGlua05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmtOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmtOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBfdGhpcy50aXRsZSA9IG51bGw7XG4gICAgICAgIF90aGlzLmV4dGVuZGVkQXV0b2xpbmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlua05vZGU7XG59KE5vZGUkMSkpO1xudmFyIENvZGVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2RlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRpY2tDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvZGVOb2RlO1xufShOb2RlJDEpKTtcbnZhciBDdXN0b21JbmxpbmVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDdXN0b21JbmxpbmVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUlubGluZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbmZvID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEN1c3RvbUlubGluZU5vZGU7XG59KE5vZGUkMSkpO1xuZnVuY3Rpb24gY3JlYXRlTm9kZSQxKHR5cGUsIHNvdXJjZXBvcykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVhZGluZ05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0Tm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5rTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjb2RlQmxvY2snOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2RlQmxvY2tOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2h0bWxCbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh0bWxCbG9ja05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAndGFibGVDZWxsJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFibGVDZWxsTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrUXVvdGUnOlxuICAgICAgICBjYXNlICd0aGVtYXRpY0JyZWFrJzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUJvZHknOlxuICAgICAgICBjYXNlICd0YWJsZUhlYWQnOlxuICAgICAgICBjYXNlICdmcm9udE1hdHRlcic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29kZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAncmVmRGVmJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmRGVmTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjdXN0b21CbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjdXN0b21JbmxpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21JbmxpbmVOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGUkMSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ29kZUJsb2NrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnY29kZUJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzSHRtbEJsb2NrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnaHRtbEJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzSGVhZGluZyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnO1xufVxuZnVuY3Rpb24gaXNMaXN0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnbGlzdCc7XG59XG5mdW5jdGlvbiBpc1RhYmxlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAndGFibGUnO1xufVxuZnVuY3Rpb24gaXNSZWZEZWYobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdyZWZEZWYnO1xufVxuZnVuY3Rpb24gaXNDdXN0b21CbG9jayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2N1c3RvbUJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tSW5saW5lKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnY3VzdG9tSW5saW5lJztcbn1cbmZ1bmN0aW9uIHRleHQkMShzLCBzb3VyY2Vwb3MpIHtcbiAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUkMSgndGV4dCcsIHNvdXJjZXBvcyk7XG4gICAgbm9kZS5saXRlcmFsID0gcztcbiAgICByZXR1cm4gbm9kZTtcbn1cblxudmFyIFRBR05BTUUgPSAnW0EtWmEtel1bQS1aYS16MC05LV0qJztcbnZhciBBVFRSSUJVVEVOQU1FID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcbnZhciBVTlFVT1RFRFZBTFVFID0gJ1teXCJcXCc9PD5gXFxcXHgwMC1cXFxceDIwXSsnO1xudmFyIFNJTkdMRVFVT1RFRFZBTFVFID0gXCInW14nXSonXCI7XG52YXIgRE9VQkxFUVVPVEVEVkFMVUUgPSAnXCJbXlwiXSpcIic7XG52YXIgQVRUUklCVVRFVkFMVUUgPSBcIig/OlwiICsgVU5RVU9URURWQUxVRSArIFwifFwiICsgU0lOR0xFUVVPVEVEVkFMVUUgKyBcInxcIiArIERPVUJMRVFVT1RFRFZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFVkFMVUVTUEVDID0gXCJcIiArICcoPzpcXFxccyo9XFxcXHMqJyArIEFUVFJJQlVURVZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFID0gXCJcIiArICcoPzpcXFxccysnICsgQVRUUklCVVRFTkFNRSArIEFUVFJJQlVURVZBTFVFU1BFQyArIFwiPylcIjtcbnZhciBPUEVOVEFHID0gXCI8XCIgKyBUQUdOQU1FICsgQVRUUklCVVRFICsgXCIqXFxcXHMqLz8+XCI7XG52YXIgQ0xPU0VUQUcgPSBcIjwvXCIgKyBUQUdOQU1FICsgXCJcXFxccypbPl1cIjtcbnZhciBIVE1MQ09NTUVOVCA9ICc8IS0tLS0+fDwhLS0oPzotP1tePi1dKSg/Oi0/W14tXSkqLS0+JztcbnZhciBQUk9DRVNTSU5HSU5TVFJVQ1RJT04gPSAnWzxdWz9dLio/Wz9dWz5dJztcbnZhciBERUNMQVJBVElPTiA9ICc8IVtBLVpdK1xcXFxzK1tePl0qPic7XG52YXIgQ0RBVEEgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JztcbnZhciBIVE1MVEFHID0gXCIoPzpcIiArIE9QRU5UQUcgKyBcInxcIiArIENMT1NFVEFHICsgXCJ8XCIgKyBIVE1MQ09NTUVOVCArIFwifFwiICsgUFJPQ0VTU0lOR0lOU1RSVUNUSU9OICsgXCJ8XCIgKyBERUNMQVJBVElPTiArIFwifFwiICsgQ0RBVEEgKyBcIilcIjtcbnZhciByZUh0bWxUYWcgPSBuZXcgUmVnRXhwKFwiXlwiICsgSFRNTFRBRywgJ2knKTtcblxuLy8gZGVyaXZlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5mcm9tQ29kZVBvaW50XG4vKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4yLjEgYnkgQG1hdGhpYXMgKi9cbnZhciBmcm9tQ29kZVBvaW50O1xuaWYgKFN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZmZmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGVfMSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgdmFyIGZsb29yXzEgPSBNYXRoLmZsb29yO1xuICAgIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwO1xuICAgICAgICB2YXIgY29kZVVuaXRzID0gW107XG4gICAgICAgIHZhciBoaWdoU3Vycm9nYXRlO1xuICAgICAgICB2YXIgbG93U3Vycm9nYXRlO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA+IDB4MTBmZmZmIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGZsb29yXzEoY29kZVBvaW50KSAhPT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweGZmZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgICAgICAvLyBCTVAgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgMHhkODAwO1xuICAgICAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweGRjMDA7XG4gICAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlXzEuYXBwbHkodm9pZCAwLCBjb2RlVW5pdHMpO1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbnZhciBmcm9tQ29kZVBvaW50JDEgPSBmcm9tQ29kZVBvaW50O1xuXG52YXIgRE9NQUlOID0gJyg/Olt3LV0rLikqW0EtWmEtejAtOS1dKy5bQS1aYS16MC05LV0rJztcbnZhciBQQVRIID0gJ1tePFxcXFxzXSpbXjw/IS4sOipfP35cXFxcc10nO1xudmFyIEVNQUlMID0gJ1tcXFxcdy4rLV0rQCg/OltcXFxcdy1dK1xcXFwuKStbXFxcXHctXSsnO1xuZnVuY3Rpb24gdHJpbVVubWF0Y2hlZFRyYWlsaW5nUGFyZW5zKHNvdXJjZSkge1xuICAgIHZhciB0cmFpbGluZ1BhcmVuID0gL1xcKSskLy5leGVjKHNvdXJjZSk7XG4gICAgaWYgKHRyYWlsaW5nUGFyZW4pIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzb3VyY2VfMSA9IHNvdXJjZTsgX2kgPCBzb3VyY2VfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHNvdXJjZV8xW19pXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgIHZhciB0cmltQ291bnQgPSBNYXRoLm1pbigtY291bnQsIHRyYWlsaW5nUGFyZW5bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic3RyaW5nKDAsIHNvdXJjZS5sZW5ndGggLSB0cmltQ291bnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiB0cmltVHJhaWxpbmdFbnRpdHkoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKC8mW0EtWmEtejAtOV0rOyQvLCAnJyk7XG59XG5mdW5jdGlvbiBwYXJzZUVtYWlsTGluayhzb3VyY2UpIHtcbiAgICB2YXIgcmVFbWFpbExpbmsgPSBuZXcgUmVnRXhwKEVNQUlMLCAnZycpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbTtcbiAgICB3aGlsZSAoKG0gPSByZUVtYWlsTGluay5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIHZhciB0ZXh0XzEgPSBtWzBdO1xuICAgICAgICBpZiAoIS9bXy1dKyQvLnRlc3QodGV4dF8xKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHQ6IHRleHRfMSxcbiAgICAgICAgICAgICAgICByYW5nZTogW20uaW5kZXgsIG0uaW5kZXggKyB0ZXh0XzEubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgdXJsOiBcIm1haWx0bzpcIiArIHRleHRfMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZVVybExpbmsoc291cmNlKSB7XG4gICAgdmFyIHJlV3d3QXV0b2xpbmsgPSBuZXcgUmVnRXhwKFwiKHd3d3xodHRwcz86Ly8pLlwiICsgRE9NQUlOICsgUEFUSCwgJ2cnKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG07XG4gICAgd2hpbGUgKChtID0gcmVXd3dBdXRvbGluay5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIHZhciB0ZXh0XzIgPSB0cmltVHJhaWxpbmdFbnRpdHkodHJpbVVubWF0Y2hlZFRyYWlsaW5nUGFyZW5zKG1bMF0pKTtcbiAgICAgICAgdmFyIHNjaGVtZSA9IG1bMV0gPT09ICd3d3cnID8gJ2h0dHA6Ly8nIDogJyc7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHRleHRfMixcbiAgICAgICAgICAgIHJhbmdlOiBbbS5pbmRleCwgbS5pbmRleCArIHRleHRfMi5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHVybDogXCJcIiArIHNjaGVtZSArIHRleHRfMixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBiYXNlQXV0b2xpbmtQYXJzZXIoc291cmNlKSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcGFyc2VVcmxMaW5rKHNvdXJjZSkpLCBwYXJzZUVtYWlsTGluayhzb3VyY2UpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnJhbmdlWzBdIC0gYi5yYW5nZVswXTsgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RXh0QXV0b0xpbmtzKHdhbGtlciwgYXV0b2xpbmtQYXJzZXIpIHtcbiAgICBpZiAodHlwZW9mIGF1dG9saW5rUGFyc2VyID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgYXV0b2xpbmtQYXJzZXIgPSBiYXNlQXV0b2xpbmtQYXJzZXI7XG4gICAgfVxuICAgIHZhciBldmVudDtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmcsIG5vZGUgPSBldmVudC5ub2RlO1xuICAgICAgICBpZiAoZW50ZXJpbmcgJiYgbm9kZS50eXBlID09PSAndGV4dCcgJiYgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgICAgIHZhciBsaW5rSW5mb3MgPSBhdXRvbGlua1BhcnNlcihsaXRlcmFsKTtcbiAgICAgICAgICAgIGlmICghbGlua0luZm9zIHx8ICFsaW5rSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0SWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBfYSA9IG5vZGUuc291cmNlcG9zWzBdLCBsaW5lTnVtXzEgPSBfYVswXSwgY2hQb3NfMSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHNvdXJjZXBvcyA9IGZ1bmN0aW9uIChzdGFydElkeCwgZW5kSWR4KSB7IHJldHVybiBbXG4gICAgICAgICAgICAgICAgW2xpbmVOdW1fMSwgY2hQb3NfMSArIHN0YXJ0SWR4XSxcbiAgICAgICAgICAgICAgICBbbGluZU51bV8xLCBjaFBvc18xICsgZW5kSWR4XSxcbiAgICAgICAgICAgIF07IH07XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlua0luZm9zXzEgPSBsaW5rSW5mb3M7IF9pIDwgbGlua0luZm9zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gbGlua0luZm9zXzFbX2ldLCByYW5nZSA9IF9iLnJhbmdlLCB1cmwgPSBfYi51cmwsIGxpbmtUZXh0ID0gX2IudGV4dDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VbMF0gPiBsYXN0SWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2godGV4dCQxKGxpdGVyYWwuc3Vic3RyaW5nKGxhc3RJZHgsIHJhbmdlWzBdKSwgc291cmNlcG9zKGxhc3RJZHgsIHJhbmdlWzBdIC0gMSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtOb2RlID0gY3JlYXRlTm9kZSQxKCdsaW5rJywgc291cmNlcG9zLmFwcGx5KHZvaWQgMCwgcmFuZ2UpKTtcbiAgICAgICAgICAgICAgICBsaW5rTm9kZS5hcHBlbmRDaGlsZCh0ZXh0JDEobGlua1RleHQsIHNvdXJjZXBvcy5hcHBseSh2b2lkIDAsIHJhbmdlKSkpO1xuICAgICAgICAgICAgICAgIGxpbmtOb2RlLmRlc3RpbmF0aW9uID0gdXJsO1xuICAgICAgICAgICAgICAgIGxpbmtOb2RlLmV4dGVuZGVkQXV0b2xpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2gobGlua05vZGUpO1xuICAgICAgICAgICAgICAgIGxhc3RJZHggPSByYW5nZVsxXSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdElkeCA8IGxpdGVyYWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaCh0ZXh0JDEobGl0ZXJhbC5zdWJzdHJpbmcobGFzdElkeCksIHNvdXJjZXBvcyhsYXN0SWR4LCBsaXRlcmFsLmxlbmd0aCAtIDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIG5ld05vZGVzXzEgPSBuZXdOb2RlczsgX2MgPCBuZXdOb2Rlc18xLmxlbmd0aDsgX2MrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gbmV3Tm9kZXNfMVtfY107XG4gICAgICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnVubGluaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgX2xvb3BfMSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cbi8vIG5vcm1hbGl6ZSBhIHJlZmVyZW5jZSBpbiByZWZlcmVuY2UgbGluayAocmVtb3ZlIFtdcywgdHJpbSxcbi8vIGNvbGxhcHNlIGludGVybmFsIHNwYWNlLCB1bmljb2RlIGNhc2UgZm9sZC5cbi8vIFNlZSBjb21tb25tYXJrL2NvbW1vbm1hcmsuanMjMTY4LlxuZnVuY3Rpb24gbm9ybWFsaXplUmVmZXJlbmNlKHN0cikge1xuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnNsaWNlKDEsIHN0ci5sZW5ndGggLSAxKVxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9bIFxcdFxcclxcbl0rLywgJyAnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGl0ZXJhdGVPYmplY3Qob2JqLCBpdGVyYXRlZSkge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGl0ZXJhdGVlKGtleSwgb2JqW2tleV0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gb21pdChvYmopIHtcbiAgICB2YXIgcHJvcE5hbWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcHJvcE5hbWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0TWFwID0gX19hc3NpZ24oe30sIG9iaik7XG4gICAgcHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgcmVzdWx0TWFwW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdE1hcDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgcmV0dXJuICFPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNsZWFyT2JqKG9iaikge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICB9KTtcbn1cblxudmFyIENfTkVXTElORSA9IDEwO1xudmFyIENfQVNURVJJU0sgPSA0MjtcbnZhciBDX1VOREVSU0NPUkUgPSA5NTtcbnZhciBDX0JBQ0tUSUNLID0gOTY7XG52YXIgQ19PUEVOX0JSQUNLRVQkMSA9IDkxO1xudmFyIENfQ0xPU0VfQlJBQ0tFVCA9IDkzO1xudmFyIENfVElMREUgPSAxMjY7XG52YXIgQ19MRVNTVEhBTiQxID0gNjA7XG52YXIgQ19CQU5HID0gMzM7XG52YXIgQ19CQUNLU0xBU0ggPSA5MjtcbnZhciBDX0FNUEVSU0FORCA9IDM4O1xudmFyIENfT1BFTl9QQVJFTiA9IDQwO1xudmFyIENfQ0xPU0VfUEFSRU4gPSA0MTtcbnZhciBDX0NPTE9OID0gNTg7XG52YXIgQ19TSU5HTEVRVU9URSA9IDM5O1xudmFyIENfRE9VQkxFUVVPVEUgPSAzNDtcbnZhciBDX0RPTExBUiA9IDM2O1xuLy8gU29tZSByZWdleHBzIHVzZWQgaW4gaW5saW5lIHBhcnNlcjpcbnZhciBFU0NBUEVEX0NIQVIgPSBcIlxcXFxcXFxcXCIgKyBFU0NBUEFCTEU7XG52YXIgcmVQdW5jdHVhdGlvbiA9IG5ldyBSZWdFeHAoL1shXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5cXHhBMVxceEE3XFx4QUJcXHhCNlxceEI3XFx4QkJcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQyXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgwMVxcdURENkZ8XFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURGM0MtXFx1REYzRV18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdLyk7XG52YXIgcmVMaW5rVGl0bGUgPSBuZXcgUmVnRXhwKFwiXig/OlxcXCIoXCIgKyBFU0NBUEVEX0NIQVIgKyBcInxbXlxcXCJcXFxceDAwXSkqXFxcIlwiICtcbiAgICBcInxcIiArXG4gICAgKFwiJyhcIiArIEVTQ0FQRURfQ0hBUiArIFwifFteJ1xcXFx4MDBdKSonXCIpICtcbiAgICBcInxcIiArXG4gICAgKFwiXFxcXCgoXCIgKyBFU0NBUEVEX0NIQVIgKyBcInxbXigpXFxcXHgwMF0pKlxcXFwpKVwiKSk7XG52YXIgcmVMaW5rRGVzdGluYXRpb25CcmFjZXMgPSAvXig/OjwoPzpbXjw+XFxuXFxcXFxceDAwXXxcXFxcLikqPikvO1xudmFyIHJlRXNjYXBhYmxlID0gbmV3IFJlZ0V4cChcIl5cIiArIEVTQ0FQQUJMRSk7XG52YXIgcmVFbnRpdHlIZXJlID0gbmV3IFJlZ0V4cChcIl5cIiArIEVOVElUWSwgJ2knKTtcbnZhciByZVRpY2tzID0gL2ArLztcbnZhciByZVRpY2tzSGVyZSA9IC9eYCsvO1xudmFyIHJlRWxsaXBzZXMgPSAvXFwuXFwuXFwuL2c7XG52YXIgcmVEYXNoID0gLy0tKy9nO1xudmFyIHJlRW1haWxBdXRvbGluayA9IC9ePChbYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqKT4vO1xudmFyIHJlQXV0b2xpbmsgPSAvXjxbQS1aYS16XVtBLVphLXowLTkuKy1dezEsMzF9OltePD5cXHgwMC1cXHgyMF0qPi9pO1xudmFyIHJlU3BubCA9IC9eICooPzpcXG4gKik/LztcbnZhciByZVdoaXRlc3BhY2VDaGFyID0gL15bIFxcdFxcblxceDBiXFx4MGNcXHgwZF0vO1xudmFyIHJlVW5pY29kZVdoaXRlc3BhY2VDaGFyID0gL15cXHMvO1xudmFyIHJlRmluYWxTcGFjZSA9IC8gKiQvO1xudmFyIHJlSW5pdGlhbFNwYWNlID0gL14gKi87XG52YXIgcmVTcGFjZUF0RW5kT2ZMaW5lID0gL14gKig/OlxcbnwkKS87XG52YXIgcmVMaW5rTGFiZWwgPSAvXlxcWyg/OlteXFxcXFxcW1xcXV18XFxcXC4pezAsMTAwMH1cXF0vO1xuLy8gTWF0Y2hlcyBhIHN0cmluZyBvZiBub24tc3BlY2lhbCBjaGFyYWN0ZXJzLlxudmFyIHJlTWFpbiA9IC9eW15cXG5gXFxbXFxdXFxcXCE8JipfJ1wifiRdKy9tO1xudmFyIElubGluZVBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmxpbmVQYXJzZXIob3B0aW9ucykge1xuICAgICAgICAvLyBBbiBJbmxpbmVQYXJzZXIga2VlcHMgdHJhY2sgb2YgYSBzdWJqZWN0IChhIHN0cmluZyB0byBiZSBwYXJzZWQpXG4gICAgICAgIC8vIGFuZCBhIHBvc2l0aW9uIGluIHRoYXQgc3ViamVjdC5cbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gJyc7XG4gICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IG51bGw7IC8vIHVzZWQgYnkgaGFuZGxlRGVsaW0gbWV0aG9kXG4gICAgICAgIHRoaXMuYnJhY2tldHMgPSBudWxsO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0TnVtID0gMDtcbiAgICAgICAgdGhpcy5saW5lSWR4ID0gMDtcbiAgICAgICAgdGhpcy5saW5lT2Zmc2V0cyA9IFswXTtcbiAgICAgICAgdGhpcy5saW5lUG9zT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5yZWZNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuc291cmNlcG9zID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIGxpbmVQb3NPZmZzZXQgPSB0aGlzLmxpbmVQb3NPZmZzZXQgKyB0aGlzLmxpbmVPZmZzZXRzW3RoaXMubGluZUlkeF07XG4gICAgICAgIHZhciBsaW5lTnVtID0gdGhpcy5saW5lU3RhcnROdW0gKyB0aGlzLmxpbmVJZHg7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IFtsaW5lTnVtLCBzdGFydCArIGxpbmVQb3NPZmZzZXRdO1xuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnRwb3MsIFtsaW5lTnVtLCBlbmQgKyBsaW5lUG9zT2Zmc2V0XV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0cG9zO1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5uZXh0TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saW5lSWR4ICs9IDE7XG4gICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IC10aGlzLnBvcztcbiAgICB9O1xuICAgIC8vIElmIHJlIG1hdGNoZXMgYXQgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgc3ViamVjdCwgYWR2YW5jZVxuICAgIC8vIHBvc2l0aW9uIGluIHN1YmplY3QgYW5kIHJldHVybiB0aGUgbWF0Y2g7IG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHJlKSB7XG4gICAgICAgIHZhciBtID0gcmUuZXhlYyh0aGlzLnN1YmplY3Quc2xpY2UodGhpcy5wb3MpKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG0uaW5kZXggKyBtWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgfTtcbiAgICAvLyBSZXR1cm5zIHRoZSBjb2RlIGZvciB0aGUgY2hhcmFjdGVyIGF0IHRoZSBjdXJyZW50IHN1YmplY3QgcG9zaXRpb24sIG9yIC0xXG4gICAgLy8gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3ViamVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YmplY3QuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgLy8gUGFyc2UgemVybyBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBhdCBtb3N0IG9uZSBuZXdsaW5lXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5zcG5sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1hdGNoKHJlU3BubCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gQWxsIG9mIHRoZSBwYXJzZXJzIGJlbG93IHRyeSB0byBtYXRjaCBzb21ldGhpbmcgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAvLyBpbiB0aGUgc3ViamVjdC4gIElmIHRoZXkgc3VjY2VlZCBpbiBtYXRjaGluZyBhbnl0aGluZywgdGhleVxuICAgIC8vIHJldHVybiB0aGUgaW5saW5lIG1hdGNoZWQsIGFkdmFuY2luZyB0aGUgc3ViamVjdC5cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGJhY2t0aWNrcywgYWRkaW5nIGVpdGhlciBhIGJhY2t0aWNrIGNvZGUgc3BhbiBvciBhXG4gICAgLy8gbGl0ZXJhbCBzZXF1ZW5jZSBvZiBiYWNrdGlja3MuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJhY2t0aWNrcyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHZhciB0aWNrcyA9IHRoaXMubWF0Y2gocmVUaWNrc0hlcmUpO1xuICAgICAgICBpZiAodGlja3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXJPcGVuVGlja3MgPSB0aGlzLnBvcztcbiAgICAgICAgdmFyIG1hdGNoZWQ7XG4gICAgICAgIHdoaWxlICgobWF0Y2hlZCA9IHRoaXMubWF0Y2gocmVUaWNrcykpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCA9PT0gdGlja3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSB0aGlzLnN1YmplY3Quc2xpY2UoYWZ0ZXJPcGVuVGlja3MsIHRoaXMucG9zIC0gdGlja3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlcG9zID0gdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBjb250ZW50cy5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lID0gbGFzdChsaW5lcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUlkeCArPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVQb3NPZmZzZXQgPSAtKHRoaXMucG9zIC0gbGFzdExpbmUubGVuZ3RoIC0gdGlja3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcG9zWzFdID0gdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGxpbmVzLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ2NvZGUnLCBzb3VyY2Vwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLm1hdGNoKC9bXiBdLykgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHNbMF0gPT0gJyAnICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzW2NvbnRlbnRzLmxlbmd0aCAtIDFdID09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxpdGVyYWwgPSBjb250ZW50cy5zbGljZSgxLCBjb250ZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IGNvbnRlbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnRpY2tDb3VudCA9IHRpY2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgd2UgZGlkbid0IG1hdGNoIGEgY2xvc2luZyBiYWNrdGljayBzZXF1ZW5jZS5cbiAgICAgICAgdGhpcy5wb3MgPSBhZnRlck9wZW5UaWNrcztcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKHRpY2tzLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MgLSAxKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIGEgYmFja3NsYXNoLWVzY2FwZWQgc3BlY2lhbCBjaGFyYWN0ZXIsIGFkZGluZyBlaXRoZXIgdGhlIGVzY2FwZWRcbiAgICAvLyBjaGFyYWN0ZXIsIGEgaGFyZCBsaW5lIGJyZWFrIChpZiB0aGUgYmFja3NsYXNoIGlzIGZvbGxvd2VkIGJ5IGEgbmV3bGluZSksXG4gICAgLy8gb3IgYSBsaXRlcmFsIGJhY2tzbGFzaCB0byB0aGUgYmxvY2sncyBjaGlsZHJlbi4gIEFzc3VtZXMgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAvLyBpcyBhIGJhY2tzbGFzaC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQmFja3NsYXNoID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdWJqID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19ORVdMSU5FKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUkMSgnbGluZWJyZWFrJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MgLSAxLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVFc2NhcGFibGUudGVzdChzdWJqLmNoYXJBdCh0aGlzLnBvcykpKSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEoc3Viai5jaGFyQXQodGhpcy5wb3MpLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKSk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKCdcXFxcJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHN0YXJ0cG9zKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhbiBhdXRvbGluayAoVVJMIG9yIGVtYWlsIGluIHBvaW50eSBicmFja2V0cykuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUF1dG9saW5rID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICB2YXIgZGVzdDtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUVtYWlsQXV0b2xpbmspKSkge1xuICAgICAgICAgICAgZGVzdCA9IG0uc2xpY2UoMSwgbS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ2xpbmsnLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIG5vZGUuZGVzdGluYXRpb24gPSBub3JtYWxpemVVUkkoXCJtYWlsdG86XCIgKyBkZXN0KTtcbiAgICAgICAgICAgIG5vZGUudGl0bGUgPSAnJztcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dCQxKGRlc3QsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zICsgMSwgdGhpcy5wb3MgLSAxKSkpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlQXV0b2xpbmspKSkge1xuICAgICAgICAgICAgZGVzdCA9IG0uc2xpY2UoMSwgbS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ2xpbmsnLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIG5vZGUuZGVzdGluYXRpb24gPSBub3JtYWxpemVVUkkoZGVzdCk7XG4gICAgICAgICAgICBub2RlLnRpdGxlID0gJyc7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRleHQkMShkZXN0LCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcyArIDEsIHRoaXMucG9zIC0gMSkpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhIHJhdyBIVE1MIHRhZy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlSHRtbFRhZyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHZhciBtID0gdGhpcy5tYXRjaChyZUh0bWxUYWcpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZSQxKCdodG1sSW5saW5lJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgIG5vZGUubGl0ZXJhbCA9IG07XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHdpdGggY29kZSBjYywgYW5kIHJldHVybiBpbmZvcm1hdGlvbiBhYm91dFxuICAgIC8vIHRoZSBudW1iZXIgb2YgZGVsaW1pdGVycyBhbmQgd2hldGhlciB0aGV5IGFyZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdFxuICAgIC8vIHRoZXkgY2FuIG9wZW4gYW5kL29yIGNsb3NlIGVtcGhhc2lzIG9yIHN0cm9uZyBlbXBoYXNpcy4gIEEgdXRpbGl0eVxuICAgIC8vIGZ1bmN0aW9uIGZvciBzdHJvbmcvZW1waCBwYXJzaW5nLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuc2NhbkRlbGltcyA9IGZ1bmN0aW9uIChjYykge1xuICAgICAgICB2YXIgbnVtZGVsaW1zID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSB8fCBjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICAgICAgbnVtZGVsaW1zKys7XG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSBjYykge1xuICAgICAgICAgICAgICAgIG51bWRlbGltcysrO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWRlbGltcyA9PT0gMCB8fCAobnVtZGVsaW1zIDwgMiAmJiAoY2MgPT09IENfVElMREUgfHwgY2MgPT09IENfRE9MTEFSKSkpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhckJlZm9yZSA9IHN0YXJ0cG9zID09PSAwID8gJ1xcbicgOiB0aGlzLnN1YmplY3QuY2hhckF0KHN0YXJ0cG9zIC0gMSk7XG4gICAgICAgIHZhciBjY0FmdGVyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHZhciBjaGFyQWZ0ZXI7XG4gICAgICAgIGlmIChjY0FmdGVyID09PSAtMSkge1xuICAgICAgICAgICAgY2hhckFmdGVyID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyQWZ0ZXIgPSBmcm9tQ29kZVBvaW50JDEoY2NBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFmdGVySXNXaGl0ZXNwYWNlID0gcmVVbmljb2RlV2hpdGVzcGFjZUNoYXIudGVzdChjaGFyQWZ0ZXIpO1xuICAgICAgICB2YXIgYWZ0ZXJJc1B1bmN0dWF0aW9uID0gcmVQdW5jdHVhdGlvbi50ZXN0KGNoYXJBZnRlcik7XG4gICAgICAgIHZhciBiZWZvcmVJc1doaXRlc3BhY2UgPSByZVVuaWNvZGVXaGl0ZXNwYWNlQ2hhci50ZXN0KGNoYXJCZWZvcmUpO1xuICAgICAgICB2YXIgYmVmb3JlSXNQdW5jdHVhdGlvbiA9IHJlUHVuY3R1YXRpb24udGVzdChjaGFyQmVmb3JlKTtcbiAgICAgICAgdmFyIGxlZnRGbGFua2luZyA9ICFhZnRlcklzV2hpdGVzcGFjZSAmJiAoIWFmdGVySXNQdW5jdHVhdGlvbiB8fCBiZWZvcmVJc1doaXRlc3BhY2UgfHwgYmVmb3JlSXNQdW5jdHVhdGlvbik7XG4gICAgICAgIHZhciByaWdodEZsYW5raW5nID0gIWJlZm9yZUlzV2hpdGVzcGFjZSAmJiAoIWJlZm9yZUlzUHVuY3R1YXRpb24gfHwgYWZ0ZXJJc1doaXRlc3BhY2UgfHwgYWZ0ZXJJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgdmFyIGNhbk9wZW47XG4gICAgICAgIHZhciBjYW5DbG9zZTtcbiAgICAgICAgaWYgKGNjID09PSBDX1VOREVSU0NPUkUpIHtcbiAgICAgICAgICAgIGNhbk9wZW4gPSBsZWZ0RmxhbmtpbmcgJiYgKCFyaWdodEZsYW5raW5nIHx8IGJlZm9yZUlzUHVuY3R1YXRpb24pO1xuICAgICAgICAgICAgY2FuQ2xvc2UgPSByaWdodEZsYW5raW5nICYmICghbGVmdEZsYW5raW5nIHx8IGFmdGVySXNQdW5jdHVhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2MgPT09IENfU0lOR0xFUVVPVEUgfHwgY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgICAgIGNhbk9wZW4gPSBsZWZ0RmxhbmtpbmcgJiYgIXJpZ2h0Rmxhbmtpbmc7XG4gICAgICAgICAgICBjYW5DbG9zZSA9IHJpZ2h0Rmxhbmtpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICBjYW5PcGVuID0gIWFmdGVySXNXaGl0ZXNwYWNlO1xuICAgICAgICAgICAgY2FuQ2xvc2UgPSAhYmVmb3JlSXNXaGl0ZXNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FuT3BlbiA9IGxlZnRGbGFua2luZztcbiAgICAgICAgICAgIGNhbkNsb3NlID0gcmlnaHRGbGFua2luZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICByZXR1cm4geyBudW1kZWxpbXM6IG51bWRlbGltcywgY2FuT3BlbjogY2FuT3BlbiwgY2FuQ2xvc2U6IGNhbkNsb3NlIH07XG4gICAgfTtcbiAgICAvLyBIYW5kbGUgYSBkZWxpbWl0ZXIgbWFya2VyIGZvciBlbXBoYXNpcyBvciBhIHF1b3RlLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuaGFuZGxlRGVsaW0gPSBmdW5jdGlvbiAoY2MsIGJsb2NrKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLnNjYW5EZWxpbXMoY2MpO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1kZWxpbXMgPSByZXMubnVtZGVsaW1zO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHZhciBjb250ZW50cztcbiAgICAgICAgdGhpcy5wb3MgKz0gbnVtZGVsaW1zO1xuICAgICAgICBpZiAoY2MgPT09IENfU0lOR0xFUVVPVEUpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gJ1xcdTIwMTknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICBjb250ZW50cyA9ICdcXHUyMDFDJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gdGhpcy5zdWJqZWN0LnNsaWNlKHN0YXJ0cG9zIC0gMSwgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGV4dCQxKGNvbnRlbnRzLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgaWYgKChyZXMuY2FuT3BlbiB8fCByZXMuY2FuQ2xvc2UpICYmXG4gICAgICAgICAgICAodGhpcy5vcHRpb25zLnNtYXJ0IHx8IChjYyAhPT0gQ19TSU5HTEVRVU9URSAmJiBjYyAhPT0gQ19ET1VCTEVRVU9URSkpKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGltaXRlcnMgPSB7XG4gICAgICAgICAgICAgICAgY2M6IGNjLFxuICAgICAgICAgICAgICAgIG51bWRlbGltczogbnVtZGVsaW1zLFxuICAgICAgICAgICAgICAgIG9yaWdkZWxpbXM6IG51bWRlbGltcyxcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiB0aGlzLmRlbGltaXRlcnMsXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICBjYW5PcGVuOiByZXMuY2FuT3BlbixcbiAgICAgICAgICAgICAgICBjYW5DbG9zZTogcmVzLmNhbkNsb3NlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGltaXRlcnMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlcnMucHJldmlvdXMubmV4dCA9IHRoaXMuZGVsaW1pdGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucmVtb3ZlRGVsaW1pdGVyID0gZnVuY3Rpb24gKGRlbGltKSB7XG4gICAgICAgIGlmIChkZWxpbS5wcmV2aW91cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsaW0ucHJldmlvdXMubmV4dCA9IGRlbGltLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGltLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHRvcCBvZiBzdGFja1xuICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gZGVsaW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxpbS5uZXh0LnByZXZpb3VzID0gZGVsaW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucmVtb3ZlRGVsaW1pdGVyc0JldHdlZW4gPSBmdW5jdGlvbiAoYm90dG9tLCB0b3ApIHtcbiAgICAgICAgaWYgKGJvdHRvbS5uZXh0ICE9PSB0b3ApIHtcbiAgICAgICAgICAgIGJvdHRvbS5uZXh0ID0gdG9wO1xuICAgICAgICAgICAgdG9wLnByZXZpb3VzID0gYm90dG9tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCBkZWxpbWl0ZXJzIC0gZW1waGFzaXMsIHN0cm9uZyBlbXBoYXNpcywgc3RyaWtldGhyb3VnaChnZm0pXG4gICAgICogSWYgdGhlIHNtYXJ0IHB1bmN0dWF0aW9uIG9wdGlvbnMgaXMgdHJ1ZSxcbiAgICAgKiBjb252ZXJ0IHNpbmdsZS9kb3VibGUgcXVvdGVzIHRvIGNvcnJlc3BvbmRpbmcgdW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgICAqKi9cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NFbXBoYXNpcyA9IGZ1bmN0aW9uIChzdGFja0JvdHRvbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBvcGVuZXI7XG4gICAgICAgIHZhciBjbG9zZXI7XG4gICAgICAgIHZhciBvbGRDbG9zZXI7XG4gICAgICAgIHZhciBvcGVuZXJJbmwsIGNsb3NlcklubDtcbiAgICAgICAgdmFyIG9wZW5lckZvdW5kO1xuICAgICAgICB2YXIgb2RkTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFyIG9wZW5lcnNCb3R0b20gPSAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW0NfVU5ERVJTQ09SRV0gPSBbc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tLCBzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX0FTVEVSSVNLXSA9IFtzdGFja0JvdHRvbSwgc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfU0lOR0xFUVVPVEVdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfRE9VQkxFUVVPVEVdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfVElMREVdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfRE9MTEFSXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYSk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3QgY2xvc2VyIGFib3ZlIHN0YWNrQm90dG9tOlxuICAgICAgICBjbG9zZXIgPSB0aGlzLmRlbGltaXRlcnM7XG4gICAgICAgIHdoaWxlIChjbG9zZXIgIT09IG51bGwgJiYgY2xvc2VyLnByZXZpb3VzICE9PSBzdGFja0JvdHRvbSkge1xuICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vdmUgZm9yd2FyZCwgbG9va2luZyBmb3IgY2xvc2VycywgYW5kIGhhbmRsaW5nIGVhY2hcbiAgICAgICAgd2hpbGUgKGNsb3NlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNsb3NlcmNjID0gY2xvc2VyLmNjO1xuICAgICAgICAgICAgdmFyIGNsb3NlckVtcGggPSBjbG9zZXJjYyA9PT0gQ19VTkRFUlNDT1JFIHx8IGNsb3NlcmNjID09PSBDX0FTVEVSSVNLO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXIuY2FuQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGVtcGhhc2lzIGNsb3Nlci4gbm93IGxvb2sgYmFjayBmb3IgZmlyc3QgbWF0Y2hpbmcgb3BlbmVyOlxuICAgICAgICAgICAgICAgIG9wZW5lciA9IGNsb3Nlci5wcmV2aW91cztcbiAgICAgICAgICAgICAgICBvcGVuZXJGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChvcGVuZXIgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyICE9PSBzdGFja0JvdHRvbSAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgIT09IG9wZW5lcnNCb3R0b21bY2xvc2VyY2NdW2Nsb3NlckVtcGggPyBjbG9zZXIub3JpZ2RlbGltcyAlIDMgOiAwXSkge1xuICAgICAgICAgICAgICAgICAgICBvZGRNYXRjaCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJFbXBoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsb3Nlci5jYW5PcGVuIHx8IG9wZW5lci5jYW5DbG9zZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXIub3JpZ2RlbGltcyAlIDMgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3BlbmVyLm9yaWdkZWxpbXMgKyBjbG9zZXIub3JpZ2RlbGltcykgJSAzID09PSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyLmNjID09PSBjbG9zZXIuY2MgJiYgb3BlbmVyLmNhbk9wZW4gJiYgIW9kZE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSBvcGVuZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9sZENsb3NlciA9IGNsb3NlcjtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VyRW1waCB8fCBjbG9zZXJjYyA9PT0gQ19USUxERSB8fCBjbG9zZXJjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAobnVsbCBvcGVuZXIgY2hlY2sgZm9yIHR5cGUgbmFycm93aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGFjdHVhbCBudW1iZXIgb2YgZGVsaW1pdGVycyB1c2VkIGZyb20gY2xvc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlRGVsaW1zID0gY2xvc2VyLm51bWRlbGltcyA+PSAyICYmIG9wZW5lci5udW1kZWxpbXMgPj0gMiA/IDIgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5RGVsaW1zID0gY2xvc2VyRW1waCA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sID0gb3BlbmVyLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwgPSBjbG9zZXIubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGNvbnRlbnRzIGZvciBuZXcgZW1waCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBjbG9zZXJFbXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB1c2VEZWxpbXMgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnZW1waCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc3Ryb25nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3N0cmlrZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgPSAnY3VzdG9tSW5saW5lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZSQxKG5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuZXJFbmRQb3MgPSBvcGVuZXJJbmwuc291cmNlcG9zWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlclN0YXJ0UG9zID0gY2xvc2VySW5sLnNvdXJjZXBvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc291cmNlcG9zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcGVuZXJFbmRQb3NbMF0sIG9wZW5lckVuZFBvc1sxXSAtIHVzZURlbGltcyArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjbG9zZXJTdGFydFBvc1swXSwgY2xvc2VyU3RhcnRQb3NbMV0gKyB1c2VEZWxpbXMgLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwuc291cmNlcG9zWzFdWzFdIC09IHVzZURlbGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlcklubC5zb3VyY2Vwb3NbMF1bMV0gKz0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLmxpdGVyYWwgPSBvcGVuZXJJbmwubGl0ZXJhbC5zbGljZSh1c2VEZWxpbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sLmxpdGVyYWwgPSBjbG9zZXJJbmwubGl0ZXJhbC5zbGljZSh1c2VEZWxpbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLm51bWRlbGltcyAtPSB1c2VEZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXIubnVtZGVsaW1zIC09IHVzZURlbGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB1c2VkIGRlbGltaXRlcnMgZnJvbSBzdGFjayBlbHRzIGFuZCBpbmxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gb3BlbmVySW5sLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0bXAgJiYgdG1wICE9PSBjbG9zZXJJbmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdG1wLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnVubGluaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQodG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVpbGQgY3VzdG9tIGlubGluZSBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHROb2RlID0gbmV3Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXRlcmFsID0gdGV4dE5vZGUubGl0ZXJhbCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGxpdGVyYWwuc3BsaXQoL1xccy8pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuaW5mbyA9IGluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpdGVyYWwubGVuZ3RoIDw9IGluZm8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnVubGluaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUuc291cmNlcG9zWzBdWzFdICs9IGluZm8ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5saXRlcmFsID0gbGl0ZXJhbC5yZXBsYWNlKGluZm8gKyBcIiBcIiwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubC5pbnNlcnRBZnRlcihuZXdOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBlbHRzIGJldHdlZW4gb3BlbmVyIGFuZCBjbG9zZXIgaW4gZGVsaW1pdGVycyBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXJzQmV0d2VlbihvcGVuZXIsIGNsb3Nlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBvcGVuZXIgaGFzIDAgZGVsaW1zLCByZW1vdmUgaXQgYW5kIHRoZSBpbmxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wZW5lciBoYXMgMSBkZWxpbXMgYW5kIGNoYXJhY3RlciBpcyB0aWxkZSwgcmVtb3ZlIGRlbGltaXRlciBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyLm51bWRlbGltcyA8PSBlbXB0eURlbGltcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXIubnVtZGVsaW1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIob3BlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNsb3NlciBoYXMgMCBkZWxpbXMsIHJlbW92ZSBpdCBhbmQgdGhlIGlubGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2xvc2VyIGhhcyAxIGRlbGltcyBhbmQgY2hhcmFjdGVyIGlzIHRpbGRlLCByZW1vdmUgZGVsaW1pdGVyIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXIubnVtZGVsaW1zIDw9IGVtcHR5RGVsaW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlci5udW1kZWxpbXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sLnVubGluaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcHN0YWNrID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIoY2xvc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXIgPSB0ZW1wc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VyY2MgPT09IENfU0lOR0xFUVVPVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyLm5vZGUubGl0ZXJhbCA9ICdcXHUyMDE5JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIubm9kZS5saXRlcmFsID0gJ1xcdTIwMTgnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbG9zZXJjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXIubm9kZS5saXRlcmFsID0gJ1xcdTIwMUQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxQyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghb3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGxvd2VyIGJvdW5kIGZvciBmdXR1cmUgc2VhcmNoZXMgZm9yIG9wZW5lcnM6XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lcnNCb3R0b21bY2xvc2VyY2NdW2Nsb3NlckVtcGggPyBvbGRDbG9zZXIub3JpZ2RlbGltcyAlIDMgOiAwXSA9IG9sZENsb3Nlci5wcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRDbG9zZXIuY2FuT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHJlbW92ZSBhIGNsb3NlciB0aGF0IGNhbid0IGJlIGFuIG9wZW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uY2Ugd2UndmUgc2VlbiB0aGVyZSdzIG5vIG1hdGNoaW5nIG9wZW5lcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKG9sZENsb3Nlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBkZWxpbWl0ZXJzXG4gICAgICAgIHdoaWxlICh0aGlzLmRlbGltaXRlcnMgIT09IG51bGwgJiYgdGhpcy5kZWxpbWl0ZXJzICE9PSBzdGFja0JvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIodGhpcy5kZWxpbWl0ZXJzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBsaW5rIHRpdGxlIChzYW5zIHF1b3RlcyksIHJldHVybmluZyB0aGUgc3RyaW5nXG4gICAgLy8gb3IgbnVsbCBpZiBubyBtYXRjaC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlua1RpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLm1hdGNoKHJlTGlua1RpdGxlKTtcbiAgICAgICAgaWYgKHRpdGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaG9wIG9mZiBxdW90ZXMgZnJvbSB0aXRsZSBhbmQgdW5lc2NhcGU6XG4gICAgICAgIHJldHVybiB1bmVzY2FwZVN0cmluZyh0aXRsZS5zdWJzdHIoMSwgdGl0bGUubGVuZ3RoIC0gMikpO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBsaW5rIGRlc3RpbmF0aW9uLCByZXR1cm5pbmcgdGhlIHN0cmluZyBvciBudWxsIGlmIG5vIG1hdGNoLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VMaW5rRGVzdGluYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLm1hdGNoKHJlTGlua0Rlc3RpbmF0aW9uQnJhY2VzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX0xFU1NUSEFOJDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEBUT0RPIGhhbmRyb2xsZWQgcGFyc2VyOyByZXMgc2hvdWxkIGJlIG51bGwgb3IgdGhlIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHNhdmVwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHZhciBvcGVucGFyZW5zID0gMDtcbiAgICAgICAgICAgIHZhciBjID0gdm9pZCAwO1xuICAgICAgICAgICAgd2hpbGUgKChjID0gdGhpcy5wZWVrKCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBDX0JBQ0tTTEFTSCAmJiByZUVzY2FwYWJsZS50ZXN0KHRoaXMuc3ViamVjdC5jaGFyQXQodGhpcy5wb3MgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVlaygpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBDX09QRU5fUEFSRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgb3BlbnBhcmVucyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBDX0NMT1NFX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVucGFyZW5zIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbnBhcmVucyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlV2hpdGVzcGFjZUNoYXIuZXhlYyhmcm9tQ29kZVBvaW50JDEoYykpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHNhdmVwb3MgJiYgYyAhPT0gQ19DTE9TRV9QQVJFTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wZW5wYXJlbnMgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHRoaXMuc3ViamVjdC5zdWJzdHIoc2F2ZXBvcywgdGhpcy5wb3MgLSBzYXZlcG9zKTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVVUkkodW5lc2NhcGVTdHJpbmcocmVzKSk7XG4gICAgICAgIH0gLy8gY2hvcCBvZmYgc3Vycm91bmRpbmcgPC4uPjpcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVSSSh1bmVzY2FwZVN0cmluZyhyZXMuc3Vic3RyKDEsIHJlcy5sZW5ndGggLSAyKSkpO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhIGxpbmsgbGFiZWwsIHJldHVybmluZyBudW1iZXIgb2YgY2hhcmFjdGVycyBwYXJzZWQuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpbmtMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKHJlTGlua0xhYmVsKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwgfHwgbS5sZW5ndGggPiAxMDAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5sZW5ndGg7XG4gICAgfTtcbiAgICAvLyBBZGQgb3BlbiBicmFja2V0IHRvIGRlbGltaXRlciBzdGFjayBhbmQgYWRkIGEgdGV4dCBub2RlIHRvIGJsb2NrJ3MgY2hpbGRyZW4uXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9wZW5CcmFja2V0ID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICB2YXIgbm9kZSA9IHRleHQkMSgnWycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcykpO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgLy8gQWRkIGVudHJ5IHRvIHN0YWNrIGZvciB0aGlzIG9wZW5lclxuICAgICAgICB0aGlzLmFkZEJyYWNrZXQobm9kZSwgc3RhcnRwb3MsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBJRiBuZXh0IGNoYXJhY3RlciBpcyBbLCBhbmQgISBkZWxpbWl0ZXIgdG8gZGVsaW1pdGVyIHN0YWNrIGFuZFxuICAgIC8vIGFkZCBhIHRleHQgbm9kZSB0byBibG9jaydzIGNoaWxkcmVuLiAgT3RoZXJ3aXNlIGp1c3QgYWRkIGEgdGV4dCBub2RlLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VCYW5nID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfT1BFTl9CUkFDS0VUJDEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRleHQkMSgnIVsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyAtIDEsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgICAgIHRoaXMuYWRkQnJhY2tldChub2RlLCBzdGFydHBvcyArIDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0ZXh0JDEoJyEnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gVHJ5IHRvIG1hdGNoIGNsb3NlIGJyYWNrZXQgYWdhaW5zdCBhbiBvcGVuaW5nIGluIHRoZSBkZWxpbWl0ZXJcbiAgICAvLyBzdGFjay4gIEFkZCBlaXRoZXIgYSBsaW5rIG9yIGltYWdlLCBvciBhIHBsYWluIFsgY2hhcmFjdGVyLFxuICAgIC8vIHRvIGJsb2NrJ3MgY2hpbGRyZW4uICBJZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGRlbGltaXRlcixcbiAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgZGVsaW1pdGVyIHN0YWNrLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VDbG9zZUJyYWNrZXQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIGRlc3QgPSBudWxsO1xuICAgICAgICB2YXIgdGl0bGUgPSBudWxsO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gZ2V0IGxhc3QgWyBvciAhW1xuICAgICAgICB2YXIgb3BlbmVyID0gdGhpcy5icmFja2V0cztcbiAgICAgICAgaWYgKG9wZW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gbWF0Y2hlZCBvcGVuZXIsIGp1c3QgcmV0dXJuIGEgbGl0ZXJhbFxuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKCddJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHN0YXJ0cG9zKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcGVuZXIuYWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBubyBtYXRjaGVkIG9wZW5lciwganVzdCByZXR1cm4gYSBsaXRlcmFsXG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEoJ10nLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgc3RhcnRwb3MpKSk7XG4gICAgICAgICAgICAvLyB0YWtlIG9wZW5lciBvZmYgYnJhY2tldHMgc3RhY2tcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIG9wZW4gaXMgYSBwb3RlbnRpYWwgb3BlbmVyXG4gICAgICAgIHZhciBpc0ltYWdlID0gb3BlbmVyLmltYWdlO1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGxpbmsvaW1hZ2VcbiAgICAgICAgdmFyIHNhdmVwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gSW5saW5lIGxpbms/XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19PUEVOX1BBUkVOKSB7XG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAgICAgKGRlc3QgPSB0aGlzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKCkpICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zcG5sKCkgJiZcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUncyBhIHNwYWNlIGJlZm9yZSB0aGUgdGl0bGU6XG4gICAgICAgICAgICAgICAgKChyZVdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5zdWJqZWN0LmNoYXJBdCh0aGlzLnBvcyAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICAgICAodGl0bGUgPSB0aGlzLnBhcnNlTGlua1RpdGxlKCkpKSB8fFxuICAgICAgICAgICAgICAgICAgICB0cnVlKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrKCkgPT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBzYXZlcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWZMYWJlbCA9ICcnO1xuICAgICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgICAgIC8vIE5leHQsIHNlZSBpZiB0aGVyZSdzIGEgbGluayBsYWJlbFxuICAgICAgICAgICAgdmFyIGJlZm9yZWxhYmVsID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMucGFyc2VMaW5rTGFiZWwoKTtcbiAgICAgICAgICAgIGlmIChuID4gMikge1xuICAgICAgICAgICAgICAgIHJlZkxhYmVsID0gdGhpcy5zdWJqZWN0LnNsaWNlKGJlZm9yZWxhYmVsLCBiZWZvcmVsYWJlbCArIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wZW5lci5icmFja2V0QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBFbXB0eSBvciBtaXNzaW5nIHNlY29uZCBsYWJlbCBtZWFucyB0byB1c2UgdGhlIGZpcnN0IGxhYmVsIGFzIHRoZSByZWZlcmVuY2UuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlZmVyZW5jZSBtdXN0IG5vdCBjb250YWluIGEgYnJhY2tldC4gSWYgd2Uga25vdyB0aGVyZSdzIGEgYnJhY2tldCwgd2UgZG9uJ3QgZXZlbiBib3RoZXIgY2hlY2tpbmcgaXQuXG4gICAgICAgICAgICAgICAgcmVmTGFiZWwgPSB0aGlzLnN1YmplY3Quc2xpY2Uob3BlbmVyLmluZGV4LCBzdGFydHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rLCByZXdpbmQgYmVmb3JlIHNwYWNlcyB3ZSBza2lwcGVkLlxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gc2F2ZXBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZMYWJlbCkge1xuICAgICAgICAgICAgICAgIHJlZkxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHJlZkxhYmVsKTtcbiAgICAgICAgICAgICAgICAvLyBsb29rdXAgcmF3bGFiZWwgaW4gcmVmTWFwXG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLnJlZk1hcFtyZWZMYWJlbF07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdCA9IGxpbmsuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbGluay50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUkMShpc0ltYWdlID8gJ2ltYWdlJyA6ICdsaW5rJyk7XG4gICAgICAgICAgICBub2RlLmRlc3RpbmF0aW9uID0gZGVzdDtcbiAgICAgICAgICAgIG5vZGUudGl0bGUgPSB0aXRsZSB8fCAnJztcbiAgICAgICAgICAgIG5vZGUuc291cmNlcG9zID0gW29wZW5lci5zdGFydHBvcywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MpXTtcbiAgICAgICAgICAgIHZhciB0bXAgPSBvcGVuZXIubm9kZS5uZXh0O1xuICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAodG1wKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRtcC5uZXh0O1xuICAgICAgICAgICAgICAgIHRtcC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgICAgICAgICAgdG1wID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRW1waGFzaXMob3BlbmVyLnByZXZpb3VzRGVsaW1pdGVyKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpO1xuICAgICAgICAgICAgb3BlbmVyLm5vZGUudW5saW5rKCk7XG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgdGhpcyBicmFja2V0IGFuZCBwcm9jZXNzRW1waGFzaXMgd2lsbCByZW1vdmUgbGF0ZXIgZGVsaW1pdGVycy5cbiAgICAgICAgICAgIC8vIE5vdywgZm9yIGEgbGluaywgd2UgYWxzbyBkZWFjdGl2YXRlIGVhcmxpZXIgbGluayBvcGVuZXJzLlxuICAgICAgICAgICAgLy8gKG5vIGxpbmtzIGluIGxpbmtzKVxuICAgICAgICAgICAgaWYgKCFpc0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgb3BlbmVyID0gdGhpcy5icmFja2V0cztcbiAgICAgICAgICAgICAgICB3aGlsZSAob3BlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3BlbmVyLmltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIuYWN0aXZlID0gZmFsc2U7IC8vIGRlYWN0aXZhdGUgdGhpcyBvcGVuZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSBvcGVuZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwW2Jsb2NrLmlkXSA9IHsgbm9kZTogYmxvY2ssIHJlZkxhYmVsOiByZWZMYWJlbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gbm8gbWF0Y2hcbiAgICAgICAgdGhpcy5yZW1vdmVCcmFja2V0KCk7IC8vIHJlbW92ZSB0aGlzIG9wZW5lciBmcm9tIHN0YWNrXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMSgnXScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXBbYmxvY2suaWRdID0geyBub2RlOiBibG9jaywgcmVmTGFiZWw6IHJlZkxhYmVsIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLmFkZEJyYWNrZXQgPSBmdW5jdGlvbiAobm9kZSwgaW5kZXgsIGltYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmJyYWNrZXRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJyYWNrZXRzLmJyYWNrZXRBZnRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5icmFja2V0cyA9IHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICBzdGFydHBvczogdGhpcy5zb3VyY2Vwb3MoaW5kZXggKyAoaW1hZ2UgPyAwIDogMSkpLFxuICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuYnJhY2tldHMsXG4gICAgICAgICAgICBwcmV2aW91c0RlbGltaXRlcjogdGhpcy5kZWxpbWl0ZXJzLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5yZW1vdmVCcmFja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5icmFja2V0cykge1xuICAgICAgICAgICAgdGhpcy5icmFja2V0cyA9IHRoaXMuYnJhY2tldHMucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYW4gZW50aXR5LlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUVudGl0eUhlcmUpKSkge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKGxpYi5kZWNvZGVIVE1MKG0pLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBQYXJzZSBhIHJ1biBvZiBvcmRpbmFyeSBjaGFyYWN0ZXJzLCBvciBhIHNpbmdsZSBjaGFyYWN0ZXIgd2l0aFxuICAgIC8vIGEgc3BlY2lhbCBtZWFuaW5nIGluIG1hcmtkb3duLCBhcyBhIHBsYWluIHN0cmluZy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIGlmICgobSA9IHRoaXMubWF0Y2gocmVNYWluKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGl0ID0gbS5yZXBsYWNlKHJlRWxsaXBzZXMsICdcXHUyMDI2JykucmVwbGFjZShyZURhc2gsIGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5Db3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJzLmxlbmd0aCAlIDMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzaWJsZSBieSAzLCB1c2UgYWxsIGVtIGRhc2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1Db3VudCA9IGNoYXJzLmxlbmd0aCAvIDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcnMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNpYmxlIGJ5IDIsIHVzZSBhbGwgZW4gZGFzaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBlbkNvdW50ID0gY2hhcnMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFycy5sZW5ndGggJSAzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiAyIGV4dHJhIGRhc2hlcywgdXNlIGVuIGRhc2ggZm9yIGxhc3QgMjsgZW0gZGFzaGVzIGZvciByZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBlbkNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtQ291bnQgPSAoY2hhcnMubGVuZ3RoIC0gMikgLyAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGVuIGRhc2hlcyBmb3IgbGFzdCA0IGh5cGhlbnM7IGVtIGRhc2hlcyBmb3IgcmVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5Db3VudCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbUNvdW50ID0gKGNoYXJzLmxlbmd0aCAtIDQpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwZWF0KCdcXHUyMDE0JywgZW1Db3VudCkgKyByZXBlYXQoJ1xcdTIwMTMnLCBlbkNvdW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEobGl0LCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRleHQkMShtLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIGEgbmV3bGluZS4gIElmIGl0IHdhcyBwcmVjZWRlZCBieSB0d28gc3BhY2VzLCByZXR1cm4gYSBoYXJkXG4gICAgLy8gbGluZSBicmVhazsgb3RoZXJ3aXNlIGEgc29mdCBsaW5lIGJyZWFrLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VOZXdsaW5lID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDE7IC8vIGFzc3VtZSB3ZSdyZSBhdCBhIFxcblxuICAgICAgICAvLyBjaGVjayBwcmV2aW91cyBub2RlIGZvciB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgdmFyIGxhc3RjID0gYmxvY2subGFzdENoaWxkO1xuICAgICAgICBpZiAobGFzdGMgJiYgbGFzdGMudHlwZSA9PT0gJ3RleHQnICYmIGxhc3RjLmxpdGVyYWxbbGFzdGMubGl0ZXJhbC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICB2YXIgaGFyZGJyZWFrID0gbGFzdGMubGl0ZXJhbFtsYXN0Yy5saXRlcmFsLmxlbmd0aCAtIDJdID09PSAnICc7XG4gICAgICAgICAgICB2YXIgbGl0TGVuID0gbGFzdGMubGl0ZXJhbC5sZW5ndGg7XG4gICAgICAgICAgICBsYXN0Yy5saXRlcmFsID0gbGFzdGMubGl0ZXJhbC5yZXBsYWNlKHJlRmluYWxTcGFjZSwgJycpO1xuICAgICAgICAgICAgdmFyIGZpbmFsU3BhY2VMZW4gPSBsaXRMZW4gLSBsYXN0Yy5saXRlcmFsLmxlbmd0aDtcbiAgICAgICAgICAgIGxhc3RjLnNvdXJjZXBvc1sxXVsxXSAtPSBmaW5hbFNwYWNlTGVuO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoY3JlYXRlTm9kZSQxKGhhcmRicmVhayA/ICdsaW5lYnJlYWsnIDogJ3NvZnRicmVhaycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zIC0gZmluYWxTcGFjZUxlbiwgdGhpcy5wb3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChjcmVhdGVOb2RlJDEoJ3NvZnRicmVhaycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcykpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgIHRoaXMubWF0Y2gocmVJbml0aWFsU3BhY2UpOyAvLyBnb2JibGUgbGVhZGluZyBzcGFjZXMgaW4gbmV4dCBsaW5lXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhIGxpbmsgcmVmZXJlbmNlLCBtb2RpZnlpbmcgcmVmbWFwLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYmxvY2ssIHJlZk1hcCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmplY3QgPSBibG9jay5zdHJpbmdDb250ZW50O1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHZhciB0aXRsZSA9IG51bGw7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICAvLyBsYWJlbDpcbiAgICAgICAgdmFyIG1hdGNoQ2hhcnMgPSB0aGlzLnBhcnNlTGlua0xhYmVsKCk7XG4gICAgICAgIGlmIChtYXRjaENoYXJzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmF3bGFiZWwgPSB0aGlzLnN1YmplY3Quc3Vic3RyKDAsIG1hdGNoQ2hhcnMpO1xuICAgICAgICAvLyBjb2xvbjpcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX0NPTE9OKSB7XG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vICBsaW5rIHVybFxuICAgICAgICB0aGlzLnNwbmwoKTtcbiAgICAgICAgdmFyIGRlc3QgPSB0aGlzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKCk7XG4gICAgICAgIGlmIChkZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZm9yZXRpdGxlID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMuc3BubCgpO1xuICAgICAgICBpZiAodGhpcy5wb3MgIT09IGJlZm9yZXRpdGxlKSB7XG4gICAgICAgICAgICB0aXRsZSA9IHRoaXMucGFyc2VMaW5rVGl0bGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGl0bGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRpdGxlID0gJyc7XG4gICAgICAgICAgICAvLyByZXdpbmQgYmVmb3JlIHNwYWNlc1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBiZWZvcmV0aXRsZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UncmUgYXQgbGluZSBlbmQ6XG4gICAgICAgIHZhciBhdExpbmVFbmQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5tYXRjaChyZVNwYWNlQXRFbmRPZkxpbmUpID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGl0bGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgYXRMaW5lRW5kID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcG90ZW50aWFsIHRpdGxlIHdlIGZvdW5kIGlzIG5vdCBhdCB0aGUgbGluZSBlbmQsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGl0IGNvdWxkIHN0aWxsIGJlIGEgbGVnYWwgbGluayByZWZlcmVuY2UgaWYgd2VcbiAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIHRoZSB0aXRsZVxuICAgICAgICAgICAgICAgIHRpdGxlID0gJyc7XG4gICAgICAgICAgICAgICAgLy8gcmV3aW5kIGJlZm9yZSBzcGFjZXNcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGJlZm9yZXRpdGxlO1xuICAgICAgICAgICAgICAgIC8vIGFuZCBpbnN0ZWFkIGNoZWNrIGlmIHRoZSBsaW5rIFVSTCBpcyBhdCB0aGUgbGluZSBlbmRcbiAgICAgICAgICAgICAgICBhdExpbmVFbmQgPSB0aGlzLm1hdGNoKHJlU3BhY2VBdEVuZE9mTGluZSkgIT09IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhdExpbmVFbmQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9ybWFsTGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2UocmF3bGFiZWwpO1xuICAgICAgICBpZiAobm9ybWFsTGFiZWwgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBsYWJlbCBtdXN0IGNvbnRhaW4gbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2Vwb3MgPSB0aGlzLmdldFJlZmVyZW5jZURlZlNvdXJjZXBvcyhibG9jayk7XG4gICAgICAgIGJsb2NrLnNvdXJjZXBvc1swXVswXSA9IHNvdXJjZXBvc1sxXVswXSArIDE7XG4gICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZSQxKCdyZWZEZWYnLCBzb3VyY2Vwb3MpO1xuICAgICAgICBub2RlLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIG5vZGUuZGVzdCA9IGRlc3Q7XG4gICAgICAgIG5vZGUubGFiZWwgPSBub3JtYWxMYWJlbDtcbiAgICAgICAgYmxvY2suaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICBpZiAoIXJlZk1hcFtub3JtYWxMYWJlbF0pIHtcbiAgICAgICAgICAgIHJlZk1hcFtub3JtYWxMYWJlbF0gPSBjcmVhdGVSZWZEZWZTdGF0ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSBzdGFydHBvcztcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUubWVyZ2VUZXh0Tm9kZXMgPSBmdW5jdGlvbiAod2Fsa2VyKSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgdmFyIHRleHROb2RlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nLCBub2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgICAgIGlmIChlbnRlcmluZyAmJiBub2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRleHROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRleHROb2RlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gdGV4dE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9kZS5zb3VyY2Vwb3MgJiYgbGFzdE5vZGUuc291cmNlcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5zb3VyY2Vwb3NbMV0gPSBsYXN0Tm9kZS5zb3VyY2Vwb3NbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5uZXh0ID0gbGFzdE5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb2RlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLm5leHQucHJldiA9IGZpcnN0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZXh0Tm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLmxpdGVyYWwgKz0gdGV4dE5vZGVzW2ldLmxpdGVyYWw7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2Rlc1tpXS51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dE5vZGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuZ2V0UmVmZXJlbmNlRGVmU291cmNlcG9zID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGJsb2NrLnN0cmluZ0NvbnRlbnQuc3BsaXQoL1xcbnxcXHJcXG4vKTtcbiAgICAgICAgdmFyIHBhc3NlZFVybExpbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHF1b3RhdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiAwLCBjaDogMCB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgaWYgKHJlV2hpdGVzcGFjZUNoYXIudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9cXDovLnRlc3QobGluZSkgJiYgcXVvdGF0aW9uQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFzc2VkVXJsTGluZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSBsaW5lLmluZGV4T2YoJzonKSA9PT0gbGluZS5sZW5ndGggLSAxID8gaSArIDEgOiBpO1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiBsaW5lT2Zmc2V0LCBjaDogbGluZXNbbGluZU9mZnNldF0ubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgcGFzc2VkVXJsTGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzaG91bGQgY29uc2lkZXIgZXh0ZW5kYWJsZSB0aXRsZVxuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBsaW5lLm1hdGNoKC8nfFwiL2cpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBxdW90YXRpb25Db3VudCArPSBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdW90YXRpb25Db3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiBpLCBjaDogbGluZS5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW2Jsb2NrLnNvdXJjZXBvc1swXVswXSwgYmxvY2suc291cmNlcG9zWzBdWzFdXSxcbiAgICAgICAgICAgIFtibG9jay5zb3VyY2Vwb3NbMF1bMF0gKyBsYXN0TGluZU9mZnNldC5saW5lLCBsYXN0TGluZU9mZnNldC5jaF0sXG4gICAgICAgIF07XG4gICAgfTtcbiAgICAvLyBQYXJzZSB0aGUgbmV4dCBpbmxpbmUgZWxlbWVudCBpbiBzdWJqZWN0LCBhZHZhbmNpbmcgc3ViamVjdCBwb3NpdGlvbi5cbiAgICAvLyBPbiBzdWNjZXNzLCBhZGQgdGhlIHJlc3VsdCB0byBibG9jaydzIGNoaWxkcmVuIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAvLyBPbiBmYWlsdXJlLCByZXR1cm4gZmFsc2UuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciByZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGMgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIENfTkVXTElORTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlTmV3bGluZShibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQkFDS1NMQVNIOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYWNrc2xhc2goYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0JBQ0tUSUNLOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYWNrdGlja3MoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0FTVEVSSVNLOlxuICAgICAgICAgICAgY2FzZSBDX1VOREVSU0NPUkU6XG4gICAgICAgICAgICBjYXNlIENfVElMREU6XG4gICAgICAgICAgICBjYXNlIENfRE9MTEFSOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMuaGFuZGxlRGVsaW0oYywgYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX1NJTkdMRVFVT1RFOlxuICAgICAgICAgICAgY2FzZSBDX0RPVUJMRVFVT1RFOlxuICAgICAgICAgICAgICAgIHJlcyA9ICEhKChfYSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNtYXJ0KSAmJiB0aGlzLmhhbmRsZURlbGltKGMsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19PUEVOX0JSQUNLRVQkMTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlT3BlbkJyYWNrZXQoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0JBTkc6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhbmcoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0NMT1NFX0JSQUNLRVQ6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUNsb3NlQnJhY2tldChibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfTEVTU1RIQU4kMTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQXV0b2xpbmsoYmxvY2spIHx8IHRoaXMucGFyc2VIdG1sVGFnKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19BTVBFUlNBTkQ6XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jay5kaXNhYmxlZEVudGl0eVBhcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VFbnRpdHkoYmxvY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZVN0cmluZyhibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEoZnJvbUNvZGVQb2ludCQxKGMpLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcywgdGhpcy5wb3MgKyAxKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gUGFyc2Ugc3RyaW5nIGNvbnRlbnQgaW4gYmxvY2sgaW50byBpbmxpbmUgY2hpbGRyZW4sXG4gICAgLy8gdXNpbmcgcmVmbWFwIHRvIHJlc29sdmUgcmVmZXJlbmNlcy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQudHJpbSgpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJhY2tldHMgPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVPZmZzZXRzID0gYmxvY2subGluZU9mZnNldHMgfHwgWzBdO1xuICAgICAgICB0aGlzLmxpbmVJZHggPSAwO1xuICAgICAgICB0aGlzLmxpbmVQb3NPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmxpbmVTdGFydE51bSA9IGJsb2NrLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgaWYgKGlzSGVhZGluZyhibG9jaykpIHtcbiAgICAgICAgICAgIHRoaXMubGluZU9mZnNldHNbMF0gKz0gYmxvY2subGV2ZWwgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnBhcnNlSW5saW5lKGJsb2NrKSkgeyB9XG4gICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBudWxsOyAvLyBhbGxvdyByYXcgc3RyaW5nIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIHRoaXMucHJvY2Vzc0VtcGhhc2lzKG51bGwpO1xuICAgICAgICB0aGlzLm1lcmdlVGV4dE5vZGVzKGJsb2NrLndhbGtlcigpKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBleHRlbmRlZEF1dG9saW5rcyA9IF9hLmV4dGVuZGVkQXV0b2xpbmtzLCBjdXN0b21QYXJzZXIgPSBfYS5jdXN0b21QYXJzZXI7XG4gICAgICAgIGlmIChleHRlbmRlZEF1dG9saW5rcykge1xuICAgICAgICAgICAgY29udmVydEV4dEF1dG9MaW5rcyhibG9jay53YWxrZXIoKSwgZXh0ZW5kZWRBdXRvbGlua3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXN0b21QYXJzZXIgJiYgYmxvY2suZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzE7XG4gICAgICAgICAgICB2YXIgd2Fsa2VyID0gYmxvY2suZmlyc3RDaGlsZC53YWxrZXIoKTtcbiAgICAgICAgICAgIHdoaWxlICgoZXZlbnRfMSA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudF8xLm5vZGUsIGVudGVyaW5nID0gZXZlbnRfMS5lbnRlcmluZztcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tUGFyc2VyW25vZGUudHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tUGFyc2VyW25vZGUudHlwZV0obm9kZSwgeyBlbnRlcmluZzogZW50ZXJpbmcsIG9wdGlvbnM6IHRoaXMub3B0aW9ucyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbmxpbmVQYXJzZXI7XG59KCkpO1xuXG52YXIgcmVUYXNrTGlzdEl0ZW1NYXJrZXIgPSAvXlxcWyhbIFxcdHhYXSlcXF1bIFxcdF0rLztcbi8vIGZpbmFsaXplIGZvciBibG9jayBoYW5kbGVyXG5mdW5jdGlvbiB0YXNrTGlzdEl0ZW1GaW5hbGl6ZShfLCBibG9jaykge1xuICAgIGlmIChibG9jay5maXJzdENoaWxkICYmIGJsb2NrLmZpcnN0Q2hpbGQudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgdmFyIHAgPSBibG9jay5maXJzdENoaWxkO1xuICAgICAgICB2YXIgbSA9IHAuc3RyaW5nQ29udGVudC5tYXRjaChyZVRhc2tMaXN0SXRlbU1hcmtlcik7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICB2YXIgbUxlbiA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcC5zdHJpbmdDb250ZW50ID0gcC5zdHJpbmdDb250ZW50LnN1YnN0cmluZyhtTGVuIC0gMSk7XG4gICAgICAgICAgICBwLnNvdXJjZXBvc1swXVsxXSArPSBtTGVuO1xuICAgICAgICAgICAgcC5saW5lT2Zmc2V0c1swXSArPSBtTGVuO1xuICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGFzayA9IHRydWU7XG4gICAgICAgICAgICBibG9jay5saXN0RGF0YS5jaGVja2VkID0gL1t4WF0vLnRlc3QobVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciB0YWJsZSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZUhlYWQnIHx8IHQgPT09ICd0YWJsZUJvZHknO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVCb2R5JDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVSb3cnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVIZWFkJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZVJvdycgfHwgdCA9PT0gJ3RhYmxlRGVsaW1Sb3cnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVEZWxpbVJvdyA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ3RhYmxlRGVsaW1DZWxsJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlRGVsaW1DZWxsID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVSb3cgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZUNlbGwnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVDZWxsID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG5cbnZhciBDT0RFX0lOREVOVCA9IDQ7XG52YXIgQ19UQUIgPSA5O1xudmFyIENfR1JFQVRFUlRIQU4gPSA2MjtcbnZhciBDX0xFU1NUSEFOID0gNjA7XG52YXIgQ19TUEFDRSA9IDMyO1xudmFyIENfT1BFTl9CUkFDS0VUID0gOTE7XG52YXIgcmVOb25TcGFjZSA9IC9bXiBcXHRcXGZcXHZcXHJcXG5dLztcbnZhciByZUNsb3NpbmdDb2RlRmVuY2UgPSAvXig/OmB7Myx9fH57Myx9KSg/PSAqJCkvO1xuLy8gUmV0dXJucyB0cnVlIGlmIGJsb2NrIGVuZHMgd2l0aCBhIGJsYW5rIGxpbmUsIGRlc2NlbmRpbmcgaWYgbmVlZGVkXG4vLyBpbnRvIGxpc3RzIGFuZCBzdWJsaXN0cy5cbmZ1bmN0aW9uIGVuZHNXaXRoQmxhbmtMaW5lKGJsb2NrKSB7XG4gICAgdmFyIGN1ckJsb2NrID0gYmxvY2s7XG4gICAgd2hpbGUgKGN1ckJsb2NrKSB7XG4gICAgICAgIGlmIChjdXJCbG9jay5sYXN0TGluZUJsYW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IGN1ckJsb2NrLnR5cGU7XG4gICAgICAgIGlmICghY3VyQmxvY2subGFzdExpbmVDaGVja2VkICYmICh0ID09PSAnbGlzdCcgfHwgdCA9PT0gJ2l0ZW0nKSkge1xuICAgICAgICAgICAgY3VyQmxvY2subGFzdExpbmVDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1ckJsb2NrID0gY3VyQmxvY2subGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VyQmxvY2subGFzdExpbmVDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBlZWsobG4sIHBvcykge1xuICAgIGlmIChwb3MgPCBsbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGxuLmNoYXJDb2RlQXQocG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLy8gUmV0dXJucyB0cnVlIGlmIHN0cmluZyBjb250YWlucyBvbmx5IHNwYWNlIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiBpc0JsYW5rKHMpIHtcbiAgICByZXR1cm4gIXJlTm9uU3BhY2UudGVzdChzKTtcbn1cbmZ1bmN0aW9uIGlzU3BhY2VPclRhYihjKSB7XG4gICAgcmV0dXJuIGMgPT09IENfU1BBQ0UgfHwgYyA9PT0gQ19UQUI7XG59XG5cbnZhciByZUNsb3NpbmdDdXN0b21CbG9jayA9IC9eXFwkXFwkJC87XG52YXIgY3VzdG9tQmxvY2skMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKHJlQ2xvc2luZ0N1c3RvbUJsb2NrKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBjbG9zaW5nIGN1c3RvbSBibG9ja1xuICAgICAgICAgICAgcGFyc2VyLmxhc3RMaW5lTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIDIgLyogRmluaXNoZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBvcHRpb25hbCBzcGFjZXMgb2YgY3VzdG9tIGJsb2NrIG9mZnNldFxuICAgICAgICB2YXIgaSA9IGNvbnRhaW5lci5vZmZzZXQ7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiBpc1NwYWNlT3JUYWIocGVlayhsaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IGxpbmUgYmVjb21lcyBpbmZvIHN0cmluZ1xuICAgICAgICB2YXIgY29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgIHZhciBuZXdsaW5lUG9zID0gY29udGVudC5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGNvbnRlbnQuc2xpY2UoMCwgbmV3bGluZVBvcyk7XG4gICAgICAgIHZhciByZXN0ID0gY29udGVudC5zbGljZShuZXdsaW5lUG9zICsgMSk7XG4gICAgICAgIHZhciBpbmZvU3RyaW5nID0gZmlyc3RMaW5lLm1hdGNoKC9eKFxccyopKC4qKS8pO1xuICAgICAgICBibG9jay5pbmZvID0gdW5lc2NhcGVTdHJpbmcoaW5mb1N0cmluZ1syXS50cmltKCkpO1xuICAgICAgICBibG9jay5saXRlcmFsID0gcmVzdDtcbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG5cbnZhciBub29wID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBkb2N1bWVudCQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCAhPT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgbGlzdCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBibG9jay5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5vbi1maW5hbCBsaXN0IGl0ZW0gZW5kaW5nIHdpdGggYmxhbmsgbGluZTpcbiAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZShpdGVtKSAmJiBpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICBibG9jay5saXN0RGF0YS50aWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVjdXJzZSBpbnRvIGNoaWxkcmVuIG9mIGxpc3QgaXRlbSwgdG8gc2VlIGlmIHRoZXJlIGFyZVxuICAgICAgICAgICAgLy8gc3BhY2VzIGJldHdlZW4gYW55IG9mIHRoZW06XG4gICAgICAgICAgICB2YXIgc3ViaXRlbSA9IGl0ZW0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChzdWJpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKHN1Yml0ZW0pICYmIChpdGVtLm5leHQgfHwgc3ViaXRlbS5uZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBibG9jay5saXN0RGF0YS50aWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViaXRlbSA9IHN1Yml0ZW0ubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLm5leHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAnaXRlbSc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciBibG9ja1F1b3RlJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgdmFyIGxuID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiBwZWVrKGxuLCBwYXJzZXIubmV4dE5vbnNwYWNlKSA9PT0gQ19HUkVBVEVSVEhBTikge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhsbiwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCAhPT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgaXRlbSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEJsYW5rIGxpbmUgYWZ0ZXIgZW1wdHkgbGlzdCBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VyLmluZGVudCA+PSBjb250YWluZXIubGlzdERhdGEubWFya2VyT2Zmc2V0ICsgY29udGFpbmVyLmxpc3REYXRhLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGNvbnRhaW5lci5saXN0RGF0YS5tYXJrZXJPZmZzZXQgKyBjb250YWluZXIubGlzdERhdGEucGFkZGluZywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IHRhc2tMaXN0SXRlbUZpbmFsaXplLFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ICE9PSAnaXRlbSc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciBoZWFkaW5nID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGEgaGVhZGluZyBjYW4gbmV2ZXIgY29udGFpbmVyID4gMSBsaW5lLCBzbyBmYWlsIHRvIG1hdGNoOlxuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRoZW1hdGljQnJlYWskMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhIHRoZW1hdGljIGJyZWFrIGNhbiBuZXZlciBjb250YWluZXIgPiAxIGxpbmUsIHNvIGZhaWwgdG8gbWF0Y2g6XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgY29kZUJsb2NrID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGxuID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgaW5kZW50ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5pc0ZlbmNlZCkge1xuICAgICAgICAgICAgLy8gZmVuY2VkXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBpbmRlbnQgPD0gMyAmJlxuICAgICAgICAgICAgICAgIGxuLmNoYXJBdChwYXJzZXIubmV4dE5vbnNwYWNlKSA9PT0gY29udGFpbmVyLmZlbmNlQ2hhciAmJlxuICAgICAgICAgICAgICAgIGxuLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpLm1hdGNoKHJlQ2xvc2luZ0NvZGVGZW5jZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID49IGNvbnRhaW5lci5mZW5jZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NpbmcgZmVuY2UgLSB3ZSdyZSBhdCBlbmQgb2YgbGluZSwgc28gd2UgY2FuIHJldHVyblxuICAgICAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IHBhcnNlci5vZmZzZXQgKyBpbmRlbnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEZpbmlzaGVkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCBvcHRpb25hbCBzcGFjZXMgb2YgZmVuY2Ugb2Zmc2V0XG4gICAgICAgICAgICB2YXIgaSA9IGNvbnRhaW5lci5mZW5jZU9mZnNldDtcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBpc1NwYWNlT3JUYWIocGVlayhsbiwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5kZW50ZWRcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPj0gQ09ERV9JTkRFTlQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChDT0RFX0lOREVOVCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9jay5pc0ZlbmNlZCkge1xuICAgICAgICAgICAgLy8gZmVuY2VkXG4gICAgICAgICAgICAvLyBmaXJzdCBsaW5lIGJlY29tZXMgaW5mbyBzdHJpbmdcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgICAgIHZhciBuZXdsaW5lUG9zID0gY29udGVudC5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgIHZhciBmaXJzdExpbmUgPSBjb250ZW50LnNsaWNlKDAsIG5ld2xpbmVQb3MpO1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBjb250ZW50LnNsaWNlKG5ld2xpbmVQb3MgKyAxKTtcbiAgICAgICAgICAgIHZhciBpbmZvU3RyaW5nID0gZmlyc3RMaW5lLm1hdGNoKC9eKFxccyopKC4qKS8pO1xuICAgICAgICAgICAgYmxvY2suaW5mb1BhZGRpbmcgPSBpbmZvU3RyaW5nWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGJsb2NrLmluZm8gPSB1bmVzY2FwZVN0cmluZyhpbmZvU3RyaW5nWzJdLnRyaW0oKSk7XG4gICAgICAgICAgICBibG9jay5saXRlcmFsID0gcmVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluZGVudGVkXG4gICAgICAgICAgICBibG9jay5saXRlcmFsID0gKF9hID0gYmxvY2suc3RyaW5nQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoLyhcXG4gKikrJC8sICdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDsgLy8gYWxsb3cgR0NcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBodG1sQmxvY2skMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIuYmxhbmsgJiYgKGNvbnRhaW5lci5odG1sQmxvY2tUeXBlID09PSA2IHx8IGNvbnRhaW5lci5odG1sQmxvY2tUeXBlID09PSA3KVxuICAgICAgICAgICAgPyAxIC8qIFN0b3AgKi9cbiAgICAgICAgICAgIDogMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBibG9jay5saXRlcmFsID0gKChfYSA9IGJsb2NrLnN0cmluZ0NvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC8oXFxuICopKyQvLCAnJykpIHx8IG51bGw7XG4gICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBudWxsOyAvLyBhbGxvdyBHQ1xuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xudmFyIHBhcmFncmFwaCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gcGFyc2VyLmJsYW5rID8gMSAvKiBTdG9wICovIDogMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAocGFyc2VyLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3M7XG4gICAgICAgIHZhciBoYXNSZWZlcmVuY2VEZWZzID0gZmFsc2U7XG4gICAgICAgIC8vIHRyeSBwYXJzaW5nIHRoZSBiZWdpbm5pbmcgYXMgbGluayByZWZlcmVuY2UgZGVmaW5pdGlvbnM6XG4gICAgICAgIHdoaWxlIChwZWVrKGJsb2NrLnN0cmluZ0NvbnRlbnQsIDApID09PSBDX09QRU5fQlJBQ0tFVCAmJlxuICAgICAgICAgICAgKHBvcyA9IHBhcnNlci5pbmxpbmVQYXJzZXIucGFyc2VSZWZlcmVuY2UoYmxvY2ssIHBhcnNlci5yZWZNYXApKSkge1xuICAgICAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgIGhhc1JlZmVyZW5jZURlZnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2VEZWZzICYmIGlzQmxhbmsoYmxvY2suc3RyaW5nQ29udGVudCkpIHtcbiAgICAgICAgICAgIGJsb2NrLnVubGluaygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgcmVmRGVmID0gbm9vcDtcbnZhciBmcm9udE1hdHRlciQyID0gbm9vcDtcbnZhciBibG9ja0hhbmRsZXJzID0ge1xuICAgIGRvY3VtZW50OiBkb2N1bWVudCQxLFxuICAgIGxpc3Q6IGxpc3QsXG4gICAgYmxvY2tRdW90ZTogYmxvY2tRdW90ZSQxLFxuICAgIGl0ZW06IGl0ZW0sXG4gICAgaGVhZGluZzogaGVhZGluZyxcbiAgICB0aGVtYXRpY0JyZWFrOiB0aGVtYXRpY0JyZWFrJDEsXG4gICAgY29kZUJsb2NrOiBjb2RlQmxvY2ssXG4gICAgaHRtbEJsb2NrOiBodG1sQmxvY2skMSxcbiAgICBwYXJhZ3JhcGg6IHBhcmFncmFwaCxcbiAgICB0YWJsZTogdGFibGUsXG4gICAgdGFibGVCb2R5OiB0YWJsZUJvZHkkMSxcbiAgICB0YWJsZUhlYWQ6IHRhYmxlSGVhZCQxLFxuICAgIHRhYmxlUm93OiB0YWJsZVJvdyxcbiAgICB0YWJsZUNlbGw6IHRhYmxlQ2VsbCxcbiAgICB0YWJsZURlbGltUm93OiB0YWJsZURlbGltUm93LFxuICAgIHRhYmxlRGVsaW1DZWxsOiB0YWJsZURlbGltQ2VsbCxcbiAgICByZWZEZWY6IHJlZkRlZixcbiAgICBjdXN0b21CbG9jazogY3VzdG9tQmxvY2skMSxcbiAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIkMixcbn07XG5cbmZ1bmN0aW9uIHBhcnNlUm93Q29udGVudChjb250ZW50KSB7XG4gICAgdmFyIHN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGNvbnRlbnRbaV0gPT09ICd8JyAmJiBjb250ZW50W2kgLSAxXSAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0SWR4LCBpKTtcbiAgICAgICAgICAgIGlmIChzdGFydElkeCA9PT0gMCAmJiBpc0VtcHR5KGNlbGwpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRJZHggPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnRJZHggPCBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY2VsbCA9IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0SWR4LCBjb250ZW50Lmxlbmd0aCk7XG4gICAgICAgIGlmICghaXNFbXB0eShjZWxsKSkge1xuICAgICAgICAgICAgY2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW29mZnNldCwgY2VsbHNdO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUYWJsZUNlbGxzKGNlbGxUeXBlLCBjb250ZW50cywgbGluZU51bSwgY2hQb3MpIHtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbnRlbnRzXzEgPSBjb250ZW50czsgX2kgPCBjb250ZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29udGVudCA9IGNvbnRlbnRzXzFbX2ldO1xuICAgICAgICB2YXIgcHJlU3BhY2VzID0gY29udGVudC5tYXRjaCgvXlsgXFx0XSsvKTtcbiAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gcHJlU3BhY2VzID8gcHJlU3BhY2VzWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgIHZhciBwYWRkaW5nUmlnaHQgPSB2b2lkIDAsIHRyaW1tZWQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChwYWRkaW5nTGVmdCA9PT0gY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IDA7XG4gICAgICAgICAgICB0cmltbWVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcG9zdFNwYWNlcyA9IGNvbnRlbnQubWF0Y2goL1sgXFx0XSskLyk7XG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBwb3N0U3BhY2VzID8gcG9zdFNwYWNlc1swXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgdHJpbW1lZCA9IGNvbnRlbnQuc2xpY2UocGFkZGluZ0xlZnQsIGNvbnRlbnQubGVuZ3RoIC0gcGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hQb3NTdGFydCA9IGNoUG9zICsgcGFkZGluZ0xlZnQ7XG4gICAgICAgIHZhciB0YWJsZUNlbGwgPSBjcmVhdGVOb2RlJDEoY2VsbFR5cGUsIFtcbiAgICAgICAgICAgIFtsaW5lTnVtLCBjaFBvc10sXG4gICAgICAgICAgICBbbGluZU51bSwgY2hQb3MgKyBjb250ZW50Lmxlbmd0aCAtIDFdLFxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGVDZWxsLnN0cmluZ0NvbnRlbnQgPSB0cmltbWVkLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTsgLy8gcmVwbGFjZSBlc2FjcGVkIHBpcGUoXFx8KVxuICAgICAgICB0YWJsZUNlbGwuc3RhcnRJZHggPSBjZWxscy5sZW5ndGg7XG4gICAgICAgIHRhYmxlQ2VsbC5lbmRJZHggPSBjZWxscy5sZW5ndGg7XG4gICAgICAgIHRhYmxlQ2VsbC5saW5lT2Zmc2V0cyA9IFtjaFBvc1N0YXJ0IC0gMV07XG4gICAgICAgIHRhYmxlQ2VsbC5wYWRkaW5nTGVmdCA9IHBhZGRpbmdMZWZ0O1xuICAgICAgICB0YWJsZUNlbGwucGFkZGluZ1JpZ2h0ID0gcGFkZGluZ1JpZ2h0O1xuICAgICAgICBjZWxscy5wdXNoKHRhYmxlQ2VsbCk7XG4gICAgICAgIGNoUG9zICs9IGNvbnRlbnQubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzO1xufVxuZnVuY3Rpb24gZ2V0Q29sdW1uRnJvbURlbGltQ2VsbChjZWxsTm9kZSkge1xuICAgIHZhciBhbGlnbiA9IG51bGw7XG4gICAgdmFyIGNvbnRlbnQgPSBjZWxsTm9kZS5zdHJpbmdDb250ZW50O1xuICAgIHZhciBmaXJzdENoID0gY29udGVudFswXTtcbiAgICB2YXIgbGFzdENoID0gY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2ggPT09ICc6Jykge1xuICAgICAgICBhbGlnbiA9IGZpcnN0Q2ggPT09ICc6JyA/ICdjZW50ZXInIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RDaCA9PT0gJzonKSB7XG4gICAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH1cbiAgICByZXR1cm4geyBhbGlnbjogYWxpZ24gfTtcbn1cbnZhciB0YWJsZUhlYWQgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgc3RyaW5nQ29udGVudCA9IGNvbnRhaW5lci5zdHJpbmdDb250ZW50O1xuICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgIXBhcnNlci5pbmRlbnRlZCAmJiAhcGFyc2VyLmJsYW5rKSB7XG4gICAgICAgIHZhciBsYXN0TmV3TGluZUlkeCA9IHN0cmluZ0NvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGxhc3RMaW5lU3RhcnRJZHggPSBzdHJpbmdDb250ZW50Lmxhc3RJbmRleE9mKCdcXG4nLCBsYXN0TmV3TGluZUlkeCAtIDEpICsgMTtcbiAgICAgICAgdmFyIGhlYWRlckNvbnRlbnQgPSBzdHJpbmdDb250ZW50LnNsaWNlKGxhc3RMaW5lU3RhcnRJZHgsIGxhc3ROZXdMaW5lSWR4KTtcbiAgICAgICAgdmFyIGRlbGltQ29udGVudCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VSb3dDb250ZW50KGhlYWRlckNvbnRlbnQpLCBoZWFkZXJPZmZzZXQgPSBfYVswXSwgaGVhZGVyQ2VsbHMgPSBfYVsxXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VSb3dDb250ZW50KGRlbGltQ29udGVudCksIGRlbGltT2Zmc2V0ID0gX2JbMF0sIGRlbGltQ2VsbHMgPSBfYlsxXTtcbiAgICAgICAgdmFyIHJlVmFsaWREZWxpbUNlbGxfMSA9IC9eWyBcXHRdKjo/LSs6P1sgXFx0XSokLztcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgY2hlY2tpbmcgaWYgdGhlIG51bWJlciBvZiBoZWFkZXIgY2VsbHMgYW5kIGRlbGltaXRlciBjZWxscyBhcmUgdGhlIHNhbWVcbiAgICAgICAgLy8gdG8gY29uc2lkZXIgdGhlIGNhc2Ugb2YgbWVyZ2VkLWNvbHVtbiAodmlhIHBsdWdpbilcbiAgICAgICAgIWhlYWRlckNlbGxzLmxlbmd0aCB8fFxuICAgICAgICAgICAgIWRlbGltQ2VsbHMubGVuZ3RoIHx8XG4gICAgICAgICAgICBkZWxpbUNlbGxzLnNvbWUoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuICFyZVZhbGlkRGVsaW1DZWxsXzEudGVzdChjZWxsKTsgfSkgfHxcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgdG8gcmVnYXJkIHNldFRleHRIZWFkaW5nIGFzIHRhYmVsIGRlbGltIGNlbGwgd2l0aCAnZGlzYWxsb3dEZWVwSGVhZGluZycgb3B0aW9uXG4gICAgICAgICAgICAoZGVsaW1DZWxscy5sZW5ndGggPT09IDEgJiYgZGVsaW1Db250ZW50LmluZGV4T2YoJ3wnKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gY29udGFpbmVyLmxpbmVPZmZzZXRzO1xuICAgICAgICB2YXIgZmlyc3RMaW5lTnVtID0gcGFyc2VyLmxpbmVOdW1iZXIgLSAxO1xuICAgICAgICB2YXIgZmlyc3RMaW5lU3RhcnQgPSBsYXN0KGxpbmVPZmZzZXRzKSArIDE7XG4gICAgICAgIHZhciB0YWJsZSA9IGNyZWF0ZU5vZGUkMSgndGFibGUnLCBbXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydF0sXG4gICAgICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5vZmZzZXRdLFxuICAgICAgICBdKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAgICAgdGFibGUuY29sdW1ucyA9IGRlbGltQ2VsbHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IGFsaWduOiBudWxsIH0pOyB9KTtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEFmdGVyKHRhYmxlKTtcbiAgICAgICAgaWYgKGxpbmVPZmZzZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnVubGluaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgPSBzdHJpbmdDb250ZW50LnNsaWNlKDAsIGxhc3RMaW5lU3RhcnRJZHgpO1xuICAgICAgICAgICAgdmFyIHBhcmFMYXN0TGluZVN0YXJ0SWR4ID0gc3RyaW5nQ29udGVudC5sYXN0SW5kZXhPZignXFxuJywgbGFzdExpbmVTdGFydElkeCAtIDIpICsgMTtcbiAgICAgICAgICAgIHZhciBwYXJhTGFzdExpbmVMZW4gPSBsYXN0TGluZVN0YXJ0SWR4IC0gcGFyYUxhc3RMaW5lU3RhcnRJZHggLSAxO1xuICAgICAgICAgICAgcGFyc2VyLmxhc3RMaW5lTGVuZ3RoID0gbGluZU9mZnNldHNbbGluZU9mZnNldHMubGVuZ3RoIC0gMl0gKyBwYXJhTGFzdExpbmVMZW47XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBmaXJzdExpbmVOdW0gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCwgZmFsc2UpO1xuICAgICAgICB2YXIgdGFibGVIZWFkXzEgPSBjcmVhdGVOb2RlJDEoJ3RhYmxlSGVhZCcsIFtcbiAgICAgICAgICAgIFtmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0XSxcbiAgICAgICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm9mZnNldF0sXG4gICAgICAgIF0pO1xuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZCh0YWJsZUhlYWRfMSk7XG4gICAgICAgIHZhciB0YWJsZUhlYWRSb3dfMSA9IGNyZWF0ZU5vZGUkMSgndGFibGVSb3cnLCBbXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydF0sXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydCArIGhlYWRlckNvbnRlbnQubGVuZ3RoIC0gMV0sXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdGFibGVEZWxpbVJvd18xID0gY3JlYXRlTm9kZSQxKCd0YWJsZURlbGltUm93JywgW1xuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMV0sXG4gICAgICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5vZmZzZXRdLFxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGVIZWFkXzEuYXBwZW5kQ2hpbGQodGFibGVIZWFkUm93XzEpO1xuICAgICAgICB0YWJsZUhlYWRfMS5hcHBlbmRDaGlsZCh0YWJsZURlbGltUm93XzEpO1xuICAgICAgICBnZW5lcmF0ZVRhYmxlQ2VsbHMoJ3RhYmxlQ2VsbCcsIGhlYWRlckNlbGxzLCBmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0ICsgaGVhZGVyT2Zmc2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsTm9kZSkge1xuICAgICAgICAgICAgdGFibGVIZWFkUm93XzEuYXBwZW5kQ2hpbGQoY2VsbE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlbGltQ2VsbE5vZGVzID0gZ2VuZXJhdGVUYWJsZUNlbGxzKCd0YWJsZURlbGltQ2VsbCcsIGRlbGltQ2VsbHMsIHBhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMSArIGRlbGltT2Zmc2V0KTtcbiAgICAgICAgZGVsaW1DZWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbE5vZGUpIHtcbiAgICAgICAgICAgIHRhYmxlRGVsaW1Sb3dfMS5hcHBlbmRDaGlsZChjZWxsTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0YWJsZS5jb2x1bW5zID0gZGVsaW1DZWxsTm9kZXMubWFwKGdldENvbHVtbkZyb21EZWxpbUNlbGwpO1xuICAgICAgICBwYXJzZXIudGlwID0gdGFibGU7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIHRhYmxlQm9keSA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIGlmICgoY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZScgJiYgY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZUJvZHknKSB8fFxuICAgICAgICAoIXBhcnNlci5ibGFuayAmJiBwYXJzZXIuY3VycmVudExpbmUuaW5kZXhPZignfCcpID09PSAtMSkpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgIHZhciB0YWJsZV8xID0gY29udGFpbmVyO1xuICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICd0YWJsZUJvZHknKSB7XG4gICAgICAgICAgICB0YWJsZV8xID0gY29udGFpbmVyLnBhcmVudDtcbiAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmZpbmFsaXplKHRhYmxlXzEsIHBhcnNlci5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIHZhciB0YWJsZUJvZHkgPSBjb250YWluZXI7XG4gICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAndGFibGUnKSB7XG4gICAgICAgIHRhYmxlQm9keSA9IHBhcnNlci5hZGRDaGlsZCgndGFibGVCb2R5JywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHRhYmxlQm9keS5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHRhYmxlUm93ID0gY3JlYXRlTm9kZSQxKCd0YWJsZVJvdycsIFtcbiAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMV0sXG4gICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aF0sXG4gICAgXSk7XG4gICAgdGFibGVCb2R5LmFwcGVuZENoaWxkKHRhYmxlUm93KTtcbiAgICB2YXIgdGFibGUgPSB0YWJsZUJvZHkucGFyZW50O1xuICAgIHZhciBjb250ZW50ID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgIHZhciBfYSA9IHBhcnNlUm93Q29udGVudChjb250ZW50KSwgb2Zmc2V0ID0gX2FbMF0sIGNlbGxDb250ZW50cyA9IF9hWzFdO1xuICAgIGdlbmVyYXRlVGFibGVDZWxscygndGFibGVDZWxsJywgY2VsbENvbnRlbnRzLCBwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDEgKyBvZmZzZXQpLmZvckVhY2goZnVuY3Rpb24gKGNlbGxOb2RlLCBpZHgpIHtcbiAgICAgICAgaWYgKGlkeCA+PSB0YWJsZS5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgY2VsbE5vZGUuaWdub3JlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVSb3cuYXBwZW5kQ2hpbGQoY2VsbE5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiAyIC8qIExlYWYgKi87XG59O1xuXG52YXIgcmVDdXN0b21CbG9jayA9IC9eKFxcJFxcJCkoXFxzKlthLXpBLVpdKSsvO1xudmFyIHJlQ2FuQmVDdXN0b21JbmxpbmUgPSAvXihcXCRcXCQpKFxccypbYS16QS1aXSkrLiooXFwkXFwkKS87XG52YXIgY3VzdG9tQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgICFyZUNhbkJlQ3VzdG9tSW5saW5lLnRlc3QocGFyc2VyLmN1cnJlbnRMaW5lKSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUubWF0Y2gocmVDdXN0b21CbG9jaykpKSB7XG4gICAgICAgIHZhciBzeW50YXhMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gcGFyc2VyLmFkZENoaWxkKCdjdXN0b21CbG9jaycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBjb250YWluZXIuc3ludGF4TGVuZ3RoID0gc3ludGF4TGVuZ3RoO1xuICAgICAgICBjb250YWluZXIub2Zmc2V0ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoc3ludGF4TGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xuXG52YXIgcmVDb2RlRmVuY2UgPSAvXmB7Myx9KD8hLipgKXxefnszLH0vO1xudmFyIHJlSHRtbEJsb2NrT3BlbiA9IFtcbiAgICAvLi8sXG4gICAgL148KD86c2NyaXB0fHByZXxzdHlsZSkoPzpcXHN8PnwkKS9pLFxuICAgIC9ePCEtLS8sXG4gICAgL148Wz9dLyxcbiAgICAvXjwhW0EtWl0vLFxuICAgIC9ePCFcXFtDREFUQVxcWy8sXG4gICAgL148Wy9dPyg/OmFkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9ufGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEyMzQ1Nl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWV8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb258cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyfHRyYWNrfHVsKSg/Olxcc3xbL10/Wz5dfCQpL2ksXG4gICAgbmV3IFJlZ0V4cChcIl4oPzpcIiArIE9QRU5UQUcgKyBcInxcIiArIENMT1NFVEFHICsgXCIpXFxcXHMqJFwiLCAnaScpLFxuXTtcbnZhciByZVNldGV4dEhlYWRpbmdMaW5lID0gL14oPzo9K3wtKylbIFxcdF0qJC87XG52YXIgcmVBVFhIZWFkaW5nTWFya2VyID0gL14jezEsNn0oPzpbIFxcdF0rfCQpLztcbnZhciByZVRoZW1hdGljQnJlYWsgPSAvXig/Oig/OlxcKlsgXFx0XSopezMsfXwoPzpfWyBcXHRdKil7Myx9fCg/Oi1bIFxcdF0qKXszLH0pWyBcXHRdKiQvO1xudmFyIHJlQnVsbGV0TGlzdE1hcmtlciA9IC9eWyorLV0vO1xudmFyIHJlT3JkZXJlZExpc3RNYXJrZXIgPSAvXihcXGR7MSw5fSkoWy4pXSkvO1xuLy8gUGFyc2UgYSBsaXN0IG1hcmtlciBhbmQgcmV0dXJuIGRhdGEgb24gdGhlIG1hcmtlciAodHlwZSxcbi8vIHN0YXJ0LCBkZWxpbWl0ZXIsIGJ1bGxldCBjaGFyYWN0ZXIsIHBhZGRpbmcpIG9yIG51bGwuXG5mdW5jdGlvbiBwYXJzZUxpc3RNYXJrZXIocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgcmVzdCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIG5leHRjO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICB0eXBlOiAnYnVsbGV0JyxcbiAgICAgICAgdGlnaHQ6IHRydWUsXG4gICAgICAgIGJ1bGxldENoYXI6ICcnLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZGVsaW1pdGVyOiAnJyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgbWFya2VyT2Zmc2V0OiBwYXJzZXIuaW5kZW50LFxuICAgICAgICAvLyBHRk06IFRhc2sgTGlzdCBJdGVtXG4gICAgICAgIHRhc2s6IGZhbHNlLFxuICAgICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICB9O1xuICAgIGlmIChwYXJzZXIuaW5kZW50ID49IDQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSByZXN0Lm1hdGNoKHJlQnVsbGV0TGlzdE1hcmtlcikpKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICdidWxsZXQnO1xuICAgICAgICBkYXRhLmJ1bGxldENoYXIgPSBtYXRjaFswXVswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG1hdGNoID0gcmVzdC5tYXRjaChyZU9yZGVyZWRMaXN0TWFya2VyKSkgJiZcbiAgICAgICAgKGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyB8fCBtYXRjaFsxXSA9PT0gJzEnKSkge1xuICAgICAgICBkYXRhLnR5cGUgPSAnb3JkZXJlZCc7XG4gICAgICAgIGRhdGEuc3RhcnQgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICBkYXRhLmRlbGltaXRlciA9IG1hdGNoWzJdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHNwYWNlcyBhZnRlclxuICAgIG5leHRjID0gcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgIGlmICghKG5leHRjID09PSAtMSB8fCBuZXh0YyA9PT0gQ19UQUIgfHwgbmV4dGMgPT09IENfU1BBQ0UpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBpZiBpdCBpbnRlcnJ1cHRzIHBhcmFncmFwaCwgbWFrZSBzdXJlIGZpcnN0IGxpbmUgaXNuJ3QgYmxhbmtcbiAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmXG4gICAgICAgICFwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSArIG1hdGNoWzBdLmxlbmd0aCkubWF0Y2gocmVOb25TcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIHdlJ3ZlIGdvdCBhIG1hdGNoISBhZHZhbmNlIG9mZnNldCBhbmQgY2FsY3VsYXRlIHBhZGRpbmdcbiAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpOyAvLyB0byBzdGFydCBvZiBtYXJrZXJcbiAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChtYXRjaFswXS5sZW5ndGgsIHRydWUpOyAvLyB0byBlbmQgb2YgbWFya2VyXG4gICAgdmFyIHNwYWNlc1N0YXJ0Q29sID0gcGFyc2VyLmNvbHVtbjtcbiAgICB2YXIgc3BhY2VzU3RhcnRPZmZzZXQgPSBwYXJzZXIub2Zmc2V0O1xuICAgIGRvIHtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgIG5leHRjID0gcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpO1xuICAgIH0gd2hpbGUgKHBhcnNlci5jb2x1bW4gLSBzcGFjZXNTdGFydENvbCA8IDUgJiYgaXNTcGFjZU9yVGFiKG5leHRjKSk7XG4gICAgdmFyIGJsYW5rSXRlbSA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSA9PT0gLTE7XG4gICAgdmFyIHNwYWNlc0FmdGVyTWFya2VyID0gcGFyc2VyLmNvbHVtbiAtIHNwYWNlc1N0YXJ0Q29sO1xuICAgIGlmIChzcGFjZXNBZnRlck1hcmtlciA+PSA1IHx8IHNwYWNlc0FmdGVyTWFya2VyIDwgMSB8fCBibGFua0l0ZW0pIHtcbiAgICAgICAgZGF0YS5wYWRkaW5nID0gbWF0Y2hbMF0ubGVuZ3RoICsgMTtcbiAgICAgICAgcGFyc2VyLmNvbHVtbiA9IHNwYWNlc1N0YXJ0Q29sO1xuICAgICAgICBwYXJzZXIub2Zmc2V0ID0gc3BhY2VzU3RhcnRPZmZzZXQ7XG4gICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEucGFkZGluZyA9IG1hdGNoWzBdLmxlbmd0aCArIHNwYWNlc0FmdGVyTWFya2VyO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGxpc3QgaXRlbXMgYXJlIG9mIHRoZSBzYW1lIHR5cGUsXG4vLyB3aXRoIHRoZSBzYW1lIGRlbGltaXRlciBhbmQgYnVsbGV0IGNoYXJhY3Rlci4gIFRoaXMgaXMgdXNlZFxuLy8gaW4gYWdnbG9tZXJhdGluZyBsaXN0IGl0ZW1zIGludG8gbGlzdHMuXG5mdW5jdGlvbiBsaXN0c01hdGNoKGxpc3REYXRhLCBpdGVtRGF0YSkge1xuICAgIHJldHVybiAobGlzdERhdGEudHlwZSA9PT0gaXRlbURhdGEudHlwZSAmJlxuICAgICAgICBsaXN0RGF0YS5kZWxpbWl0ZXIgPT09IGl0ZW1EYXRhLmRlbGltaXRlciAmJlxuICAgICAgICBsaXN0RGF0YS5idWxsZXRDaGFyID09PSBpdGVtRGF0YS5idWxsZXRDaGFyKTtcbn1cbmZ1bmN0aW9uIGlzRGlzYWxsb3dlZERlZXBIZWFkaW5nKHBhcnNlciwgbm9kZSkge1xuICAgIHJldHVybiBwYXJzZXIub3B0aW9ucy5kaXNhbGxvd0RlZXBIZWFkaW5nICYmIChub2RlLnR5cGUgPT09ICdibG9ja1F1b3RlJyB8fCBub2RlLnR5cGUgPT09ICdpdGVtJyk7XG59XG52YXIgYmxvY2tRdW90ZSA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm5leHROb25zcGFjZSkgPT09IENfR1JFQVRFUlRIQU4pIHtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgZmFsc2UpO1xuICAgICAgICAvLyBvcHRpb25hbCBmb2xsb3dpbmcgc3BhY2VcbiAgICAgICAgaWYgKGlzU3BhY2VPclRhYihwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgcGFyc2VyLmFkZENoaWxkKCdibG9ja1F1b3RlJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHJldHVybiAxIC8qIENvbnRhaW5lciAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgYXR4SGVhZGluZyA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAvLyBUaGUgbmVzdGVkIEhlYWRpbmcgaXMgZGlzYWxsb3dlZCBpbiBsaXN0IGFuZCBibG9ja3F1b3RlIHdpdGggJ2Rpc2FsbG93RGVlcEhlYWRpbmcnIG9wdGlvblxuICAgICAgICAhaXNEaXNhbGxvd2VkRGVlcEhlYWRpbmcocGFyc2VyLCBjb250YWluZXIpICYmXG4gICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUFUWEhlYWRpbmdNYXJrZXIpKSkge1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChtYXRjaFswXS5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBoZWFkaW5nID0gcGFyc2VyLmFkZENoaWxkKCdoZWFkaW5nJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGhlYWRpbmcubGV2ZWwgPSBtYXRjaFswXS50cmltKCkubGVuZ3RoOyAvLyBudW1iZXIgb2YgI3NcbiAgICAgICAgaGVhZGluZy5oZWFkaW5nVHlwZSA9ICdhdHgnO1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgIyMjczpcbiAgICAgICAgaGVhZGluZy5zdHJpbmdDb250ZW50ID0gcGFyc2VyLmN1cnJlbnRMaW5lXG4gICAgICAgICAgICAuc2xpY2UocGFyc2VyLm9mZnNldClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eWyBcXHRdKiMrWyBcXHRdKiQvLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bIFxcdF0rIytbIFxcdF0qJC8sICcnKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBmZW5jZWRDb2RlQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUNvZGVGZW5jZSkpKSB7XG4gICAgICAgIHZhciBmZW5jZUxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBwYXJzZXIuYWRkQ2hpbGQoJ2NvZGVCbG9jaycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBjb250YWluZXIuaXNGZW5jZWQgPSB0cnVlO1xuICAgICAgICBjb250YWluZXIuZmVuY2VMZW5ndGggPSBmZW5jZUxlbmd0aDtcbiAgICAgICAgY29udGFpbmVyLmZlbmNlQ2hhciA9IG1hdGNoWzBdWzBdO1xuICAgICAgICBjb250YWluZXIuZmVuY2VPZmZzZXQgPSBwYXJzZXIuaW5kZW50O1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChmZW5jZUxlbmd0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBodG1sQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm5leHROb25zcGFjZSkgPT09IENfTEVTU1RIQU4pIHtcbiAgICAgICAgdmFyIHMgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHZhciBkaXNhbGxvd2VkVGFncyA9IHBhcnNlci5vcHRpb25zLmRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzO1xuICAgICAgICB2YXIgYmxvY2tUeXBlID0gdm9pZCAwO1xuICAgICAgICBmb3IgKGJsb2NrVHlwZSA9IDE7IGJsb2NrVHlwZSA8PSA3OyBibG9ja1R5cGUrKykge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBzLm1hdGNoKHJlSHRtbEJsb2NrT3BlbltibG9ja1R5cGVdKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrVHlwZSA9PT0gNykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNhbGxvd2VkVGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVEaXNhbGxvd2VkVGFncyA9IG5ldyBSZWdFeHAoXCI8Lz8oPzpcIiArIGRpc2FsbG93ZWRUYWdzLmpvaW4oJ3wnKSArIFwiKVwiLCAnaScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlRGlzYWxsb3dlZFRhZ3MudGVzdChtYXRjaGVkWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWRqdXN0IHBhcnNlci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgLy8gc3BhY2VzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MIGJsb2NrOlxuICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VyLmFkZENoaWxkKCdodG1sQmxvY2snLCBwYXJzZXIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBiLmh0bWxCbG9ja1R5cGUgPSBibG9ja1R5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBzZVRleHRIZWFkaW5nID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmIChjb250YWluZXIuc3RyaW5nQ29udGVudCAhPT0gbnVsbCAmJlxuICAgICAgICAhcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgIGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJyAmJlxuICAgICAgICAvLyBUaGUgbmVzdGVkIEhlYWRpbmcgaXMgZGlzYWxsb3dlZCBpbiBsaXN0IGFuZCBibG9ja3F1b3RlIHdpdGggJ2Rpc2FsbG93RGVlcEhlYWRpbmcnIG9wdGlvblxuICAgICAgICAhaXNEaXNhbGxvd2VkRGVlcEhlYWRpbmcocGFyc2VyLCBjb250YWluZXIucGFyZW50KSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVTZXRleHRIZWFkaW5nTGluZSkpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAvLyByZXNvbHZlIHJlZmVyZW5jZSBsaW5rIGRlZmluaXRpb25zXG4gICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG4gICAgICAgIHdoaWxlIChwZWVrKGNvbnRhaW5lci5zdHJpbmdDb250ZW50LCAwKSA9PT0gQ19PUEVOX0JSQUNLRVQgJiZcbiAgICAgICAgICAgIChwb3MgPSBwYXJzZXIuaW5saW5lUGFyc2VyLnBhcnNlUmVmZXJlbmNlKGNvbnRhaW5lciwgcGFyc2VyLnJlZk1hcCkpKSB7XG4gICAgICAgICAgICBjb250YWluZXIuc3RyaW5nQ29udGVudCA9IGNvbnRhaW5lci5zdHJpbmdDb250ZW50LnNsaWNlKHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lci5zdHJpbmdDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBoZWFkaW5nID0gY3JlYXRlTm9kZSQxKCdoZWFkaW5nJywgY29udGFpbmVyLnNvdXJjZXBvcyk7XG4gICAgICAgICAgICBoZWFkaW5nLmxldmVsID0gbWF0Y2hbMF1bMF0gPT09ICc9JyA/IDEgOiAyO1xuICAgICAgICAgICAgaGVhZGluZy5oZWFkaW5nVHlwZSA9ICdzZXRleHQnO1xuICAgICAgICAgICAgaGVhZGluZy5zdHJpbmdDb250ZW50ID0gY29udGFpbmVyLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWZ0ZXIoaGVhZGluZyk7XG4gICAgICAgICAgICBjb250YWluZXIudW5saW5rKCk7XG4gICAgICAgICAgICBwYXJzZXIudGlwID0gaGVhZGluZztcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIHRoZW1hdGljQnJlYWsgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcmVUaGVtYXRpY0JyZWFrLnRlc3QocGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpKSkge1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgcGFyc2VyLmFkZENoaWxkKCd0aGVtYXRpY0JyZWFrJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGxpc3RJdGVtID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIGN1cnJOb2RlID0gY29udGFpbmVyO1xuICAgIGlmICgoIXBhcnNlci5pbmRlbnRlZCB8fCBjb250YWluZXIudHlwZSA9PT0gJ2xpc3QnKSAmJlxuICAgICAgICAoZGF0YSA9IHBhcnNlTGlzdE1hcmtlcihwYXJzZXIsIGN1cnJOb2RlKSkpIHtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIC8vIGFkZCB0aGUgbGlzdCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHBhcnNlci50aXAudHlwZSAhPT0gJ2xpc3QnIHx8ICFsaXN0c01hdGNoKGN1cnJOb2RlLmxpc3REYXRhLCBkYXRhKSkge1xuICAgICAgICAgICAgY3Vyck5vZGUgPSBwYXJzZXIuYWRkQ2hpbGQoJ2xpc3QnLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgICAgIGN1cnJOb2RlLmxpc3REYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGxpc3QgaXRlbVxuICAgICAgICBjdXJyTm9kZSA9IHBhcnNlci5hZGRDaGlsZCgnaXRlbScsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBjdXJyTm9kZS5saXN0RGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiAxIC8qIENvbnRhaW5lciAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG4vLyBpbmRlbnRlZCBjb2RlIGJsb2NrXG52YXIgaW5kZW50ZWRDb2RlQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgaWYgKHBhcnNlci5pbmRlbnRlZCAmJiBwYXJzZXIudGlwLnR5cGUgIT09ICdwYXJhZ3JhcGgnICYmICFwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgLy8gaW5kZW50ZWQgY29kZVxuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChDT0RFX0lOREVOVCwgdHJ1ZSk7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICBwYXJzZXIuYWRkQ2hpbGQoJ2NvZGVCbG9jaycsIHBhcnNlci5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBibG9ja1N0YXJ0cyA9IFtcbiAgICBibG9ja1F1b3RlLFxuICAgIGF0eEhlYWRpbmcsXG4gICAgZmVuY2VkQ29kZUJsb2NrLFxuICAgIGh0bWxCbG9jayxcbiAgICBzZVRleHRIZWFkaW5nLFxuICAgIHRoZW1hdGljQnJlYWssXG4gICAgbGlzdEl0ZW0sXG4gICAgaW5kZW50ZWRDb2RlQmxvY2ssXG4gICAgdGFibGVIZWFkLFxuICAgIHRhYmxlQm9keSxcbiAgICBjdXN0b21CbG9jayxcbl07XG5cbi8vIGAtLS1gIGZvciBZQU1MLCBgKysrYCBmb3IgVE9NTCwgYDs7O2AgZm9yIEpTT05cbnZhciByZUZyb250TWF0dGVyID0gL14oLXszfXxcXCt7M318O3szfSkkLztcbnZhciBmcm9udE1hdHRlciQxID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIGN1cnJlbnRMaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lLCBsaW5lTnVtYmVyID0gcGFyc2VyLmxpbmVOdW1iZXIsIGluZGVudGVkID0gcGFyc2VyLmluZGVudGVkO1xuICAgIGlmIChsaW5lTnVtYmVyID09PSAxICYmXG4gICAgICAgICFpbmRlbnRlZCAmJlxuICAgICAgICBjb250YWluZXIudHlwZSA9PT0gJ2RvY3VtZW50JyAmJlxuICAgICAgICByZUZyb250TWF0dGVyLnRlc3QoY3VycmVudExpbmUpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgZnJvbnRNYXR0ZXJfMSA9IHBhcnNlci5hZGRDaGlsZCgnZnJvbnRNYXR0ZXInLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgZnJvbnRNYXR0ZXJfMS5zdHJpbmdDb250ZW50ID0gY3VycmVudExpbmU7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGN1cnJlbnRMaW5lLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcblxudmFyIGZyb250TWF0dGVyID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBwYXJzZXIuY3VycmVudExpbmU7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmUubWF0Y2gocmVGcm9udE1hdHRlcik7XG4gICAgICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ2Zyb250TWF0dGVyJyAmJiBtYXRjaCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgKz0gbGluZTtcbiAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiAyIC8qIEZpbmlzaGVkICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmxpdGVyYWwgPSBibG9jay5zdHJpbmdDb250ZW50O1xuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcblxudmFyIHJlSHRtbEJsb2NrQ2xvc2UgPSBbXG4gICAgLy4vLFxuICAgIC88XFwvKD86c2NyaXB0fHByZXxzdHlsZSk+L2ksXG4gICAgLy0tPi8sXG4gICAgL1xcPz4vLFxuICAgIC8+LyxcbiAgICAvXFxdXFxdPi8sXG5dO1xudmFyIHJlTWF5YmVTcGVjaWFsID0gL15bI2B+KitfPTw+MC05LTskXS87XG52YXIgcmVMaW5lRW5kaW5nJDEgPSAvXFxyXFxufFxcbnxcXHIvO1xuZnVuY3Rpb24gZG9jdW1lbnQkMigpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZSQxKCdkb2N1bWVudCcsIFtcbiAgICAgICAgWzEsIDFdLFxuICAgICAgICBbMCwgMF0sXG4gICAgXSk7XG59XG52YXIgZGVmYXVsdE9wdGlvbnMkMSA9IHtcbiAgICBzbWFydDogZmFsc2UsXG4gICAgdGFnRmlsdGVyOiBmYWxzZSxcbiAgICBleHRlbmRlZEF1dG9saW5rczogZmFsc2UsXG4gICAgZGlzYWxsb3dlZEh0bWxCbG9ja1RhZ3M6IFtdLFxuICAgIHJlZmVyZW5jZURlZmluaXRpb246IGZhbHNlLFxuICAgIGRpc2FsbG93RGVlcEhlYWRpbmc6IGZhbHNlLFxuICAgIGN1c3RvbVBhcnNlcjogbnVsbCxcbiAgICBmcm9udE1hdHRlcjogZmFsc2UsXG59O1xudmFyIFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMkMSksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvYyA9IGRvY3VtZW50JDIoKTtcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5vbGR0aXAgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMubmV4dE5vbnNwYWNlID0gMDtcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSAnJztcbiAgICAgICAgdGhpcy5pbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsYW5rID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGxDbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMucmVmTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5saW5lcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZyb250TWF0dGVyKSB7XG4gICAgICAgICAgICBibG9ja0hhbmRsZXJzLmZyb250TWF0dGVyID0gZnJvbnRNYXR0ZXI7XG4gICAgICAgICAgICBibG9ja1N0YXJ0cy51bnNoaWZ0KGZyb250TWF0dGVyJDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyID0gbmV3IElubGluZVBhcnNlcih0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBQYXJzZXIucHJvdG90eXBlLmFkdmFuY2VPZmZzZXQgPSBmdW5jdGlvbiAoY291bnQsIGNvbHVtbnMpIHtcbiAgICAgICAgaWYgKGNvbHVtbnMgPT09IHZvaWQgMCkgeyBjb2x1bW5zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gdGhpcy5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIGNoYXJzVG9UYWIsIGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKGNvdW50ID4gMCAmJiAoYyA9IGN1cnJlbnRMaW5lW3RoaXMub2Zmc2V0XSkpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIGNoYXJzVG9UYWIgPSA0IC0gKHRoaXMuY29sdW1uICUgNCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGNoYXJzVG9UYWIgPiBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNUb0FkdmFuY2UgPSBjaGFyc1RvVGFiID4gY291bnQgPyBjb3VudCA6IGNoYXJzVG9UYWI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBjaGFyc1RvVGFiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IDE7IC8vIGFzc3VtZSBhc2NpaTsgYmxvY2sgc3RhcnRzIGFyZSBhc2NpaVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuYWR2YW5jZU5leHROb25zcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLm5leHROb25zcGFjZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSB0aGlzLm5leHROb25zcGFjZUNvbHVtbjtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5maW5kTmV4dE5vbnNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudExpbmUgPSB0aGlzLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgaSA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgY29scyA9IHRoaXMuY29sdW1uO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKChjID0gY3VycmVudExpbmUuY2hhckF0KGkpKSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29scysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29scyArPSA0IC0gKGNvbHMgJSA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmxhbmsgPSBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJyB8fCBjID09PSAnJztcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2UgPSBpO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZUNvbHVtbiA9IGNvbHM7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW4gLSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdGhpcy5pbmRlbnRlZCA9IHRoaXMuaW5kZW50ID49IENPREVfSU5ERU5UO1xuICAgIH07XG4gICAgLy8gQWRkIGEgbGluZSB0byB0aGUgYmxvY2sgYXQgdGhlIHRpcC4gIFdlIGFzc3VtZSB0aGUgdGlwXG4gICAgLy8gY2FuIGFjY2VwdCBsaW5lcyAtLSB0aGF0IGNoZWNrIHNob3VsZCBiZSBkb25lIGJlZm9yZSBjYWxsaW5nIHRoaXMuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5hZGRMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYikge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMTsgLy8gc2tpcCBvdmVyIHRhYlxuICAgICAgICAgICAgLy8gYWRkIHNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICAgICAgICB2YXIgY2hhcnNUb1RhYiA9IDQgLSAodGhpcy5jb2x1bW4gJSA0KTtcbiAgICAgICAgICAgIHRoaXMudGlwLnN0cmluZ0NvbnRlbnQgKz0gcmVwZWF0KCcgJywgY2hhcnNUb1RhYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGlwLmxpbmVPZmZzZXRzKSB7XG4gICAgICAgICAgICB0aGlzLnRpcC5saW5lT2Zmc2V0cy5wdXNoKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGlwLmxpbmVPZmZzZXRzID0gW3RoaXMub2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpcC5zdHJpbmdDb250ZW50ICs9IHRoaXMuY3VycmVudExpbmUuc2xpY2UodGhpcy5vZmZzZXQpICsgXCJcXG5cIjtcbiAgICB9O1xuICAgIC8vIEFkZCBibG9jayBvZiB0eXBlIHRhZyBhcyBhIGNoaWxkIG9mIHRoZSB0aXAuICBJZiB0aGUgdGlwIGNhbid0XG4gICAgLy8gYWNjZXB0IGNoaWxkcmVuLCBjbG9zZSBhbmQgZmluYWxpemUgaXQgYW5kIHRyeSBpdHMgcGFyZW50LFxuICAgIC8vIGFuZCBzbyBvbiB0aWwgd2UgZmluZCBhIGJsb2NrIHRoYXQgY2FuIGFjY2VwdCBjaGlsZHJlbi5cbiAgICBQYXJzZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKHRhZywgb2Zmc2V0KSB7XG4gICAgICAgIHdoaWxlICghYmxvY2tIYW5kbGVyc1t0aGlzLnRpcC50eXBlXS5jYW5Db250YWluKHRhZykpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUodGhpcy50aXAsIHRoaXMubGluZU51bWJlciAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBvZmZzZXQgKyAxOyAvLyBvZmZzZXQgMCA9IGNvbHVtbiAxXG4gICAgICAgIHZhciBuZXdCbG9jayA9IGNyZWF0ZU5vZGUkMSh0YWcsIFtcbiAgICAgICAgICAgIFt0aGlzLmxpbmVOdW1iZXIsIGNvbHVtbk51bWJlcl0sXG4gICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgIF0pO1xuICAgICAgICBuZXdCbG9jay5zdHJpbmdDb250ZW50ID0gJyc7XG4gICAgICAgIHRoaXMudGlwLmFwcGVuZENoaWxkKG5ld0Jsb2NrKTtcbiAgICAgICAgdGhpcy50aXAgPSBuZXdCbG9jaztcbiAgICAgICAgcmV0dXJuIG5ld0Jsb2NrO1xuICAgIH07XG4gICAgLy8gRmluYWxpemUgYW5kIGNsb3NlIGFueSB1bm1hdGNoZWQgYmxvY2tzLlxuICAgIFBhcnNlci5wcm90b3R5cGUuY2xvc2VVbm1hdGNoZWRCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxDbG9zZWQpIHtcbiAgICAgICAgICAgIC8vIGZpbmFsaXplIGFueSBibG9ja3Mgbm90IG1hdGNoZWRcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLm9sZHRpcCAhPT0gdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMub2xkdGlwLnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMub2xkdGlwLCB0aGlzLmxpbmVOdW1iZXIgLSAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZHRpcCA9IHBhcmVudF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbGxDbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBGaW5hbGl6ZSBhIGJsb2NrLiAgQ2xvc2UgaXQgYW5kIGRvIGFueSBuZWNlc3NhcnkgcG9zdHByb2Nlc3NpbmcsXG4gICAgLy8gZS5nLiBjcmVhdGluZyBzdHJpbmdDb250ZW50IGZyb20gc3RyaW5ncywgc2V0dGluZyB0aGUgJ3RpZ2h0J1xuICAgIC8vIG9yICdsb29zZScgc3RhdHVzIG9mIGEgbGlzdCwgYW5kIHBhcnNpbmcgdGhlIGJlZ2lubmluZ3NcbiAgICAvLyBvZiBwYXJhZ3JhcGhzIGZvciByZWZlcmVuY2UgZGVmaW5pdGlvbnMuICBSZXNldCB0aGUgdGlwIHRvIHRoZVxuICAgIC8vIHBhcmVudCBvZiB0aGUgY2xvc2VkIGJsb2NrLlxuICAgIFBhcnNlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoYmxvY2ssIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdmFyIGFib3ZlID0gYmxvY2sucGFyZW50O1xuICAgICAgICBibG9jay5vcGVuID0gZmFsc2U7XG4gICAgICAgIGJsb2NrLnNvdXJjZXBvc1sxXSA9IFtsaW5lTnVtYmVyLCB0aGlzLmxhc3RMaW5lTGVuZ3RoXTtcbiAgICAgICAgYmxvY2tIYW5kbGVyc1tibG9jay50eXBlXS5maW5hbGl6ZSh0aGlzLCBibG9jayk7XG4gICAgICAgIHRoaXMudGlwID0gYWJvdmU7XG4gICAgfTtcbiAgICAvLyBXYWxrIHRocm91Z2ggYSBibG9jayAmIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LCBwYXJzaW5nIHN0cmluZyBjb250ZW50XG4gICAgLy8gaW50byBpbmxpbmUgY29udGVudCB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICBQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NJbmxpbmVzID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgdmFyIGN1c3RvbVBhcnNlciA9IHRoaXMub3B0aW9ucy5jdXN0b21QYXJzZXI7XG4gICAgICAgIHZhciB3YWxrZXIgPSBibG9jay53YWxrZXIoKTtcbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIucmVmTWFwID0gdGhpcy5yZWZNYXA7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXA7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgICAgIHZhciB0ID0gbm9kZS50eXBlO1xuICAgICAgICAgICAgaWYgKGN1c3RvbVBhcnNlciAmJiBjdXN0b21QYXJzZXJbdF0pIHtcbiAgICAgICAgICAgICAgICBjdXN0b21QYXJzZXJbdF0obm9kZSwgeyBlbnRlcmluZzogZW50ZXJpbmcsIG9wdGlvbnM6IHRoaXMub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZW50ZXJpbmcgJiZcbiAgICAgICAgICAgICAgICAodCA9PT0gJ3BhcmFncmFwaCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdCA9PT0gJ2hlYWRpbmcnIHx8XG4gICAgICAgICAgICAgICAgICAgICh0ID09PSAndGFibGVDZWxsJyAmJiAhbm9kZS5pZ25vcmVkKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZVBhcnNlci5wYXJzZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQW5hbHl6ZSBhIGxpbmUgb2YgdGV4dCBhbmQgdXBkYXRlIHRoZSBkb2N1bWVudCBhcHByb3ByaWF0ZWx5LlxuICAgIC8vIFdlIHBhcnNlIG1hcmtkb3duIHRleHQgYnkgY2FsbGluZyB0aGlzIG9uIGVhY2ggbGluZSBvZiBpbnB1dCxcbiAgICAvLyB0aGVuIGZpbmFsaXppbmcgdGhlIGRvY3VtZW50LlxuICAgIFBhcnNlci5wcm90b3R5cGUuaW5jb3Jwb3JhdGVMaW5lID0gZnVuY3Rpb24gKGxuKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5vbGR0aXAgPSB0aGlzLnRpcDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMuYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgKz0gMTtcbiAgICAgICAgLy8gcmVwbGFjZSBOVUwgY2hhcmFjdGVycyBmb3Igc2VjdXJpdHlcbiAgICAgICAgaWYgKGxuLmluZGV4T2YoJ1xcdTAwMDAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxuID0gbG4ucmVwbGFjZSgvXFwwL2csICdcXHVGRkZEJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IGxuO1xuICAgICAgICAvLyBGb3IgZWFjaCBjb250YWluaW5nIGJsb2NrLCB0cnkgdG8gcGFyc2UgdGhlIGFzc29jaWF0ZWQgbGluZSBzdGFydC5cbiAgICAgICAgLy8gQmFpbCBvdXQgb24gZmFpbHVyZTogY29udGFpbmVyIHdpbGwgcG9pbnQgdG8gdGhlIGxhc3QgbWF0Y2hpbmcgYmxvY2suXG4gICAgICAgIC8vIFNldCBhbGxNYXRjaGVkIHRvIGZhbHNlIGlmIG5vdCBhbGwgY29udGFpbmVycyBtYXRjaC5cbiAgICAgICAgdmFyIGFsbE1hdGNoZWQgPSB0cnVlO1xuICAgICAgICB2YXIgbGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAoKGxhc3RDaGlsZCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpICYmIGxhc3RDaGlsZC5vcGVuKSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZpbmROZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoYmxvY2tIYW5kbGVyc1tjb250YWluZXIudHlwZV1bJ2NvbnRpbnVlJ10odGhpcywgY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBHbyAqLzogLy8gd2UndmUgbWF0Y2hlZCwga2VlcCBnb2luZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogU3RvcCAqLzogLy8gd2UndmUgZmFpbGVkIHRvIG1hdGNoIGEgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgYWxsTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogRmluaXNoZWQgKi86IC8vIHdlJ3ZlIGhpdCBlbmQgb2YgbGluZSBmb3IgZmVuY2VkIGNvZGUgY2xvc2UgYW5kIGNhbiByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IGxuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGludWUgcmV0dXJuZWQgaWxsZWdhbCB2YWx1ZSwgbXVzdCBiZSAwLCAxLCBvciAyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbE1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50OyAvLyBiYWNrIHVwIHRvIGxhc3QgbWF0Y2hpbmcgYmxvY2tcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbENsb3NlZCA9IGNvbnRhaW5lciA9PT0gdGhpcy5vbGR0aXA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHZhciBtYXRjaGVkTGVhZiA9IGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyAmJiBibG9ja0hhbmRsZXJzW2NvbnRhaW5lci50eXBlXS5hY2NlcHRzTGluZXM7XG4gICAgICAgIHZhciBibG9ja1N0YXJ0c0xlbiA9IGJsb2NrU3RhcnRzLmxlbmd0aDtcbiAgICAgICAgLy8gVW5sZXNzIGxhc3QgbWF0Y2hlZCBjb250YWluZXIgaXMgYSBjb2RlIGJsb2NrLCB0cnkgbmV3IGNvbnRhaW5lciBzdGFydHMsXG4gICAgICAgIC8vIGFkZGluZyBjaGlsZHJlbiB0byB0aGUgbGFzdCBtYXRjaGVkIGNvbnRhaW5lcjpcbiAgICAgICAgd2hpbGUgKCFtYXRjaGVkTGVhZikge1xuICAgICAgICAgICAgdGhpcy5maW5kTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgbGl0dGxlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjpcbiAgICAgICAgICAgIGlmIChjb250YWluZXIudHlwZSAhPT0gJ3RhYmxlJyAmJlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci50eXBlICE9PSAndGFibGVCb2R5JyAmJlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmluZGVudGVkICYmXG4gICAgICAgICAgICAgICAgIXJlTWF5YmVTcGVjaWFsLnRlc3QobG4uc2xpY2UodGhpcy5uZXh0Tm9uc3BhY2UpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBibG9ja1N0YXJ0c0xlbikge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBibG9ja1N0YXJ0c1tpXSh0aGlzLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IDEgLyogQ29udGFpbmVyICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMudGlwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzID09PSAyIC8qIExlYWYgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy50aXA7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRMZWFmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IGJsb2NrU3RhcnRzTGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyBtYXRjaGVkXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hhdCByZW1haW5zIGF0IHRoZSBvZmZzZXQgaXMgYSB0ZXh0IGxpbmUuICBBZGQgdGhlIHRleHQgdG8gdGhlXG4gICAgICAgIC8vIGFwcHJvcHJpYXRlIGNvbnRhaW5lci5cbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgZm9yIGEgbGF6eSBwYXJhZ3JhcGggY29udGludWF0aW9uOlxuICAgICAgICBpZiAoIXRoaXMuYWxsQ2xvc2VkICYmICF0aGlzLmJsYW5rICYmIHRoaXMudGlwLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAvLyBsYXp5IHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAgICAgICAgIHRoaXMuYWRkTGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IGEgbGF6eSBjb250aW51YXRpb25cbiAgICAgICAgICAgIC8vIGZpbmFsaXplIGFueSBibG9ja3Mgbm90IG1hdGNoZWRcbiAgICAgICAgICAgIHRoaXMuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJsYW5rICYmIGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIubGFzdENoaWxkLmxhc3RMaW5lQmxhbmsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSBjb250YWluZXIudHlwZTtcbiAgICAgICAgICAgIC8vIEJsb2NrIHF1b3RlIGxpbmVzIGFyZSBuZXZlciBibGFuayBhcyB0aGV5IHN0YXJ0IHdpdGggPlxuICAgICAgICAgICAgLy8gYW5kIHdlIGRvbid0IGNvdW50IGJsYW5rcyBpbiBmZW5jZWQgY29kZSBmb3IgcHVycG9zZXMgb2YgdGlnaHQvbG9vc2VcbiAgICAgICAgICAgIC8vIGxpc3RzIG9yIGJyZWFraW5nIG91dCBvZiBsaXN0cy4gV2UgYWxzbyBkb24ndCBzZXQgX2xhc3RMaW5lQmxhbmtcbiAgICAgICAgICAgIC8vIG9uIGFuIGVtcHR5IGxpc3QgaXRlbSwgb3IgaWYgd2UganVzdCBjbG9zZWQgYSBmZW5jZWQgYmxvY2suXG4gICAgICAgICAgICB2YXIgbGFzdExpbmVCbGFuayA9IHRoaXMuYmxhbmsgJiZcbiAgICAgICAgICAgICAgICAhKHQgPT09ICdibG9ja1F1b3RlJyB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNDb2RlQmxvY2soY29udGFpbmVyKSAmJiBjb250YWluZXIuaXNGZW5jZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0ID09PSAnaXRlbScgJiYgIWNvbnRhaW5lci5maXJzdENoaWxkICYmIGNvbnRhaW5lci5zb3VyY2Vwb3NbMF1bMF0gPT09IHRoaXMubGluZU51bWJlcikpO1xuICAgICAgICAgICAgLy8gcHJvcGFnYXRlIGxhc3RMaW5lQmxhbmsgdXAgdGhyb3VnaCBwYXJlbnRzOlxuICAgICAgICAgICAgdmFyIGNvbnQgPSBjb250YWluZXI7XG4gICAgICAgICAgICB3aGlsZSAoY29udCkge1xuICAgICAgICAgICAgICAgIGNvbnQubGFzdExpbmVCbGFuayA9IGxhc3RMaW5lQmxhbms7XG4gICAgICAgICAgICAgICAgY29udCA9IGNvbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFuZGxlcnNbdF0uYWNjZXB0c0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaW5lKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgSHRtbEJsb2NrLCBjaGVjayBmb3IgZW5kIGNvbmRpdGlvblxuICAgICAgICAgICAgICAgIGlmIChpc0h0bWxCbG9jayhjb250YWluZXIpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5odG1sQmxvY2tUeXBlID49IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmh0bWxCbG9ja1R5cGUgPD0gNSAmJlxuICAgICAgICAgICAgICAgICAgICByZUh0bWxCbG9ja0Nsb3NlW2NvbnRhaW5lci5odG1sQmxvY2tUeXBlXS50ZXN0KHRoaXMuY3VycmVudExpbmUuc2xpY2UodGhpcy5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gbG4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKGNvbnRhaW5lciwgdGhpcy5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9mZnNldCA8IGxuLmxlbmd0aCAmJiAhdGhpcy5ibGFuaykge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBwYXJhZ3JhcGggY29udGFpbmVyIGZvciBsaW5lXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5hZGRDaGlsZCgncGFyYWdyYXBoJywgdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSBsbi5sZW5ndGg7XG4gICAgfTtcbiAgICAvLyBUaGUgbWFpbiBwYXJzaW5nIGZ1bmN0aW9uLiAgUmV0dXJucyBhIHBhcnNlZCBkb2N1bWVudCBBU1QuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChpbnB1dCwgbGluZVRleHRzKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jdW1lbnQkMigpO1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB2YXIgbGluZXMgPSBpbnB1dC5zcGxpdChyZUxpbmVFbmRpbmckMSk7XG4gICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lVGV4dHMgPyBsaW5lVGV4dHMgOiBsaW5lcztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyUmVmTWFwcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpID09PSBDX05FV0xJTkUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBsYXN0IGJsYW5rIGxpbmUgY3JlYXRlZCBieSBmaW5hbCBuZXdsaW5lXG4gICAgICAgICAgICBsZW4gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluY29ycG9yYXRlTGluZShsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMudGlwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMudGlwLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc0lubGluZXModGhpcy5kb2MpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2M7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnRpYWxQYXJzZVN0YXJ0ID0gZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGxpbmVzKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jdW1lbnQkMigpO1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSAnJztcbiAgICAgICAgdmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbmNvcnBvcmF0ZUxpbmUobGluZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRvYztcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFydGlhbFBhcnNlRXh0ZW5kcyA9IGZ1bmN0aW9uIChsaW5lcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluY29ycG9yYXRlTGluZShsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFydGlhbFBhcnNlRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy50aXApIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUodGhpcy50aXAsIHRoaXMubGluZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzSW5saW5lcyh0aGlzLmRvYyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnNldFJlZk1hcHMgPSBmdW5jdGlvbiAocmVmTWFwLCByZWZMaW5rQ2FuZGlkYXRlTWFwLCByZWZEZWZDYW5kaWRhdGVNYXApIHtcbiAgICAgICAgdGhpcy5yZWZNYXAgPSByZWZNYXA7XG4gICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCA9IHJlZkxpbmtDYW5kaWRhdGVNYXA7XG4gICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwID0gcmVmRGVmQ2FuZGlkYXRlTWFwO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5jbGVhclJlZk1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFt0aGlzLnJlZk1hcCwgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcF0uZm9yRWFjaChmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBjbGVhck9iaihtYXApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xuXG5mdW5jdGlvbiBjb21wYXJlUG9zKHAxLCBwMikge1xuICAgIGlmIChwMVswXSA8IHAyWzBdKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAocDFbMF0gPiBwMlswXSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIGlmIChwMVsxXSA8IHAyWzFdKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAocDFbMV0gPiBwMlsxXSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEVRICovO1xufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlQW5kUG9zKF9hLCBwb3MpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBfYVswXSwgZW5kUG9zID0gX2FbMV07XG4gICAgaWYgKGNvbXBhcmVQb3MoZW5kUG9zLCBwb3MpID09PSAxIC8qIExUICovKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZVBvcyhzdGFydFBvcywgcG9zKSA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBFUSAqLztcbn1cbmZ1bmN0aW9uIHJlbW92ZU5leHRVbnRpbChub2RlLCBsYXN0KSB7XG4gICAgaWYgKG5vZGUucGFyZW50ICE9PSBsYXN0LnBhcmVudCB8fCBub2RlID09PSBsYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBub2RlLm5leHQ7XG4gICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPT0gbGFzdCkge1xuICAgICAgICB2YXIgdGVtcCA9IG5leHQubmV4dDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFsncGFyZW50JywgJ3ByZXYnLCAnbmV4dCddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAobmV4dFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGVCeUlkKG5leHRbdHlwZV0uaWQpO1xuICAgICAgICAgICAgICAgIG5leHRbdHlwZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQgPSB0ZW1wO1xuICAgIH1cbiAgICBub2RlLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgaWYgKGxhc3QubmV4dCkge1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnBhcmVudC5sYXN0Q2hpbGQgPSBub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkTm9kZXMocGFyZW50KSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIGN1cnIgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY3Vycikge1xuICAgICAgICBub2Rlcy5wdXNoKGN1cnIpO1xuICAgICAgICBjdXJyID0gY3Vyci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBpbnNlcnROb2Rlc0JlZm9yZSh0YXJnZXQsIG5vZGVzKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBub2Rlc18xID0gbm9kZXM7IF9pIDwgbm9kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc18xW19pXTtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVwZW5kQ2hpbGROb2RlcyhwYXJlbnQsIG5vZGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHBhcmVudC5wcmVwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZU5leHRMaW5lTnVtYmVycyhiYXNlLCBkaWZmKSB7XG4gICAgaWYgKCFiYXNlIHx8ICFiYXNlLnBhcmVudCB8fCBkaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHdhbGtlciA9IGJhc2UucGFyZW50LndhbGtlcigpO1xuICAgIHdhbGtlci5yZXN1bWVBdChiYXNlLCB0cnVlKTtcbiAgICB2YXIgZXZlbnQ7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBub2RlLnNvdXJjZXBvc1swXVswXSArPSBkaWZmO1xuICAgICAgICAgICAgbm9kZS5zb3VyY2Vwb3NbMV1bMF0gKz0gZGlmZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZUFuZExpbmUoX2EsIGxpbmUpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBfYVswXSwgZW5kUG9zID0gX2FbMV07XG4gICAgaWYgKGVuZFBvc1swXSA8IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChzdGFydFBvc1swXSA+IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBFUSAqLztcbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZE5vZGVBdExpbmUocGFyZW50LCBsaW5lKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmVSYW5nZUFuZExpbmUobm9kZS5zb3VyY2Vwb3MsIGxpbmUpO1xuICAgICAgICBpZiAoY29tcCA9PT0gMCAvKiBFUSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgICAgICAvLyBUbyBjb25zaWRlciB0aGF0IHRvcCBsaW5lIGlzIGJsYW5rIGxpbmVcbiAgICAgICAgICAgIHJldHVybiBub2RlLnByZXYgfHwgbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Lmxhc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGxhc3RMZWFmTm9kZShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzYW1lTGluZVRvcEFuY2VzdG9yKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5wYXJlbnQgJiZcbiAgICAgICAgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2RvY3VtZW50JyAmJlxuICAgICAgICBub2RlLnBhcmVudC5zb3VyY2Vwb3NbMF1bMF0gPT09IG5vZGUuc291cmNlcG9zWzBdWzBdKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5kRmlyc3ROb2RlQXRMaW5lKHBhcmVudCwgbGluZSkge1xuICAgIHZhciBub2RlID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcGFyZVJhbmdlQW5kTGluZShub2RlLnNvdXJjZXBvcywgbGluZSk7XG4gICAgICAgIGlmIChjb21wID09PSAwIC8qIEVRICovKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5zb3VyY2Vwb3NbMF1bMF0gPT09IGxpbmUgfHwgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXAgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldikge1xuICAgICAgICByZXR1cm4gc2FtZUxpbmVUb3BBbmNlc3RvcihsYXN0TGVhZk5vZGUocHJldikpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlQXRQb3NpdGlvbihwYXJlbnQsIHBvcykge1xuICAgIHZhciBub2RlID0gcGFyZW50O1xuICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmVSYW5nZUFuZFBvcyhub2RlLnNvdXJjZXBvcywgcG9zKTtcbiAgICAgICAgaWYgKGNvbXAgPT09IDAgLyogRVEgKi8pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcCA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubmV4dCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZmluZE5vZGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGdldE5vZGVCeUlkKGlkKSB8fCBudWxsO1xufVxuZnVuY3Rpb24gaW52b2tlTmV4dFVudGlsKGNhbGxiYWNrLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IG51bGw7IH1cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIHdhbGtlciA9IHN0YXJ0LndhbGtlcigpO1xuICAgICAgICB3aGlsZSAoc3RhcnQgJiYgc3RhcnQgIT09IGVuZCkge1xuICAgICAgICAgICAgY2FsbGJhY2soc3RhcnQpO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IG5leHQubm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNVbmxpbmtlZChpZCkge1xuICAgIHZhciBub2RlID0gZmluZE5vZGVCeUlkKGlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG5vZGUudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgIGlmICghbm9kZS5wYXJlbnQgJiYgIW5vZGUucHJldiAmJiAhbm9kZS5uZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHJlTGluZUVuZGluZyA9IC9cXHJcXG58XFxufFxcci87XG5mdW5jdGlvbiBjYW5CZUNvbnRpbnVlZExpc3RJdGVtKGxpbmVUZXh0KSB7XG4gICAgdmFyIHNwYWNlTWF0Y2ggPSBsaW5lVGV4dC5tYXRjaCgvXlsgXFx0XSsvKTtcbiAgICBpZiAoc3BhY2VNYXRjaCAmJiAoc3BhY2VNYXRjaFswXS5sZW5ndGggPj0gMiB8fCAvXFx0Ly50ZXN0KHNwYWNlTWF0Y2hbMF0pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxlZnRUcmltbWVkID0gc3BhY2VNYXRjaCA/IGxpbmVUZXh0LnNsaWNlKHNwYWNlTWF0Y2gubGVuZ3RoKSA6IGxpbmVUZXh0O1xuICAgIHJldHVybiByZUJ1bGxldExpc3RNYXJrZXIudGVzdChsZWZ0VHJpbW1lZCkgfHwgcmVPcmRlcmVkTGlzdE1hcmtlci50ZXN0KGxlZnRUcmltbWVkKTtcbn1cbmZ1bmN0aW9uIGNhbkJlQ29udGludWVkVGFibGVCb2R5KGxpbmVUZXh0KSB7XG4gICAgcmV0dXJuICFpc0JsYW5rKGxpbmVUZXh0KSAmJiBsaW5lVGV4dC5pbmRleE9mKCd8JykgIT09IC0xO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmRGVmU3RhdGUobm9kZSkge1xuICAgIHZhciBpZCA9IG5vZGUuaWQsIHRpdGxlID0gbm9kZS50aXRsZSwgc291cmNlcG9zID0gbm9kZS5zb3VyY2Vwb3MsIGRlc3QgPSBub2RlLmRlc3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIHNvdXJjZXBvczogc291cmNlcG9zLFxuICAgICAgICB1bmxpbmtlZDogZmFsc2UsXG4gICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0LFxuICAgIH07XG59XG52YXIgVG9hc3RNYXJrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0TWFyayhjb250ZW50cywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uID0gISEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGFyc2VyLnNldFJlZk1hcHModGhpcy5yZWZNYXAsIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcCA9IHsgY2hhbmdlOiBbXSB9O1xuICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzIHx8ICcnO1xuICAgICAgICB0aGlzLmxpbmVUZXh0cyA9IGNvbnRlbnRzLnNwbGl0KHJlTGluZUVuZGluZyk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucGFyc2VyLnBhcnNlKGNvbnRlbnRzLCB0aGlzLmxpbmVUZXh0cyk7XG4gICAgfVxuICAgIFRvYXN0TWFyay5wcm90b3R5cGUudXBkYXRlTGluZVRleHRzID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBlbmRQb3MsIG5ld1RleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgc3RhcnRMaW5lID0gc3RhcnRQb3NbMF0sIHN0YXJ0Q29sID0gc3RhcnRQb3NbMV07XG4gICAgICAgIHZhciBlbmRMaW5lID0gZW5kUG9zWzBdLCBlbmRDb2wgPSBlbmRQb3NbMV07XG4gICAgICAgIHZhciBuZXdMaW5lcyA9IG5ld1RleHQuc3BsaXQocmVMaW5lRW5kaW5nKTtcbiAgICAgICAgdmFyIG5ld0xpbmVMZW4gPSBuZXdMaW5lcy5sZW5ndGg7XG4gICAgICAgIHZhciBzdGFydExpbmVUZXh0ID0gdGhpcy5saW5lVGV4dHNbc3RhcnRMaW5lIC0gMV07XG4gICAgICAgIHZhciBlbmRMaW5lVGV4dCA9IHRoaXMubGluZVRleHRzW2VuZExpbmUgLSAxXTtcbiAgICAgICAgbmV3TGluZXNbMF0gPSBzdGFydExpbmVUZXh0LnNsaWNlKDAsIHN0YXJ0Q29sIC0gMSkgKyBuZXdMaW5lc1swXTtcbiAgICAgICAgbmV3TGluZXNbbmV3TGluZUxlbiAtIDFdID0gbmV3TGluZXNbbmV3TGluZUxlbiAtIDFdICsgZW5kTGluZVRleHQuc2xpY2UoZW5kQ29sIC0gMSk7XG4gICAgICAgIHZhciByZW1vdmVkTGluZUxlbiA9IGVuZExpbmUgLSBzdGFydExpbmUgKyAxO1xuICAgICAgICAoX2EgPSB0aGlzLmxpbmVUZXh0cykuc3BsaWNlLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFtzdGFydExpbmUgLSAxLCByZW1vdmVkTGluZUxlbl0sIG5ld0xpbmVzKSk7XG4gICAgICAgIHJldHVybiBuZXdMaW5lTGVuIC0gcmVtb3ZlZExpbmVMZW47XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnVwZGF0ZVJvb3ROb2RlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVUZXh0cy5sZW5ndGggPT09IDEgJiYgdGhpcy5saW5lVGV4dHNbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QubGFzdExpbmVCbGFuayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJvb3Quc291cmNlcG9zID0gW1xuICAgICAgICAgICAgICAgIFsxLCAxXSxcbiAgICAgICAgICAgICAgICBbMSwgMF0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvb3QubGFzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QubGFzdExpbmVCbGFuayA9IHRoaXMucm9vdC5sYXN0Q2hpbGQubGFzdExpbmVCbGFuaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZVRleHRzID0gdGhpcy5saW5lVGV4dHM7XG4gICAgICAgIHZhciBpZHggPSBsaW5lVGV4dHMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGxpbmVUZXh0c1tpZHhdID09PSAnJykge1xuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVUZXh0cy5sZW5ndGggLSAyID4gaWR4KSB7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3Quc291cmNlcG9zWzFdID0gW2lkeCArIDEsIGxpbmVUZXh0c1tpZHhdLmxlbmd0aF07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlcGxhY2VSYW5nZU5vZGVzID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbmV3Tm9kZXMpIHtcbiAgICAgICAgaWYgKCFzdGFydE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0Tm9kZXNCZWZvcmUoZW5kTm9kZSwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGVCeUlkKGVuZE5vZGUuaWQpO1xuICAgICAgICAgICAgICAgIGVuZE5vZGUudW5saW5rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVwZW5kQ2hpbGROb2Rlcyh0aGlzLnJvb3QsIG5ld05vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydE5vZGVzQmVmb3JlKHN0YXJ0Tm9kZSwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgcmVtb3ZlTmV4dFVudGlsKHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XG4gICAgICAgICAgICBbc3RhcnROb2RlLmlkLCBlbmROb2RlLmlkXS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVtb3ZlTm9kZUJ5SWQoaWQpOyB9KTtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZS51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXROb2RlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcykge1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gZmluZENoaWxkTm9kZUF0TGluZSh0aGlzLnJvb3QsIHN0YXJ0UG9zWzBdKTtcbiAgICAgICAgdmFyIGVuZE5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgZW5kUG9zWzBdKTtcbiAgICAgICAgLy8gZXh0ZW5kIG5vZGUgcmFuZ2UgdG8gaW5jbHVkZSBhIGZvbGxvd2luZyBibG9jayB3aGljaCBkb2Vzbid0IGhhdmUgcHJlY2VkaW5nIGJsYW5rIGxpbmVcbiAgICAgICAgaWYgKGVuZE5vZGUgJiYgZW5kTm9kZS5uZXh0ICYmIGVuZFBvc1swXSArIDEgPT09IGVuZE5vZGUubmV4dC5zb3VyY2Vwb3NbMF1bMF0pIHtcbiAgICAgICAgICAgIGVuZE5vZGUgPSBlbmROb2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzdGFydE5vZGUsIGVuZE5vZGVdO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGFyYW0pIHtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJNYXBbZXZlbnROYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHBhcmFtKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmV4dGVuZEVuZExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5saW5lVGV4dHNbbGluZV0gPT09ICcnKSB7XG4gICAgICAgICAgICBsaW5lICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnBhcnNlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgICAgICAgLy8gZXh0ZW5kcyBzdGFydGluZyByYW5nZSBpZiB0aGUgZmlyc3Qgbm9kZSBjYW4gYmUgYSBjb250aW51ZWQgbGlzdCBpdGVtXG4gICAgICAgIGlmIChzdGFydE5vZGUgJiZcbiAgICAgICAgICAgIHN0YXJ0Tm9kZS5wcmV2ICYmXG4gICAgICAgICAgICAoKGlzTGlzdChzdGFydE5vZGUucHJldikgJiYgY2FuQmVDb250aW51ZWRMaXN0SXRlbSh0aGlzLmxpbmVUZXh0c1tzdGFydExpbmUgLSAxXSkpIHx8XG4gICAgICAgICAgICAgICAgKGlzVGFibGUoc3RhcnROb2RlLnByZXYpICYmIGNhbkJlQ29udGludWVkVGFibGVCb2R5KHRoaXMubGluZVRleHRzW3N0YXJ0TGluZSAtIDFdKSkpKSB7XG4gICAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUucHJldjtcbiAgICAgICAgICAgIHN0YXJ0TGluZSA9IHN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkaXRlZExpbmVzID0gdGhpcy5saW5lVGV4dHMuc2xpY2Uoc3RhcnRMaW5lIC0gMSwgZW5kTGluZSk7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5wYXJzZXIucGFydGlhbFBhcnNlU3RhcnQoc3RhcnRMaW5lLCBlZGl0ZWRMaW5lcyk7XG4gICAgICAgIC8vIGV4dGVuZHMgZW5kaW5nIHJhbmdlIGlmIHRoZSBmb2xsb3dpbmcgbm9kZSBjYW4gYmUgYSBmZW5jZWQgY29kZSBibG9jayBvciBhIGNvbnRpbnVlZCBsaXN0IGl0ZW1cbiAgICAgICAgdmFyIG5leHROb2RlID0gZW5kTm9kZSA/IGVuZE5vZGUubmV4dCA6IHRoaXMucm9vdC5maXJzdENoaWxkO1xuICAgICAgICB2YXIgbGFzdENoaWxkID0gcm9vdC5sYXN0Q2hpbGQ7XG4gICAgICAgIHZhciBpc09wZW5lZExhc3RDaGlsZENvZGVCbG9jayA9IGxhc3RDaGlsZCAmJiBpc0NvZGVCbG9jayhsYXN0Q2hpbGQpICYmIGxhc3RDaGlsZC5vcGVuO1xuICAgICAgICB2YXIgaXNPcGVuZWRMYXN0Q2hpbGRDdXN0b21CbG9jayA9IGxhc3RDaGlsZCAmJiBpc0N1c3RvbUJsb2NrKGxhc3RDaGlsZCkgJiYgbGFzdENoaWxkLm9wZW47XG4gICAgICAgIHZhciBpc0xhc3RDaGlsZExpc3QgPSBsYXN0Q2hpbGQgJiYgaXNMaXN0KGxhc3RDaGlsZCk7XG4gICAgICAgIHdoaWxlICgoKGlzT3BlbmVkTGFzdENoaWxkQ29kZUJsb2NrIHx8IGlzT3BlbmVkTGFzdENoaWxkQ3VzdG9tQmxvY2spICYmIG5leHROb2RlKSB8fFxuICAgICAgICAgICAgKGlzTGFzdENoaWxkTGlzdCAmJiBuZXh0Tm9kZSAmJiAobmV4dE5vZGUudHlwZSA9PT0gJ2xpc3QnIHx8IG5leHROb2RlLnNvdXJjZXBvc1swXVsxXSA+PSAyKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmRMaW5lID0gdGhpcy5leHRlbmRFbmRMaW5lKG5leHROb2RlLnNvdXJjZXBvc1sxXVswXSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5wYXJ0aWFsUGFyc2VFeHRlbmRzKHRoaXMubGluZVRleHRzLnNsaWNlKGVuZExpbmUsIG5ld0VuZExpbmUpKTtcbiAgICAgICAgICAgIGlmICghc3RhcnROb2RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnROb2RlID0gZW5kTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgIGVuZExpbmUgPSBuZXdFbmRMaW5lO1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0Tm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VyLnBhcnRpYWxQYXJzZUZpbmlzaCgpO1xuICAgICAgICB2YXIgbmV3Tm9kZXMgPSBnZXRDaGlsZE5vZGVzKHJvb3QpO1xuICAgICAgICByZXR1cm4geyBuZXdOb2RlczogbmV3Tm9kZXMsIGV4dFN0YXJ0Tm9kZTogc3RhcnROb2RlLCBleHRFbmROb2RlOiBlbmROb2RlIH07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldFJlbW92ZWROb2RlUmFuZ2UgPSBmdW5jdGlvbiAoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKSB7XG4gICAgICAgIGlmICghZXh0U3RhcnROb2RlIHx8XG4gICAgICAgICAgICAoZXh0U3RhcnROb2RlICYmIGlzUmVmRGVmKGV4dFN0YXJ0Tm9kZSkpIHx8XG4gICAgICAgICAgICAoZXh0RW5kTm9kZSAmJiBpc1JlZkRlZihleHRFbmROb2RlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogW2V4dFN0YXJ0Tm9kZS5pZCwgZXh0RW5kTm9kZS5pZF0sXG4gICAgICAgICAgICBsaW5lOiBbZXh0U3RhcnROb2RlLnNvdXJjZXBvc1swXVswXSAtIDEsIGV4dEVuZE5vZGUuc291cmNlcG9zWzFdWzBdIC0gMV0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLm1hcmtEZWxldGVkUmVmTWFwID0gZnVuY3Rpb24gKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZNYXApKSB7XG4gICAgICAgICAgICB2YXIgbWFya0RlbGV0ZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZkRlZihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmRGVmU3RhdGUgPSBfdGhpcy5yZWZNYXBbbm9kZS5sYWJlbF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZEZWZTdGF0ZSAmJiBub2RlLmlkID09PSByZWZEZWZTdGF0ZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmRGVmU3RhdGUudW5saW5rZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChleHRTdGFydE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VOZXh0VW50aWwobWFya0RlbGV0ZWQsIGV4dFN0YXJ0Tm9kZS5wYXJlbnQsIGV4dEVuZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dEVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VOZXh0VW50aWwobWFya0RlbGV0ZWQsIGV4dEVuZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlcGxhY2VXaXRoTmV3UmVmRGVmU3RhdGUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKHRoaXMucmVmTWFwKSkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VXaXRoXzEgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZkRlZihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBub2RlLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmRGVmU3RhdGUgPSBfdGhpcy5yZWZNYXBbbGFiZWxdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZkRlZlN0YXRlIHx8IHJlZkRlZlN0YXRlLnVubGlua2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZNYXBbbGFiZWxdID0gY3JlYXRlUmVmRGVmU3RhdGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGludm9rZU5leHRVbnRpbChyZXBsYWNlV2l0aF8xLCBub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlcGxhY2VXaXRoUmVmRGVmQ2FuZGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApKSB7XG4gICAgICAgICAgICBpdGVyYXRlT2JqZWN0KHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwLCBmdW5jdGlvbiAoXywgY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gY2FuZGlkYXRlLmxhYmVsLCBzb3VyY2Vwb3MgPSBjYW5kaWRhdGUuc291cmNlcG9zO1xuICAgICAgICAgICAgICAgIHZhciByZWZEZWZTdGF0ZSA9IF90aGlzLnJlZk1hcFtsYWJlbF07XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZEZWZTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICByZWZEZWZTdGF0ZS51bmxpbmtlZCB8fFxuICAgICAgICAgICAgICAgICAgICByZWZEZWZTdGF0ZS5zb3VyY2Vwb3NbMF1bMF0gPiBzb3VyY2Vwb3NbMF1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmTWFwW2xhYmVsXSA9IGNyZWF0ZVJlZkRlZlN0YXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0UmFuZ2VXaXRoUmVmRGVmID0gZnVuY3Rpb24gKHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnROb2RlLCBlbmROb2RlLCBsaW5lRGlmZikge1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uICYmICFpc0VtcHR5T2JqKHRoaXMucmVmTWFwKSkge1xuICAgICAgICAgICAgdmFyIHByZXZOb2RlID0gZmluZENoaWxkTm9kZUF0TGluZSh0aGlzLnJvb3QsIHN0YXJ0TGluZSAtIDEpO1xuICAgICAgICAgICAgdmFyIG5leHROb2RlID0gZmluZENoaWxkTm9kZUF0TGluZSh0aGlzLnJvb3QsIGVuZExpbmUgKyAxKTtcbiAgICAgICAgICAgIGlmIChwcmV2Tm9kZSAmJiBpc1JlZkRlZihwcmV2Tm9kZSkgJiYgcHJldk5vZGUgIT09IHN0YXJ0Tm9kZSAmJiBwcmV2Tm9kZSAhPT0gZW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHByZXZOb2RlO1xuICAgICAgICAgICAgICAgIHN0YXJ0TGluZSA9IHN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUgJiYgaXNSZWZEZWYobmV4dE5vZGUpICYmIG5leHROb2RlICE9PSBzdGFydE5vZGUgJiYgbmV4dE5vZGUgIT09IGVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbmROb2RlID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IHRoaXMuZXh0ZW5kRW5kTGluZShlbmROb2RlLnNvdXJjZXBvc1sxXVswXSArIGxpbmVEaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXJ0Tm9kZSwgZW5kTm9kZSwgc3RhcnRMaW5lLCBlbmRMaW5lXTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcywgbGluZURpZmYpIHtcbiAgICAgICAgaWYgKGxpbmVEaWZmID09PSB2b2lkIDApIHsgbGluZURpZmYgPSAwOyB9XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Tm9kZVJhbmdlKHN0YXJ0UG9zLCBlbmRQb3MpO1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gcmFuZ2VbMF0sIGVuZE5vZGUgPSByYW5nZVsxXTtcbiAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHN0YXJ0Tm9kZSA/IE1hdGgubWluKHN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF0sIHN0YXJ0UG9zWzBdKSA6IHN0YXJ0UG9zWzBdO1xuICAgICAgICB2YXIgZW5kTGluZSA9IHRoaXMuZXh0ZW5kRW5kTGluZSgoZW5kTm9kZSA/IE1hdGgubWF4KGVuZE5vZGUuc291cmNlcG9zWzFdWzBdLCBlbmRQb3NbMF0pIDogZW5kUG9zWzBdKSArIGxpbmVEaWZmKTtcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gdGhpcy5wYXJzZVJhbmdlLmFwcGx5KHRoaXMsIHRoaXMuZ2V0UmFuZ2VXaXRoUmVmRGVmKHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnROb2RlLCBlbmROb2RlLCBsaW5lRGlmZikpO1xuICAgICAgICB2YXIgbmV3Tm9kZXMgPSBwYXJzZVJlc3VsdC5uZXdOb2RlcywgZXh0U3RhcnROb2RlID0gcGFyc2VSZXN1bHQuZXh0U3RhcnROb2RlLCBleHRFbmROb2RlID0gcGFyc2VSZXN1bHQuZXh0RW5kTm9kZTtcbiAgICAgICAgdmFyIHJlbW92ZWROb2RlUmFuZ2UgPSB0aGlzLmdldFJlbW92ZWROb2RlUmFuZ2UoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKTtcbiAgICAgICAgdmFyIG5leHROb2RlID0gZXh0RW5kTm9kZSA/IGV4dEVuZE5vZGUubmV4dCA6IHRoaXMucm9vdC5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtEZWxldGVkUmVmTWFwKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSYW5nZU5vZGVzKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aE5ld1JlZkRlZlN0YXRlKG5ld05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlTm9kZXMoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IG5ld05vZGVzLCByZW1vdmVkTm9kZVJhbmdlOiByZW1vdmVkTm9kZVJhbmdlLCBuZXh0Tm9kZTogbmV4dE5vZGUgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucGFyc2VSZWZMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QodGhpcy5yZWZNYXAsIGZ1bmN0aW9uIChsYWJlbCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudW5saW5rZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJlZk1hcFtsYWJlbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QoX3RoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgZnVuY3Rpb24gKF8sIGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNhbmRpZGF0ZS5ub2RlLCByZWZMYWJlbCA9IGNhbmRpZGF0ZS5yZWZMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkxhYmVsID09PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX3RoaXMucGFyc2Uobm9kZS5zb3VyY2Vwb3NbMF0sIG5vZGUuc291cmNlcG9zWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlbW92ZVVubGlua2VkQ2FuZGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApKSB7XG4gICAgICAgICAgICBbdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcF0uZm9yRWFjaChmdW5jdGlvbiAoY2FuZGlkYXRlTWFwKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZU9iamVjdChjYW5kaWRhdGVNYXAsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmxpbmtlZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYW5kaWRhdGVNYXBbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5lZGl0TWFya2Rvd24gPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcywgbmV3VGV4dCkge1xuICAgICAgICB2YXIgbGluZURpZmYgPSB0aGlzLnVwZGF0ZUxpbmVUZXh0cyhzdGFydFBvcywgZW5kUG9zLCBuZXdUZXh0KTtcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gdGhpcy5wYXJzZShzdGFydFBvcywgZW5kUG9zLCBsaW5lRGlmZik7XG4gICAgICAgIHZhciBlZGl0UmVzdWx0ID0gb21pdChwYXJzZVJlc3VsdCwgJ25leHROb2RlJyk7XG4gICAgICAgIHVwZGF0ZU5leHRMaW5lTnVtYmVycyhwYXJzZVJlc3VsdC5uZXh0Tm9kZSwgbGluZURpZmYpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJvb3ROb2RlU3RhdGUoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtlZGl0UmVzdWx0XTtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVVbmxpbmtlZENhbmRpZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aFJlZkRlZkNhbmRpZGF0ZSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcnNlUmVmTGluaygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldExpbmVUZXh0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZVRleHRzO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRSb290Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZmluZE5vZGVBdFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgbm9kZSA9IGZpbmROb2RlQXRQb3NpdGlvbih0aGlzLnJvb3QsIHBvcyk7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kRmlyc3ROb2RlQXRMaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRGaXJzdE5vZGVBdExpbmUodGhpcy5yb290LCBsaW5lKTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdO1xuICAgICAgICB2YXIgaWR4ID0gaGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kTm9kZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGZpbmROb2RlQnlJZChpZCk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlbW92ZUFsbE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUFsbE5vZGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdE1hcms7XG59KCkpO1xuXG52YXIgZGlzYWxsb3dlZFRhZ3MgPSBbXG4gICAgJ3RpdGxlJyxcbiAgICAndGV4dGFyZWEnLFxuICAgICdzdHlsZScsXG4gICAgJ3htcCcsXG4gICAgJ2lmcmFtZScsXG4gICAgJ25vZW1iZWQnLFxuICAgICdub2ZyYW1lcycsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ3BsYWludGV4dCcsXG5dO1xudmFyIHJlRGlzYWxsb3dlZFRhZyA9IG5ldyBSZWdFeHAoXCI8KC8/KD86XCIgKyBkaXNhbGxvd2VkVGFncy5qb2luKCd8JykgKyBcIilbXj5dKj4pXCIsICdpZycpO1xuZnVuY3Rpb24gZmlsdGVyRGlzYWxsb3dlZFRhZ3Moc3RyKSB7XG4gICAgaWYgKHJlRGlzYWxsb3dlZFRhZy50ZXN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlRGlzYWxsb3dlZFRhZywgZnVuY3Rpb24gKF8sIGdyb3VwKSB7IHJldHVybiBcIiZsdDtcIiArIGdyb3VwOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJhc2VDb252ZXJ0b3JzJDEgPSB7XG4gICAgaGVhZGluZzogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogXCJoXCIgKyBub2RlLmxldmVsLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGV4dDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNvZnRicmVhazogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG9wdGlvbnMuc29mdGJyZWFrLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGluZWJyZWFrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICBjb250ZW50OiAnPGJyIC8+XFxuJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGVtcGg6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdlbScsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdHJvbmc6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdzdHJvbmcnLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyYWdyYXBoOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIGdyYW5kcGFyZW50ID0gKF9iID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQ7XG4gICAgICAgIGlmIChncmFuZHBhcmVudCAmJiBncmFuZHBhcmVudC50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgIGlmIChncmFuZHBhcmVudC5saXN0RGF0YS50aWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAncCcsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnaHInLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgc2VsZkNsb3NlOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYmxvY2tRdW90ZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgaW5uZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGlzdDogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgX2IgPSBub2RlLmxpc3REYXRhLCB0eXBlID0gX2IudHlwZSwgc3RhcnQgPSBfYi5zdGFydDtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0eXBlID09PSAnYnVsbGV0JyA/ICd1bCcgOiAnb2wnO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ29sJyAmJiBzdGFydCAhPT0gbnVsbCAmJiBzdGFydCAhPT0gMSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5zdGFydCA9IHN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGh0bWxJbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBjb250ZW50ID0gb3B0aW9ucy50YWdGaWx0ZXIgPyBmaWx0ZXJEaXNhbGxvd2VkVGFncyhub2RlLmxpdGVyYWwpIDogbm9kZS5saXRlcmFsO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfTtcbiAgICB9LFxuICAgIGh0bWxCbG9jazogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBvcHRpb25zLnRhZ0ZpbHRlciA/IGZpbHRlckRpc2FsbG93ZWRUYWdzKG5vZGUubGl0ZXJhbCkgOiBub2RlLmxpdGVyYWw7XG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2h0bWwnLCBjb250ZW50OiBjb250ZW50IH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdodG1sJywgY29udGVudDogY29udGVudCwgb3V0ZXJOZXdMaW5lOiB0cnVlIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZm9TdHIgPSBub2RlLmluZm87XG4gICAgICAgIHZhciBpbmZvV29yZHMgPSBpbmZvU3RyID8gaW5mb1N0ci5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgIHZhciBjb2RlQ2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICBpZiAoaW5mb1dvcmRzLmxlbmd0aCA+IDAgJiYgaW5mb1dvcmRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvZGVDbGFzc05hbWVzLnB1c2goXCJsYW5ndWFnZS1cIiArIGVzY2FwZVhtbChpbmZvV29yZHNbMF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdwcmUnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnY29kZScsIGNsYXNzTmFtZXM6IGNvZGVDbGFzc05hbWVzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAncHJlJywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIF9iID0gbm9kZSwgdGl0bGUgPSBfYi50aXRsZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdhJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBfX2Fzc2lnbih7IGhyZWY6IGVzY2FwZVhtbChkZXN0aW5hdGlvbikgfSwgKHRpdGxlICYmIHsgdGl0bGU6IGVzY2FwZVhtbCh0aXRsZSkgfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnYScgfTtcbiAgICB9LFxuICAgIGltYWdlOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGdldENoaWxkcmVuVGV4dCA9IF9hLmdldENoaWxkcmVuVGV4dCwgc2tpcENoaWxkcmVuID0gX2Euc2tpcENoaWxkcmVuO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCB0aXRsZSA9IF9iLnRpdGxlLCBkZXN0aW5hdGlvbiA9IF9iLmRlc3RpbmF0aW9uO1xuICAgICAgICBza2lwQ2hpbGRyZW4oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdpbWcnLFxuICAgICAgICAgICAgc2VsZkNsb3NlOiB0cnVlLFxuICAgICAgICAgICAgYXR0cmlidXRlczogX19hc3NpZ24oeyBzcmM6IGVzY2FwZVhtbChkZXN0aW5hdGlvbiksIGFsdDogZ2V0Q2hpbGRyZW5UZXh0KG5vZGUpIH0sICh0aXRsZSAmJiB7IHRpdGxlOiBlc2NhcGVYbWwodGl0bGUpIH0pKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGN1c3RvbUJsb2NrOiBmdW5jdGlvbiAobm9kZSwgY29udGV4dCwgY29udmVydG9ycykge1xuICAgICAgICB2YXIgaW5mbyA9IG5vZGUuaW5mby50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGNvbnZlcnRvcnNbaW5mb107XG4gICAgICAgIGlmIChjdXN0b21Db252ZXJ0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0B0b2FzdC11aS9lZGl0b3JdIC0gVGhlIGVycm9yIG9jY3VycmVkIHdoZW4gXCIgKyBpbmZvICsgXCIgYmxvY2sgbm9kZSB3YXMgcGFyc2VkIGluIG1hcmtkb3duIHJlbmRlcmVyOiBcIiArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBmcm9udE1hdHRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgZnJvbnQgbWF0dGVyIGlzIG1ldGFkYXRhLCBpdCBzaG91bGQgbm90IGJlIHJlbmRlci5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IHN0eWxlOiAnd2hpdGUtc3BhY2U6IHByZTsgZGlzcGxheTogbm9uZTsnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBjdXN0b21JbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKSB7XG4gICAgICAgIHZhciBfYSA9IG5vZGUsIGluZm8gPSBfYS5pbmZvLCBmaXJzdENoaWxkID0gX2EuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIG5vbWFsaXplZEluZm8gPSBpbmZvLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yID0gY29udmVydG9yc1tub21hbGl6ZWRJbmZvXTtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gY29udGV4dC5lbnRlcmluZztcbiAgICAgICAgaWYgKGN1c3RvbUNvbnZlcnRvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tQ29udmVydG9yKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbQHRvYXN0LXVpL2VkaXRvcl0gLSBUaGUgZXJyb3Igb2NjdXJyZWQgd2hlbiBcIiArIG5vbWFsaXplZEluZm8gKyBcIiBpbmxpbmUgbm9kZSB3YXMgcGFyc2VkIGluIG1hcmtkb3duIHJlbmRlcmVyOiBcIiArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRlcmluZ1xuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdzcGFuJyB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBcIiQkXCIgKyBpbmZvICsgKGZpcnN0Q2hpbGQgPyAnICcgOiAnJykgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiAnJCQnIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnc3BhbicgfSxcbiAgICAgICAgICAgIF07XG4gICAgfSxcbn07XG5cbnZhciBnZm1Db252ZXJ0b3JzID0ge1xuICAgIHN0cmlrZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2RlbCcsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBpdGVtOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBfYiA9IG5vZGUubGlzdERhdGEsIGNoZWNrZWQgPSBfYi5jaGVja2VkLCB0YXNrID0gX2IudGFzaztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaXRlbVRhZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBpdGVtVGFnLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZkNsb3NlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogX19hc3NpZ24oX19hc3NpZ24oe30sIChjaGVja2VkICYmIHsgY2hlY2tlZDogJycgfSkpLCB7IGRpc2FibGVkOiAnJywgdHlwZTogJ2NoZWNrYm94JyB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyAnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbVRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RhYmxlJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RoZWFkJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlQm9keTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3Rib2R5JyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlUm93OiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ3RyJyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uTGVuID0gbm9kZS5wYXJlbnQucGFyZW50LmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxhc3RDb2xJZHggPSBub2RlLmxhc3RDaGlsZC5lbmRJZHg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGFzdENvbElkeCArIDE7IGkgPCBjb2x1bW5MZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGQnLFxuICAgICAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGQnLFxuICAgICAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0cicsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgdGFibGVDZWxsOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChub2RlLmlnbm9yZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFibGVQYXJ0ID0gbm9kZS5wYXJlbnQucGFyZW50O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRhYmxlUGFydC50eXBlID09PSAndGFibGVIZWFkJyA/ICd0aCcgOiAndGQnO1xuICAgICAgICB2YXIgdGFibGUgPSB0YWJsZVBhcnQucGFyZW50O1xuICAgICAgICB2YXIgY29sdW1uSW5mbyA9IHRhYmxlLmNvbHVtbnNbbm9kZS5zdGFydElkeF07XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gKGNvbHVtbkluZm8gPT09IG51bGwgfHwgY29sdW1uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uSW5mby5hbGlnbikgPyB7IGFsaWduOiBjb2x1bW5JbmZvLmFsaWduIH0gOiBudWxsO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogdGFnTmFtZSwgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sIChhdHRyaWJ1dGVzICYmIHsgYXR0cmlidXRlczogYXR0cmlidXRlcyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc29mdGJyZWFrOiAnXFxuJyxcbiAgICBnZm06IGZhbHNlLFxuICAgIHRhZ0ZpbHRlcjogZmFsc2UsXG4gICAgbm9kZUlkOiBmYWxzZSxcbn07XG5mdW5jdGlvbiBnZXRDaGlsZHJlblRleHQobm9kZSkge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgd2Fsa2VyID0gbm9kZS53YWxrZXIoKTtcbiAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgbm9kZV8xID0gZXZlbnQubm9kZTtcbiAgICAgICAgaWYgKG5vZGVfMS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vZGVfMS5saXRlcmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xufVxudmFyIFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zKSwgY3VzdG9tT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29udmVydG9ycyA9IHRoaXMuY3JlYXRlQ29udmVydG9ycygpO1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLmNvbnZlcnRvcnM7XG4gICAgfVxuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb252ZXJ0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udmVydG9ycyA9IF9fYXNzaWduKHt9LCBiYXNlQ29udmVydG9ycyQxKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgICAgIGNvbnZlcnRvcnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udmVydG9ycyksIGdmbUNvbnZlcnRvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udmVydG9ycykge1xuICAgICAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvcnNfMSA9IHRoaXMub3B0aW9ucy5jb252ZXJ0b3JzO1xuICAgICAgICAgICAgdmFyIG5vZGVUeXBlcyA9IE9iamVjdC5rZXlzKGN1c3RvbUNvbnZlcnRvcnNfMSk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdENvbnZlcnRvcnNfMSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBiYXNlQ29udmVydG9ycyQxKSwgZ2ZtQ29udmVydG9ycyk7XG4gICAgICAgICAgICBub2RlVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JnQ29udmVydG9yID0gY29udmVydG9yc1tub2RlVHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvcnNfMVtub2RlVHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRvclR5cGUgPSBPYmplY3Qua2V5cyhkZWZhdWx0Q29udmVydG9yc18xKS5pbmRleE9mKG5vZGVUeXBlKSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlVHlwZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIDogbm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKG9yZ0NvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW2NvbnZlcnRvclR5cGVdID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub3JpZ2luID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JnQ29udmVydG9yKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbY29udmVydG9yVHlwZV0gPSBjb252ZXJ0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRvcnM7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q29udmVydG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydG9ycztcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZXRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChyb290Tm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB2YXIgd2Fsa2VyID0gcm9vdE5vZGUud2Fsa2VyKCk7XG4gICAgICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudC5ub2RlLCBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nO1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IHRoaXNfMS5jb252ZXJ0b3JzW25vZGUudHlwZV07XG4gICAgICAgICAgICBpZiAoIWNvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2tpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgZW50ZXJpbmc6IGVudGVyaW5nLFxuICAgICAgICAgICAgICAgIGxlYWY6ICFpc0NvbnRhaW5lciQxKG5vZGUpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXNfMS5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuVGV4dDogZ2V0Q2hpbGRyZW5UZXh0LFxuICAgICAgICAgICAgICAgIHNraXBDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWQgPSBpc0N1c3RvbUJsb2NrKG5vZGUpIHx8IGlzQ3VzdG9tSW5saW5lKG5vZGUpXG4gICAgICAgICAgICAgICAgPyBjb252ZXJ0b3Iobm9kZSwgY29udGV4dCwgdGhpc18xLmNvbnZlcnRvcnMpXG4gICAgICAgICAgICAgICAgOiBjb252ZXJ0b3Iobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoY29udmVydGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxOb2RlcyA9IEFycmF5LmlzQXJyYXkoY29udmVydGVkKSA/IGNvbnZlcnRlZCA6IFtjb252ZXJ0ZWRdO1xuICAgICAgICAgICAgICAgIGh0bWxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChodG1sTm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh0bWxOb2RlLnR5cGUgPT09ICdvcGVuVGFnJyAmJiBfdGhpcy5vcHRpb25zLm5vZGVJZCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFodG1sTm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbE5vZGUuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbE5vZGUuYXR0cmlidXRlc1snZGF0YS1ub2RlaWQnXSA9IFN0cmluZyhub2RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJIVE1MTm9kZShodG1sTm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLnJlc3VtZUF0KG5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZE5ld0xpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmpvaW4oJycpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckhUTUxOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29wZW5UYWcnOlxuICAgICAgICAgICAgY2FzZSAnY2xvc2VUYWcnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRWxlbWVudE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRleHROb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSYXdIdG1sTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIG5vLWRlZmF1bHQtY2FzZVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVPcGVuVGFnU3RyaW5nID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBub2RlLnRhZ05hbWUsIGNsYXNzTmFtZXMgPSBub2RlLmNsYXNzTmFtZXMsIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCI8XCIgKyB0YWdOYW1lKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZXMgJiYgY2xhc3NOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiIGNsYXNzPVxcXCJcIiArIGNsYXNzTmFtZXMuam9pbignICcpICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICBfdGhpcy5idWZmZXIucHVzaChcIiBcIiArIGF0dHJOYW1lICsgXCI9XFxcIlwiICsgYXR0clZhbHVlICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2VsZkNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKCcgLycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goJz4nKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZUNsb3NlVGFnU3RyaW5nID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gX2EudGFnTmFtZTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChcIjwvXCIgKyB0YWdOYW1lICsgXCI+XCIpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmFkZE5ld0xpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggJiYgbGFzdChsYXN0KHRoaXMuYnVmZmVyKSkgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKCdcXG4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmFkZE91dGVyTmV3TGluZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm91dGVyTmV3TGluZSkge1xuICAgICAgICAgICAgdGhpcy5hZGROZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5hZGRJbm5lck5ld0xpbmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pbm5lck5ld0xpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTmV3TGluZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGV4dE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGVzY2FwZVhtbChub2RlLmNvbnRlbnQpKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJSYXdIdG1sTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5vZGUuY29udGVudCk7XG4gICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckVsZW1lbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ29wZW5UYWcnKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVPcGVuVGFnU3RyaW5nKG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUuc2VsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZElubmVyTmV3TGluZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSW5uZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUNsb3NlVGFnU3RyaW5nKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oKSk7XG5cbi8qISBAbGljZW5zZSBET01QdXJpZnkgMi4zLjMgfCAoYykgQ3VyZTUzIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIGxpY2Vuc2UgMi4wIGFuZCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIDIuMCB8IGdpdGh1Yi5jb20vY3VyZTUzL0RPTVB1cmlmeS9ibG9iLzIuMy4zL0xJQ0VOU0UgKi9cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eSxcbiAgICBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZixcbiAgICBpc0Zyb3plbiA9IE9iamVjdC5pc0Zyb3plbixcbiAgICBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemUsXG4gICAgc2VhbCA9IE9iamVjdC5zZWFsLFxuICAgIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0c1xuXG52YXIgX3JlZiA9IHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LFxuICAgIGFwcGx5ID0gX3JlZi5hcHBseSxcbiAgICBjb25zdHJ1Y3QgPSBfcmVmLmNvbnN0cnVjdDtcblxuaWYgKCFhcHBseSkge1xuICBhcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGZ1biwgdGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bi5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICB9O1xufVxuXG5pZiAoIWZyZWV6ZSkge1xuICBmcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5pZiAoIXNlYWwpIHtcbiAgc2VhbCA9IGZ1bmN0aW9uIHNlYWwoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5pZiAoIWNvbnN0cnVjdCkge1xuICBjb25zdHJ1Y3QgPSBmdW5jdGlvbiBjb25zdHJ1Y3QoRnVuYywgYXJncykge1xuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KEZ1bmMsIFtudWxsXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKSkpKCk7XG4gIH07XG59XG5cbnZhciBhcnJheUZvckVhY2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbnZhciBhcnJheVBvcCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnBvcCk7XG52YXIgYXJyYXlQdXNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucHVzaCk7XG5cbnZhciBzdHJpbmdUb0xvd2VyQ2FzZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZSk7XG52YXIgc3RyaW5nTWF0Y2ggPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUubWF0Y2gpO1xudmFyIHN0cmluZ1JlcGxhY2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mKTtcbnZhciBzdHJpbmdUcmltID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuXG52YXIgcmVnRXhwVGVzdCA9IHVuYXBwbHkoUmVnRXhwLnByb3RvdHlwZS50ZXN0KTtcblxudmFyIHR5cGVFcnJvckNyZWF0ZSA9IHVuY29uc3RydWN0KFR5cGVFcnJvcik7XG5cbmZ1bmN0aW9uIHVuYXBwbHkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5jb25zdHJ1Y3QoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnN0cnVjdChmdW5jLCBhcmdzKTtcbiAgfTtcbn1cblxuLyogQWRkIHByb3BlcnRpZXMgdG8gYSBsb29rdXAgdGFibGUgKi9cbmZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgYXJyYXkpIHtcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgLy8gTWFrZSAnaW4nIGFuZCB0cnV0aHkgY2hlY2tzIGxpa2UgQm9vbGVhbihzZXQuY29uc3RydWN0b3IpXG4gICAgLy8gaW5kZXBlbmRlbnQgb2YgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICAgIC8vIFByZXZlbnQgcHJvdG90eXBlIHNldHRlcnMgZnJvbSBpbnRlcmNlcHRpbmcgc2V0IGFzIGEgdGhpcyB2YWx1ZS5cbiAgICBzZXRQcm90b3R5cGVPZihzZXQsIG51bGwpO1xuICB9XG5cbiAgdmFyIGwgPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsLS0pIHtcbiAgICB2YXIgZWxlbWVudCA9IGFycmF5W2xdO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBsY0VsZW1lbnQgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50KTtcbiAgICAgIGlmIChsY0VsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ29uZmlnIHByZXNldHMgKGUuZy4gdGFncy5qcywgYXR0cnMuanMpIGFyZSBpbW11dGFibGUuXG4gICAgICAgIGlmICghaXNGcm96ZW4oYXJyYXkpKSB7XG4gICAgICAgICAgYXJyYXlbbF0gPSBsY0VsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50ID0gbGNFbGVtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldFtlbGVtZW50XSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gc2V0O1xufVxuXG4vKiBTaGFsbG93IGNsb25lIGFuIG9iamVjdCAqL1xuZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XG4gIHZhciBuZXdPYmplY3QgPSBjcmVhdGUobnVsbCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gdm9pZCAwO1xuICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgIGlmIChhcHBseShoYXNPd25Qcm9wZXJ0eSwgb2JqZWN0LCBbcHJvcGVydHldKSkge1xuICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cblxuLyogSUUxMCBkb2Vzbid0IHN1cHBvcnQgX19sb29rdXBHZXR0ZXJfXyBzbyBsZXRzJ1xuICogc2ltdWxhdGUgaXQuIEl0IGFsc28gYXV0b21hdGljYWxseSBjaGVja3NcbiAqIGlmIHRoZSBwcm9wIGlzIGZ1bmN0aW9uIG9yIGdldHRlciBhbmQgYmVoYXZlc1xuICogYWNjb3JkaW5nbHkuICovXG5mdW5jdGlvbiBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wKSB7XG4gIHdoaWxlIChvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZGVzYyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3ApO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy5nZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhbGxiYWNrVmFsdWUoZWxlbWVudCkge1xuICAgIGNvbnNvbGUud2FybignZmFsbGJhY2sgdmFsdWUgZm9yJywgZWxlbWVudCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbn1cblxudmFyIGh0bWwkMiA9IGZyZWV6ZShbJ2EnLCAnYWJicicsICdhY3JvbnltJywgJ2FkZHJlc3MnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2F1ZGlvJywgJ2InLCAnYmRpJywgJ2JkbycsICdiaWcnLCAnYmxpbmsnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdjb250ZW50JywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGQnLCAnZGVjb3JhdG9yJywgJ2RlbCcsICdkZXRhaWxzJywgJ2RmbicsICdkaWFsb2cnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbGVtZW50JywgJ2VtJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2ZvbnQnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaScsICdpbWcnLCAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdsYWJlbCcsICdsZWdlbmQnLCAnbGknLCAnbWFpbicsICdtYXAnLCAnbWFyaycsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0ZXInLCAnbmF2JywgJ25vYnInLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ291dHB1dCcsICdwJywgJ3BpY3R1cmUnLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLCAncnAnLCAncnQnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc2hhZG93JywgJ3NtYWxsJywgJ3NvdXJjZScsICdzcGFjZXInLCAnc3BhbicsICdzdHJpa2UnLCAnc3Ryb25nJywgJ3N0eWxlJywgJ3N1YicsICdzdW1tYXJ5JywgJ3N1cCcsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aW1lJywgJ3RyJywgJ3RyYWNrJywgJ3R0JywgJ3UnLCAndWwnLCAndmFyJywgJ3ZpZGVvJywgJ3diciddKTtcblxuLy8gU1ZHXG52YXIgc3ZnID0gZnJlZXplKFsnc3ZnJywgJ2EnLCAnYWx0Z2x5cGgnLCAnYWx0Z2x5cGhkZWYnLCAnYWx0Z2x5cGhpdGVtJywgJ2FuaW1hdGVjb2xvcicsICdhbmltYXRlbW90aW9uJywgJ2FuaW1hdGV0cmFuc2Zvcm0nLCAnY2lyY2xlJywgJ2NsaXBwYXRoJywgJ2RlZnMnLCAnZGVzYycsICdlbGxpcHNlJywgJ2ZpbHRlcicsICdmb250JywgJ2cnLCAnZ2x5cGgnLCAnZ2x5cGhyZWYnLCAnaGtlcm4nLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJncmFkaWVudCcsICdtYXJrZXInLCAnbWFzaycsICdtZXRhZGF0YScsICdtcGF0aCcsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxncmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAnc3R5bGUnLCAnc3dpdGNoJywgJ3N5bWJvbCcsICd0ZXh0JywgJ3RleHRwYXRoJywgJ3RpdGxlJywgJ3RyZWYnLCAndHNwYW4nLCAndmlldycsICd2a2VybiddKTtcblxudmFyIHN2Z0ZpbHRlcnMgPSBmcmVlemUoWydmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLCAnZmVDb21wb25lbnRUcmFuc2ZlcicsICdmZUNvbXBvc2l0ZScsICdmZUNvbnZvbHZlTWF0cml4JywgJ2ZlRGlmZnVzZUxpZ2h0aW5nJywgJ2ZlRGlzcGxhY2VtZW50TWFwJywgJ2ZlRGlzdGFudExpZ2h0JywgJ2ZlRmxvb2QnLCAnZmVGdW5jQScsICdmZUZ1bmNCJywgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsICdmZUdhdXNzaWFuQmx1cicsICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJywgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLCAnZmVTcGVjdWxhckxpZ2h0aW5nJywgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsICdmZVR1cmJ1bGVuY2UnXSk7XG5cbi8vIExpc3Qgb2YgU1ZHIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FsbG93ZWQgYnkgZGVmYXVsdC5cbi8vIFdlIHN0aWxsIG5lZWQgdG8ga25vdyB0aGVtIHNvIHRoYXQgd2UgY2FuIGRvIG5hbWVzcGFjZVxuLy8gY2hlY2tzIHByb3Blcmx5IGluIGNhc2Ugb25lIHdhbnRzIHRvIGFkZCB0aGVtIHRvXG4vLyBhbGxvdy1saXN0LlxudmFyIHN2Z0Rpc2FsbG93ZWQgPSBmcmVlemUoWydhbmltYXRlJywgJ2NvbG9yLXByb2ZpbGUnLCAnY3Vyc29yJywgJ2Rpc2NhcmQnLCAnZmVkcm9wc2hhZG93JywgJ2ZlaW1hZ2UnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXNyYycsICdmb250LWZhY2UtdXJpJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGF0Y2gnLCAnaGF0Y2hwYXRoJywgJ21lc2gnLCAnbWVzaGdyYWRpZW50JywgJ21lc2hwYXRjaCcsICdtZXNocm93JywgJ21pc3NpbmctZ2x5cGgnLCAnc2NyaXB0JywgJ3NldCcsICdzb2xpZGNvbG9yJywgJ3Vua25vd24nLCAndXNlJ10pO1xuXG52YXIgbWF0aE1sID0gZnJlZXplKFsnbWF0aCcsICdtZW5jbG9zZScsICdtZXJyb3InLCAnbWZlbmNlZCcsICdtZnJhYycsICdtZ2x5cGgnLCAnbWknLCAnbWxhYmVsZWR0cicsICdtbXVsdGlzY3JpcHRzJywgJ21uJywgJ21vJywgJ21vdmVyJywgJ21wYWRkZWQnLCAnbXBoYW50b20nLCAnbXJvb3QnLCAnbXJvdycsICdtcycsICdtc3BhY2UnLCAnbXNxcnQnLCAnbXN0eWxlJywgJ21zdWInLCAnbXN1cCcsICdtc3Vic3VwJywgJ210YWJsZScsICdtdGQnLCAnbXRleHQnLCAnbXRyJywgJ211bmRlcicsICdtdW5kZXJvdmVyJ10pO1xuXG4vLyBTaW1pbGFybHkgdG8gU1ZHLCB3ZSB3YW50IHRvIGtub3cgYWxsIE1hdGhNTCBlbGVtZW50cyxcbi8vIGV2ZW4gdGhvc2UgdGhhdCB3ZSBkaXNhbGxvdyBieSBkZWZhdWx0LlxudmFyIG1hdGhNbERpc2FsbG93ZWQgPSBmcmVlemUoWydtYWN0aW9uJywgJ21hbGlnbmdyb3VwJywgJ21hbGlnbm1hcmsnLCAnbWxvbmdkaXYnLCAnbXNjYXJyaWVzJywgJ21zY2FycnknLCAnbXNncm91cCcsICdtc3RhY2snLCAnbXNsaW5lJywgJ21zcm93JywgJ3NlbWFudGljcycsICdhbm5vdGF0aW9uJywgJ2Fubm90YXRpb24teG1sJywgJ21wcmVzY3JpcHRzJywgJ25vbmUnXSk7XG5cbnZhciB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG5cbnZhciBodG1sJDEkMSA9IGZyZWV6ZShbJ2FjY2VwdCcsICdhY3Rpb24nLCAnYWxpZ24nLCAnYWx0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsICdhdXRvcGljdHVyZWlucGljdHVyZScsICdhdXRvcGxheScsICdiYWNrZ3JvdW5kJywgJ2JnY29sb3InLCAnYm9yZGVyJywgJ2NhcHR1cmUnLCAnY2VsbHBhZGRpbmcnLCAnY2VsbHNwYWNpbmcnLCAnY2hlY2tlZCcsICdjaXRlJywgJ2NsYXNzJywgJ2NsZWFyJywgJ2NvbG9yJywgJ2NvbHMnLCAnY29sc3BhbicsICdjb250cm9scycsICdjb250cm9sc2xpc3QnLCAnY29vcmRzJywgJ2Nyb3Nzb3JpZ2luJywgJ2RhdGV0aW1lJywgJ2RlY29kaW5nJywgJ2RlZmF1bHQnLCAnZGlyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVwaWN0dXJlaW5waWN0dXJlJywgJ2Rpc2FibGVyZW1vdGVwbGF5YmFjaycsICdkb3dubG9hZCcsICdkcmFnZ2FibGUnLCAnZW5jdHlwZScsICdlbnRlcmtleWhpbnQnLCAnZmFjZScsICdmb3InLCAnaGVhZGVycycsICdoZWlnaHQnLCAnaGlkZGVuJywgJ2hpZ2gnLCAnaHJlZicsICdocmVmbGFuZycsICdpZCcsICdpbnB1dG1vZGUnLCAnaW50ZWdyaXR5JywgJ2lzbWFwJywgJ2tpbmQnLCAnbGFiZWwnLCAnbGFuZycsICdsaXN0JywgJ2xvYWRpbmcnLCAnbG9vcCcsICdsb3cnLCAnbWF4JywgJ21heGxlbmd0aCcsICdtZWRpYScsICdtZXRob2QnLCAnbWluJywgJ21pbmxlbmd0aCcsICdtdWx0aXBsZScsICdtdXRlZCcsICduYW1lJywgJ25vc2hhZGUnLCAnbm92YWxpZGF0ZScsICdub3dyYXAnLCAnb3BlbicsICdvcHRpbXVtJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncGxheXNpbmxpbmUnLCAncG9zdGVyJywgJ3ByZWxvYWQnLCAncHViZGF0ZScsICdyYWRpb2dyb3VwJywgJ3JlYWRvbmx5JywgJ3JlbCcsICdyZXF1aXJlZCcsICdyZXYnLCAncmV2ZXJzZWQnLCAncm9sZScsICdyb3dzJywgJ3Jvd3NwYW4nLCAnc3BlbGxjaGVjaycsICdzY29wZScsICdzZWxlY3RlZCcsICdzaGFwZScsICdzaXplJywgJ3NpemVzJywgJ3NwYW4nLCAnc3JjbGFuZycsICdzdGFydCcsICdzcmMnLCAnc3Jjc2V0JywgJ3N0ZXAnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJpbmRleCcsICd0aXRsZScsICd0cmFuc2xhdGUnLCAndHlwZScsICd1c2VtYXAnLCAndmFsaWduJywgJ3ZhbHVlJywgJ3dpZHRoJywgJ3htbG5zJywgJ3Nsb3QnXSk7XG5cbnZhciBzdmckMSA9IGZyZWV6ZShbJ2FjY2VudC1oZWlnaHQnLCAnYWNjdW11bGF0ZScsICdhZGRpdGl2ZScsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXNjZW50JywgJ2F0dHJpYnV0ZW5hbWUnLCAnYXR0cmlidXRldHlwZScsICdhemltdXRoJywgJ2Jhc2VmcmVxdWVuY3knLCAnYmFzZWxpbmUtc2hpZnQnLCAnYmVnaW4nLCAnYmlhcycsICdieScsICdjbGFzcycsICdjbGlwJywgJ2NsaXBwYXRodW5pdHMnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvcicsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdjeCcsICdjeScsICdkJywgJ2R4JywgJ2R5JywgJ2RpZmZ1c2Vjb25zdGFudCcsICdkaXJlY3Rpb24nLCAnZGlzcGxheScsICdkaXZpc29yJywgJ2R1cicsICdlZGdlbW9kZScsICdlbGV2YXRpb24nLCAnZW5kJywgJ2ZpbGwnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmaWx0ZXInLCAnZmlsdGVydW5pdHMnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZngnLCAnZnknLCAnZzEnLCAnZzInLCAnZ2x5cGgtbmFtZScsICdnbHlwaHJlZicsICdncmFkaWVudHVuaXRzJywgJ2dyYWRpZW50dHJhbnNmb3JtJywgJ2hlaWdodCcsICdocmVmJywgJ2lkJywgJ2ltYWdlLXJlbmRlcmluZycsICdpbicsICdpbjInLCAnaycsICdrMScsICdrMicsICdrMycsICdrNCcsICdrZXJuaW5nJywgJ2tleXBvaW50cycsICdrZXlzcGxpbmVzJywgJ2tleXRpbWVzJywgJ2xhbmcnLCAnbGVuZ3RoYWRqdXN0JywgJ2xldHRlci1zcGFjaW5nJywgJ2tlcm5lbG1hdHJpeCcsICdrZXJuZWx1bml0bGVuZ3RoJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ2xvY2FsJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnbWFya2VyaGVpZ2h0JywgJ21hcmtlcnVuaXRzJywgJ21hcmtlcndpZHRoJywgJ21hc2tjb250ZW50dW5pdHMnLCAnbWFza3VuaXRzJywgJ21heCcsICdtYXNrJywgJ21lZGlhJywgJ21ldGhvZCcsICdtb2RlJywgJ21pbicsICduYW1lJywgJ251bW9jdGF2ZXMnLCAnb2Zmc2V0JywgJ29wZXJhdG9yJywgJ29wYWNpdHknLCAnb3JkZXInLCAnb3JpZW50JywgJ29yaWVudGF0aW9uJywgJ29yaWdpbicsICdvdmVyZmxvdycsICdwYWludC1vcmRlcicsICdwYXRoJywgJ3BhdGhsZW5ndGgnLCAncGF0dGVybmNvbnRlbnR1bml0cycsICdwYXR0ZXJudHJhbnNmb3JtJywgJ3BhdHRlcm51bml0cycsICdwb2ludHMnLCAncHJlc2VydmVhbHBoYScsICdwcmVzZXJ2ZWFzcGVjdHJhdGlvJywgJ3ByaW1pdGl2ZXVuaXRzJywgJ3InLCAncngnLCAncnknLCAncmFkaXVzJywgJ3JlZngnLCAncmVmeScsICdyZXBlYXRjb3VudCcsICdyZXBlYXRkdXInLCAncmVzdGFydCcsICdyZXN1bHQnLCAncm90YXRlJywgJ3NjYWxlJywgJ3NlZWQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3NwZWN1bGFyY29uc3RhbnQnLCAnc3BlY3VsYXJleHBvbmVudCcsICdzcHJlYWRtZXRob2QnLCAnc3RhcnRvZmZzZXQnLCAnc3RkZGV2aWF0aW9uJywgJ3N0aXRjaHRpbGVzJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZScsICdzdHJva2Utd2lkdGgnLCAnc3R5bGUnLCAnc3VyZmFjZXNjYWxlJywgJ3N5c3RlbWxhbmd1YWdlJywgJ3RhYmluZGV4JywgJ3RhcmdldHgnLCAndGFyZ2V0eScsICd0cmFuc2Zvcm0nLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3RleHRsZW5ndGgnLCAndHlwZScsICd1MScsICd1MicsICd1bmljb2RlJywgJ3ZhbHVlcycsICd2aWV3Ym94JywgJ3Zpc2liaWxpdHknLCAndmVyc2lvbicsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3aWR0aCcsICd3b3JkLXNwYWNpbmcnLCAnd3JhcCcsICd3cml0aW5nLW1vZGUnLCAneGNoYW5uZWxzZWxlY3RvcicsICd5Y2hhbm5lbHNlbGVjdG9yJywgJ3gnLCAneDEnLCAneDInLCAneG1sbnMnLCAneScsICd5MScsICd5MicsICd6JywgJ3pvb21hbmRwYW4nXSk7XG5cbnZhciBtYXRoTWwkMSA9IGZyZWV6ZShbJ2FjY2VudCcsICdhY2NlbnR1bmRlcicsICdhbGlnbicsICdiZXZlbGxlZCcsICdjbG9zZScsICdjb2x1bW5zYWxpZ24nLCAnY29sdW1ubGluZXMnLCAnY29sdW1uc3BhbicsICdkZW5vbWFsaWduJywgJ2RlcHRoJywgJ2RpcicsICdkaXNwbGF5JywgJ2Rpc3BsYXlzdHlsZScsICdlbmNvZGluZycsICdmZW5jZScsICdmcmFtZScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdsYXJnZW9wJywgJ2xlbmd0aCcsICdsaW5ldGhpY2tuZXNzJywgJ2xzcGFjZScsICdscXVvdGUnLCAnbWF0aGJhY2tncm91bmQnLCAnbWF0aGNvbG9yJywgJ21hdGhzaXplJywgJ21hdGh2YXJpYW50JywgJ21heHNpemUnLCAnbWluc2l6ZScsICdtb3ZhYmxlbGltaXRzJywgJ25vdGF0aW9uJywgJ251bWFsaWduJywgJ29wZW4nLCAncm93YWxpZ24nLCAncm93bGluZXMnLCAncm93c3BhY2luZycsICdyb3dzcGFuJywgJ3JzcGFjZScsICdycXVvdGUnLCAnc2NyaXB0bGV2ZWwnLCAnc2NyaXB0bWluc2l6ZScsICdzY3JpcHRzaXplbXVsdGlwbGllcicsICdzZWxlY3Rpb24nLCAnc2VwYXJhdG9yJywgJ3NlcGFyYXRvcnMnLCAnc3RyZXRjaHknLCAnc3Vic2NyaXB0c2hpZnQnLCAnc3Vwc2NyaXB0c2hpZnQnLCAnc3ltbWV0cmljJywgJ3ZvZmZzZXQnLCAnd2lkdGgnLCAneG1sbnMnXSk7XG5cbnZhciB4bWwgPSBmcmVlemUoWyd4bGluazpocmVmJywgJ3htbDppZCcsICd4bGluazp0aXRsZScsICd4bWw6c3BhY2UnLCAneG1sbnM6eGxpbmsnXSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxudmFyIE1VU1RBQ0hFX0VYUFIgPSBzZWFsKC9cXHtcXHtbXFxzXFxTXSp8W1xcc1xcU10qXFx9XFx9L2dtKTsgLy8gU3BlY2lmeSB0ZW1wbGF0ZSBkZXRlY3Rpb24gcmVnZXggZm9yIFNBRkVfRk9SX1RFTVBMQVRFUyBtb2RlXG52YXIgRVJCX0VYUFIgPSBzZWFsKC88JVtcXHNcXFNdKnxbXFxzXFxTXSolPi9nbSk7XG52YXIgREFUQV9BVFRSID0gc2VhbCgvXmRhdGEtW1xcLVxcdy5cXHUwMEI3LVxcdUZGRkZdLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbnZhciBBUklBX0FUVFIgPSBzZWFsKC9eYXJpYS1bXFwtXFx3XSskLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbnZhciBJU19BTExPV0VEX1VSSSA9IHNlYWwoL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98Y2lkfHhtcHApOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2kgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuKTtcbnZhciBJU19TQ1JJUFRfT1JfREFUQSA9IHNlYWwoL14oPzpcXHcrc2NyaXB0fGRhdGEpOi9pKTtcbnZhciBBVFRSX1dISVRFU1BBQ0UgPSBzZWFsKC9bXFx1MDAwMC1cXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDI5XFx1MjA1RlxcdTMwMDBdL2cgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheSQxKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuby1vcCBwb2xpY3kgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICogRG9uJ3QgZXhwb3J0IHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSFcbiAqIEBwYXJhbSB7P1RydXN0ZWRUeXBlUG9saWN5RmFjdG9yeX0gdHJ1c3RlZFR5cGVzIFRoZSBwb2xpY3kgZmFjdG9yeS5cbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY3VtZW50IFRoZSBkb2N1bWVudCBvYmplY3QgKHRvIGRldGVybWluZSBwb2xpY3kgbmFtZSBzdWZmaXgpXG4gKiBAcmV0dXJuIHs/VHJ1c3RlZFR5cGVQb2xpY3l9IFRoZSBwb2xpY3kgY3JlYXRlZCAob3IgbnVsbCwgaWYgVHJ1c3RlZCBUeXBlc1xuICogYXJlIG5vdCBzdXBwb3J0ZWQpLlxuICovXG52YXIgX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSA9IGZ1bmN0aW9uIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBkb2N1bWVudCkge1xuICBpZiAoKHR5cGVvZiB0cnVzdGVkVHlwZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRydXN0ZWRUeXBlcykpICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsb3cgdGhlIGNhbGxlcnMgdG8gY29udHJvbCB0aGUgdW5pcXVlIHBvbGljeSBuYW1lXG4gIC8vIGJ5IGFkZGluZyBhIGRhdGEtdHQtcG9saWN5LXN1ZmZpeCB0byB0aGUgc2NyaXB0IGVsZW1lbnQgd2l0aCB0aGUgRE9NUHVyaWZ5LlxuICAvLyBQb2xpY3kgY3JlYXRpb24gd2l0aCBkdXBsaWNhdGUgbmFtZXMgdGhyb3dzIGluIFRydXN0ZWQgVHlwZXMuXG4gIHZhciBzdWZmaXggPSBudWxsO1xuICB2YXIgQVRUUl9OQU1FID0gJ2RhdGEtdHQtcG9saWN5LXN1ZmZpeCc7XG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpIHtcbiAgICBzdWZmaXggPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShBVFRSX05BTUUpO1xuICB9XG5cbiAgdmFyIHBvbGljeU5hbWUgPSAnZG9tcHVyaWZ5JyArIChzdWZmaXggPyAnIycgKyBzdWZmaXggOiAnJyk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShwb2xpY3lOYW1lLCB7XG4gICAgICBjcmVhdGVIVE1MOiBmdW5jdGlvbiBjcmVhdGVIVE1MKGh0bWwkJDEpIHtcbiAgICAgICAgcmV0dXJuIGh0bWwkJDE7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBQb2xpY3kgY3JlYXRpb24gZmFpbGVkIChtb3N0IGxpa2VseSBhbm90aGVyIERPTVB1cmlmeSBzY3JpcHQgaGFzXG4gICAgLy8gYWxyZWFkeSBydW4pLiBTa2lwIGNyZWF0aW5nIHRoZSBwb2xpY3ksIGFzIHRoaXMgd2lsbCBvbmx5IGNhdXNlIGVycm9yc1xuICAgIC8vIGlmIFRUIGFyZSBlbmZvcmNlZC5cbiAgICBjb25zb2xlLndhcm4oJ1RydXN0ZWRUeXBlcyBwb2xpY3kgJyArIHBvbGljeU5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVET01QdXJpZnkoKSB7XG4gIHZhciB3aW5kb3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGdldEdsb2JhbCgpO1xuXG4gIHZhciBET01QdXJpZnkgPSBmdW5jdGlvbiBET01QdXJpZnkocm9vdCkge1xuICAgIHJldHVybiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZlcnNpb24gbGFiZWwsIGV4cG9zZWQgZm9yIGVhc2llciBjaGVja3NcbiAgICogaWYgRE9NUHVyaWZ5IGlzIHVwIHRvIGRhdGUgb3Igbm90XG4gICAqL1xuICBET01QdXJpZnkudmVyc2lvbiA9ICcyLjMuMyc7XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgRE9NUHVyaWZ5IHJlbW92ZWQgZHVyaW5nIHNhbml0YXRpb24uXG4gICAqIEVtcHR5IGlmIG5vdGhpbmcgd2FzIHJlbW92ZWQuXG4gICAqL1xuICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuXG4gIGlmICghd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50Lm5vZGVUeXBlICE9PSA5KSB7XG4gICAgLy8gTm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLCBwcm92aWRlIGEgZmFjdG9yeSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgeW91IGNhbiBwYXNzIHlvdXIgb3duIFdpbmRvd1xuICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbERvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgdmFyIERvY3VtZW50RnJhZ21lbnQgPSB3aW5kb3cuRG9jdW1lbnRGcmFnbWVudCxcbiAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPSB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAgICAgIE5vZGUgPSB3aW5kb3cuTm9kZSxcbiAgICAgIEVsZW1lbnQgPSB3aW5kb3cuRWxlbWVudCxcbiAgICAgIE5vZGVGaWx0ZXIgPSB3aW5kb3cuTm9kZUZpbHRlcixcbiAgICAgIF93aW5kb3ckTmFtZWROb2RlTWFwID0gd2luZG93Lk5hbWVkTm9kZU1hcCxcbiAgICAgIE5hbWVkTm9kZU1hcCA9IF93aW5kb3ckTmFtZWROb2RlTWFwID09PSB1bmRlZmluZWQgPyB3aW5kb3cuTmFtZWROb2RlTWFwIHx8IHdpbmRvdy5Nb3pOYW1lZEF0dHJNYXAgOiBfd2luZG93JE5hbWVkTm9kZU1hcCxcbiAgICAgIFRleHQgPSB3aW5kb3cuVGV4dCxcbiAgICAgIENvbW1lbnQgPSB3aW5kb3cuQ29tbWVudCxcbiAgICAgIERPTVBhcnNlciA9IHdpbmRvdy5ET01QYXJzZXIsXG4gICAgICB0cnVzdGVkVHlwZXMgPSB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuXG5cbiAgdmFyIEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcblxuICB2YXIgY2xvbmVOb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjbG9uZU5vZGUnKTtcbiAgdmFyIGdldE5leHRTaWJsaW5nID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICduZXh0U2libGluZycpO1xuICB2YXIgZ2V0Q2hpbGROb2RlcyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2hpbGROb2RlcycpO1xuICB2YXIgZ2V0UGFyZW50Tm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAncGFyZW50Tm9kZScpO1xuXG4gIC8vIEFzIHBlciBpc3N1ZSAjNDcsIHRoZSB3ZWItY29tcG9uZW50cyByZWdpc3RyeSBpcyBpbmhlcml0ZWQgYnkgYVxuICAvLyBuZXcgZG9jdW1lbnQgY3JlYXRlZCB2aWEgY3JlYXRlSFRNTERvY3VtZW50LiBBcyBwZXIgdGhlIHNwZWNcbiAgLy8gKGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2NyZWF0aW5nLWFuZC1wYXNzaW5nLXJlZ2lzdHJpZXMpXG4gIC8vIGEgbmV3IGVtcHR5IHJlZ2lzdHJ5IGlzIHVzZWQgd2hlbiBjcmVhdGluZyBhIHRlbXBsYXRlIGNvbnRlbnRzIG93bmVyXG4gIC8vIGRvY3VtZW50LCBzbyB3ZSB1c2UgdGhhdCBhcyBvdXIgcGFyZW50IGRvY3VtZW50IHRvIGVuc3VyZSBub3RoaW5nXG4gIC8vIGlzIGluaGVyaXRlZC5cbiAgaWYgKHR5cGVvZiBIVE1MVGVtcGxhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICBpZiAodGVtcGxhdGUuY29udGVudCAmJiB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQpIHtcbiAgICAgIGRvY3VtZW50ID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgfVxuXG4gIHZhciB0cnVzdGVkVHlwZXNQb2xpY3kgPSBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgb3JpZ2luYWxEb2N1bWVudCk7XG4gIHZhciBlbXB0eUhUTUwgPSB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKSA6ICcnO1xuXG4gIHZhciBfZG9jdW1lbnQgPSBkb2N1bWVudCxcbiAgICAgIGltcGxlbWVudGF0aW9uID0gX2RvY3VtZW50LmltcGxlbWVudGF0aW9uLFxuICAgICAgY3JlYXRlTm9kZUl0ZXJhdG9yID0gX2RvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcixcbiAgICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCxcbiAgICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lID0gX2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lO1xuICB2YXIgaW1wb3J0Tm9kZSA9IG9yaWdpbmFsRG9jdW1lbnQuaW1wb3J0Tm9kZTtcblxuXG4gIHZhciBkb2N1bWVudE1vZGUgPSB7fTtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudE1vZGUgPSBjbG9uZShkb2N1bWVudCkuZG9jdW1lbnRNb2RlID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDoge307XG4gIH0gY2F0Y2ggKF8pIHt9XG5cbiAgdmFyIGhvb2tzID0ge307XG5cbiAgLyoqXG4gICAqIEV4cG9zZSB3aGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBydW5uaW5nIHRoZSBmdWxsIERPTVB1cmlmeS5cbiAgICovXG4gIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IHR5cGVvZiBnZXRQYXJlbnROb2RlID09PSAnZnVuY3Rpb24nICYmIGltcGxlbWVudGF0aW9uICYmIHR5cGVvZiBpbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50TW9kZSAhPT0gOTtcblxuICB2YXIgTVVTVEFDSEVfRVhQUiQkMSA9IE1VU1RBQ0hFX0VYUFIsXG4gICAgICBFUkJfRVhQUiQkMSA9IEVSQl9FWFBSLFxuICAgICAgREFUQV9BVFRSJCQxID0gREFUQV9BVFRSLFxuICAgICAgQVJJQV9BVFRSJCQxID0gQVJJQV9BVFRSLFxuICAgICAgSVNfU0NSSVBUX09SX0RBVEEkJDEgPSBJU19TQ1JJUFRfT1JfREFUQSxcbiAgICAgIEFUVFJfV0hJVEVTUEFDRSQkMSA9IEFUVFJfV0hJVEVTUEFDRTtcbiAgdmFyIElTX0FMTE9XRURfVVJJJCQxID0gSVNfQUxMT1dFRF9VUkk7XG5cbiAgLyoqXG4gICAqIFdlIGNvbnNpZGVyIHRoZSBlbGVtZW50cyBhbmQgYXR0cmlidXRlcyBiZWxvdyB0byBiZSBzYWZlLiBJZGVhbGx5XG4gICAqIGRvbid0IGFkZCBhbnkgbmV3IG9uZXMgYnV0IGZlZWwgZnJlZSB0byByZW1vdmUgdW53YW50ZWQgb25lcy5cbiAgICovXG5cbiAgLyogYWxsb3dlZCBlbGVtZW50IG5hbWVzICovXG5cbiAgdmFyIEFMTE9XRURfVEFHUyA9IG51bGw7XG4gIHZhciBERUZBVUxUX0FMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEoaHRtbCQyKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnRmlsdGVycyksIF90b0NvbnN1bWFibGVBcnJheSQxKG1hdGhNbCksIF90b0NvbnN1bWFibGVBcnJheSQxKHRleHQpKSk7XG5cbiAgLyogQWxsb3dlZCBhdHRyaWJ1dGUgbmFtZXMgKi9cbiAgdmFyIEFMTE9XRURfQVRUUiA9IG51bGw7XG4gIHZhciBERUZBVUxUX0FMTE9XRURfQVRUUiA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEoaHRtbCQxJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShzdmckMSksIF90b0NvbnN1bWFibGVBcnJheSQxKG1hdGhNbCQxKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoeG1sKSkpO1xuXG4gIC8qIEV4cGxpY2l0bHkgZm9yYmlkZGVuIHRhZ3MgKG92ZXJyaWRlcyBBTExPV0VEX1RBR1MvQUREX1RBR1MpICovXG4gIHZhciBGT1JCSURfVEFHUyA9IG51bGw7XG5cbiAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gYXR0cmlidXRlcyAob3ZlcnJpZGVzIEFMTE9XRURfQVRUUi9BRERfQVRUUikgKi9cbiAgdmFyIEZPUkJJRF9BVFRSID0gbnVsbDtcblxuICAvKiBEZWNpZGUgaWYgQVJJQSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gIHZhciBBTExPV19BUklBX0FUVFIgPSB0cnVlO1xuXG4gIC8qIERlY2lkZSBpZiBjdXN0b20gZGF0YSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gIHZhciBBTExPV19EQVRBX0FUVFIgPSB0cnVlO1xuXG4gIC8qIERlY2lkZSBpZiB1bmtub3duIHByb3RvY29scyBhcmUgb2theSAqL1xuICB2YXIgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBmYWxzZTtcblxuICAvKiBPdXRwdXQgc2hvdWxkIGJlIHNhZmUgZm9yIGNvbW1vbiB0ZW1wbGF0ZSBlbmdpbmVzLlxuICAgKiBUaGlzIG1lYW5zLCBET01QdXJpZnkgcmVtb3ZlcyBkYXRhIGF0dHJpYnV0ZXMsIG11c3RhY2hlcyBhbmQgRVJCXG4gICAqL1xuICB2YXIgU0FGRV9GT1JfVEVNUExBVEVTID0gZmFsc2U7XG5cbiAgLyogRGVjaWRlIGlmIGRvY3VtZW50IHdpdGggPGh0bWw+Li4uIHNob3VsZCBiZSByZXR1cm5lZCAqL1xuICB2YXIgV0hPTEVfRE9DVU1FTlQgPSBmYWxzZTtcblxuICAvKiBUcmFjayB3aGV0aGVyIGNvbmZpZyBpcyBhbHJlYWR5IHNldCBvbiB0aGlzIGluc3RhbmNlIG9mIERPTVB1cmlmeS4gKi9cbiAgdmFyIFNFVF9DT05GSUcgPSBmYWxzZTtcblxuICAvKiBEZWNpZGUgaWYgYWxsIGVsZW1lbnRzIChlLmcuIHN0eWxlLCBzY3JpcHQpIG11c3QgYmUgY2hpbGRyZW4gb2ZcbiAgICogZG9jdW1lbnQuYm9keS4gQnkgZGVmYXVsdCwgYnJvd3NlcnMgbWlnaHQgbW92ZSB0aGVtIHRvIGRvY3VtZW50LmhlYWQgKi9cbiAgdmFyIEZPUkNFX0JPRFkgPSBmYWxzZTtcblxuICAvKiBEZWNpZGUgaWYgYSBET00gYEhUTUxCb2R5RWxlbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgKiBzdHJpbmcgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkuXG4gICAqIElmIGBXSE9MRV9ET0NVTUVOVGAgaXMgZW5hYmxlZCBhIGBIVE1MSHRtbEVsZW1lbnRgIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZFxuICAgKi9cbiAgdmFyIFJFVFVSTl9ET00gPSBmYWxzZTtcblxuICAvKiBEZWNpZGUgaWYgYSBET00gYERvY3VtZW50RnJhZ21lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICogc3RyaW5nICAob3IgYSBUcnVzdGVkSFRNTCBvYmplY3QgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgc3VwcG9ydGVkKSAqL1xuICB2YXIgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGZhbHNlO1xuXG4gIC8qIElmIGBSRVRVUk5fRE9NYCBvciBgUkVUVVJOX0RPTV9GUkFHTUVOVGAgaXMgZW5hYmxlZCwgZGVjaWRlIGlmIHRoZSByZXR1cm5lZCBET01cbiAgICogYE5vZGVgIGlzIGltcG9ydGVkIGludG8gdGhlIGN1cnJlbnQgYERvY3VtZW50YC4gSWYgdGhpcyBmbGFnIGlzIG5vdCBlbmFibGVkIHRoZVxuICAgKiBgTm9kZWAgd2lsbCBiZWxvbmcgKGl0cyBvd25lckRvY3VtZW50KSB0byBhIGZyZXNoIGBIVE1MRG9jdW1lbnRgLCBjcmVhdGVkIGJ5XG4gICAqIERPTVB1cmlmeS5cbiAgICpcbiAgICogVGhpcyBkZWZhdWx0cyB0byBgdHJ1ZWAgc3RhcnRpbmcgRE9NUHVyaWZ5IDIuMi4wLiBOb3RlIHRoYXQgc2V0dGluZyBpdCB0byBgZmFsc2VgXG4gICAqIG1pZ2h0IGNhdXNlIFhTUyBmcm9tIGF0dGFja3MgaGlkZGVuIGluIGNsb3NlZCBzaGFkb3dyb290cyBpbiBjYXNlIHRoZSBicm93c2VyXG4gICAqIHN1cHBvcnRzIERlY2xhcmF0aXZlIFNoYWRvdzogRE9NIGh0dHBzOi8vd2ViLmRldi9kZWNsYXJhdGl2ZS1zaGFkb3ctZG9tL1xuICAgKi9cbiAgdmFyIFJFVFVSTl9ET01fSU1QT1JUID0gdHJ1ZTtcblxuICAvKiBUcnkgdG8gcmV0dXJuIGEgVHJ1c3RlZCBUeXBlIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nLCByZXR1cm4gYSBzdHJpbmcgaW5cbiAgICogY2FzZSBUcnVzdGVkIFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkICAqL1xuICB2YXIgUkVUVVJOX1RSVVNURURfVFlQRSA9IGZhbHNlO1xuXG4gIC8qIE91dHB1dCBzaG91bGQgYmUgZnJlZSBmcm9tIERPTSBjbG9iYmVyaW5nIGF0dGFja3M/ICovXG4gIHZhciBTQU5JVElaRV9ET00gPSB0cnVlO1xuXG4gIC8qIEtlZXAgZWxlbWVudCBjb250ZW50IHdoZW4gcmVtb3ZpbmcgZWxlbWVudD8gKi9cbiAgdmFyIEtFRVBfQ09OVEVOVCA9IHRydWU7XG5cbiAgLyogSWYgYSBgTm9kZWAgaXMgcGFzc2VkIHRvIHNhbml0aXplKCksIHRoZW4gcGVyZm9ybXMgc2FuaXRpemF0aW9uIGluLXBsYWNlIGluc3RlYWRcbiAgICogb2YgaW1wb3J0aW5nIGl0IGludG8gYSBuZXcgRG9jdW1lbnQgYW5kIHJldHVybmluZyBhIHNhbml0aXplZCBjb3B5ICovXG4gIHZhciBJTl9QTEFDRSA9IGZhbHNlO1xuXG4gIC8qIEFsbG93IHVzYWdlIG9mIHByb2ZpbGVzIGxpa2UgaHRtbCwgc3ZnIGFuZCBtYXRoTWwgKi9cbiAgdmFyIFVTRV9QUk9GSUxFUyA9IHt9O1xuXG4gIC8qIFRhZ3MgdG8gaWdub3JlIGNvbnRlbnQgb2Ygd2hlbiBLRUVQX0NPTlRFTlQgaXMgdHJ1ZSAqL1xuICB2YXIgRk9SQklEX0NPTlRFTlRTID0gbnVsbDtcbiAgdmFyIERFRkFVTFRfRk9SQklEX0NPTlRFTlRTID0gYWRkVG9TZXQoe30sIFsnYW5ub3RhdGlvbi14bWwnLCAnYXVkaW8nLCAnY29sZ3JvdXAnLCAnZGVzYycsICdmb3JlaWdub2JqZWN0JywgJ2hlYWQnLCAnaWZyYW1lJywgJ21hdGgnLCAnbWknLCAnbW4nLCAnbW8nLCAnbXMnLCAnbXRleHQnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdwbGFpbnRleHQnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3N2ZycsICd0ZW1wbGF0ZScsICd0aGVhZCcsICd0aXRsZScsICd2aWRlbycsICd4bXAnXSk7XG5cbiAgLyogVGFncyB0aGF0IGFyZSBzYWZlIGZvciBkYXRhOiBVUklzICovXG4gIHZhciBEQVRBX1VSSV9UQUdTID0gbnVsbDtcbiAgdmFyIERFRkFVTFRfREFUQV9VUklfVEFHUyA9IGFkZFRvU2V0KHt9LCBbJ2F1ZGlvJywgJ3ZpZGVvJywgJ2ltZycsICdzb3VyY2UnLCAnaW1hZ2UnLCAndHJhY2snXSk7XG5cbiAgLyogQXR0cmlidXRlcyBzYWZlIGZvciB2YWx1ZXMgbGlrZSBcImphdmFzY3JpcHQ6XCIgKi9cbiAgdmFyIFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsO1xuICB2YXIgREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTID0gYWRkVG9TZXQoe30sIFsnYWx0JywgJ2NsYXNzJywgJ2ZvcicsICdpZCcsICdsYWJlbCcsICduYW1lJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncm9sZScsICdzdW1tYXJ5JywgJ3RpdGxlJywgJ3ZhbHVlJywgJ3N0eWxlJywgJ3htbG5zJ10pO1xuXG4gIHZhciBNQVRITUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xuICB2YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIHZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgLyogRG9jdW1lbnQgbmFtZXNwYWNlICovXG4gIHZhciBOQU1FU1BBQ0UgPSBIVE1MX05BTUVTUEFDRTtcbiAgdmFyIElTX0VNUFRZX0lOUFVUID0gZmFsc2U7XG5cbiAgLyogUGFyc2luZyBvZiBzdHJpY3QgWEhUTUwgZG9jdW1lbnRzICovXG4gIHZhciBQQVJTRVJfTUVESUFfVFlQRSA9IHZvaWQgMDtcbiAgdmFyIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMgPSBbJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcsICd0ZXh0L2h0bWwnXTtcbiAgdmFyIERFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUgPSAndGV4dC9odG1sJztcbiAgdmFyIHRyYW5zZm9ybUNhc2VGdW5jID0gdm9pZCAwO1xuXG4gIC8qIEtlZXAgYSByZWZlcmVuY2UgdG8gY29uZmlnIHRvIHBhc3MgdG8gaG9va3MgKi9cbiAgdmFyIENPTkZJRyA9IG51bGw7XG5cbiAgLyogSWRlYWxseSwgZG8gbm90IHRvdWNoIGFueXRoaW5nIGJlbG93IHRoaXMgbGluZSAqL1xuICAvKiBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fICovXG5cbiAgdmFyIGZvcm1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuXG4gIC8qKlxuICAgKiBfcGFyc2VDb25maWdcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjZmcgb3B0aW9uYWwgY29uZmlnIGxpdGVyYWxcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIHZhciBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcoY2ZnKSB7XG4gICAgaWYgKENPTkZJRyAmJiBDT05GSUcgPT09IGNmZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHRhbXBlcmluZyAqL1xuICAgIGlmICghY2ZnIHx8ICh0eXBlb2YgY2ZnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjZmcpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHByb3RvdHlwZSBwb2xsdXRpb24gKi9cbiAgICBjZmcgPSBjbG9uZShjZmcpO1xuXG4gICAgLyogU2V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuICAgIEFMTE9XRURfVEFHUyA9ICdBTExPV0VEX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9UQUdTKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgIEFMTE9XRURfQVRUUiA9ICdBTExPV0VEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9BVFRSKSA6IERFRkFVTFRfQUxMT1dFRF9BVFRSO1xuICAgIFVSSV9TQUZFX0FUVFJJQlVURVMgPSAnQUREX1VSSV9TQUZFX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KGNsb25lKERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyksIGNmZy5BRERfVVJJX1NBRkVfQVRUUikgOiBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVM7XG4gICAgREFUQV9VUklfVEFHUyA9ICdBRERfREFUQV9VUklfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgY2ZnLkFERF9EQVRBX1VSSV9UQUdTKSA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICBGT1JCSURfQ09OVEVOVFMgPSAnRk9SQklEX0NPTlRFTlRTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9DT05URU5UUykgOiBERUZBVUxUX0ZPUkJJRF9DT05URU5UUztcbiAgICBGT1JCSURfVEFHUyA9ICdGT1JCSURfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfVEFHUykgOiB7fTtcbiAgICBGT1JCSURfQVRUUiA9ICdGT1JCSURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQVRUUikgOiB7fTtcbiAgICBVU0VfUFJPRklMRVMgPSAnVVNFX1BST0ZJTEVTJyBpbiBjZmcgPyBjZmcuVVNFX1BST0ZJTEVTIDogZmFsc2U7XG4gICAgQUxMT1dfQVJJQV9BVFRSID0gY2ZnLkFMTE9XX0FSSUFfQVRUUiAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIEFMTE9XX0RBVEFfQVRUUiA9IGNmZy5BTExPV19EQVRBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGNmZy5BTExPV19VTktOT1dOX1BST1RPQ09MUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGNmZy5TQUZFX0ZPUl9URU1QTEFURVMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBXSE9MRV9ET0NVTUVOVCA9IGNmZy5XSE9MRV9ET0NVTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET00gPSBjZmcuUkVUVVJOX0RPTSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET01fRlJBR01FTlQgPSBjZmcuUkVUVVJOX0RPTV9GUkFHTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET01fSU1QT1JUID0gY2ZnLlJFVFVSTl9ET01fSU1QT1JUICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgUkVUVVJOX1RSVVNURURfVFlQRSA9IGNmZy5SRVRVUk5fVFJVU1RFRF9UWVBFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgRk9SQ0VfQk9EWSA9IGNmZy5GT1JDRV9CT0RZIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgU0FOSVRJWkVfRE9NID0gY2ZnLlNBTklUSVpFX0RPTSAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIEtFRVBfQ09OVEVOVCA9IGNmZy5LRUVQX0NPTlRFTlQgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBJTl9QTEFDRSA9IGNmZy5JTl9QTEFDRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIElTX0FMTE9XRURfVVJJJCQxID0gY2ZnLkFMTE9XRURfVVJJX1JFR0VYUCB8fCBJU19BTExPV0VEX1VSSSQkMTtcbiAgICBOQU1FU1BBQ0UgPSBjZmcuTkFNRVNQQUNFIHx8IEhUTUxfTkFNRVNQQUNFO1xuXG4gICAgUEFSU0VSX01FRElBX1RZUEUgPVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMuaW5kZXhPZihjZmcuUEFSU0VSX01FRElBX1RZUEUpID09PSAtMSA/IFBBUlNFUl9NRURJQV9UWVBFID0gREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA6IFBBUlNFUl9NRURJQV9UWVBFID0gY2ZnLlBBUlNFUl9NRURJQV9UWVBFO1xuXG4gICAgLy8gSFRNTCB0YWdzIGFuZCBhdHRyaWJ1dGVzIGFyZSBub3QgY2FzZS1zZW5zaXRpdmUsIGNvbnZlcnRpbmcgdG8gbG93ZXJjYXNlLiBLZWVwaW5nIFhIVE1MIGFzIGlzLlxuICAgIHRyYW5zZm9ybUNhc2VGdW5jID0gUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0gOiBzdHJpbmdUb0xvd2VyQ2FzZTtcblxuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgIEFMTE9XX0RBVEFfQVRUUiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICBSRVRVUk5fRE9NID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBQYXJzZSBwcm9maWxlIGluZm8gKi9cbiAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICBBTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSQxKHRleHQpKSk7XG4gICAgICBBTExPV0VEX0FUVFIgPSBbXTtcbiAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGh0bWwkMik7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgaHRtbCQxJDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2ZyA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Zyk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnJDEpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnRmlsdGVycyA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Z0ZpbHRlcnMpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2ZyQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIG1hdGhNbCk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgbWF0aE1sJDEpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogTWVyZ2UgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgaWYgKGNmZy5BRERfVEFHUykge1xuICAgICAgaWYgKEFMTE9XRURfVEFHUyA9PT0gREVGQVVMVF9BTExPV0VEX1RBR1MpIHtcbiAgICAgICAgQUxMT1dFRF9UQUdTID0gY2xvbmUoQUxMT1dFRF9UQUdTKTtcbiAgICAgIH1cblxuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBjZmcuQUREX1RBR1MpO1xuICAgIH1cblxuICAgIGlmIChjZmcuQUREX0FUVFIpIHtcbiAgICAgIGlmIChBTExPV0VEX0FUVFIgPT09IERFRkFVTFRfQUxMT1dFRF9BVFRSKSB7XG4gICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICB9XG5cbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgY2ZnLkFERF9BVFRSKTtcbiAgICB9XG5cbiAgICBpZiAoY2ZnLkFERF9VUklfU0FGRV9BVFRSKSB7XG4gICAgICBhZGRUb1NldChVUklfU0FGRV9BVFRSSUJVVEVTLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIpO1xuICAgIH1cblxuICAgIGlmIChjZmcuRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICBpZiAoRk9SQklEX0NPTlRFTlRTID09PSBERUZBVUxUX0ZPUkJJRF9DT05URU5UUykge1xuICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSBjbG9uZShGT1JCSURfQ09OVEVOVFMpO1xuICAgICAgfVxuXG4gICAgICBhZGRUb1NldChGT1JCSURfQ09OVEVOVFMsIGNmZy5GT1JCSURfQ09OVEVOVFMpO1xuICAgIH1cblxuICAgIC8qIEFkZCAjdGV4dCBpbiBjYXNlIEtFRVBfQ09OVEVOVCBpcyBzZXQgdG8gdHJ1ZSAqL1xuICAgIGlmIChLRUVQX0NPTlRFTlQpIHtcbiAgICAgIEFMTE9XRURfVEFHU1snI3RleHQnXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyogQWRkIGh0bWwsIGhlYWQgYW5kIGJvZHkgdG8gQUxMT1dFRF9UQUdTIGluIGNhc2UgV0hPTEVfRE9DVU1FTlQgaXMgdHJ1ZSAqL1xuICAgIGlmIChXSE9MRV9ET0NVTUVOVCkge1xuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ2h0bWwnLCAnaGVhZCcsICdib2R5J10pO1xuICAgIH1cblxuICAgIC8qIEFkZCB0Ym9keSB0byBBTExPV0VEX1RBR1MgaW4gY2FzZSB0YWJsZXMgYXJlIHBlcm1pdHRlZCwgc2VlICMyODYsICMzNjUgKi9cbiAgICBpZiAoQUxMT1dFRF9UQUdTLnRhYmxlKSB7XG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsndGJvZHknXSk7XG4gICAgICBkZWxldGUgRk9SQklEX1RBR1MudGJvZHk7XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBmdXJ0aGVyIG1hbmlwdWxhdGlvbiBvZiBjb25maWd1cmF0aW9uLlxuICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSUU4LCBTYWZhcmkgNSwgZXRjLlxuICAgIGlmIChmcmVlemUpIHtcbiAgICAgIGZyZWV6ZShjZmcpO1xuICAgIH1cblxuICAgIENPTkZJRyA9IGNmZztcbiAgfTtcblxuICB2YXIgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnbWknLCAnbW8nLCAnbW4nLCAnbXMnLCAnbXRleHQnXSk7XG5cbiAgdmFyIEhUTUxfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnZm9yZWlnbm9iamVjdCcsICdkZXNjJywgJ3RpdGxlJywgJ2Fubm90YXRpb24teG1sJ10pO1xuXG4gIC8qIEtlZXAgdHJhY2sgb2YgYWxsIHBvc3NpYmxlIFNWRyBhbmQgTWF0aE1MIHRhZ3NcbiAgICogc28gdGhhdCB3ZSBjYW4gcGVyZm9ybSB0aGUgbmFtZXNwYWNlIGNoZWNrc1xuICAgKiBjb3JyZWN0bHkuICovXG4gIHZhciBBTExfU1ZHX1RBR1MgPSBhZGRUb1NldCh7fSwgc3ZnKTtcbiAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdEaXNhbGxvd2VkKTtcblxuICB2YXIgQUxMX01BVEhNTF9UQUdTID0gYWRkVG9TZXQoe30sIG1hdGhNbCk7XG4gIGFkZFRvU2V0KEFMTF9NQVRITUxfVEFHUywgbWF0aE1sRGlzYWxsb3dlZCk7XG5cbiAgLyoqXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgYSBET00gZWxlbWVudCB3aG9zZSBuYW1lc3BhY2UgaXMgYmVpbmcgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIGZhbHNlIGlmIHRoZSBlbGVtZW50IGhhcyBhXG4gICAqICBuYW1lc3BhY2UgdGhhdCBhIHNwZWMtY29tcGxpYW50IHBhcnNlciB3b3VsZCBuZXZlclxuICAgKiAgcmV0dXJuLiBSZXR1cm4gdHJ1ZSBvdGhlcndpc2UuXG4gICAqL1xuICB2YXIgX2NoZWNrVmFsaWROYW1lc3BhY2UgPSBmdW5jdGlvbiBfY2hlY2tWYWxpZE5hbWVzcGFjZShlbGVtZW50KSB7XG4gICAgdmFyIHBhcmVudCA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgICAvLyBJbiBKU0RPTSwgaWYgd2UncmUgaW5zaWRlIHNoYWRvdyBET00sIHRoZW4gcGFyZW50Tm9kZVxuICAgIC8vIGNhbiBiZSBudWxsLiBXZSBqdXN0IHNpbXVsYXRlIHBhcmVudCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50YWdOYW1lKSB7XG4gICAgICBwYXJlbnQgPSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSTogSFRNTF9OQU1FU1BBQ0UsXG4gICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50LnRhZ05hbWUpO1xuICAgIHZhciBwYXJlbnRUYWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UocGFyZW50LnRhZ05hbWUpO1xuXG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gU1ZHXG4gICAgICAvLyBpcyB2aWEgPHN2Zz4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gTWF0aE1MIHRvIFNWRyBpcyB2aWFcbiAgICAgIC8vIHN2ZyBpZiBwYXJlbnQgaXMgZWl0aGVyIDxhbm5vdGF0aW9uLXhtbD4gb3IgTWF0aE1MXG4gICAgICAvLyB0ZXh0IGludGVncmF0aW9uIHBvaW50cy5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJyAmJiAocGFyZW50VGFnTmFtZSA9PT0gJ2Fubm90YXRpb24teG1sJyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gU1ZHXG4gICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIFNWRyBuYW1lc3BhY2UuXG4gICAgICByZXR1cm4gQm9vbGVhbihBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIE1hdGhNTFxuICAgICAgLy8gaXMgdmlhIDxtYXRoPi4gSWYgaXQgaGFwcGVucyB2aWEgYW55IG90aGVyIHRhZywgdGhlblxuICAgICAgLy8gaXQgc2hvdWxkIGJlIGtpbGxlZC5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ21hdGgnO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIE1hdGhNTCBpcyB2aWFcbiAgICAgIC8vIDxtYXRoPiBhbmQgSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCcgJiYgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIG9ubHkgYWxsb3cgZWxlbWVudHMgdGhhdCBhcmUgZGVmaW5lZCBpbiBNYXRoTUxcbiAgICAgIC8vIHNwZWMuIEFsbCBvdGhlcnMgYXJlIGRpc2FsbG93ZWQgaW4gTWF0aE1MIG5hbWVzcGFjZS5cbiAgICAgIHJldHVybiBCb29sZWFuKEFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIFNWRyB0byBIVE1MIGlzIHZpYVxuICAgICAgLy8gSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHMsIGFuZCBmcm9tIE1hdGhNTCB0byBIVE1MXG4gICAgICAvLyBpcyB2aWEgTWF0aE1MIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSAmJiAhSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSAmJiAhTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2VydGFpbiBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiBib3RoIFNWRyBhbmQgSFRNTFxuICAgICAgLy8gbmFtZXNwYWNlLiBXZSBuZWVkIHRvIHNwZWNpZnkgdGhlbSBleHBsaWNpdGx5XG4gICAgICAvLyBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IGVycm9ub3VzbHkgZGVsZXRlZCBmcm9tXG4gICAgICAvLyBIVE1MIG5hbWVzcGFjZS5cbiAgICAgIHZhciBjb21tb25TdmdBbmRIVE1MRWxlbWVudHMgPSBhZGRUb1NldCh7fSwgWyd0aXRsZScsICdzdHlsZScsICdmb250JywgJ2EnLCAnc2NyaXB0J10pO1xuXG4gICAgICAvLyBXZSBkaXNhbGxvdyB0YWdzIHRoYXQgYXJlIHNwZWNpZmljIGZvciBNYXRoTUxcbiAgICAgIC8vIG9yIFNWRyBhbmQgc2hvdWxkIG5ldmVyIGFwcGVhciBpbiBIVE1MIG5hbWVzcGFjZVxuICAgICAgcmV0dXJuICFBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0gJiYgKGNvbW1vblN2Z0FuZEhUTUxFbGVtZW50c1t0YWdOYW1lXSB8fCAhQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgY29kZSBzaG91bGQgbmV2ZXIgcmVhY2ggdGhpcyBwbGFjZSAodGhpcyBtZWFuc1xuICAgIC8vIHRoYXQgdGhlIGVsZW1lbnQgc29tZWhvdyBnb3QgbmFtZXNwYWNlIHRoYXQgaXMgbm90XG4gICAgLy8gSFRNTCwgU1ZHIG9yIE1hdGhNTCkuIFJldHVybiBmYWxzZSBqdXN0IGluIGNhc2UuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfZm9yY2VSZW1vdmVcbiAgICpcbiAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBhIERPTSBub2RlXG4gICAqL1xuICB2YXIgX2ZvcmNlUmVtb3ZlID0gZnVuY3Rpb24gX2ZvcmNlUmVtb3ZlKG5vZGUpIHtcbiAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogbm9kZSB9KTtcbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLXJlbW92ZVxuICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vZGUub3V0ZXJIVE1MID0gZW1wdHlIVE1MO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogX3JlbW92ZUF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgYW4gQXR0cmlidXRlIG5hbWVcbiAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBhIERPTSBub2RlXG4gICAqL1xuICB2YXIgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgbm9kZSkge1xuICAgIHRyeSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgYXR0cmlidXRlOiBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgIGZyb206IG5vZGVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgIGZyb206IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXG4gICAgLy8gV2Ugdm9pZCBhdHRyaWJ1dGUgdmFsdWVzIGZvciB1bnJlbW92YWJsZSBcImlzXCJcIiBhdHRyaWJ1dGVzXG4gICAgaWYgKG5hbWUgPT09ICdpcycgJiYgIUFMTE9XRURfQVRUUltuYW1lXSkge1xuICAgICAgaWYgKFJFVFVSTl9ET00gfHwgUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShub2RlKTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogX2luaXREb2N1bWVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcnR5IGEgc3RyaW5nIG9mIGRpcnR5IG1hcmt1cFxuICAgKiBAcmV0dXJuIHtEb2N1bWVudH0gYSBET00sIGZpbGxlZCB3aXRoIHRoZSBkaXJ0eSBtYXJrdXBcbiAgICovXG4gIHZhciBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgIC8qIENyZWF0ZSBhIEhUTUwgZG9jdW1lbnQgKi9cbiAgICB2YXIgZG9jID0gdm9pZCAwO1xuICAgIHZhciBsZWFkaW5nV2hpdGVzcGFjZSA9IHZvaWQgMDtcblxuICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICBkaXJ0eSA9ICc8cmVtb3ZlPjwvcmVtb3ZlPicgKyBkaXJ0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSWYgRk9SQ0VfQk9EWSBpc24ndCB1c2VkLCBsZWFkaW5nIHdoaXRlc3BhY2UgbmVlZHMgdG8gYmUgcHJlc2VydmVkIG1hbnVhbGx5ICovXG4gICAgICB2YXIgbWF0Y2hlcyA9IHN0cmluZ01hdGNoKGRpcnR5LCAvXltcXHJcXG5cXHQgXSsvKTtcbiAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIGlmIChQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcpIHtcbiAgICAgIC8vIFJvb3Qgb2YgWEhUTUwgZG9jIG11c3QgY29udGFpbiB4bWxucyBkZWNsYXJhdGlvbiAoc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvbm9ybWF0aXZlLmh0bWwjc3RyaWN0KVxuICAgICAgZGlydHkgPSAnPGh0bWwgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI+PGhlYWQ+PC9oZWFkPjxib2R5PicgKyBkaXJ0eSArICc8L2JvZHk+PC9odG1sPic7XG4gICAgfVxuXG4gICAgdmFyIGRpcnR5UGF5bG9hZCA9IHRydXN0ZWRUeXBlc1BvbGljeSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKGRpcnR5KSA6IGRpcnR5O1xuICAgIC8qXG4gICAgICogVXNlIHRoZSBET01QYXJzZXIgQVBJIGJ5IGRlZmF1bHQsIGZhbGxiYWNrIGxhdGVyIGlmIG5lZWRzIGJlXG4gICAgICogRE9NUGFyc2VyIG5vdCB3b3JrIGZvciBzdmcgd2hlbiBoYXMgbXVsdGlwbGUgcm9vdCBlbGVtZW50LlxuICAgICAqL1xuICAgIGlmIChOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGRpcnR5UGF5bG9hZCwgUEFSU0VSX01FRElBX1RZUEUpO1xuICAgICAgfSBjYXRjaCAoXykge31cbiAgICB9XG5cbiAgICAvKiBVc2UgY3JlYXRlSFRNTERvY3VtZW50IGluIGNhc2UgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAgICBpZiAoIWRvYyB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gSVNfRU1QVFlfSU5QVVQgPyAnJyA6IGRpcnR5UGF5bG9hZDtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gU3ludGF4IGVycm9yIGlmIGRpcnR5UGF5bG9hZCBpcyBpbnZhbGlkIHhtbFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBib2R5ID0gZG9jLmJvZHkgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgIGlmIChkaXJ0eSAmJiBsZWFkaW5nV2hpdGVzcGFjZSkge1xuICAgICAgYm9keS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGVhZGluZ1doaXRlc3BhY2UpLCBib2R5LmNoaWxkTm9kZXNbMF0gfHwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyogV29yayBvbiB3aG9sZSBkb2N1bWVudCBvciBqdXN0IGl0cyBib2R5ICovXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBXSE9MRV9ET0NVTUVOVCA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBib2R5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBfY3JlYXRlSXRlcmF0b3JcbiAgICpcbiAgICogQHBhcmFtICB7RG9jdW1lbnR9IHJvb3QgZG9jdW1lbnQvZnJhZ21lbnQgdG8gY3JlYXRlIGl0ZXJhdG9yIGZvclxuICAgKiBAcmV0dXJuIHtJdGVyYXRvcn0gaXRlcmF0b3IgaW5zdGFuY2VcbiAgICovXG4gIHZhciBfY3JlYXRlSXRlcmF0b3IgPSBmdW5jdGlvbiBfY3JlYXRlSXRlcmF0b3Iocm9vdCkge1xuICAgIHJldHVybiBjcmVhdGVOb2RlSXRlcmF0b3IuY2FsbChyb290Lm93bmVyRG9jdW1lbnQgfHwgcm9vdCwgcm9vdCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19URVhULCBudWxsLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9pc0Nsb2JiZXJlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtOb2RlfSBlbG0gZWxlbWVudCB0byBjaGVjayBmb3IgY2xvYmJlcmluZyBhdHRhY2tzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY2xvYmJlcmVkLCBmYWxzZSBpZiBzYWZlXG4gICAqL1xuICB2YXIgX2lzQ2xvYmJlcmVkID0gZnVuY3Rpb24gX2lzQ2xvYmJlcmVkKGVsbSkge1xuICAgIGlmIChlbG0gaW5zdGFuY2VvZiBUZXh0IHx8IGVsbSBpbnN0YW5jZW9mIENvbW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVsbS5ub2RlTmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS50ZXh0Q29udGVudCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS5yZW1vdmVDaGlsZCAhPT0gJ2Z1bmN0aW9uJyB8fCAhKGVsbS5hdHRyaWJ1dGVzIGluc3RhbmNlb2YgTmFtZWROb2RlTWFwKSB8fCB0eXBlb2YgZWxtLnJlbW92ZUF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxtLnNldEF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxtLm5hbWVzcGFjZVVSSSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS5pbnNlcnRCZWZvcmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogX2lzTm9kZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOb2RlfSBvYmogb2JqZWN0IHRvIGNoZWNrIHdoZXRoZXIgaXQncyBhIERPTSBub2RlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaXMgb2JqZWN0IGlzIGEgRE9NIG5vZGVcbiAgICovXG4gIHZhciBfaXNOb2RlID0gZnVuY3Rpb24gX2lzTm9kZShvYmplY3QpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBOb2RlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihOb2RlKSkgPT09ICdvYmplY3QnID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IG9iamVjdCAmJiAodHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqZWN0KSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfZXhlY3V0ZUhvb2tcbiAgICogRXhlY3V0ZSB1c2VyIGNvbmZpZ3VyYWJsZSBob29rc1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVudHJ5UG9pbnQgIE5hbWUgb2YgdGhlIGhvb2sncyBlbnRyeSBwb2ludFxuICAgKiBAcGFyYW0gIHtOb2RlfSBjdXJyZW50Tm9kZSBub2RlIHRvIHdvcmsgb24gd2l0aCB0aGUgaG9va1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgYWRkaXRpb25hbCBob29rIHBhcmFtZXRlcnNcbiAgICovXG4gIHZhciBfZXhlY3V0ZUhvb2sgPSBmdW5jdGlvbiBfZXhlY3V0ZUhvb2soZW50cnlQb2ludCwgY3VycmVudE5vZGUsIGRhdGEpIHtcbiAgICBpZiAoIWhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXJyYXlGb3JFYWNoKGhvb2tzW2VudHJ5UG9pbnRdLCBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgaG9vay5jYWxsKERPTVB1cmlmeSwgY3VycmVudE5vZGUsIGRhdGEsIENPTkZJRyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9zYW5pdGl6ZUVsZW1lbnRzXG4gICAqXG4gICAqIEBwcm90ZWN0IG5vZGVOYW1lXG4gICAqIEBwcm90ZWN0IHRleHRDb250ZW50XG4gICAqIEBwcm90ZWN0IHJlbW92ZUNoaWxkXG4gICAqXG4gICAqIEBwYXJhbSAgIHtOb2RlfSBjdXJyZW50Tm9kZSB0byBjaGVjayBmb3IgcGVybWlzc2lvbiB0byBleGlzdFxuICAgKiBAcmV0dXJuICB7Qm9vbGVhbn0gdHJ1ZSBpZiBub2RlIHdhcyBraWxsZWQsIGZhbHNlIGlmIGxlZnQgYWxpdmVcbiAgICovXG4gIHZhciBfc2FuaXRpemVFbGVtZW50cyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB2b2lkIDA7XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuXG4gICAgLyogQ2hlY2sgaWYgZWxlbWVudCBpcyBjbG9iYmVyZWQgb3IgY2FuIGNsb2JiZXIgKi9cbiAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qIENoZWNrIGlmIHRhZ25hbWUgY29udGFpbnMgVW5pY29kZSAqL1xuICAgIGlmIChzdHJpbmdNYXRjaChjdXJyZW50Tm9kZS5ub2RlTmFtZSwgL1tcXHUwMDgwLVxcdUZGRkZdLykpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBOb3cgbGV0J3MgY2hlY2sgdGhlIGVsZW1lbnQncyB0eXBlIGFuZCBuYW1lICovXG4gICAgdmFyIHRhZ05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVFbGVtZW50JywgY3VycmVudE5vZGUsIHtcbiAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICBhbGxvd2VkVGFnczogQUxMT1dFRF9UQUdTXG4gICAgfSk7XG5cbiAgICAvKiBEZXRlY3QgbVhTUyBhdHRlbXB0cyBhYnVzaW5nIG5hbWVzcGFjZSBjb25mdXNpb24gKi9cbiAgICBpZiAoIV9pc05vZGUoY3VycmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpICYmICghX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50KSB8fCAhX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkKSkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyogTWl0aWdhdGUgYSBwcm9ibGVtIHdpdGggdGVtcGxhdGVzIGluc2lkZSBzZWxlY3QgKi9cbiAgICBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcgJiYgcmVnRXhwVGVzdCgvPHRlbXBsYXRlL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBSZW1vdmUgZWxlbWVudCBpZiBhbnl0aGluZyBmb3JiaWRzIGl0cyBwcmVzZW5jZSAqL1xuICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAvKiBLZWVwIGNvbnRlbnQgZXhjZXB0IGZvciBiYWQtbGlzdGVkIGVsZW1lbnRzICovXG4gICAgICBpZiAoS0VFUF9DT05URU5UICYmICFGT1JCSURfQ09OVEVOVFNbdGFnTmFtZV0pIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSkge1xuICAgICAgICAgIHZhciBjaGlsZENvdW50ID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZU5vZGUoY2hpbGROb2Rlc1tpXSwgdHJ1ZSksIGdldE5leHRTaWJsaW5nKGN1cnJlbnROb2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBDaGVjayB3aGV0aGVyIGVsZW1lbnQgaGFzIGEgdmFsaWQgbmFtZXNwYWNlICovXG4gICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhX2NoZWNrVmFsaWROYW1lc3BhY2UoY3VycmVudE5vZGUpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCh0YWdOYW1lID09PSAnbm9zY3JpcHQnIHx8IHRhZ05hbWUgPT09ICdub2VtYmVkJykgJiYgcmVnRXhwVGVzdCgvPFxcL25vKHNjcmlwdHxlbWJlZCkvaSwgY3VycmVudE5vZGUuaW5uZXJIVE1MKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qIFNhbml0aXplIGVsZW1lbnQgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUyAmJiBjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgLyogR2V0IHRoZSBlbGVtZW50J3MgdGV4dCBjb250ZW50ICovXG4gICAgICBjb250ZW50ID0gY3VycmVudE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBNVVNUQUNIRV9FWFBSJCQxLCAnICcpO1xuICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICBpZiAoY3VycmVudE5vZGUudGV4dENvbnRlbnQgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7IGVsZW1lbnQ6IGN1cnJlbnROb2RlLmNsb25lTm9kZSgpIH0pO1xuICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfaXNWYWxpZEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxjVGFnIExvd2VyY2FzZSB0YWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbGNOYW1lIExvd2VyY2FzZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICB2YXIgX2lzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkge1xuICAgIC8qIE1ha2Ugc3VyZSBhdHRyaWJ1dGUgY2Fubm90IGNsb2JiZXIgKi9cbiAgICBpZiAoU0FOSVRJWkVfRE9NICYmIChsY05hbWUgPT09ICdpZCcgfHwgbGNOYW1lID09PSAnbmFtZScpICYmICh2YWx1ZSBpbiBkb2N1bWVudCB8fCB2YWx1ZSBpbiBmb3JtRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiBBbGxvdyB2YWxpZCBkYXRhLSogYXR0cmlidXRlczogQXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhZnRlciBcIi1cIlxuICAgICAgICAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjZW1iZWRkaW5nLWN1c3RvbS1ub24tdmlzaWJsZS1kYXRhLXdpdGgtdGhlLWRhdGEtKi1hdHRyaWJ1dGVzKVxuICAgICAgICBYTUwtY29tcGF0aWJsZSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN4bWwtY29tcGF0aWJsZSBhbmQgaHR0cDovL3d3dy53My5vcmcvVFIveG1sLyNkMGU4MDQpXG4gICAgICAgIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgdGhlIHZhbHVlOyBpdCdzIGFsd2F5cyBVUkkgc2FmZS4gKi9cbiAgICBpZiAoQUxMT1dfREFUQV9BVFRSICYmICFGT1JCSURfQVRUUltsY05hbWVdICYmIHJlZ0V4cFRlc3QoREFUQV9BVFRSJCQxLCBsY05hbWUpKSA7IGVsc2UgaWYgKEFMTE9XX0FSSUFfQVRUUiAmJiByZWdFeHBUZXN0KEFSSUFfQVRUUiQkMSwgbGNOYW1lKSkgOyBlbHNlIGlmICghQUxMT1dFRF9BVFRSW2xjTmFtZV0gfHwgRk9SQklEX0FUVFJbbGNOYW1lXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvKiBDaGVjayB2YWx1ZSBpcyBzYWZlLiBGaXJzdCwgaXMgYXR0ciBpbmVydD8gSWYgc28sIGlzIHNhZmUgKi9cbiAgICB9IGVsc2UgaWYgKFVSSV9TQUZFX0FUVFJJQlVURVNbbGNOYW1lXSkgOyBlbHNlIGlmIChyZWdFeHBUZXN0KElTX0FMTE9XRURfVVJJJCQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UkJDEsICcnKSkpIDsgZWxzZSBpZiAoKGxjTmFtZSA9PT0gJ3NyYycgfHwgbGNOYW1lID09PSAneGxpbms6aHJlZicgfHwgbGNOYW1lID09PSAnaHJlZicpICYmIGxjVGFnICE9PSAnc2NyaXB0JyAmJiBzdHJpbmdJbmRleE9mKHZhbHVlLCAnZGF0YTonKSA9PT0gMCAmJiBEQVRBX1VSSV9UQUdTW2xjVGFnXSkgOyBlbHNlIGlmIChBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJiAhcmVnRXhwVGVzdChJU19TQ1JJUFRfT1JfREFUQSQkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJCQxLCAnJykpKSA7IGVsc2UgaWYgKCF2YWx1ZSkgOyBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogX3Nhbml0aXplQXR0cmlidXRlc1xuICAgKlxuICAgKiBAcHJvdGVjdCBhdHRyaWJ1dGVzXG4gICAqIEBwcm90ZWN0IG5vZGVOYW1lXG4gICAqIEBwcm90ZWN0IHJlbW92ZUF0dHJpYnV0ZVxuICAgKiBAcHJvdGVjdCBzZXRBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtICB7Tm9kZX0gY3VycmVudE5vZGUgdG8gc2FuaXRpemVcbiAgICovXG4gIHZhciBfc2FuaXRpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSkge1xuICAgIHZhciBhdHRyID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICB2YXIgbGNOYW1lID0gdm9pZCAwO1xuICAgIHZhciBsID0gdm9pZCAwO1xuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplQXR0cmlidXRlcycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gY3VycmVudE5vZGUuYXR0cmlidXRlcztcblxuICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYXR0cmlidXRlczsgaWYgbm90IHdlIG1pZ2h0IGhhdmUgYSB0ZXh0IG5vZGUgKi9cblxuICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBob29rRXZlbnQgPSB7XG4gICAgICBhdHRyTmFtZTogJycsXG4gICAgICBhdHRyVmFsdWU6ICcnLFxuICAgICAga2VlcEF0dHI6IHRydWUsXG4gICAgICBhbGxvd2VkQXR0cmlidXRlczogQUxMT1dFRF9BVFRSXG4gICAgfTtcbiAgICBsID0gYXR0cmlidXRlcy5sZW5ndGg7XG5cbiAgICAvKiBHbyBiYWNrd2FyZHMgb3ZlciBhbGwgYXR0cmlidXRlczsgc2FmZWx5IHJlbW92ZSBiYWQgb25lcyAqL1xuICAgIHdoaWxlIChsLS0pIHtcbiAgICAgIGF0dHIgPSBhdHRyaWJ1dGVzW2xdO1xuICAgICAgdmFyIF9hdHRyID0gYXR0cixcbiAgICAgICAgICBuYW1lID0gX2F0dHIubmFtZSxcbiAgICAgICAgICBuYW1lc3BhY2VVUkkgPSBfYXR0ci5uYW1lc3BhY2VVUkk7XG5cbiAgICAgIHZhbHVlID0gc3RyaW5nVHJpbShhdHRyLnZhbHVlKTtcbiAgICAgIGxjTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKG5hbWUpO1xuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBob29rRXZlbnQuYXR0ck5hbWUgPSBsY05hbWU7XG4gICAgICBob29rRXZlbnQuYXR0clZhbHVlID0gdmFsdWU7XG4gICAgICBob29rRXZlbnQua2VlcEF0dHIgPSB0cnVlO1xuICAgICAgaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIgPSB1bmRlZmluZWQ7IC8vIEFsbG93cyBkZXZlbG9wZXJzIHRvIHNlZSB0aGlzIGlzIGEgcHJvcGVydHkgdGhleSBjYW4gc2V0XG4gICAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZUF0dHJpYnV0ZScsIGN1cnJlbnROb2RlLCBob29rRXZlbnQpO1xuICAgICAgdmFsdWUgPSBob29rRXZlbnQuYXR0clZhbHVlO1xuICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG4gICAgICBpZiAoaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFJlbW92ZSBhdHRyaWJ1dGUgKi9cbiAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuXG4gICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGlmICghaG9va0V2ZW50LmtlZXBBdHRyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBXb3JrIGFyb3VuZCBhIHNlY3VyaXR5IGlzc3VlIGluIGpRdWVyeSAzLjAgKi9cbiAgICAgIGlmIChyZWdFeHBUZXN0KC9cXC8+L2ksIHZhbHVlKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFNhbml0aXplIGF0dHJpYnV0ZSBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBNVVNUQUNIRV9FWFBSJCQxLCAnICcpO1xuICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIEVSQl9FWFBSJCQxLCAnICcpO1xuICAgICAgfVxuXG4gICAgICAvKiBJcyBgdmFsdWVgIHZhbGlkIGZvciB0aGlzIGF0dHJpYnV0ZT8gKi9cbiAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgIGlmICghX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBIYW5kbGUgaW52YWxpZCBkYXRhLSogYXR0cmlidXRlIHNldCBieSB0cnktY2F0Y2hpbmcgaXQgKi9cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBGYWxsYmFjayB0byBzZXRBdHRyaWJ1dGUoKSBmb3IgYnJvd3Nlci11bnJlY29nbml6ZWQgbmFtZXNwYWNlcyBlLmcuIFwieC1zY2hlbWFcIi4gKi9cbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlQb3AoRE9NUHVyaWZ5LnJlbW92ZWQpO1xuICAgICAgfSBjYXRjaCAoXykge31cbiAgICB9XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplQXR0cmlidXRlcycsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogX3Nhbml0aXplU2hhZG93RE9NXG4gICAqXG4gICAqIEBwYXJhbSAge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdtZW50IHRvIGl0ZXJhdGUgb3ZlciByZWN1cnNpdmVseVxuICAgKi9cbiAgdmFyIF9zYW5pdGl6ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uIF9zYW5pdGl6ZVNoYWRvd0RPTShmcmFnbWVudCkge1xuICAgIHZhciBzaGFkb3dOb2RlID0gdm9pZCAwO1xuICAgIHZhciBzaGFkb3dJdGVyYXRvciA9IF9jcmVhdGVJdGVyYXRvcihmcmFnbWVudCk7XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZVNoYWRvd0RPTScsIGZyYWdtZW50LCBudWxsKTtcblxuICAgIHdoaWxlIChzaGFkb3dOb2RlID0gc2hhZG93SXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVTaGFkb3dOb2RlJywgc2hhZG93Tm9kZSwgbnVsbCk7XG5cbiAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICBpZiAoX3Nhbml0aXplRWxlbWVudHMoc2hhZG93Tm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIERlZXAgc2hhZG93IERPTSBkZXRlY3RlZCAqL1xuICAgICAgaWYgKHNoYWRvd05vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKHNoYWRvd05vZGUuY29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhzaGFkb3dOb2RlKTtcbiAgICB9XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplU2hhZG93RE9NJywgZnJhZ21lbnQsIG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTYW5pdGl6ZVxuICAgKiBQdWJsaWMgbWV0aG9kIHByb3ZpZGluZyBjb3JlIHNhbml0YXRpb24gZnVuY3Rpb25hbGl0eVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOb2RlfSBkaXJ0eSBzdHJpbmcgb3IgRE9NIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBET01QdXJpZnkuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGlydHksIGNmZykge1xuICAgIHZhciBib2R5ID0gdm9pZCAwO1xuICAgIHZhciBpbXBvcnRlZE5vZGUgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnROb2RlID0gdm9pZCAwO1xuICAgIHZhciBvbGROb2RlID0gdm9pZCAwO1xuICAgIHZhciByZXR1cm5Ob2RlID0gdm9pZCAwO1xuICAgIC8qIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc3RyaW5nIHRvIHNhbml0aXplLlxuICAgICAgRE8gTk9UIHJldHVybiBlYXJseSwgYXMgdGhpcyB3aWxsIHJldHVybiB0aGUgd3JvbmcgdHlwZSBpZlxuICAgICAgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBhIERPTSBvYmplY3QgcmF0aGVyIHRoYW4gYSBzdHJpbmcgKi9cbiAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcbiAgICBpZiAoSVNfRU1QVFlfSU5QVVQpIHtcbiAgICAgIGRpcnR5ID0gJzwhLS0+JztcbiAgICB9XG5cbiAgICAvKiBTdHJpbmdpZnksIGluIGNhc2UgZGlydHkgaXMgYW4gb2JqZWN0ICovXG4gICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycgJiYgIV9pc05vZGUoZGlydHkpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVnYXRlZC1jb25kaXRpb25cbiAgICAgIGlmICh0eXBlb2YgZGlydHkudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCd0b1N0cmluZyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlydHkgPSBkaXJ0eS50b1N0cmluZygpO1xuICAgICAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgnZGlydHkgaXMgbm90IGEgc3RyaW5nLCBhYm9ydGluZycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogQ2hlY2sgd2UgY2FuIHJ1bi4gT3RoZXJ3aXNlIGZhbGwgYmFjayBvciBpZ25vcmUgKi9cbiAgICBpZiAoIURPTVB1cmlmeS5pc1N1cHBvcnRlZCkge1xuICAgICAgaWYgKF90eXBlb2Yod2luZG93LnRvU3RhdGljSFRNTCkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB3aW5kb3cudG9TdGF0aWNIVE1MID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy50b1N0YXRpY0hUTUwoZGlydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9pc05vZGUoZGlydHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy50b1N0YXRpY0hUTUwoZGlydHkub3V0ZXJIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuXG4gICAgLyogQXNzaWduIGNvbmZpZyB2YXJzICovXG4gICAgaWYgKCFTRVRfQ09ORklHKSB7XG4gICAgICBfcGFyc2VDb25maWcoY2ZnKTtcbiAgICB9XG5cbiAgICAvKiBDbGVhbiB1cCByZW1vdmVkIGVsZW1lbnRzICovXG4gICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcblxuICAgIC8qIENoZWNrIGlmIGRpcnR5IGlzIGNvcnJlY3RseSB0eXBlZCBmb3IgSU5fUExBQ0UgKi9cbiAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoSU5fUExBQ0UpIDsgZWxzZSBpZiAoZGlydHkgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAvKiBJZiBkaXJ0eSBpcyBhIERPTSBlbGVtZW50LCBhcHBlbmQgdG8gYW4gZW1wdHkgZG9jdW1lbnQgdG8gYXZvaWRcbiAgICAgICAgIGVsZW1lbnRzIGJlaW5nIHN0cmlwcGVkIGJ5IHRoZSBwYXJzZXIgKi9cbiAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tLS0+Jyk7XG4gICAgICBpbXBvcnRlZE5vZGUgPSBib2R5Lm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShkaXJ0eSwgdHJ1ZSk7XG4gICAgICBpZiAoaW1wb3J0ZWROb2RlLm5vZGVUeXBlID09PSAxICYmIGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIC8qIE5vZGUgaXMgYWxyZWFkeSBhIGJvZHksIHVzZSBhcyBpcyAqL1xuICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGltcG9ydGVkTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIEV4aXQgZGlyZWN0bHkgaWYgd2UgaGF2ZSBub3RoaW5nIHRvIGRvICovXG4gICAgICBpZiAoIVJFVFVSTl9ET00gJiYgIVNBRkVfRk9SX1RFTVBMQVRFUyAmJiAhV0hPTEVfRE9DVU1FTlQgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgZGlydHkuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgIH1cblxuICAgICAgLyogSW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnQgdG8gd29yayBvbiAqL1xuICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoZGlydHkpO1xuXG4gICAgICAvKiBDaGVjayB3ZSBoYXZlIGEgRE9NIG5vZGUgZnJvbSB0aGUgZGF0YSAqL1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBSRVRVUk5fRE9NID8gbnVsbCA6IGVtcHR5SFRNTDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBSZW1vdmUgZmlyc3QgZWxlbWVudCBub2RlIChvdXJzKSBpZiBGT1JDRV9CT0RZIGlzIHNldCAqL1xuICAgIGlmIChib2R5ICYmIEZPUkNFX0JPRFkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShib2R5LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIC8qIEdldCBub2RlIGl0ZXJhdG9yICovXG4gICAgdmFyIG5vZGVJdGVyYXRvciA9IF9jcmVhdGVJdGVyYXRvcihJTl9QTEFDRSA/IGRpcnR5IDogYm9keSk7XG5cbiAgICAvKiBOb3cgc3RhcnQgaXRlcmF0aW5nIG92ZXIgdGhlIGNyZWF0ZWQgZG9jdW1lbnQgKi9cbiAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgLyogRml4IElFJ3Mgc3RyYW5nZSBiZWhhdmlvciB3aXRoIG1hbmlwdWxhdGVkIHRleHROb2RlcyAjODkgKi9cbiAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMyAmJiBjdXJyZW50Tm9kZSA9PT0gb2xkTm9kZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFNoYWRvdyBET00gZGV0ZWN0ZWQsIHNhbml0aXplIGl0ICovXG4gICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKGN1cnJlbnROb2RlLmNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICAvKiBDaGVjayBhdHRyaWJ1dGVzLCBzYW5pdGl6ZSBpZiBuZWNlc3NhcnkgKi9cbiAgICAgIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpO1xuXG4gICAgICBvbGROb2RlID0gY3VycmVudE5vZGU7XG4gICAgfVxuXG4gICAgb2xkTm9kZSA9IG51bGw7XG5cbiAgICAvKiBJZiB3ZSBzYW5pdGl6ZWQgYGRpcnR5YCBpbi1wbGFjZSwgcmV0dXJuIGl0LiAqL1xuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cblxuICAgIC8qIFJldHVybiBzYW5pdGl6ZWQgc3RyaW5nIG9yIERPTSAqL1xuICAgIGlmIChSRVRVUk5fRE9NKSB7XG4gICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICByZXR1cm5Ob2RlID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudC5jYWxsKGJvZHkub3duZXJEb2N1bWVudCk7XG5cbiAgICAgICAgd2hpbGUgKGJvZHkuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgICByZXR1cm5Ob2RlLmFwcGVuZENoaWxkKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybk5vZGUgPSBib2R5O1xuICAgICAgfVxuXG4gICAgICBpZiAoUkVUVVJOX0RPTV9JTVBPUlQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICBBZG9wdE5vZGUoKSBpcyBub3QgdXNlZCBiZWNhdXNlIGludGVybmFsIHN0YXRlIGlzIG5vdCByZXNldFxuICAgICAgICAgIChlLmcuIHRoZSBwYXN0IG5hbWVzIG1hcCBvZiBhIEhUTUxGb3JtRWxlbWVudCksIHRoaXMgaXMgc2FmZVxuICAgICAgICAgIGluIHRoZW9yeSBidXQgd2Ugd291bGQgcmF0aGVyIG5vdCByaXNrIGFub3RoZXIgYXR0YWNrIHZlY3Rvci5cbiAgICAgICAgICBUaGUgc3RhdGUgdGhhdCBpcyBjbG9uZWQgYnkgaW1wb3J0Tm9kZSgpIGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgICAgIGJ5IHRoZSBzcGVjcy5cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuTm9kZSA9IGltcG9ydE5vZGUuY2FsbChvcmlnaW5hbERvY3VtZW50LCByZXR1cm5Ob2RlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVybk5vZGU7XG4gICAgfVxuXG4gICAgdmFyIHNlcmlhbGl6ZWRIVE1MID0gV0hPTEVfRE9DVU1FTlQgPyBib2R5Lm91dGVySFRNTCA6IGJvZHkuaW5uZXJIVE1MO1xuXG4gICAgLyogU2FuaXRpemUgZmluYWwgc3RyaW5nIHRlbXBsYXRlLXNhZmUgKi9cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIE1VU1RBQ0hFX0VYUFIkJDEsICcgJyk7XG4gICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIEVSQl9FWFBSJCQxLCAnICcpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKSA6IHNlcmlhbGl6ZWRIVE1MO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHNldCB0aGUgY29uZmlndXJhdGlvbiBvbmNlXG4gICAqIHNldENvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBET01QdXJpZnkuc2V0Q29uZmlnID0gZnVuY3Rpb24gKGNmZykge1xuICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgIFNFVF9DT05GSUcgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSB0aGUgY29uZmlndXJhdGlvblxuICAgKiBjbGVhckNvbmZpZ1xuICAgKlxuICAgKi9cbiAgRE9NUHVyaWZ5LmNsZWFyQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIENPTkZJRyA9IG51bGw7XG4gICAgU0VUX0NPTkZJRyA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIHRvIGNoZWNrIGlmIGFuIGF0dHJpYnV0ZSB2YWx1ZSBpcyB2YWxpZC5cbiAgICogVXNlcyBsYXN0IHNldCBjb25maWcsIGlmIGFueS4gT3RoZXJ3aXNlLCB1c2VzIGNvbmZpZyBkZWZhdWx0cy5cbiAgICogaXNWYWxpZEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUYWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXR0ciBBdHRyaWJ1dGUgbmFtZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiBPdGhlcndpc2UsIHJldHVybnMgZmFsc2UuXG4gICAqL1xuICBET01QdXJpZnkuaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHIsIHZhbHVlKSB7XG4gICAgLyogSW5pdGlhbGl6ZSBzaGFyZWQgY29uZmlnIHZhcnMgaWYgbmVjZXNzYXJ5LiAqL1xuICAgIGlmICghQ09ORklHKSB7XG4gICAgICBfcGFyc2VDb25maWcoe30pO1xuICAgIH1cblxuICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKHRhZyk7XG4gICAgdmFyIGxjTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGF0dHIpO1xuICAgIHJldHVybiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZEhvb2tcbiAgICogUHVibGljIG1ldGhvZCB0byBhZGQgRE9NUHVyaWZ5IGhvb2tzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9vayB0byBhZGRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va0Z1bmN0aW9uIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICovXG4gIERPTVB1cmlmeS5hZGRIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQsIGhvb2tGdW5jdGlvbikge1xuICAgIGlmICh0eXBlb2YgaG9va0Z1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaG9va3NbZW50cnlQb2ludF0gPSBob29rc1tlbnRyeVBvaW50XSB8fCBbXTtcbiAgICBhcnJheVB1c2goaG9va3NbZW50cnlQb2ludF0sIGhvb2tGdW5jdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZUhvb2tcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYSBET01QdXJpZnkgaG9vayBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICogKHBvcHMgaXQgZnJvbSB0aGUgc3RhY2sgb2YgaG9va3MgaWYgbW9yZSBhcmUgcHJlc2VudClcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rIHRvIHJlbW92ZVxuICAgKi9cbiAgRE9NUHVyaWZ5LnJlbW92ZUhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgIGlmIChob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgYXJyYXlQb3AoaG9va3NbZW50cnlQb2ludF0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlSG9va3NcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rcyBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9va3MgdG8gcmVtb3ZlXG4gICAqL1xuICBET01QdXJpZnkucmVtb3ZlSG9va3MgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgIGlmIChob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgaG9va3NbZW50cnlQb2ludF0gPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZUFsbEhvb2tzXG4gICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIGFsbCBET01QdXJpZnkgaG9va3NcbiAgICpcbiAgICovXG4gIERPTVB1cmlmeS5yZW1vdmVBbGxIb29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBob29rcyA9IHt9O1xuICB9O1xuXG4gIHJldHVybiBET01QdXJpZnk7XG59XG5cbnZhciBwdXJpZnkgPSBjcmVhdGVET01QdXJpZnkoKTtcblxudmFyIENBTl9CRV9XSElURV9UQUdfTElTVCA9IFsnaWZyYW1lJywgJ2VtYmVkJ107XG52YXIgd2hpdGVUYWdMaXN0ID0gW107XG5mdW5jdGlvbiByZWdpc3RlclRhZ1doaXRlbGlzdElmUG9zc2libGUodGFnTmFtZSkge1xuICAgIGlmIChpbmNsdWRlcyhDQU5fQkVfV0hJVEVfVEFHX0xJU1QsIHRhZ05hbWUpKSB7XG4gICAgICAgIHdoaXRlVGFnTGlzdC5wdXNoKHRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FuaXRpemVIVE1MKGh0bWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHVyaWZ5LnNhbml0aXplKGh0bWwsIF9fYXNzaWduJDEoeyBBRERfVEFHUzogd2hpdGVUYWdMaXN0LCBBRERfQVRUUjogWydyZWwnLCAndGFyZ2V0JywgJ2hyZWZsYW5nJywgJ3R5cGUnXSwgRk9SQklEX1RBR1M6IFtcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICAnc2NyaXB0JyxcbiAgICAgICAgICAgICd0ZXh0YXJlYScsXG4gICAgICAgICAgICAnZm9ybScsXG4gICAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICAgICdzZWxlY3QnLFxuICAgICAgICAgICAgJ21ldGEnLFxuICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgICdsaW5rJyxcbiAgICAgICAgICAgICd0aXRsZScsXG4gICAgICAgICAgICAnb2JqZWN0JyxcbiAgICAgICAgICAgICdiYXNlJyxcbiAgICAgICAgXSB9LCBvcHRpb25zKSk7XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuSFRNTChub2RlLCB0eXBlTmFtZSkge1xuICAgIHJldHVybiBub2RlXG4gICAgICAgIC5saXRlcmFsLnJlcGxhY2UobmV3IFJlZ0V4cChcIig8XFxcXHMqXCIgKyB0eXBlTmFtZSArIFwiW14+XSo+KXwoPC9cIiArIHR5cGVOYW1lICsgXCJcXFxccypbPl0pXCIsICdpZycpLCAnJylcbiAgICAgICAgLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGdldEhUTUxBdHRyc0J5SFRNTFN0cmluZyhodG1sKSB7XG4gICAgaHRtbCA9IGh0bWwubWF0Y2gocmVIVE1MVGFnKVswXTtcbiAgICB2YXIgYXR0cnMgPSBodG1sLm1hdGNoKG5ldyBSZWdFeHAoQVRUUklCVVRFJDEsICdnJykpO1xuICAgIHJldHVybiBhdHRyc1xuICAgICAgICA/IGF0dHJzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBhdHRyLnRyaW0oKS5zcGxpdCgnPScpLCBuYW1lID0gX2FbMF0sIHZhbHVlcyA9IF9hLnNsaWNlKDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhY2NbbmFtZV0gPSB2YWx1ZXMuam9pbignPScpLnJlcGxhY2UoLyd8XCIvZywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IHt9O1xufVxuZnVuY3Rpb24gZ2V0SFRNTEF0dHJzKGRvbSkge1xuICAgIHJldHVybiB0b0FycmF5XzEoZG9tLmF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7XG4gICAgICAgIGFjY1thdHRyLm5vZGVOYW1lXSA9IGF0dHIubm9kZVZhbHVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRE9NKG5vZGUsIHR5cGVOYW1lLCBzYW5pdGl6ZXIsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgdmFyIGRvbSA9IHd3VG9ET01BZGFwdG9yLmdldFRvRE9NTm9kZSh0eXBlTmFtZSkobm9kZSk7XG4gICAgdmFyIGh0bWwgPSBzYW5pdGl6ZXIoZG9tLm91dGVySFRNTCk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgIGRvbSA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIHZhciBodG1sQXR0cnMgPSBnZXRIVE1MQXR0cnMoZG9tKTtcbiAgICByZXR1cm4geyBkb206IGRvbSwgaHRtbEF0dHJzOiBodG1sQXR0cnMgfTtcbn1cbnZhciBzY2hlbWFGYWN0b3J5ID0ge1xuICAgIGh0bWxCbG9jazogZnVuY3Rpb24gKHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdG9tOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudDogJ2Jsb2NrKycsXG4gICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IHt9IH0sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5IVE1MOiB7IGRlZmF1bHQ6ICcnIH0sXG4gICAgICAgICAgICAgICAgaHRtbEJsb2NrOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEF0dHJzOiBnZXRIVE1MQXR0cnMoZG9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkhUTUw6IGRvbS5pbm5lckhUTUwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gc2FuaXRpemVET00obm9kZSwgdHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpLCBkb20gPSBfYS5kb20sIGh0bWxBdHRycyA9IF9hLmh0bWxBdHRycztcbiAgICAgICAgICAgICAgICBodG1sQXR0cnMuY2xhc3MgPSBodG1sQXR0cnMuY2xhc3MgPyBodG1sQXR0cnMuY2xhc3MgKyBcIiBodG1sLWJsb2NrXCIgOiAnaHRtbC1ibG9jayc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkkMShbdHlwZU5hbWUsIGh0bWxBdHRyc10sIHRvQXJyYXlfMShkb20uY2hpbGROb2RlcykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGh0bWxJbmxpbmU6IGZ1bmN0aW9uICh0eXBlTmFtZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBodG1sQXR0cnM6IHsgZGVmYXVsdDoge30gfSxcbiAgICAgICAgICAgICAgICBodG1sSW5saW5lOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEF0dHJzOiBnZXRIVE1MQXR0cnMoZG9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbEF0dHJzID0gc2FuaXRpemVET00obm9kZSwgdHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpLmh0bWxBdHRycztcbiAgICAgICAgICAgICAgICByZXR1cm4gW3R5cGVOYW1lLCBodG1sQXR0cnMsIDBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUhUTUxTY2hlbWFNYXAoY29udmVydG9yTWFwLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgdmFyIGh0bWxTY2hlbWFNYXAgPSB7IG5vZGVzOiB7fSwgbWFya3M6IHt9IH07XG4gICAgWydodG1sQmxvY2snLCAnaHRtbElubGluZSddLmZvckVhY2goZnVuY3Rpb24gKGh0bWxUeXBlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0b3JNYXBbaHRtbFR5cGVdKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb252ZXJ0b3JNYXBbaHRtbFR5cGVdKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFR5cGUgPSBodG1sVHlwZSA9PT0gJ2h0bWxCbG9jaycgPyAnbm9kZXMnIDogJ21hcmtzJztcbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0YWcgd2hpdGUgbGlzdCBmb3IgcHJldmVudGluZyB0byByZW1vdmUgdGhlIGh0bWwgaW4gc2FuaXRpemVyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJUYWdXaGl0ZWxpc3RJZlBvc3NpYmxlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGh0bWxTY2hlbWFNYXBbdGFyZ2V0VHlwZV1bdHlwZV0gPSBzY2hlbWFGYWN0b3J5W2h0bWxUeXBlXSh0eXBlLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGh0bWxTY2hlbWFNYXA7XG59XG5cbnZhciByZUNsb3NlVGFnID0gL15cXHMqPFxccypcXC8vO1xudmFyIGJhc2VDb252ZXJ0b3JzID0ge1xuICAgIHBhcmFncmFwaDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBvcmlnaW4gPSBfYS5vcmlnaW4sIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5ub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAncCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4oKTtcbiAgICB9LFxuICAgIHNvZnRicmVhazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGlzUHJldk5vZGVIVE1MID0gbm9kZS5wcmV2ICYmIG5vZGUucHJldi50eXBlID09PSAnaHRtbElubGluZSc7XG4gICAgICAgIHZhciBpc1ByZXZCUiA9IGlzUHJldk5vZGVIVE1MICYmIC88YnIgP1xcLz8+Ly50ZXN0KG5vZGUucHJldi5saXRlcmFsKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBpc1ByZXZCUiA/ICdcXG4nIDogJzxicj5cXG4nO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfTtcbiAgICB9LFxuICAgIGl0ZW06IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmxpc3REYXRhLnRhc2spIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzWydkYXRhLXRhc2snXSA9ICcnO1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgndGFzay1saXN0LWl0ZW0nKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0RGF0YS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnY2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzWydkYXRhLXRhc2stY2hlY2tlZCddID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHsgJ2RhdGEtYmFja3RpY2tzJzogU3RyaW5nKG5vZGUudGlja0NvdW50KSB9O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJywgYXR0cmlidXRlczogYXR0cmlidXRlcyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF9hID0gbm9kZSwgZmVuY2VMZW5ndGggPSBfYS5mZW5jZUxlbmd0aCwgaW5mbyA9IF9hLmluZm87XG4gICAgICAgIHZhciBpbmZvV29yZHMgPSBpbmZvID8gaW5mby5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgIHZhciBwcmVDbGFzc2VzID0gW107XG4gICAgICAgIHZhciBjb2RlQXR0cnMgPSB7fTtcbiAgICAgICAgaWYgKGZlbmNlTGVuZ3RoID4gMykge1xuICAgICAgICAgICAgY29kZUF0dHJzWydkYXRhLWJhY2t0aWNrcyddID0gZmVuY2VMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm9Xb3Jkcy5sZW5ndGggPiAwICYmIGluZm9Xb3Jkc1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFuZyA9IGluZm9Xb3Jkc1swXTtcbiAgICAgICAgICAgIHByZUNsYXNzZXMucHVzaChcImxhbmctXCIgKyBsYW5nKTtcbiAgICAgICAgICAgIGNvZGVBdHRyc1snZGF0YS1sYW5ndWFnZSddID0gbGFuZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdwcmUnLCBjbGFzc05hbWVzOiBwcmVDbGFzc2VzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2NvZGUnLCBhdHRyaWJ1dGVzOiBjb2RlQXR0cnMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdwcmUnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBjdXN0b21JbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgb3JpZ2luID0gX2Eub3JpZ2luLCBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBpbmZvID0gbm9kZS5pbmZvO1xuICAgICAgICBpZiAoaW5mby5pbmRleE9mKCd3aWRnZXQnKSAhPT0gLTEgJiYgZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBnZXRXaWRnZXRDb250ZW50KG5vZGUpO1xuICAgICAgICAgICAgdmFyIGh0bWxJbmxpbmUgPSB3aWRnZXRUb0RPTShpbmZvLCBjb250ZW50KS5vdXRlckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnc3BhbicsIGNsYXNzTmFtZXM6IFsndHVpLXdpZGdldCddIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGh0bWxJbmxpbmUgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdzcGFuJyB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luKCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRIVE1MUmVuZGVyQ29udmVydG9ycyhsaW5rQXR0cmlidXRlcywgY3VzdG9tQ29udmVydG9ycykge1xuICAgIHZhciBjb252ZXJ0b3JzID0gX19hc3NpZ24kMSh7fSwgYmFzZUNvbnZlcnRvcnMpO1xuICAgIGlmIChsaW5rQXR0cmlidXRlcykge1xuICAgICAgICBjb252ZXJ0b3JzLmxpbmsgPSBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBvcmlnaW4gPSBfYS5vcmlnaW47XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luKCk7XG4gICAgICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXR0cmlidXRlcyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgcmVzdWx0LmF0dHJpYnV0ZXMpLCBsaW5rQXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY3VzdG9tQ29udmVydG9ycykge1xuICAgICAgICBPYmplY3Qua2V5cyhjdXN0b21Db252ZXJ0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlVHlwZSkge1xuICAgICAgICAgICAgdmFyIG9yZ0NvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgaWYgKG9yZ0NvbnZlcnRvciAmJiBpc0Z1bmN0aW9uXzEoY3VzdG9tQ29udmVydG9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbbm9kZVR5cGVdID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NvbnRleHQgPSBfX2Fzc2lnbiQxKHt9LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dC5vcmlnaW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmdDb252ZXJ0b3Iobm9kZSwgY29udGV4dCk7IH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21Db252ZXJ0b3Iobm9kZSwgbmV3Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluY2x1ZGVzKFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXSwgbm9kZVR5cGUpICYmICFpc0Z1bmN0aW9uXzEoY3VzdG9tQ29udmVydG9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbbm9kZVR5cGVdID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBub2RlLmxpdGVyYWwubWF0Y2gocmVIVE1MVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290SFRNTCA9IG1hdGNoZWRbMF0sIG9wZW5UYWdOYW1lID0gbWF0Y2hlZFsxXSwgY2xvc2VUYWdOYW1lID0gbWF0Y2hlZFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IChvcGVuVGFnTmFtZSB8fCBjbG9zZVRhZ05hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbENvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvclt0eXBlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5IVE1MID0gZ2V0Q2hpbGRyZW5IVE1MKG5vZGUsIHR5cGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodG1sQ29udmVydG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29weSBmb3IgcHJldmVudGluZyB0byBvdmVyd3JpdGUgdGhlIG9yaWdpbmlhbCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gX19hc3NpZ24kMSh7fSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5hdHRycyA9IGdldEhUTUxBdHRyc0J5SFRNTFN0cmluZyhyb290SFRNTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5jaGlsZHJlbkhUTUwgPSBjaGlsZHJlbkhUTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS50eXBlID0gdHlwZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbnRlcmluZyA9ICFyZUNsb3NlVGFnLnRlc3Qobm9kZS5saXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHRtbENvbnZlcnRvcihuZXdOb2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5vcmlnaW4oKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udmVydG9yc1tub2RlVHlwZV0gPSBjdXN0b21Db252ZXJ0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydG9ycztcbn1cblxudmFyIG5lc3RhYmxlVHlwZXMgPSBbJ2xpc3QnLCAnaXRlbScsICdibG9ja1F1b3RlJ107XG52YXIgbmVzdGFibGVUYWdOYW1lcyA9IFsnVUwnLCAnT0wnLCAnQkxPQ0tRVU9URSddO1xuZnVuY3Rpb24gaXNCbGFua0xpbmUoZG9jLCBpbmRleCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcG1Ob2RlID0gZG9jLmNoaWxkKGluZGV4KTtcbiAgICByZXR1cm4gIXBtTm9kZS5jaGlsZENvdW50IHx8IChwbU5vZGUuY2hpbGRDb3VudCA9PT0gMSAmJiAhKChfYSA9IHBtTm9kZS5maXJzdENoaWxkLnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmltKCkpKTtcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclJhbmdlSGVpZ2h0SW5mbyhkb2MsIG1kTm9kZSwgY2hpbGRyZW4pIHtcbiAgICB2YXIgc3RhcnQgPSBnZXRNZFN0YXJ0TGluZShtZE5vZGUpIC0gMTtcbiAgICB2YXIgZW5kID0gZ2V0TWRFbmRMaW5lKG1kTm9kZSkgLSAxO1xuICAgIHZhciByZWN0ID0gY2hpbGRyZW5bc3RhcnRdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBoZWlnaHQgPSBjaGlsZHJlbltlbmRdLm9mZnNldFRvcCAtXG4gICAgICAgIGNoaWxkcmVuW3N0YXJ0XS5vZmZzZXRUb3AgK1xuICAgICAgICBjaGlsZHJlbltlbmRdLmNsaWVudEhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IGhlaWdodCA8PSAwXG4gICAgICAgICAgICA/IGNoaWxkcmVuW3N0YXJ0XS5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIDogaGVpZ2h0ICsgZ2V0QmxhbmtMaW5lc0hlaWdodChkb2MsIGNoaWxkcmVuLCBNYXRoLm1pbihlbmQgKyAxLCBkb2MuY2hpbGRDb3VudCAtIDEpKSxcbiAgICAgICAgcmVjdDogcmVjdCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QmxhbmtMaW5lc0hlaWdodChkb2MsIGNoaWxkcmVuLCBzdGFydCkge1xuICAgIHZhciBlbmQgPSBkb2MuY2hpbGRDb3VudCAtIDE7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCAmJiBpc0JsYW5rTGluZShkb2MsIHN0YXJ0KSkge1xuICAgICAgICBoZWlnaHQgKz0gY2hpbGRyZW5bc3RhcnRdLmNsaWVudEhlaWdodDtcbiAgICAgICAgc3RhcnQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbn1cbmZ1bmN0aW9uIGZpbmRBbmNlc3RvckhhdmluZ0lkKGVsLCByb290KSB7XG4gICAgd2hpbGUgKCFlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJykgJiYgZWwucGFyZW50RWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGdldFRvdGFsT2Zmc2V0VG9wKGVsLCByb290KSB7XG4gICAgdmFyIG9mZnNldFRvcCA9IDA7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSByb290KSB7XG4gICAgICAgIGlmICghaW5jbHVkZXMobmVzdGFibGVUYWdOYW1lcywgZWwudGFnTmFtZSkpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLm9mZnNldFBhcmVudCA9PT0gcm9vdC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldFRvcDtcbn1cbmZ1bmN0aW9uIGZpbmRBZGphY2VudEVsZW1lbnRUb1Njcm9sbFRvcChzY3JvbGxUb3AsIHJvb3QpIHtcbiAgICB2YXIgZWwgPSByb290O1xuICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgdmFyIGZpcnN0RWxlbWVudENoaWxkID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIGlmICghZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0U2libGluZyA9IGZpbmRMYXN0U2libGluZ0VsZW1lbnRUb1Njcm9sbFRvcChmaXJzdEVsZW1lbnRDaGlsZCwgc2Nyb2xsVG9wLCBnZXRUb3RhbE9mZnNldFRvcChlbCwgcm9vdCkpO1xuICAgICAgICBwcmV2ID0gZWw7XG4gICAgICAgIGVsID0gbGFzdFNpYmxpbmc7XG4gICAgfVxuICAgIHZhciBhZGphY2VudEVsID0gZWwgfHwgcHJldjtcbiAgICByZXR1cm4gYWRqYWNlbnRFbCA9PT0gcm9vdCA/IG51bGwgOiBhZGphY2VudEVsO1xufVxuZnVuY3Rpb24gZmluZExhc3RTaWJsaW5nRWxlbWVudFRvU2Nyb2xsVG9wKGVsLCBzY3JvbGxUb3AsIG9mZnNldFRvcCkge1xuICAgIGlmIChlbCAmJiBzY3JvbGxUb3AgPiBvZmZzZXRUb3AgKyBlbC5vZmZzZXRUb3ApIHtcbiAgICAgICAgcmV0dXJuIChmaW5kTGFzdFNpYmxpbmdFbGVtZW50VG9TY3JvbGxUb3AoZWwubmV4dEVsZW1lbnRTaWJsaW5nLCBzY3JvbGxUb3AsIG9mZnNldFRvcCkgfHwgZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEFkZGl0aW9uYWxQb3Moc2Nyb2xsVG9wLCBvZmZzZXRUb3AsIGhlaWdodCwgdGFyZ2V0Tm9kZUhlaWdodCkge1xuICAgIHZhciByYXRpbyA9IE1hdGgubWluKChzY3JvbGxUb3AgLSBvZmZzZXRUb3ApIC8gaGVpZ2h0LCAxKTtcbiAgICByZXR1cm4gcmF0aW8gKiB0YXJnZXROb2RlSGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZU9iaihwcmV2aWV3Q29udGVudCwgbWROb2RlKSB7XG4gICAgdmFyIGVsID0gcHJldmlld0NvbnRlbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLW5vZGVpZD1cXFwiXCIgKyBtZE5vZGUuaWQgKyBcIlxcXCJdXCIpO1xuICAgIHdoaWxlICghZWwgfHwgaXNTdHlsZWRJbmxpbmVOb2RlKG1kTm9kZSkpIHtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICAgICAgZWwgPSBwcmV2aWV3Q29udGVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZWlkPVxcXCJcIiArIG1kTm9kZS5pZCArIFwiXFxcIl1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZXROb25OZXN0YWJsZU5vZGVPYmooeyBtZE5vZGU6IG1kTm9kZSwgZWw6IGVsIH0pO1xufVxuZnVuY3Rpb24gZ2V0Tm9uTmVzdGFibGVOb2RlT2JqKF9hKSB7XG4gICAgdmFyIG1kTm9kZSA9IF9hLm1kTm9kZSwgZWwgPSBfYS5lbDtcbiAgICB3aGlsZSAoKGluY2x1ZGVzKG5lc3RhYmxlVHlwZXMsIG1kTm9kZS50eXBlKSB8fCBtZE5vZGUudHlwZSA9PT0gJ3RhYmxlJykgJiYgbWROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGVsID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB7IG1kTm9kZTogbWROb2RlLCBlbDogZWwgfTtcbn1cblxudmFyIG9mZnNldEluZm9NYXAgPSB7fTtcbmZ1bmN0aW9uIHNldEhlaWdodChpZCwgaGVpZ2h0KSB7XG4gICAgb2Zmc2V0SW5mb01hcFtpZF0gPSBvZmZzZXRJbmZvTWFwW2lkXSB8fCB7fTtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXS5oZWlnaHQgPSBoZWlnaHQ7XG59XG5mdW5jdGlvbiBzZXRPZmZzZXRUb3AoaWQsIG9mZnNldFRvcCkge1xuICAgIG9mZnNldEluZm9NYXBbaWRdID0gb2Zmc2V0SW5mb01hcFtpZF0gfHwge307XG4gICAgb2Zmc2V0SW5mb01hcFtpZF0ub2Zmc2V0VG9wID0gb2Zmc2V0VG9wO1xufVxuZnVuY3Rpb24gZ2V0SGVpZ2h0KGlkKSB7XG4gICAgcmV0dXJuIG9mZnNldEluZm9NYXBbaWRdICYmIG9mZnNldEluZm9NYXBbaWRdLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldFRvcChpZCkge1xuICAgIHJldHVybiBvZmZzZXRJbmZvTWFwW2lkXSAmJiBvZmZzZXRJbmZvTWFwW2lkXS5vZmZzZXRUb3A7XG59XG5mdW5jdGlvbiByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBkZWxldGUgb2Zmc2V0SW5mb01hcFtOdW1iZXIobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJykpXTtcbiAgICAgICAgdG9BcnJheV8xKG5vZGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QW5kU2F2ZU9mZnNldEluZm8obm9kZSwgcm9vdCwgbWROb2RlSWQpIHtcbiAgICB2YXIgY2FjaGVkSGVpZ2h0ID0gZ2V0SGVpZ2h0KG1kTm9kZUlkKTtcbiAgICB2YXIgY2FjaGVkVG9wID0gZ2V0T2Zmc2V0VG9wKG1kTm9kZUlkKTtcbiAgICB2YXIgbm9kZUhlaWdodCA9IGNhY2hlZEhlaWdodCB8fCBub2RlLmNsaWVudEhlaWdodDtcbiAgICB2YXIgb2Zmc2V0VG9wID0gY2FjaGVkVG9wIHx8IGdldFRvdGFsT2Zmc2V0VG9wKG5vZGUsIHJvb3QpIHx8IG5vZGUub2Zmc2V0VG9wO1xuICAgIGlmICghY2FjaGVkSGVpZ2h0KSB7XG4gICAgICAgIHNldEhlaWdodChtZE5vZGVJZCwgbm9kZUhlaWdodCk7XG4gICAgfVxuICAgIGlmICghY2FjaGVkVG9wKSB7XG4gICAgICAgIHNldE9mZnNldFRvcChtZE5vZGVJZCwgb2Zmc2V0VG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZUhlaWdodDogbm9kZUhlaWdodCwgb2Zmc2V0VG9wOiBvZmZzZXRUb3AgfTtcbn1cblxudmFyIENMQVNTX0hJR0hMSUdIVCA9IGNscygnbWQtcHJldmlldy1oaWdobGlnaHQnKTtcbmZ1bmN0aW9uIGZpbmRUYWJsZUNlbGwodGFibGVSb3csIGNoT2Zmc2V0KSB7XG4gICAgdmFyIGNlbGwgPSB0YWJsZVJvdy5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjZWxsICYmIGNlbGwubmV4dCkge1xuICAgICAgICBpZiAoZ2V0TWRTdGFydENoKGNlbGwubmV4dCkgPiBjaE9mZnNldCArIDEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNlbGwgPSBjZWxsLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xufVxuLyoqXG4gKiBDbGFzcyBNYXJrZG93biBQcmV2aWV3XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGJhc2UgZWxlbWVudFxuICogQHBhcmFtIHtldmVudEVtaXR0ZXJ9IGV2ZW50RW1pdHRlciAtIGV2ZW50IG1hbmFnZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaXNWaWV3ZXIgLSB0cnVlIGZvciB2aWV3LW9ubHkgbW9kZVxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmhpZ2hsaWdodCAtIHRydWUgZm9yIHVzaW5nIGxpdmUtaGlnaGxpZ2h0IGZlYXR1cmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGl0b25zLmxpbmtBdHRyaWJ1dGVzIC0gYXR0cmlidXRlcyBmb3IgbGluayBlbGVtZW50XG4gKiBAcGFyYW0ge29iamVjdH0gb3BpdG9ucy5jdXN0b21IVE1MUmVuZGVyZXIgLSBtYXAgb2YgY3VzdG9tIEhUTUwgcmVuZGVyIGZ1bmN0aW9uc1xuICpcbiAqIEBpZ25vcmVcbiAqL1xudmFyIE1hcmtkb3duUHJldmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXJrZG93blByZXZpZXcoZXZlbnRFbWl0dGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmlzVmlld2VyID0gISFvcHRpb25zLmlzVmlld2VyO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IGNscygnbWQtcHJldmlldycpO1xuICAgICAgICB2YXIgbGlua0F0dHJpYnV0ZXMgPSBvcHRpb25zLmxpbmtBdHRyaWJ1dGVzLCBjdXN0b21IVE1MUmVuZGVyZXIgPSBvcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlciwgc2FuaXRpemVyID0gb3B0aW9ucy5zYW5pdGl6ZXIsIF9hID0gb3B0aW9ucy5oaWdobGlnaHQsIGhpZ2hsaWdodCA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHtcbiAgICAgICAgICAgIGdmbTogdHJ1ZSxcbiAgICAgICAgICAgIG5vZGVJZDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnZlcnRvcnM6IGdldEhUTUxSZW5kZXJDb252ZXJ0b3JzKGxpbmtBdHRyaWJ1dGVzLCBjdXN0b21IVE1MUmVuZGVyZXIpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdXJzb3JOb2RlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgdGhpcy5pbml0RXZlbnQoaGlnaGxpZ2h0KTtcbiAgICAgICAgdGhpcy5pbml0Q29udGVudFNlY3Rpb24oKTtcbiAgICAgICAgLy8gVG8gcHJldmVudCBvdmVyZmxvd2luZyBjb250ZW50cyBpbiB0aGUgdmlld2VyXG4gICAgICAgIGlmICh0aGlzLmlzVmlld2VyKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXdDb250ZW50LnN0eWxlLm92ZXJmbG93V3JhcCA9ICdicmVhay13b3JkJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmluaXRDb250ZW50U2VjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcmV2aWV3Q29udGVudCA9IGNyZWF0ZUVsZW1lbnRXaXRoKFwiPGRpdiBjbGFzcz1cXFwiXCIgKyBjbHMoJ2NvbnRlbnRzJykgKyBcIlxcXCI+PC9kaXY+XCIpO1xuICAgICAgICBpZiAoIXRoaXMuaXNWaWV3ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3Q29udGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUudG9nZ2xlQWN0aXZlID0gZnVuY3Rpb24gKGFjdGl2ZSkge1xuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLmVsLCAnYWN0aXZlJywgYWN0aXZlKTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24gKGhpZ2hsaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3VwZGF0ZVByZXZpZXcnLCB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVRvb2xiYXJTdGF0ZScsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSBfYS5tZE5vZGUsIGN1cnNvclBvcyA9IF9hLmN1cnNvclBvcztcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVDdXJzb3JOb2RlKG1kTm9kZSwgY3Vyc29yUG9zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb25fMSh0aGlzLmVsLCAnc2Nyb2xsJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnc2Nyb2xsJywgJ3ByZXZpZXcnLCBmaW5kQWRqYWNlbnRFbGVtZW50VG9TY3JvbGxUb3AoZXZlbnQudGFyZ2V0LnNjcm9sbFRvcCwgX3RoaXMucHJldmlld0NvbnRlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlUHJldmlld1RhYlByZXZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUodHJ1ZSk7IH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRvZ2dsZUFjdGl2ZShmYWxzZSk7IH0pO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5yZW1vdmVIaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvck5vZGVJZCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRFbCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKHRoaXMuY3Vyc29yTm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RWwpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzc18xKGN1cnJlbnRFbCwgQ0xBU1NfSElHSExJR0hUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS51cGRhdGVDdXJzb3JOb2RlID0gZnVuY3Rpb24gKGN1cnNvck5vZGUsIGN1cnNvclBvcykge1xuICAgICAgICBpZiAoY3Vyc29yTm9kZSkge1xuICAgICAgICAgICAgY3Vyc29yTm9kZSA9IGZpbmRDbG9zZXN0Tm9kZShjdXJzb3JOb2RlLCBmdW5jdGlvbiAobWROb2RlKSB7IHJldHVybiAhaXNJbmxpbmVOb2RlJDEobWROb2RlKTsgfSk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yTm9kZS50eXBlID09PSAndGFibGVSb3cnKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yTm9kZSA9IGZpbmRUYWJsZUNlbGwoY3Vyc29yTm9kZSwgY3Vyc29yUG9zWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnNvck5vZGUudHlwZSA9PT0gJ3RhYmxlQm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBsaW5lIG5leHQgdG8gdGFibGVcbiAgICAgICAgICAgICAgICBjdXJzb3JOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3Vyc29yTm9kZUlkID0gY3Vyc29yTm9kZSA/IGN1cnNvck5vZGUuaWQgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JOb2RlSWQgPT09IGN1cnNvck5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRFTCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKHRoaXMuY3Vyc29yTm9kZUlkKTtcbiAgICAgICAgdmFyIG5ld0VMID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQoY3Vyc29yTm9kZUlkKTtcbiAgICAgICAgaWYgKG9sZEVMKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzc18xKG9sZEVMLCBDTEFTU19ISUdITElHSFQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdFTCkge1xuICAgICAgICAgICAgYWRkQ2xhc3NfMShuZXdFTCwgQ0xBU1NfSElHSExJR0hUKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnNvck5vZGVJZCA9IGN1cnNvck5vZGVJZDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5Tm9kZUlkID0gZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICByZXR1cm4gbm9kZUlkXG4gICAgICAgICAgICA/IHRoaXMucHJldmlld0NvbnRlbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLW5vZGVpZD1cXFwiXCIgKyBub2RlSWQgKyBcIlxcXCJdXCIpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjaGFuZ2VkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNoYW5nZWQuZm9yRWFjaChmdW5jdGlvbiAoZWRpdFJlc3VsdCkgeyByZXR1cm4gX3RoaXMucmVwbGFjZVJhbmdlTm9kZXMoZWRpdFJlc3VsdCk7IH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdhZnRlclByZXZpZXdSZW5kZXInLCB0aGlzKTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUucmVwbGFjZVJhbmdlTm9kZXMgPSBmdW5jdGlvbiAoZWRpdFJlc3VsdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZXMgPSBlZGl0UmVzdWx0Lm5vZGVzLCByZW1vdmVkTm9kZVJhbmdlID0gZWRpdFJlc3VsdC5yZW1vdmVkTm9kZVJhbmdlO1xuICAgICAgICB2YXIgY29udGVudEVsID0gdGhpcy5wcmV2aWV3Q29udGVudDtcbiAgICAgICAgdmFyIG5ld0h0bWwgPSB0aGlzLmV2ZW50RW1pdHRlci5lbWl0UmVkdWNlKCdiZWZvcmVQcmV2aWV3UmVuZGVyJywgdGhpcy5zYW5pdGl6ZXIobm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5yZW5kZXIobm9kZSk7IH0pLmpvaW4oJycpKSk7XG4gICAgICAgIGlmICghcmVtb3ZlZE5vZGVSYW5nZSkge1xuICAgICAgICAgICAgY29udGVudEVsLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJiZWdpbicsIG5ld0h0bWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9hID0gcmVtb3ZlZE5vZGVSYW5nZS5pZCwgc3RhcnROb2RlSWQgPSBfYVswXSwgZW5kTm9kZUlkID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgc3RhcnRFbCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKHN0YXJ0Tm9kZUlkKTtcbiAgICAgICAgICAgIHZhciBlbmRFbCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKGVuZE5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRFbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIG5ld0h0bWwpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHN0YXJ0RWw7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBlbmRFbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEVsID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlJDEoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBuZXh0RWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gbnVsbCB8fCBlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlJDEoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0UmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZfMSh0aGlzLmVsLCAnc2Nyb2xsJyk7XG4gICAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0SFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKHRoaXMucHJldmlld0NvbnRlbnQuaW5uZXJIVE1MKTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0SFRNTCA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIHRoaXMucHJldmlld0NvbnRlbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICBjc3NfMSh0aGlzLmVsLCB7IGhlaWdodDogaGVpZ2h0ICsgXCJweFwiIH0pO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5zZXRNaW5IZWlnaHQgPSBmdW5jdGlvbiAobWluSGVpZ2h0KSB7XG4gICAgICAgIGNzc18xKHRoaXMuZWwsIHsgbWluSGVpZ2h0OiBtaW5IZWlnaHQgKyBcInB4XCIgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFya2Rvd25QcmV2aWV3O1xufSgpKTtcblxuZnVuY3Rpb24gZmluZE5vZGVCeShwb3MsIGNvbmRpdGlvbikge1xuICAgIHZhciBkZXB0aCA9IHBvcy5kZXB0aDtcbiAgICB3aGlsZSAoZGVwdGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwb3Mubm9kZShkZXB0aCk7XG4gICAgICAgIGlmIChjb25kaXRpb24obm9kZSwgZGVwdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZGVwdGggPiAwID8gcG9zLmJlZm9yZShkZXB0aCkgOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzSW5MaXN0Tm9kZShwb3MpIHtcbiAgICByZXR1cm4gISFmaW5kTm9kZUJ5KHBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ2xpc3RJdGVtJyB8fCB0eXBlLm5hbWUgPT09ICdidWxsZXRMaXN0JyB8fCB0eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc0luVGFibGVOb2RlKHBvcykge1xuICAgIHJldHVybiAhIWZpbmROb2RlQnkocG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAndGFibGVIZWFkQ2VsbCcgfHwgdHlwZS5uYW1lID09PSAndGFibGVCb2R5Q2VsbCc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaW5kTGlzdEl0ZW0ocG9zKSB7XG4gICAgcmV0dXJuIGZpbmROb2RlQnkocG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAnbGlzdEl0ZW0nO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRE9NSW5mb1BhcnNlZFJhd0hUTUwodGFnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxsQXR0cnMoYXR0cnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyTmFtZSkge1xuICAgICAgICBpZiAoYXR0ck5hbWUgIT09ICdyYXdIVE1MJyAmJiBhdHRyc1thdHRyTmFtZV0pIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ck5hbWUgPT09ICdjbGFzc05hbWUnID8gJ2NsYXNzJyA6IGF0dHJOYW1lO1xuICAgICAgICAgICAgYWNjW2F0dHJOYW1lXSA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlZENlbGxET00odGFnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICByZXR1cm4gWydyYXdIVE1MJywgJ2NvbHNwYW4nLCAncm93c3BhbicsICdleHRlbmRlZCddLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZUluRE9NID0gYXR0ck5hbWUgPT09ICdyYXdIVE1MJyA/ICdkYXRhLXJhdy1odG1sJyA6IGF0dHJOYW1lO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBkb20uZ2V0QXR0cmlidXRlKGF0dHJOYW1lSW5ET00pO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2F0dHJOYW1lXSA9IGluY2x1ZGVzKFsncmF3SFRNTCcsICdleHRlbmRlZCddLCBhdHRyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXR0clZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE51bWJlcihhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgY2xhc3NOYW1lczogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEN1c3RvbUF0dHJzKGF0dHJzKSB7XG4gICAgdmFyIGh0bWxBdHRycyA9IGF0dHJzLmh0bWxBdHRycywgY2xhc3NOYW1lcyA9IGF0dHJzLmNsYXNzTmFtZXM7XG4gICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgaHRtbEF0dHJzKSwgeyBjbGFzczogY2xhc3NOYW1lcyA/IGNsYXNzTmFtZXMuam9pbignICcpIDogbnVsbCB9KTtcbn1cblxuZnVuY3Rpb24gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgdHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSByYW5nZS5wYXJlbnQsIHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4LCBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4O1xuICAgIHZhciBhcm91bmQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoc3RhcnRJbmRleCkuZmluZFdyYXBwaW5nKHR5cGUpO1xuICAgIGlmIChhcm91bmQpIHtcbiAgICAgICAgdmFyIG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gICAgICAgIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIG91dGVyKSA/IGFyb3VuZCA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nSW5zaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudCwgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gcmFuZ2UuZW5kSW5kZXg7XG4gICAgdmFyIGlubmVyID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgIHZhciBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gICAgaWYgKGluc2lkZSkge1xuICAgICAgICB2YXIgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gICAgICAgIHZhciBpbm5lck1hdGNoID0gbGFzdFR5cGUuY29udGVudE1hdGNoO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaW5uZXJNYXRjaCAmJiBpIDwgZW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5uZXJNYXRjaCA9IGlubmVyTWF0Y2gubWF0Y2hUeXBlKHBhcmVudC5jaGlsZChpKS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5uZXJNYXRjaCAmJiBpbm5lck1hdGNoLnZhbGlkRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFdyYXBwZXJzKHJhbmdlLCBpbm5lclJhbmdlLCBub2RlVHlwZSwgYXR0cnMpIHtcbiAgICB2YXIgYXJvdW5kID0gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgbm9kZVR5cGUpO1xuICAgIHZhciBpbm5lciA9IGZpbmRXcmFwcGluZ0luc2lkZShpbm5lclJhbmdlLCBub2RlVHlwZSk7XG4gICAgaWYgKGFyb3VuZCAmJiBpbm5lcikge1xuICAgICAgICB2YXIgYXJvdW5kTm9kZXMgPSBhcm91bmQubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW5uZXJOb2RlcyA9IGlubmVyLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgYXR0cnM6IGF0dHJzIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJvdW5kTm9kZXMuY29uY2F0KHsgdHlwZTogbm9kZVR5cGUgfSkuY29uY2F0KGlubmVyTm9kZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHdyYXBJbkxpc3QodHIsIF9hLCB3cmFwcGVycywgam9pbkJlZm9yZSwgbGlzdCkge1xuICAgIHZhciBzdGFydCA9IF9hLnN0YXJ0LCBlbmQgPSBfYS5lbmQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4LCBwYXJlbnQgPSBfYS5wYXJlbnQ7XG4gICAgdmFyIGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKHZhciBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgZW5kLCBzdGFydCwgZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICAgIHZhciBmb3VuZExpc3RJbmRleCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3cmFwcGVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAod3JhcHBlcnNbaV0udHlwZSA9PT0gbGlzdCkge1xuICAgICAgICAgICAgZm91bmRMaXN0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzcGxpdERlcHRoID0gd3JhcHBlcnMubGVuZ3RoIC0gZm91bmRMaXN0SW5kZXg7XG4gICAgdmFyIHNwbGl0UG9zID0gc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCwgbGVuID0gZW5kSW5kZXg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB2YXIgZmlyc3QgPSBpID09PSBzdGFydEluZGV4O1xuICAgICAgICBpZiAoIWZpcnN0ICYmIGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICAgICAgICBzcGxpdFBvcyArPSBzcGxpdERlcHRoICogMjtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdFBvcyArPSBwYXJlbnQuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGNoYW5nZVRvTGlzdCh0ciwgcmFuZ2UsIGxpc3QsIGF0dHJzKSB7XG4gICAgdmFyICRmcm9tID0gcmFuZ2UuJGZyb20sICR0byA9IHJhbmdlLiR0bywgZGVwdGggPSByYW5nZS5kZXB0aDtcbiAgICB2YXIgb3V0ZXJSYW5nZSA9IHJhbmdlO1xuICAgIHZhciBqb2luQmVmb3JlID0gZmFsc2U7XG4gICAgaWYgKGRlcHRoID49IDIgJiZcbiAgICAgICAgJGZyb20ubm9kZShkZXB0aCAtIDEpLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobGlzdCkgJiZcbiAgICAgICAgcmFuZ2Uuc3RhcnRJbmRleCA9PT0gMCAmJlxuICAgICAgICAkZnJvbS5pbmRleChkZXB0aCAtIDEpKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0IC0gMik7XG4gICAgICAgIG91dGVyUmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHN0YXJ0LCBzdGFydCwgZGVwdGgpO1xuICAgICAgICBpZiAocmFuZ2UuZW5kSW5kZXggPCByYW5nZS5wYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRmcm9tLCB0ci5kb2MucmVzb2x2ZSgkdG8uZW5kKGRlcHRoKSksIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICBqb2luQmVmb3JlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHdyYXBwZXJzID0gZmluZFdyYXBwZXJzKG91dGVyUmFuZ2UsIHJhbmdlLCBsaXN0LCBhdHRycyk7XG4gICAgaWYgKHdyYXBwZXJzKSB7XG4gICAgICAgIHJldHVybiB3cmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVMaW5lTGlzdEl0ZW0oZG9jLCBvZmZzZXQpIHtcbiAgICB2YXIgZW5kTGlzdEl0ZW1Qb3MgPSBkb2MucmVzb2x2ZShvZmZzZXQpO1xuICAgIHdoaWxlIChlbmRMaXN0SXRlbVBvcy5ub2RlKCkudHlwZS5uYW1lICE9PSAncGFyYWdyYXBoJykge1xuICAgICAgICBvZmZzZXQgLT0gMjsgLy8gVGhlIHBvc2l0aW9uIHZhbHVlIG9mIDwvbGk+PC91bD5cbiAgICAgICAgZW5kTGlzdEl0ZW1Qb3MgPSBkb2MucmVzb2x2ZShvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZmluZExpc3RJdGVtKGVuZExpc3RJdGVtUG9zKTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVRhc2tMaXN0SXRlbXModHIsIF9hKSB7XG4gICAgdmFyICRmcm9tID0gX2EuJGZyb20sICR0byA9IF9hLiR0bztcbiAgICB2YXIgc3RhcnRMaXN0SXRlbSA9IGZpbmRMaXN0SXRlbSgkZnJvbSk7XG4gICAgdmFyIGVuZExpc3RJdGVtID0gZmluZExpc3RJdGVtKCR0byk7XG4gICAgaWYgKHN0YXJ0TGlzdEl0ZW0gJiYgZW5kTGlzdEl0ZW0pIHtcbiAgICAgICAgd2hpbGUgKGVuZExpc3RJdGVtKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZW5kTGlzdEl0ZW0ub2Zmc2V0LCBub2RlID0gZW5kTGlzdEl0ZW0ubm9kZTtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHsgdGFzazogIW5vZGUuYXR0cnMudGFzaywgY2hlY2tlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAob2Zmc2V0LCBudWxsLCBhdHRycyk7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydExpc3RJdGVtLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTGlzdEl0ZW0gPSBnZXRCZWZvcmVMaW5lTGlzdEl0ZW0odHIuZG9jLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGNoYW5nZUxpc3RUeXBlKHRyLCBfYSwgbGlzdCkge1xuICAgIHZhciAkZnJvbSA9IF9hLiRmcm9tLCAkdG8gPSBfYS4kdG87XG4gICAgdmFyIHN0YXJ0TGlzdEl0ZW0gPSBmaW5kTGlzdEl0ZW0oJGZyb20pO1xuICAgIHZhciBlbmRMaXN0SXRlbSA9IGZpbmRMaXN0SXRlbSgkdG8pO1xuICAgIGlmIChzdGFydExpc3RJdGVtICYmIGVuZExpc3RJdGVtKSB7XG4gICAgICAgIHdoaWxlIChlbmRMaXN0SXRlbSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGVuZExpc3RJdGVtLm9mZnNldCwgbm9kZSA9IGVuZExpc3RJdGVtLm5vZGUsIGRlcHRoID0gZW5kTGlzdEl0ZW0uZGVwdGg7XG4gICAgICAgICAgICBpZiAobm9kZS5hdHRycy50YXNrKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChvZmZzZXQsIG51bGwsIHsgdGFzazogZmFsc2UsIGNoZWNrZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc29sdmVkUG9zID0gdHIuZG9jLnJlc29sdmUob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFBvcy5wYXJlbnQudHlwZSAhPT0gbGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRPZmZzZXQgPSByZXNvbHZlZFBvcy5iZWZvcmUoZGVwdGggLSAxKTtcbiAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBhcmVudE9mZnNldCwgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydExpc3RJdGVtLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTGlzdEl0ZW0gPSBnZXRCZWZvcmVMaW5lTGlzdEl0ZW0odHIuZG9jLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGNoYW5nZUxpc3QobGlzdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHI7XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBuZXdUciA9IGlzSW5MaXN0Tm9kZSgkZnJvbSlcbiAgICAgICAgICAgICAgICA/IGNoYW5nZUxpc3RUeXBlKHRyLCByYW5nZSwgbGlzdClcbiAgICAgICAgICAgICAgICA6IGNoYW5nZVRvTGlzdCh0ciwgcmFuZ2UsIGxpc3QpO1xuICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVUYXNrKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIG5ld1RyID0gaXNJbkxpc3ROb2RlKCRmcm9tKVxuICAgICAgICAgICAgICAgID8gdG9nZ2xlVGFza0xpc3RJdGVtcyh0ciwgcmFuZ2UpXG4gICAgICAgICAgICAgICAgOiBjaGFuZ2VUb0xpc3QodHIsIHJhbmdlLCBzY2hlbWEubm9kZXMuYnVsbGV0TGlzdCwgeyB0YXNrOiB0cnVlIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0obGlzdEl0ZW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgdHIgPSBfYS50ciwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZENvdW50ID0gX2EuY2hpbGRDb3VudCwgZmlyc3RDaGlsZCA9IF9hLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICByZXR1cm4gISFjaGlsZENvdW50ICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gbGlzdEl0ZW07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmFuZ2UgJiYgcmFuZ2Uuc3RhcnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHJhbmdlLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBub2RlQmVmb3JlID0gcGFyZW50XzEuY2hpbGQocmFuZ2Uuc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICAgICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPT0gbGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PT0gcGFyZW50XzEudHlwZTtcbiAgICAgICAgICAgIHZhciBpbm5lciA9IG5lc3RlZEJlZm9yZSA/IEZyYWdtZW50LmZyb20obGlzdEl0ZW0uY3JlYXRlKCkpIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGxpc3RJdGVtLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKHBhcmVudF8xLnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSwgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoYmVmb3JlIC0gKG5lc3RlZEJlZm9yZSA/IDMgOiAxKSwgYWZ0ZXIsIGJlZm9yZSwgYWZ0ZXIsIHNsaWNlLCAxLCB0cnVlKSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpZnRUb091dGVyTGlzdCh0ciwgcmFuZ2UsIGxpc3RJdGVtKSB7XG4gICAgdmFyICRmcm9tID0gcmFuZ2UuJGZyb20sICR0byA9IHJhbmdlLiR0bywgZW5kID0gcmFuZ2UuZW5kLCBkZXB0aCA9IHJhbmdlLmRlcHRoLCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgdmFyIGVuZE9mTGlzdCA9ICR0by5lbmQoZGVwdGgpO1xuICAgIGlmIChlbmQgPCBlbmRPZkxpc3QpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNpYmxpbmdzIGFmdGVyIHRoZSBsaWZ0ZWQgaXRlbXMsIHdoaWNoIG11c3QgYmVjb21lXG4gICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obGlzdEl0ZW0uY3JlYXRlKG51bGwsIHBhcmVudC5jb3B5KCkpKSwgMSwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIGRlcHRoKTtcbiAgICB9XG4gICAgdHIubGlmdChyYW5nZSwgbGlmdFRhcmdldChyYW5nZSkpO1xuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGxpZnRPdXRPZkxpc3QodHIsIHJhbmdlKSB7XG4gICAgdmFyIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG4gICAgdmFyIHBvcyA9IHJhbmdlLmVuZDtcbiAgICAvLyBNZXJnZSB0aGUgbGlzdCBpdGVtcyBpbnRvIGEgc2luZ2xlIGJpZyBpdGVtXG4gICAgZm9yICh2YXIgaSA9IHJhbmdlLmVuZEluZGV4IC0gMSwgbGVuID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGxlbjsgaSAtPSAxKSB7XG4gICAgICAgIHBvcyAtPSBsaXN0LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgICB0ci5kZWxldGUocG9zIC0gMSwgcG9zICsgMSk7XG4gICAgfVxuICAgIHZhciBzdGFydFBvcyA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0KTtcbiAgICB2YXIgbGlzdEl0ZW0gPSBzdGFydFBvcy5ub2RlQWZ0ZXI7XG4gICAgdmFyIGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09PSAwO1xuICAgIHZhciBhdEVuZCA9IHJhbmdlLmVuZEluZGV4ID09PSBsaXN0LmNoaWxkQ291bnQ7XG4gICAgdmFyIHBhcmVudCA9IHN0YXJ0UG9zLm5vZGUoLTEpO1xuICAgIHZhciBpbmRleEJlZm9yZSA9IHN0YXJ0UG9zLmluZGV4KC0xKTtcbiAgICB2YXIgY2FuUmVwbGFjZVBhcmVudCA9IHBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSwgbGlzdEl0ZW0gPT09IG51bGwgfHwgbGlzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RJdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QpKSk7XG4gICAgaWYgKGxpc3RJdGVtICYmIGNhblJlcGxhY2VQYXJlbnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRQb3MucG9zO1xuICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBsaXN0SXRlbS5ub2RlU2l6ZTtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBzdXJyb3VuZGluZyBsaXN0LiBBdCB0aGUgc2lkZXMgd2hlcmUgd2UncmUgbm90IGF0XG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZSBleGlzdGluZyBsaXN0IGlzIGNsb3NlZC4gQXQgc2lkZXMgd2hlcmVcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kLCBpdCBpcyBvdmVyd3JpdHRlbiB0byBpdHMgZW5kLlxuICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IFNsaWNlKChhdFN0YXJ0ID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKS5hcHBlbmQoYXRFbmQgPyBGcmFnbWVudC5lbXB0eSA6IEZyYWdtZW50LmZyb20obGlzdC5jb3B5KEZyYWdtZW50LmVtcHR5KSkpLCBhdFN0YXJ0ID8gMCA6IDEsIGF0RW5kID8gMCA6IDEpLCBhdFN0YXJ0ID8gMCA6IDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gbGlmdExpc3RJdGVtKGxpc3RJdGVtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHRyID0gX2EudHIsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IF9hLmNoaWxkQ291bnQsIGZpcnN0Q2hpbGQgPSBfYS5maXJzdENoaWxkO1xuICAgICAgICAgICAgcmV0dXJuICEhY2hpbGRDb3VudCAmJiBmaXJzdENoaWxkLnR5cGUgPT09IGxpc3RJdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgdG9wTGlzdEl0ZW0gPSAkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PT0gbGlzdEl0ZW07XG4gICAgICAgICAgICB2YXIgbmV3VHIgPSB0b3BMaXN0SXRlbSA/IGxpZnRUb091dGVyTGlzdCh0ciwgcmFuZ2UsIGxpc3RJdGVtKSA6IGxpZnRPdXRPZkxpc3QodHIsIHJhbmdlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3BsaXRMaXN0SXRlbShsaXN0SXRlbSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IF9hLnRyLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgaWYgKCRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgICAgIGlmIChncmFuZFBhcmVudC50eXBlICE9PSBsaXN0SXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09PSAwICYmICRmcm9tLm5vZGUoLTEpLmNoaWxkQ291bnQgPT09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgICAgICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XG4gICAgICAgICAgICAvLyBjb21tYW5kIGhhbmRsZSBsaWZ0aW5nLlxuICAgICAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09PSAyIHx8XG4gICAgICAgICAgICAgICAgJGZyb20ubm9kZSgtMykudHlwZSAhPT0gbGlzdEl0ZW0gfHxcbiAgICAgICAgICAgICAgICAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtlZXBJdGVtID0gJGZyb20uaW5kZXgoLTEpID4gMDtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICAgICAgICBmb3IgKHZhciBkZXB0aCA9ICRmcm9tLmRlcHRoIC0gKGtlZXBJdGVtID8gMSA6IDIpOyBkZXB0aCA+PSAkZnJvbS5kZXB0aCAtIDM7IGRlcHRoIC09IDEpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGRlcHRoKS5jb3B5KHdyYXBwZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyLmFwcGVuZChGcmFnbWVudC5mcm9tKGxpc3RJdGVtLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgdHIucmVwbGFjZShrZWVwSXRlbSA/ICRmcm9tLmJlZm9yZSgpIDogJGZyb20uYmVmb3JlKC0xKSwgJGZyb20uYWZ0ZXIoLTMpLCBuZXcgU2xpY2Uod3JhcHBlciwga2VlcEl0ZW0gPyAzIDogMiwgMikpO1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIChrZWVwSXRlbSA/IDMgOiAyKSkpKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0VHlwZSA9ICR0by5wb3MgPT09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgICAgICB2YXIgdHlwZXMgPSBuZXh0VHlwZSAmJiBbbnVsbCwgeyB0eXBlOiBuZXh0VHlwZSB9XTtcbiAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgICAgIGlmIChjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICAgICAgaWYgKHJhbmdlICYmIGlzSW5MaXN0Tm9kZSgkZnJvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5rTGlzdEl0ZW0oc2NoZW1hLm5vZGVzLmxpc3RJdGVtKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9OyB9O1xufVxuZnVuY3Rpb24gb3V0ZGVudCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICBpZiAocmFuZ2UgJiYgaXNJbkxpc3ROb2RlKCRmcm9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpZnRMaXN0SXRlbShzY2hlbWEubm9kZXMubGlzdEl0ZW0pKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07IH07XG59XG5mdW5jdGlvbiBnZXRXd0NvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluZGVudDogaW5kZW50KCksXG4gICAgICAgIG91dGRlbnQ6IG91dGRlbnQoKSxcbiAgICB9O1xufVxuXG52YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbnZhciBUYWJsZU9mZnNldE1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZU9mZnNldE1hcCh0YWJsZSwgdGFibGVSb3dzLCB0YWJsZVN0YXJ0UG9zLCByb3dJbmZvKSB7XG4gICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICAgICAgdGhpcy50YWJsZVJvd3MgPSB0YWJsZVJvd3M7XG4gICAgICAgIHRoaXMudGFibGVTdGFydFBvcyA9IHRhYmxlU3RhcnRQb3M7XG4gICAgICAgIHRoaXMucm93SW5mbyA9IHJvd0luZm87XG4gICAgfVxuICAgIFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZSA9IGZ1bmN0aW9uIChjZWxsUG9zKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IGZpbmROb2RlQnkoY2VsbFBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAndGFibGUnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRhYmxlLm5vZGUsIGRlcHRoID0gdGFibGUuZGVwdGgsIG9mZnNldCA9IHRhYmxlLm9mZnNldDtcbiAgICAgICAgICAgIHZhciBjYWNoZWQgPSBjYWNoZS5nZXQobm9kZSk7XG4gICAgICAgICAgICBpZiAoKGNhY2hlZCA9PT0gbnVsbCB8fCBjYWNoZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhY2hlZC50YWJsZVN0YXJ0UG9zKSA9PT0gb2Zmc2V0ICsgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm93c18xID0gW107XG4gICAgICAgICAgICB2YXIgdGFibGVQb3MgPSBjZWxsUG9zLnN0YXJ0KGRlcHRoKTtcbiAgICAgICAgICAgIHZhciB0aGVhZCA9IG5vZGUuY2hpbGQoMCk7XG4gICAgICAgICAgICB2YXIgdGJvZHkgPSBub2RlLmNoaWxkKDEpO1xuICAgICAgICAgICAgdmFyIHRoZWFkQ2VsbEluZm8gPSBjcmVhdGVPZmZzZXRNYXAodGhlYWQsIHRhYmxlUG9zKTtcbiAgICAgICAgICAgIHZhciB0Ym9keUNlbGxJbmZvID0gY3JlYXRlT2Zmc2V0TWFwKHRib2R5LCB0YWJsZVBvcyArIHRoZWFkLm5vZGVTaXplKTtcbiAgICAgICAgICAgIHRoZWFkLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93c18xLnB1c2gocm93KTsgfSk7XG4gICAgICAgICAgICB0Ym9keS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd3NfMS5wdXNoKHJvdyk7IH0pO1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBUYWJsZU9mZnNldE1hcChub2RlLCByb3dzXzEsIHRhYmxlUG9zLCB0aGVhZENlbGxJbmZvLmNvbmNhdCh0Ym9keUNlbGxJbmZvKSk7XG4gICAgICAgICAgICBjYWNoZS5zZXQobm9kZSwgbWFwKTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBcInRvdGFsUm93Q291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0luZm8ubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgXCJ0b3RhbENvbHVtbkNvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmZvWzBdLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidGFibGVTdGFydE9mZnNldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFibGVTdGFydFBvcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidGFibGVFbmRPZmZzZXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYmxlU3RhcnRQb3MgKyB0aGlzLnRhYmxlLm5vZGVTaXplIC0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsSW5mbyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5wb3NBdCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgcm93U3RhcnQgPSB0aGlzLnRhYmxlU3RhcnRQb3M7OyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciByb3dFbmQgPSByb3dTdGFydCArIHRoaXMudGFibGVSb3dzW2ldLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkgPT09IHJvd0lkeCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGNvbElkeDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBjZWxscyBmcm9tIHByZXZpb3VzIHJvdyh2aWEgcm93c3BhbilcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCB0aGlzLnRvdGFsQ29sdW1uQ291bnQgJiYgdGhpcy5yb3dJbmZvW2ldW2luZGV4XS5vZmZzZXQgPCByb3dTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPT09IHRoaXMudG90YWxDb2x1bW5Db3VudCA/IHJvd0VuZCA6IHRoaXMucm93SW5mb1tpXVtpbmRleF0ub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93U3RhcnQgPSByb3dFbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXROb2RlQW5kUG9zID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBjZWxsSW5mbyA9IHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiB0aGlzLnRhYmxlLm5vZGVBdChjZWxsSW5mby5vZmZzZXQgLSB0aGlzLnRhYmxlU3RhcnRPZmZzZXQpLFxuICAgICAgICAgICAgcG9zOiBjZWxsSW5mby5vZmZzZXQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZXh0ZW5kZWRSb3dzcGFuID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5leHRlbmRlZENvbHNwYW4gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFJvd3NwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDb2xzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZGVjcmVhc2VDb2xzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZGVjcmVhc2VSb3dzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q29sc3BhblN0YXJ0SW5mbyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRSb3dzcGFuU3RhcnRJbmZvID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENlbGxTdGFydE9mZnNldCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XS5vZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgPyB0aGlzLnBvc0F0KHJvd0lkeCwgY29sSWR4KSA6IG9mZnNldDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsRW5kT2Zmc2V0ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF0sIG9mZnNldCA9IF9hLm9mZnNldCwgbm9kZVNpemUgPSBfYS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSA/IHRoaXMucG9zQXQocm93SWR4LCBjb2xJZHgpIDogb2Zmc2V0ICsgbm9kZVNpemU7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q2VsbEluZGV4ID0gZnVuY3Rpb24gKGNlbGxQb3MpIHtcbiAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgdGhpcy50b3RhbFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgdmFyIHJvd0luZm8gPSB0aGlzLnJvd0luZm9bcm93SWR4XTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IDA7IGNvbElkeCA8IHRoaXMudG90YWxDb2x1bW5Db3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93SW5mb1tjb2xJZHhdLm9mZnNldCArIDEgPiBjZWxsUG9zLnBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Jvd0lkeCwgY29sSWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRSZWN0T2Zmc2V0cyA9IGZ1bmN0aW9uIChzdGFydENlbGxQb3MsIGVuZENlbGxQb3MpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChlbmRDZWxsUG9zID09PSB2b2lkIDApIHsgZW5kQ2VsbFBvcyA9IHN0YXJ0Q2VsbFBvczsgfVxuICAgICAgICBpZiAoc3RhcnRDZWxsUG9zLnBvcyA+IGVuZENlbGxQb3MucG9zKSB7XG4gICAgICAgICAgICBfYSA9IFtlbmRDZWxsUG9zLCBzdGFydENlbGxQb3NdLCBzdGFydENlbGxQb3MgPSBfYVswXSwgZW5kQ2VsbFBvcyA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfZCA9IHRoaXMuZ2V0Q2VsbEluZGV4KHN0YXJ0Q2VsbFBvcyksIHN0YXJ0Um93SWR4ID0gX2RbMF0sIHN0YXJ0Q29sSWR4ID0gX2RbMV07XG4gICAgICAgIHZhciBfZSA9IHRoaXMuZ2V0Q2VsbEluZGV4KGVuZENlbGxQb3MpLCBlbmRSb3dJZHggPSBfZVswXSwgZW5kQ29sSWR4ID0gX2VbMV07XG4gICAgICAgIF9iID0gZ2V0U29ydGVkTnVtUGFpcihzdGFydFJvd0lkeCwgZW5kUm93SWR4KSwgc3RhcnRSb3dJZHggPSBfYlswXSwgZW5kUm93SWR4ID0gX2JbMV07XG4gICAgICAgIF9jID0gZ2V0U29ydGVkTnVtUGFpcihzdGFydENvbElkeCwgZW5kQ29sSWR4KSwgc3RhcnRDb2xJZHggPSBfY1swXSwgZW5kQ29sSWR4ID0gX2NbMV07XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNwYW5uZWRPZmZzZXRzKHsgc3RhcnRSb3dJZHg6IHN0YXJ0Um93SWR4LCBzdGFydENvbElkeDogc3RhcnRDb2xJZHgsIGVuZFJvd0lkeDogZW5kUm93SWR4LCBlbmRDb2xJZHg6IGVuZENvbElkeCB9KTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRTcGFubmVkT2Zmc2V0cyA9IGZ1bmN0aW9uIChzZWxlY3Rpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25JbmZvO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlT2Zmc2V0TWFwO1xufSgpKTtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG52YXIgY3JlYXRlT2Zmc2V0TWFwID0gZnVuY3Rpb24gKGhlYWRPckJvZHksIHN0YXJ0T2Zmc2V0KSB7XG4gICAgdmFyIGNlbGxJbmZvTWF0cml4ID0gW107XG4gICAgaGVhZE9yQm9keS5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIHJvd09mZnNldCkge1xuICAgICAgICAvLyBnZXQgcm93IGluZGV4IGJhc2VkIG9uIHRhYmxlKG5vdCB0YWJsZSBoZWFkIG9yIHRhYmxlIGJvZHkpXG4gICAgICAgIHZhciByb3dJbmZvID0geyByb3dzcGFuTWFwOiB7fSwgY29sc3Bhbk1hcDoge30sIGxlbmd0aDogMCB9O1xuICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbiAoX2EsIGNlbGxPZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBub2RlU2l6ZSA9IF9hLm5vZGVTaXplO1xuICAgICAgICAgICAgdmFyIGNvbElkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocm93SW5mb1tjb2xJZHhdKSB7XG4gICAgICAgICAgICAgICAgY29sSWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dJbmZvW2NvbElkeF0gPSB7XG4gICAgICAgICAgICAgICAgLy8gMiBpcyB0aGUgc3VtIG9mIHRoZSBmcm9udCBhbmQgYmFjayBwb3NpdGlvbnMgb2YgdGhlIHRhZ1xuICAgICAgICAgICAgICAgIG9mZnNldDogc3RhcnRPZmZzZXQgKyByb3dPZmZzZXQgKyBjZWxsT2Zmc2V0ICsgMixcbiAgICAgICAgICAgICAgICBub2RlU2l6ZTogbm9kZVNpemUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcm93SW5mby5sZW5ndGggKz0gMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNlbGxJbmZvTWF0cml4LnB1c2gocm93SW5mbyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNlbGxJbmZvTWF0cml4O1xufTtcbmZ1bmN0aW9uIG1peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUob2Zmc2V0TWFwTWl4aW4sIGNyZWF0ZU9mZnNldE1hcE1peGluKSB7XG4gICAgYXNzaWduKFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgb2Zmc2V0TWFwTWl4aW4pO1xuICAgIGNyZWF0ZU9mZnNldE1hcCA9IGNyZWF0ZU9mZnNldE1hcE1peGluO1xuICAgIHJldHVybiBUYWJsZU9mZnNldE1hcDtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmFuZ2VzKGRvYywgbWFwLCBfYSkge1xuICAgIHZhciBzdGFydFJvd0lkeCA9IF9hLnN0YXJ0Um93SWR4LCBzdGFydENvbElkeCA9IF9hLnN0YXJ0Q29sSWR4LCBlbmRSb3dJZHggPSBfYS5lbmRSb3dJZHgsIGVuZENvbElkeCA9IF9hLmVuZENvbElkeDtcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgcm93SWR4ID0gc3RhcnRSb3dJZHg7IHJvd0lkeCA8PSBlbmRSb3dJZHg7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGNvbElkeCA9IHN0YXJ0Q29sSWR4OyBjb2xJZHggPD0gZW5kQ29sSWR4OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFNlbGVjdGlvblJhbmdlKGRvYy5yZXNvbHZlKG9mZnNldCArIDEpLCBkb2MucmVzb2x2ZShvZmZzZXQgKyBub2RlU2l6ZSAtIDEpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlRnJhZ21lbnQodGFibGVIZWFkLCB0YWJsZUJvZHkpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBbXTtcbiAgICBpZiAodGFibGVIZWFkLmNoaWxkQ291bnQpIHtcbiAgICAgICAgZnJhZ21lbnQucHVzaCh0YWJsZUhlYWQpO1xuICAgIH1cbiAgICBpZiAodGFibGVCb2R5LmNoaWxkQ291bnQpIHtcbiAgICAgICAgZnJhZ21lbnQucHVzaCh0YWJsZUJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShmcmFnbWVudCk7XG59XG52YXIgQ2VsbFNlbGVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDZWxsU2VsZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENlbGxTZWxlY3Rpb24oc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKSB7XG4gICAgICAgIGlmIChlbmRDZWxsUG9zID09PSB2b2lkIDApIHsgZW5kQ2VsbFBvcyA9IHN0YXJ0Q2VsbFBvczsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZG9jID0gc3RhcnRDZWxsUG9zLm5vZGUoMCk7XG4gICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoc3RhcnRDZWxsUG9zKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKTtcbiAgICAgICAgdmFyIHJhbmdlcyA9IGdldFNlbGVjdGlvblJhbmdlcyhkb2MsIG1hcCwgc2VsZWN0aW9uSW5mbyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmFuZ2VzWzBdLiRmcm9tLCByYW5nZXNbMF0uJHRvLCByYW5nZXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXJ0Q2VsbCA9IHN0YXJ0Q2VsbFBvcztcbiAgICAgICAgX3RoaXMuZW5kQ2VsbCA9IGVuZENlbGxQb3M7XG4gICAgICAgIF90aGlzLm9mZnNldE1hcCA9IG1hcDtcbiAgICAgICAgX3RoaXMuaXNDZWxsU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyB0aGUgYXBpIG9mIHRoZSAnU2VsZWN0aW9uJyBpbiBwcm9zZW1pcnJvcixcbiAgICAgICAgLy8gYW5kIGlzIHVzZWQgdG8gZGlzYWJsZSB0aGUgdGV4dCBzZWxlY3Rpb24uXG4gICAgICAgIF90aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnRDZWxsLnBvcztcbiAgICAgICAgdmFyIGVuZFBvcyA9IHRoaXMuZW5kQ2VsbC5wb3M7XG4gICAgICAgIHZhciBzdGFydENlbGwgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChzdGFydFBvcykpO1xuICAgICAgICB2YXIgZW5kQ2VsbCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKGVuZFBvcykpO1xuICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKHN0YXJ0Q2VsbCk7XG4gICAgICAgIC8vIHRleHQgc2VsZWN0aW9uIHdoZW4gcm93cyBvciBjb2x1bW5zIGFyZSBkZWxldGVkXG4gICAgICAgIGlmICh0aGlzLm9mZnNldE1hcC50b3RhbENvbHVtbkNvdW50ID4gbWFwLnRvdGFsQ29sdW1uQ291bnQgfHxcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0TWFwLnRvdGFsUm93Q291bnQgPiBtYXAudG90YWxSb3dDb3VudCkge1xuICAgICAgICAgICAgdmFyIGRlcHRoTWFwID0geyB0YWJsZUJvZHk6IDEsIHRhYmxlUm93OiAyLCB0YWJsZUNlbGw6IDMsIHBhcmFncmFwaDogNCB9O1xuICAgICAgICAgICAgdmFyIGRlcHRoRnJvbVRhYmxlID0gZGVwdGhNYXBbZW5kQ2VsbC5wYXJlbnQudHlwZS5uYW1lXTtcbiAgICAgICAgICAgIHZhciB0YWJsZUVuZFBvcyA9IGVuZENlbGwuZW5kKGVuZENlbGwuZGVwdGggLSBkZXB0aEZyb21UYWJsZSk7XG4gICAgICAgICAgICAvLyBzdWJ0cmFjdCA0KDwvdGQ+PC90cj48L3Rib2R5PjwvdGFibGU+IHRhZyBsZW5ndGgpXG4gICAgICAgICAgICB2YXIgZnJvbSA9IE1hdGgubWluKHRhYmxlRW5kUG9zIC0gNCwgZW5kQ2VsbC5wb3MpO1xuICAgICAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsU2VsZWN0aW9uKHN0YXJ0Q2VsbCwgZW5kQ2VsbCk7XG4gICAgfTtcbiAgICBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIHJldHVybiAoY2VsbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIGNlbGwuc3RhcnRDZWxsLnBvcyA9PT0gdGhpcy5zdGFydENlbGwucG9zICYmXG4gICAgICAgICAgICBjZWxsLmVuZENlbGwucG9zID09PSB0aGlzLmVuZENlbGwucG9zKTtcbiAgICB9O1xuICAgIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMuc3RhcnRDZWxsLm5vZGUoLTIpO1xuICAgICAgICB2YXIgdGFibGVPZmZzZXQgPSB0aGlzLnN0YXJ0Q2VsbC5zdGFydCgtMik7XG4gICAgICAgIHZhciByb3cgPSB0YWJsZS5jaGlsZCgxKS5maXJzdENoaWxkO1xuICAgICAgICB2YXIgdGFibGVIZWFkID0gdGFibGUuY2hpbGQoMCkudHlwZS5jcmVhdGUoKTtcbiAgICAgICAgdmFyIHRhYmxlQm9keSA9IHRhYmxlLmNoaWxkKDEpLnR5cGUuY3JlYXRlKCk7XG4gICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUodGhpcy5zdGFydENlbGwpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyh0aGlzLnN0YXJ0Q2VsbCwgdGhpcy5lbmRDZWxsKTtcbiAgICAgICAgdmFyIHN0YXJ0Um93SWR4ID0gc2VsZWN0aW9uSW5mby5zdGFydFJvd0lkeCwgc3RhcnRDb2xJZHggPSBzZWxlY3Rpb25JbmZvLnN0YXJ0Q29sSWR4LCBlbmRSb3dJZHggPSBzZWxlY3Rpb25JbmZvLmVuZFJvd0lkeCwgZW5kQ29sSWR4ID0gc2VsZWN0aW9uSW5mby5lbmRDb2xJZHg7XG4gICAgICAgIHZhciBpc1RhYmxlSGVhZENlbGwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gc3RhcnRSb3dJZHg7IHJvd0lkeCA8PSBlbmRSb3dJZHg7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IHN0YXJ0Q29sSWR4OyBjb2xJZHggPD0gZW5kQ29sSWR4OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCBjb2xJZHgpLm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRhYmxlLm5vZGVBdChvZmZzZXQgLSB0YWJsZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNUYWJsZUhlYWRDZWxsID0gY2VsbC50eXBlLm5hbWUgPT09ICd0YWJsZUhlYWRDZWxsJztcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFyayB0aGUgZXh0ZW5kZWQgY2VsbCBmb3IgcGFzdGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgfHwgbWFwLmV4dGVuZGVkQ29sc3Bhbihyb3dJZHgsIGNvbElkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbC50eXBlLmNyZWF0ZSh7IGV4dGVuZGVkOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbC5jb3B5KGNlbGwuY29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvcGllZFJvdyA9IHJvdy5jb3B5KEZyYWdtZW50LmZyb20oY2VsbHMpKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gaXNUYWJsZUhlYWRDZWxsID8gdGFibGVIZWFkIDogdGFibGVCb2R5O1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGFyZ2V0Tm9kZS5jb250ZW50ID0gdGFyZ2V0Tm9kZS5jb250ZW50LmFwcGVuZChGcmFnbWVudC5mcm9tKGNvcGllZFJvdykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoY3JlYXRlVGFibGVGcmFnbWVudCh0YWJsZUhlYWQsIHRhYmxlQm9keSksIDEsIDEpO1xuICAgIH07XG4gICAgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2VsbFNlbGVjdGlvbjtcbn0oU2VsZWN0aW9uKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlSGVhZFJvdyhjb2x1bW5Db3VudCwgc2NoZW1hLCBkYXRhKSB7XG4gICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZVJvdyA9IF9hLnRhYmxlUm93LCB0YWJsZUhlYWRDZWxsID0gX2EudGFibGVIZWFkQ2VsbCwgcGFyYWdyYXBoID0gX2EucGFyYWdyYXBoO1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjb2x1bW5Db3VudDsgaW5kZXggKz0gMSkge1xuICAgICAgICB2YXIgdGV4dCA9IGRhdGEgJiYgZGF0YVtpbmRleF07XG4gICAgICAgIHZhciBwYXJhID0gcGFyYWdyYXBoLmNyZWF0ZShudWxsLCB0ZXh0ID8gc2NoZW1hLnRleHQodGV4dCkgOiBbXSk7XG4gICAgICAgIGNlbGxzLnB1c2godGFibGVIZWFkQ2VsbC5jcmVhdGUobnVsbCwgcGFyYSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RhYmxlUm93LmNyZWF0ZShudWxsLCBjZWxscyldO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVCb2R5Um93cyhyb3dDb3VudCwgY29sdW1uQ291bnQsIHNjaGVtYSwgZGF0YSkge1xuICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVSb3cgPSBfYS50YWJsZVJvdywgdGFibGVCb2R5Q2VsbCA9IF9hLnRhYmxlQm9keUNlbGwsIHBhcmFncmFwaCA9IF9hLnBhcmFncmFwaDtcbiAgICB2YXIgdGFibGVSb3dzID0gW107XG4gICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgcm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgIHZhciBjZWxscyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjb2xJZHggPSAwOyBjb2xJZHggPCBjb2x1bW5Db3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZGF0YSAmJiBkYXRhW3Jvd0lkeCAqIGNvbHVtbkNvdW50ICsgY29sSWR4XTtcbiAgICAgICAgICAgIHZhciBwYXJhID0gcGFyYWdyYXBoLmNyZWF0ZShudWxsLCB0ZXh0ID8gc2NoZW1hLnRleHQodGV4dCkgOiBbXSk7XG4gICAgICAgICAgICBjZWxscy5wdXNoKHRhYmxlQm9keUNlbGwuY3JlYXRlKG51bGwsIHBhcmEpKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZVJvd3MucHVzaCh0YWJsZVJvdy5jcmVhdGUobnVsbCwgY2VsbHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlUm93cztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUR1bW15Q2VsbHMoY29sdW1uQ291bnQsIHJvd0lkeCwgc2NoZW1hLCBhdHRycykge1xuICAgIGlmIChhdHRycyA9PT0gdm9pZCAwKSB7IGF0dHJzID0gbnVsbDsgfVxuICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVIZWFkQ2VsbCA9IF9hLnRhYmxlSGVhZENlbGwsIHRhYmxlQm9keUNlbGwgPSBfYS50YWJsZUJvZHlDZWxsLCBwYXJhZ3JhcGggPSBfYS5wYXJhZ3JhcGg7XG4gICAgdmFyIGNlbGwgPSByb3dJZHggPT09IDAgPyB0YWJsZUhlYWRDZWxsIDogdGFibGVCb2R5Q2VsbDtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY29sdW1uQ291bnQ7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgY2VsbHMucHVzaChjZWxsLmNyZWF0ZShhdHRycywgcGFyYWdyYXBoLmNyZWF0ZSgpKSk7XG4gICAgfVxuICAgIHJldHVybiBjZWxscztcbn1cbmZ1bmN0aW9uIGZpbmRDZWxsRWxlbWVudChub2RlLCByb290KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1REJyB8fCBub2RlLm5vZGVOYW1lID09PSAnVEgnKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRDZWxsKHBvcykge1xuICAgIHJldHVybiBmaW5kTm9kZUJ5KHBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZENlbGwnIHx8IHR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keUNlbGwnO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyICRhbmNob3IgPSBzZWxlY3Rpb24uJGFuY2hvcjtcbiAgICAgICAgdmFyIGZvdW5kQ2VsbCA9IGZpbmRDZWxsKCRhbmNob3IpO1xuICAgICAgICBpZiAoZm91bmRDZWxsKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gJGFuY2hvci5ub2RlKDApLnJlc29sdmUoJGFuY2hvci5iZWZvcmUoZm91bmRDZWxsLmRlcHRoKSk7XG4gICAgICAgICAgICByZXR1cm4geyBhbmNob3I6IGFuY2hvciwgaGVhZDogYW5jaG9yIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9hID0gc2VsZWN0aW9uLCBzdGFydENlbGwgPSBfYS5zdGFydENlbGwsIGVuZENlbGwgPSBfYS5lbmRDZWxsO1xuICAgIHJldHVybiB7IGFuY2hvcjogc3RhcnRDZWxsLCBoZWFkOiBlbmRDZWxsIH07XG59XG5mdW5jdGlvbiBnZXRUYWJsZUNvbnRlbnRGcm9tU2xpY2Uoc2xpY2UpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHNsaWNlLnNpemUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQsIG9wZW5FbmQgPSBzbGljZS5vcGVuRW5kO1xuICAgICAgICBpZiAoY29udGVudC5jaGlsZENvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29udGVudC5jaGlsZENvdW50ID09PSAxICYmXG4gICAgICAgICAgICAoKG9wZW5TdGFydCA+IDAgJiYgb3BlbkVuZCA+IDApIHx8ICgoX2EgPSBjb250ZW50LmZpcnN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlLm5hbWUpID09PSAndGFibGUnKSkge1xuICAgICAgICAgICAgb3BlblN0YXJ0IC09IDE7XG4gICAgICAgICAgICBvcGVuRW5kIC09IDE7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLm5hbWUgPT09ICd0YWJsZUhlYWQnIHx8XG4gICAgICAgICAgICBjb250ZW50LmZpcnN0Q2hpbGQudHlwZS5uYW1lID09PSAndGFibGVCb2R5Jykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRSb3dBbmRDb2x1bW5Db3VudChfYSkge1xuICAgIHZhciBzdGFydFJvd0lkeCA9IF9hLnN0YXJ0Um93SWR4LCBzdGFydENvbElkeCA9IF9hLnN0YXJ0Q29sSWR4LCBlbmRSb3dJZHggPSBfYS5lbmRSb3dJZHgsIGVuZENvbElkeCA9IF9hLmVuZENvbElkeDtcbiAgICB2YXIgcm93Q291bnQgPSBlbmRSb3dJZHggLSBzdGFydFJvd0lkeCArIDE7XG4gICAgdmFyIGNvbHVtbkNvdW50ID0gZW5kQ29sSWR4IC0gc3RhcnRDb2xJZHggKyAxO1xuICAgIHJldHVybiB7IHJvd0NvdW50OiByb3dDb3VudCwgY29sdW1uQ291bnQ6IGNvbHVtbkNvdW50IH07XG59XG5mdW5jdGlvbiBzZXRBdHRycyhjZWxsLCBhdHRycykge1xuICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGNlbGwuYXR0cnMpLCBhdHRycyk7XG59XG5cbnZhciBwbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdjZWxsU2VsZWN0aW9uJyk7XG52YXIgTU9VU0VfUklHSFRfQlVUVE9OID0gMjtcbnZhciBUYWJsZVNlbGVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZVNlbGVjdGlvbih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBtb3VzZWRvd246IHRoaXMuaGFuZGxlTW91c2Vkb3duLmJpbmQodGhpcyksXG4gICAgICAgICAgICBtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2Vtb3ZlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBtb3VzZXVwOiB0aGlzLmhhbmRsZU1vdXNldXAuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGFydENlbGxQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVycy5tb3VzZWRvd24pO1xuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmhhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgZm91bmRDZWxsID0gZmluZENlbGxFbGVtZW50KGV2LnRhcmdldCwgdGhpcy52aWV3LmRvbSk7XG4gICAgICAgIGlmIChldi5idXR0b24gPT09IE1PVVNFX1JJR0hUX0JVVFRPTikge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDZWxsKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRDZWxsUG9zID0gdGhpcy5nZXRDZWxsUG9zKGV2KTtcbiAgICAgICAgICAgIGlmIChzdGFydENlbGxQb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q2VsbFBvcyA9IHN0YXJ0Q2VsbFBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmluZEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVNb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIHByZXZFbmRDZWxsT2Zmc2V0ID0gcGx1Z2luS2V5LmdldFN0YXRlKHRoaXMudmlldy5zdGF0ZSk7XG4gICAgICAgIHZhciBlbmRDZWxsUG9zID0gdGhpcy5nZXRDZWxsUG9zKGV2KTtcbiAgICAgICAgdmFyIHN0YXJ0Q2VsbFBvcyA9IHRoaXMuc3RhcnRDZWxsUG9zO1xuICAgICAgICB2YXIgcHJldkVuZENlbGxQb3M7XG4gICAgICAgIGlmIChwcmV2RW5kQ2VsbE9mZnNldCkge1xuICAgICAgICAgICAgcHJldkVuZENlbGxQb3MgPSB0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocHJldkVuZENlbGxPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0Q2VsbFBvcyAhPT0gZW5kQ2VsbFBvcykge1xuICAgICAgICAgICAgcHJldkVuZENlbGxQb3MgPSBzdGFydENlbGxQb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZFbmRDZWxsUG9zICYmIHN0YXJ0Q2VsbFBvcyAmJiBlbmRDZWxsUG9zKSB7XG4gICAgICAgICAgICB0aGlzLnNldENlbGxTZWxlY3Rpb24oc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmhhbmRsZU1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRDZWxsUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmJpbmRFdmVudCgpO1xuICAgICAgICBpZiAocGx1Z2luS2V5LmdldFN0YXRlKHRoaXMudmlldy5zdGF0ZSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0aGlzLnZpZXcuc3RhdGUudHIuc2V0TWV0YShwbHVnaW5LZXksIC0xKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5iaW5kRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb20gPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVycy5tb3VzZW1vdmUpO1xuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlcnMubW91c2V1cCk7XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUudW5iaW5kRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb20gPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVycy5tb3VzZW1vdmUpO1xuICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlcnMubW91c2V1cCk7XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0Q2VsbFBvcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY2xpZW50WCA9IF9hLmNsaWVudFgsIGNsaWVudFkgPSBfYS5jbGllbnRZO1xuICAgICAgICB2YXIgbW91c2VQb3MgPSB0aGlzLnZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBjbGllbnRYLCB0b3A6IGNsaWVudFkgfSk7XG4gICAgICAgIGlmIChtb3VzZVBvcykge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHRoaXMudmlldy5zdGF0ZS5kb2M7XG4gICAgICAgICAgICB2YXIgY3VycmVudFBvcyA9IGRvYy5yZXNvbHZlKG1vdXNlUG9zLnBvcyk7XG4gICAgICAgICAgICB2YXIgZm91bmRDZWxsID0gZmluZENlbGwoY3VycmVudFBvcyk7XG4gICAgICAgICAgICBpZiAoZm91bmRDZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxPZmZzZXQgPSBjdXJyZW50UG9zLmJlZm9yZShmb3VuZENlbGwuZGVwdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2MucmVzb2x2ZShjZWxsT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5zZXRDZWxsU2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Q2VsbFBvcywgZW5kQ2VsbFBvcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50cjtcbiAgICAgICAgdmFyIHN0YXJ0aW5nID0gcGx1Z2luS2V5LmdldFN0YXRlKHRoaXMudmlldy5zdGF0ZSkgPT09IG51bGw7XG4gICAgICAgIHZhciBjZWxsU2VsZWN0aW9uID0gbmV3IENlbGxTZWxlY3Rpb24oc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKTtcbiAgICAgICAgaWYgKHN0YXJ0aW5nIHx8ICFzZWxlY3Rpb24uZXEoY2VsbFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBuZXdUciA9IHRyLnNldFNlbGVjdGlvbihjZWxsU2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdGFydGluZykge1xuICAgICAgICAgICAgICAgIG5ld1RyLnNldE1ldGEocGx1Z2luS2V5LCBlbmRDZWxsUG9zLnBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZXJzLm1vdXNlZG93bik7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVTZWxlY3Rpb247XG59KCkpO1xuXG52YXIgU0VMRUNURURfQ0VMTF9DTEFTU19OQU1FID0gY2xzKCdjZWxsLXNlbGVjdGVkJyk7XG5mdW5jdGlvbiBkcmF3Q2VsbFNlbGVjdGlvbihfYSkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIGRvYyA9IF9hLmRvYztcbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikge1xuICAgICAgICB2YXIgY2VsbHNfMSA9IFtdO1xuICAgICAgICB2YXIgcmFuZ2VzID0gc2VsZWN0aW9uLnJhbmdlcztcbiAgICAgICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBfYS4kZnJvbSwgJHRvID0gX2EuJHRvO1xuICAgICAgICAgICAgY2VsbHNfMS5wdXNoKERlY29yYXRpb24ubm9kZSgkZnJvbS5wb3MgLSAxLCAkdG8ucG9zICsgMSwgeyBjbGFzczogU0VMRUNURURfQ0VMTF9DTEFTU19OQU1FIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGNlbGxzXzEpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRhYmxlU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBwbHVnaW5LZXksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHk6IGZ1bmN0aW9uICh0ciwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbE9mZnNldCA9IHRyLmdldE1ldGEocGx1Z2luS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbE9mZnNldCA9PT0gLTEgPyBudWxsIDogY2VsbE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbF8xKHZhbHVlKSB8fCAhdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfYSA9IHRyLm1hcHBpbmcubWFwUmVzdWx0KHZhbHVlKSwgZGVsZXRlZCA9IF9hLmRlbGV0ZWQsIHBvcyA9IF9hLnBvcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBwb3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IGRyYXdDZWxsU2VsZWN0aW9uLFxuICAgICAgICAgICAgY3JlYXRlU2VsZWN0aW9uQmV0d2VlbjogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGxfMShwbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uIChlZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhYmxlU2VsZWN0aW9uKGVkaXRvclZpZXcpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBjbGFzc1xuICogQGlnbm9yZVxuICogQGNsYXNzZGVzYyBFUzYgTWFwXG4gKi9cbnZhciBNYXAkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBNYXAucHJvdG90eXBlLmdldEtleUluZGV4ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gaW5BcnJheV8xKGtleSwgdGhpcy5rZXlzKTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5nZXRLZXlJbmRleChrZXkpXTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGtleUluZGV4ID0gdGhpcy5nZXRLZXlJbmRleChrZXkpO1xuICAgICAgICBpZiAoa2V5SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXNba2V5SW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5SW5kZXgoa2V5KSA+IC0xO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBrZXlJbmRleCA9IHRoaXMuZ2V0S2V5SW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKGtleUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5zcGxpY2Uoa2V5SW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGtleUluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpc0FyZyA9PT0gdm9pZCAwKSB7IHRoaXNBcmcgPSB0aGlzOyB9XG4gICAgICAgIHRoaXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIF90aGlzLmtleXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgX3RoaXMua2V5c1tpbmRleF0sIF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiBNYXA7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW1wbGVtZW50cyBpMThuXG4gKiBAYXV0aG9yIE5ITiBDbG91ZCBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xudmFyIERFRkFVTFRfQ09ERSA9ICdlbi1VUyc7XG4vKipcbiAqIENsYXNzIEkxOG5cbiAqIEBpZ25vcmVcbiAqL1xudmFyIEkxOG4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSTE4bigpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gREVGQVVMVF9DT0RFO1xuICAgICAgICB0aGlzLmxhbmdzID0gbmV3IE1hcCQxKCk7XG4gICAgfVxuICAgIEkxOG4ucHJvdG90eXBlLnNldENvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlIHx8IERFRkFVTFRfQ09ERTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBsYW5ndWFnZSBzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY29kZXMgbG9jYWxlIGNvZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBsYW5ndWFnZSBzZXRcbiAgICAgKi9cbiAgICBJMThuLnByb3RvdHlwZS5zZXRMYW5ndWFnZSA9IGZ1bmN0aW9uIChjb2RlcywgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb2RlcyA9IFtdLmNvbmNhdChjb2Rlcyk7XG4gICAgICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubGFuZ3MuaGFzKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFuZ3Muc2V0KGNvZGUsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmdEYXRhID0gX3RoaXMubGFuZ3MuZ2V0KGNvZGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxhbmdzLnNldChjb2RlLCBleHRlbmRfMShsYW5nRGF0YSwgZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEkxOG4ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIGNvZGUpIHtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYW5nU2V0ID0gdGhpcy5sYW5ncy5nZXQoY29kZSk7XG4gICAgICAgIGlmICghbGFuZ1NldCkge1xuICAgICAgICAgICAgbGFuZ1NldCA9IHRoaXMubGFuZ3MuZ2V0KERFRkFVTFRfQ09ERSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSBsYW5nU2V0W2tleV07XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gdGV4dCBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGluIFwiICsgY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gSTE4bjtcbn0oKSk7XG52YXIgaTE4biA9IG5ldyBJMThuKCk7XG5cbnZhciBjb250ZXh0TWVudUdyb3VwcyA9IFtcbiAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ0FkZCByb3cgdG8gdXAnLFxuICAgICAgICAgICAgY29tbWFuZDogJ2FkZFJvd1RvVXAnLFxuICAgICAgICAgICAgZGlzYWJsZUluVGhlYWQ6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhZGQtcm93LXVwJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAnQWRkIHJvdyB0byBkb3duJyxcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdhZGRSb3dUb0Rvd24nLFxuICAgICAgICAgICAgZGlzYWJsZUluVGhlYWQ6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhZGQtcm93LWRvd24nLFxuICAgICAgICB9LFxuICAgICAgICB7IGFjdGlvbjogJ1JlbW92ZSByb3cnLCBjb21tYW5kOiAncmVtb3ZlUm93JywgZGlzYWJsZUluVGhlYWQ6IHRydWUsIGNsYXNzTmFtZTogJ3JlbW92ZS1yb3cnIH0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgIHsgYWN0aW9uOiAnQWRkIGNvbHVtbiB0byBsZWZ0JywgY29tbWFuZDogJ2FkZENvbHVtblRvTGVmdCcsIGNsYXNzTmFtZTogJ2FkZC1jb2x1bW4tbGVmdCcgfSxcbiAgICAgICAgeyBhY3Rpb246ICdBZGQgY29sdW1uIHRvIHJpZ2h0JywgY29tbWFuZDogJ2FkZENvbHVtblRvUmlnaHQnLCBjbGFzc05hbWU6ICdhZGQtY29sdW1uLXJpZ2h0JyB9LFxuICAgICAgICB7IGFjdGlvbjogJ1JlbW92ZSBjb2x1bW4nLCBjb21tYW5kOiAncmVtb3ZlQ29sdW1uJywgY2xhc3NOYW1lOiAncmVtb3ZlLWNvbHVtbicgfSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAnQWxpZ24gY29sdW1uIHRvIGxlZnQnLFxuICAgICAgICAgICAgY29tbWFuZDogJ2FsaWduQ29sdW1uJyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHsgYWxpZ246ICdsZWZ0JyB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYWxpZ24tY29sdW1uLWxlZnQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb246ICdBbGlnbiBjb2x1bW4gdG8gY2VudGVyJyxcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdhbGlnbkNvbHVtbicsXG4gICAgICAgICAgICBwYXlsb2FkOiB7IGFsaWduOiAnY2VudGVyJyB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYWxpZ24tY29sdW1uLWNlbnRlcicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ0FsaWduIGNvbHVtbiB0byByaWdodCcsXG4gICAgICAgICAgICBjb21tYW5kOiAnYWxpZ25Db2x1bW4nLFxuICAgICAgICAgICAgcGF5bG9hZDogeyBhbGlnbjogJ3JpZ2h0JyB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYWxpZ24tY29sdW1uLXJpZ2h0JyxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIFt7IGFjdGlvbjogJ1JlbW92ZSB0YWJsZScsIGNvbW1hbmQ6ICdyZW1vdmVUYWJsZScsIGNsYXNzTmFtZTogJ3JlbW92ZS10YWJsZScgfV0sXG5dO1xuZnVuY3Rpb24gZ2V0Q29udGV4dE1lbnVHcm91cHMoZXZlbnRFbWl0dGVyLCBpblRhYmxlSGVhZCkge1xuICAgIHJldHVybiBjb250ZXh0TWVudUdyb3Vwc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChjb250ZXh0TWVudUdyb3VwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWVudUdyb3VwLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfYS5hY3Rpb24sIGNvbW1hbmQgPSBfYS5jb21tYW5kLCBwYXlsb2FkID0gX2EucGF5bG9hZCwgZGlzYWJsZUluVGhlYWQgPSBfYS5kaXNhYmxlSW5UaGVhZCwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogaTE4bi5nZXQoYWN0aW9uKSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjb21tYW5kJywgY29tbWFuZCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogaW5UYWJsZUhlYWQgJiYgISFkaXNhYmxlSW5UaGVhZCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC5jb25jYXQoKTtcbn1cbmZ1bmN0aW9uIHRhYmxlQ29udGV4dE1lbnUoZXZlbnRFbWl0dGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgY29udGV4dG1lbnU6IGZ1bmN0aW9uICh2aWV3LCBldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVDZWxsID0gZmluZENlbGxFbGVtZW50KGV2LnRhcmdldCwgdmlldy5kb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFibGVDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZXYsIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IHZpZXcuZG9tLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxlZnQgPSBfYi5sZWZ0LCB0b3BfMSA9IF9iLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpblRhYmxlSGVhZCA9IHRhYmxlQ2VsbC5ub2RlTmFtZSA9PT0gJ1RIJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjb250ZXh0bWVudScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHsgbGVmdDogY2xpZW50WCAtIGxlZnQgKyAxMCArIFwicHhcIiwgdG9wOiBjbGllbnRZIC0gdG9wXzEgKyAzMCArIFwicHhcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVHcm91cHM6IGdldENvbnRleHRNZW51R3JvdXBzKGV2ZW50RW1pdHRlciwgaW5UYWJsZUhlYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2VsbDogdGFibGVDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHRhc2soKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbiAodmlldywgZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZXYsIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGNsaWVudFgsIHRvcDogY2xpZW50WSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdXNlUG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSB2aWV3LnN0YXRlLCBkb2MgPSBfYi5kb2MsIHRyID0gX2IudHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBvcyA9IGRvYy5yZXNvbHZlKG1vdXNlUG9zLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdEl0ZW0gPSBmaW5kTGlzdEl0ZW0oY3VycmVudFBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQsICc6YmVmb3JlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBldiwgb2Zmc2V0WCA9IF9jLm9mZnNldFgsIG9mZnNldFkgPSBfYy5vZmZzZXRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaXN0SXRlbSB8fCAhaXNQb3NpdGlvbkluQm94KHN0eWxlLCBvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gY3VycmVudFBvcy5iZWZvcmUobGlzdEl0ZW0uZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gbGlzdEl0ZW0ubm9kZS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAob2Zmc2V0LCBudWxsLCBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGF0dHJzKSwgeyBjaGVja2VkOiAhYXR0cnMuY2hlY2tlZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxudmFyIEVYQ0VQVF9UWVBFUyA9IFsnaW1hZ2UnLCAnbGluaycsICdjdXN0b21CbG9jaycsICdmcm9udE1hdHRlciddO1xudmFyIE1BUktfVFlQRVMgPSBbJ3N0cm9uZycsICdzdHJpa2UnLCAnZW1waCcsICdjb2RlJ107XG52YXIgTElTVF9UWVBFUyA9IFsnYnVsbGV0TGlzdCcsICdvcmRlcmVkTGlzdCcsICd0YXNrTGlzdCddO1xuZnVuY3Rpb24gZ2V0VG9vbGJhclN0YXRlVHlwZShub2RlLCBwYXJlbnROb2RlKSB7XG4gICAgdmFyIHR5cGUgPSBub2RlLnR5cGUubmFtZTtcbiAgICBpZiAodHlwZSA9PT0gJ2xpc3RJdGVtJykge1xuICAgICAgICByZXR1cm4gbm9kZS5hdHRycy50YXNrID8gJ3Rhc2tMaXN0JyA6IHBhcmVudE5vZGUudHlwZS5uYW1lO1xuICAgIH1cbiAgICBpZiAodHlwZS5pbmRleE9mKCd0YWJsZScpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gJ3RhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBzZXRMaXN0Tm9kZVRvb2xiYXJTdGF0ZSh0eXBlLCBub2RlVHlwZVN0YXRlKSB7XG4gICAgbm9kZVR5cGVTdGF0ZVt0eXBlXSA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgTElTVF9UWVBFUy5maWx0ZXIoZnVuY3Rpb24gKGxpc3ROYW1lKSB7IHJldHVybiBsaXN0TmFtZSAhPT0gdHlwZTsgfSkuZm9yRWFjaChmdW5jdGlvbiAobGlzdFR5cGUpIHtcbiAgICAgICAgaWYgKG5vZGVUeXBlU3RhdGVbbGlzdFR5cGVdKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZVR5cGVTdGF0ZVtsaXN0VHlwZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldE1hcmtUeXBlU3RhdGVzKGZyb20sIHRvLCBzY2hlbWEsIHRvb2xiYXJTdGF0ZSkge1xuICAgIE1BUktfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgbWFyayA9IHNjaGVtYS5tYXJrc1t0eXBlXTtcbiAgICAgICAgdmFyIG1hcmtzQXRQb3MgPSBmcm9tLm1hcmtzQWNyb3NzKHRvKSB8fCBbXTtcbiAgICAgICAgdmFyIGZvdW5kTWFyayA9ICEhbWFyay5pc0luU2V0KG1hcmtzQXRQb3MpO1xuICAgICAgICBpZiAoZm91bmRNYXJrKSB7XG4gICAgICAgICAgICB0b29sYmFyU3RhdGVbdHlwZV0gPSB7IGFjdGl2ZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRUb29sYmFyU3RhdGUoc2VsZWN0aW9uLCBkb2MsIHNjaGVtYSkge1xuICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bywgZnJvbSA9IHNlbGVjdGlvbi5mcm9tLCB0byA9IHNlbGVjdGlvbi50bztcbiAgICB2YXIgdG9vbGJhclN0YXRlID0ge1xuICAgICAgICBpbmRlbnQ6IHsgYWN0aXZlOiBmYWxzZSwgZGlzYWJsZWQ6IHRydWUgfSxcbiAgICAgICAgb3V0ZGVudDogeyBhY3RpdmU6IGZhbHNlLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgIH07XG4gICAgZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIF8sIHBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUb29sYmFyU3RhdGVUeXBlKG5vZGUsIHBhcmVudE5vZGUpO1xuICAgICAgICBpZiAoaW5jbHVkZXMoRVhDRVBUX1RZUEVTLCB0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlcyhMSVNUX1RZUEVTLCB0eXBlKSkge1xuICAgICAgICAgICAgc2V0TGlzdE5vZGVUb29sYmFyU3RhdGUodHlwZSwgdG9vbGJhclN0YXRlKTtcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZS5pbmRlbnQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZS5vdXRkZW50LmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgdHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBzZXRNYXJrVHlwZVN0YXRlcygkZnJvbSwgJHRvLCBzY2hlbWEsIHRvb2xiYXJTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b29sYmFyU3RhdGVbdHlwZV0gPSB7IGFjdGl2ZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvb2xiYXJTdGF0ZTtcbn1cbmZ1bmN0aW9uIHRvb2xiYXJTdGF0ZUhpZ2hsaWdodChldmVudEVtaXR0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSB2aWV3LnN0YXRlLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIGRvYyA9IF9hLmRvYywgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlVG9vbGJhclN0YXRlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbGJhclN0YXRlOiBnZXRUb29sYmFyU3RhdGUoc2VsZWN0aW9uLCBkb2MsIHNjaGVtYSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG52YXIgQ3VzdG9tQmxvY2tWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEN1c3RvbUJsb2NrVmlldyhub2RlLCB2aWV3LCBnZXRQb3MsIHRvRE9NQWRhcHRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wZW5FZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaW5uZXJFZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZWRpdG9yIGlzIGFscmVhZHkgb3BlbmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZG9tLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgX3RoaXMuaW5uZXJWaWV3Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgX3RoaXMuaW5uZXJFZGl0b3JWaWV3ID0gbmV3IEVkaXRvclZpZXcoX3RoaXMuaW5uZXJWaWV3Q29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRvYzogX3RoaXMubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5bWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTW9kLXonOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRvKF90aGlzLmlubmVyRWRpdG9yVmlldy5zdGF0ZSwgX3RoaXMuaW5uZXJFZGl0b3JWaWV3LmRpc3BhdGNoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU2hpZnQtTW9kLXonOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWRvKF90aGlzLmlubmVyRWRpdG9yVmlldy5zdGF0ZSwgX3RoaXMuaW5uZXJFZGl0b3JWaWV3LmRpc3BhdGNoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUYWI6IGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0VGV4dCgnXFx0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVudGVyOiBuZXdsaW5lSW5Db2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVzY2FwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYW5jZWxFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0N0cmwtRW50ZXInOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNhdmVBbmRGaW5pc2hFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcnkoKSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiBmdW5jdGlvbiAodHIpIHsgcmV0dXJuIF90aGlzLmRpc3BhdGNoSW5uZXIodHIpOyB9LFxuICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5lZGl0b3JWaWV3Lmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbm5lckVkaXRvclZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBibHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zYXZlQW5kRmluaXNoRWRpdGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuaW5uZXJFZGl0b3JWaWV3LmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZ2V0UG9zID0gZ2V0UG9zO1xuICAgICAgICB0aGlzLnRvRE9NQWRhcHRvciA9IHRvRE9NQWRhcHRvcjtcbiAgICAgICAgdGhpcy5pbm5lckVkaXRvclZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IGNscygnY3VzdG9tLWJsb2NrJyk7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NOYW1lID0gY2xzKCdjdXN0b20tYmxvY2stdmlldycpO1xuICAgICAgICB0aGlzLmNyZWF0ZUlubmVyVmlld0NvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLnJlbmRlckN1c3RvbUJsb2NrKCk7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuaW5uZXJWaWV3Q29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICB9XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5yZW5kZXJUb29sQXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRvb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgdG9vbC5jbGFzc05hbWUgPSAndG9vbCc7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm5vZGUuYXR0cnMuaW5mbztcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSAnaW5mbyc7XG4gICAgICAgIGJ1dHRvbi50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9wZW5FZGl0b3IoKTsgfSk7XG4gICAgICAgIHRvb2wuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICAgIHRvb2wuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRvb2wpO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5yZW5kZXJDdXN0b21CbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvRE9NTm9kZSA9IHRoaXMudG9ET01BZGFwdG9yLmdldFRvRE9NTm9kZSh0aGlzLm5vZGUuYXR0cnMuaW5mbyk7XG4gICAgICAgIGlmICh0b0RPTU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdG9ET01Ob2RlKHRoaXMubm9kZSk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy53cmFwcGVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIubGFzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUb29sQXJlYSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmNyZWF0ZUlubmVyVmlld0NvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lclZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5pbm5lclZpZXdDb250YWluZXIuY2xhc3NOYW1lID0gY2xzKCdjdXN0b20tYmxvY2stZWRpdG9yJyk7XG4gICAgICAgIHRoaXMuaW5uZXJWaWV3Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmNsb3NlRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbm5lckVkaXRvclZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJFZGl0b3JWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJFZGl0b3JWaWV3ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJWaWV3Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5zYXZlQW5kRmluaXNoRWRpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgdmFyIG91dGVyU3RhdGUgPSB0aGlzLmVkaXRvclZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldy5kaXNwYXRjaChvdXRlclN0YXRlLnRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKG91dGVyU3RhdGUudHIsIHRvKSkpO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXN0b21CbG9jaygpO1xuICAgICAgICB0aGlzLmNsb3NlRWRpdG9yKCk7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmNhbmNlbEVkaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bmRvYWJsZUNvdW50ID0gdW5kb0RlcHRoKHRoaXMuaW5uZXJFZGl0b3JWaWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIC8vIHNob3VsZCB1bmRvIGVkaXRpbmcgcmVzdWx0XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xuICAgICAgICB3aGlsZSAodW5kb2FibGVDb3VudC0tKSB7XG4gICAgICAgICAgICB1bmRvKHRoaXMuaW5uZXJFZGl0b3JWaWV3LnN0YXRlLCB0aGlzLmlubmVyRWRpdG9yVmlldy5kaXNwYXRjaCk7XG4gICAgICAgICAgICB1bmRvKHRoaXMuZWRpdG9yVmlldy5zdGF0ZSwgdGhpcy5lZGl0b3JWaWV3LmRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciB0byA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIHZhciBvdXRlclN0YXRlID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcuZGlzcGF0Y2gob3V0ZXJTdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUob3V0ZXJTdGF0ZS5kb2MsIHRvKSkpO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVkaXRvcigpO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5kaXNwYXRjaElubmVyID0gZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuaW5uZXJFZGl0b3JWaWV3LnN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odHIpLCBzdGF0ZSA9IF9hLnN0YXRlLCB0cmFuc2FjdGlvbnMgPSBfYS50cmFuc2FjdGlvbnM7XG4gICAgICAgIHRoaXMuaW5uZXJFZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgaWYgKCF0aGlzLmNhbmNlbGVkICYmIGlzRnVuY3Rpb25fMSh0aGlzLmdldFBvcykpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclRyID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIG9mZnNldE1hcCA9IFN0ZXBNYXAub2Zmc2V0KHRoaXMuZ2V0UG9zKCkgKyAxKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBzID0gdHJhbnNhY3Rpb25zW2ldLnN0ZXBzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJUci5zdGVwKHN0ZXBzW2pdLm1hcChvZmZzZXRNYXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0ZXJUci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3JWaWV3LmRpc3BhdGNoKG91dGVyVHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICBpZiAoIXRoaXMuaW5uZXJFZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckN1c3RvbUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gKCEhdGhpcy5pbm5lckVkaXRvclZpZXcgJiZcbiAgICAgICAgICAgICEhZXZlbnQudGFyZ2V0ICYmXG4gICAgICAgICAgICB0aGlzLmlubmVyRWRpdG9yVmlldy5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSk7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLm9wZW5FZGl0b3IpO1xuICAgICAgICB0aGlzLmNsb3NlRWRpdG9yKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ3VzdG9tQmxvY2tWaWV3O1xufSgpKTtcblxudmFyIElNQUdFX0xJTktfQ0xBU1NfTkFNRSA9ICdpbWFnZS1saW5rJztcbnZhciBJbWFnZVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW1hZ2VWaWV3KG5vZGUsIHZpZXcsIGdldFBvcywgZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0LCBvZmZzZXRYID0gZXYub2Zmc2V0WCwgb2Zmc2V0WSA9IGV2Lm9mZnNldFk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaW1hZ2VMaW5rICYmXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbl8xKF90aGlzLmdldFBvcykgJiZcbiAgICAgICAgICAgICAgICBoYXNDbGFzc18xKHRhcmdldCwgSU1BR0VfTElOS19DTEFTU19OQU1FKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0LCAnOmJlZm9yZScpO1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Bvc2l0aW9uSW5Cb3goc3R5bGUsIG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ciA9IF90aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBfdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHBvcywgcG9zICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ29wZW5Qb3B1cCcsICdsaW5rJywgX3RoaXMuaW1hZ2VMaW5rLmF0dHJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZ2V0UG9zID0gZ2V0UG9zO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5pbWFnZUxpbmsgPSAoX2EgPSBub2RlLm1hcmtzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdsaW5rJztcbiAgICAgICAgfSlbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gdGhpcy5jcmVhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuYmluZEV2ZW50KCk7XG4gICAgfVxuICAgIEltYWdlVmlldy5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5jcmVhdGVJbWFnZUVsZW1lbnQodGhpcy5ub2RlKTtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VMaW5rKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gSU1BR0VfTElOS19DTEFTU19OQU1FO1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpbWFnZSk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLmNyZWF0ZUltYWdlRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICB2YXIgX2EgPSBub2RlLmF0dHJzLCBpbWFnZVVybCA9IF9hLmltYWdlVXJsLCBhbHRUZXh0ID0gX2EuYWx0VGV4dDtcbiAgICAgICAgdmFyIGF0dHJzID0gZ2V0Q3VzdG9tQXR0cnMobm9kZS5hdHRycyk7XG4gICAgICAgIGltYWdlLnNyYyA9IGltYWdlVXJsO1xuICAgICAgICBpZiAoYWx0VGV4dCkge1xuICAgICAgICAgICAgaW1hZ2UuYWx0ID0gYWx0VGV4dDtcbiAgICAgICAgfVxuICAgICAgICBzZXRBdHRyaWJ1dGVzKGF0dHJzLCBpbWFnZSk7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9O1xuICAgIEltYWdlVmlldy5wcm90b3R5cGUuYmluZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbWFnZUxpbmspIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW1hZ2VWaWV3LnByb3RvdHlwZS5zdG9wRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgSW1hZ2VWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbWFnZUxpbmspIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEltYWdlVmlldztcbn0oKSk7XG5cbnZhciBXUkFQUEVSX0NMQVNTX05BTUUgPSAndG9hc3R1aS1lZGl0b3Itd3ctY29kZS1ibG9jayc7XG52YXIgQ09ERV9CTE9DS19MQU5HX0NMQVNTX05BTUUgPSAndG9hc3R1aS1lZGl0b3Itd3ctY29kZS1ibG9jay1sYW5ndWFnZSc7XG52YXIgQ29kZUJsb2NrVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2RlQmxvY2tWaWV3KG5vZGUsIHZpZXcsIGdldFBvcywgZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgJzphZnRlcicpO1xuICAgICAgICAgICAgLy8ganVkZ2UgdG8gY2xpY2sgcHNldWRvIGVsZW1lbnQgd2l0aCBiYWNrZ3JvdW5kIGltYWdlIGZvciBJRTExXG4gICAgICAgICAgICBpZiAoc3R5bGUuYmFja2dyb3VuZEltYWdlICE9PSAnbm9uZScgJiYgaXNGdW5jdGlvbl8xKF90aGlzLmdldFBvcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy52aWV3LmNvb3Jkc0F0UG9zKF90aGlzLmdldFBvcygpKSwgdG9wXzEgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlTGFuZ3VhZ2VFZGl0b3IoeyB0b3A6IHRvcF8xLCByaWdodDogcmlnaHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5ZG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyAmJiBfdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlTGFuZ3VhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5nZXRQb3MgPSBnZXRQb3M7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5iaW5kRE9NRXZlbnQoKTtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnQoKTtcbiAgICB9XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gdGhpcy5ub2RlLmF0dHJzLmxhbmd1YWdlO1xuICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZSgnZGF0YS1sYW5ndWFnZScsIGxhbmd1YWdlIHx8ICd0ZXh0Jyk7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gV1JBUFBFUl9DTEFTU19OQU1FO1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5jcmVhdGVDb2RlQmxvY2tFbGVtZW50KCk7XG4gICAgICAgIHZhciBjb2RlID0gcHJlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocHJlKTtcbiAgICAgICAgdGhpcy5kb20gPSB3cmFwcGVyO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb2RlO1xuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuY3JlYXRlQ29kZUJsb2NrRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuICAgICAgICB2YXIgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gdGhpcy5ub2RlLmF0dHJzLmxhbmd1YWdlO1xuICAgICAgICB2YXIgYXR0cnMgPSBnZXRDdXN0b21BdHRycyh0aGlzLm5vZGUuYXR0cnMpO1xuICAgICAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIGNvZGUuc2V0QXR0cmlidXRlKCdkYXRhLWxhbmd1YWdlJywgbGFuZ3VhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHNldEF0dHJpYnV0ZXMoYXR0cnMsIHByZSk7XG4gICAgICAgIHByZS5hcHBlbmRDaGlsZChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHByZTtcbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmNyZWF0ZUxhbmd1YWdlRWRpdG9yID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IENPREVfQkxPQ0tfTEFOR19DTEFTU19OQU1FO1xuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC50eXBlID0gJ3RleHQnO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHRoaXMubm9kZS5hdHRycy5sYW5ndWFnZTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgdmFyIHdycHBlcldpZHRoID0gd3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgICAgY3NzXzEod3JhcHBlciwge1xuICAgICAgICAgICAgdG9wOiB0b3AgKyAxMCArIFwicHhcIixcbiAgICAgICAgICAgIGxlZnQ6IHJpZ2h0IC0gd3JwcGVyV2lkdGggLSAxMCArIFwicHhcIixcbiAgICAgICAgICAgIHdpZHRoOiB3cnBwZXJXaWR0aCArIFwicHhcIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2hhbmdlTGFuZ3VhZ2UoKTsgfSk7XG4gICAgICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bik7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmJpbmRET01FdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuYmluZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuY2hhbmdlTGFuZ3VhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0ICYmIGlzRnVuY3Rpb25fMSh0aGlzLmdldFBvcykpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXQudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgICAgIHZhciB0ciA9IHRoaXMudmlldy5zdGF0ZS50cjtcbiAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCBudWxsLCB7IGxhbmd1YWdlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLmlucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5pbnB1dC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVOb2RlJDEocGFyZW50XzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5jbGVhclRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVNb3VzZWRvd24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZUJsb2NrVmlldztcbn0oKSk7XG5cbnZhciByZU1TT0xpc3RDbGFzc05hbWUgPSAvTXNvTGlzdFBhcmFncmFwaC87XG52YXIgcmVNU09TdHlsZVByZWZpeCA9IC9zdHlsZT0oLnxcXG4pKm1zby0vO1xudmFyIHJlTVNPTGlzdFN0eWxlID0gL21zby1saXN0OiguKikvO1xudmFyIHJlTVNPVGFnTmFtZSA9IC9POlAvO1xudmFyIHJlTVNPTGlzdEJ1bGxldCA9IC9eKG58dXxsKS87XG52YXIgTVNPX0NMQVNTX05BTUVfTElTVF9QQVJBID0gJ3AuTXNvTGlzdFBhcmFncmFwaCc7XG5mdW5jdGlvbiBpc0Zyb21Nc28oaHRtbCkge1xuICAgIHJldHVybiByZU1TT1N0eWxlUHJlZml4LnRlc3QoaHRtbCk7XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbUNvbnRlbnRzKHBhcmEpIHtcbiAgICB2YXIgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgdmFyIHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIocGFyYSwgMSwgbnVsbCwgZmFsc2UpO1xuICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICB2YXIgbm9kZSA9IHdhbGtlci5jdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKGlzRWxlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IG5vZGUsIG91dGVySFRNTCA9IF9hLm91dGVySFRNTCwgdGV4dENvbnRlbnQgPSBfYS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIHZhciBtc29TcGFuID0gcmVNU09TdHlsZVByZWZpeC50ZXN0KG91dGVySFRNTCk7XG4gICAgICAgICAgICB2YXIgYnVsbGV0U3BhbiA9IHJlTVNPTGlzdFN0eWxlLnRlc3Qob3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIGlmIChtc29TcGFuICYmICFidWxsZXRTcGFuICYmIHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGVzLnB1c2goW25vZGUsIHRydWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlTVNPVGFnTmFtZS50ZXN0KG5vZGUubm9kZU5hbWUpIHx8IChtc29TcGFuICYmICF0ZXh0Q29udGVudCkgfHwgYnVsbGV0U3Bhbikge1xuICAgICAgICAgICAgICAgIHJlbW92ZWROb2Rlcy5wdXNoKFtub2RlLCBmYWxzZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hWzBdLCBpc1Vud3JhcCA9IF9hWzFdO1xuICAgICAgICBpZiAoaXNVbndyYXApIHtcbiAgICAgICAgICAgIHVud3JhcE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlJDEobm9kZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYS5pbm5lckhUTUwudHJpbSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlTGlzdEl0ZW1EYXRhRnJvbVBhcmFncmFwaChwYXJhLCBpbmRleCkge1xuICAgIHZhciBzdHlsZUF0dHIgPSBwYXJhLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICBpZiAoc3R5bGVBdHRyKSB7XG4gICAgICAgIHZhciBfYSA9IHN0eWxlQXR0ci5tYXRjaChyZU1TT0xpc3RTdHlsZSksIGxpc3RJdGVtSW5mbyA9IF9hWzFdO1xuICAgICAgICB2YXIgX2IgPSBsaXN0SXRlbUluZm8udHJpbSgpLnNwbGl0KCcgJyksIGxldmVsU3RyID0gX2JbMV07XG4gICAgICAgIHZhciBsZXZlbCA9IHBhcnNlSW50KGxldmVsU3RyLnJlcGxhY2UoJ2xldmVsJywgJycpLCAxMCk7XG4gICAgICAgIHZhciB1bm9yZGVyZWQgPSByZU1TT0xpc3RCdWxsZXQudGVzdChwYXJhLnRleHRDb250ZW50IHx8ICcnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpbmRleCxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICB1bm9yZGVyZWQ6IHVub3JkZXJlZCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBnZXRMaXN0SXRlbUNvbnRlbnRzKHBhcmEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGFkZExpc3RJdGVtRGV0YWlsRGF0YShkYXRhLCBwcmV2RGF0YSkge1xuICAgIGlmIChwcmV2RGF0YS5sZXZlbCA8IGRhdGEubGV2ZWwpIHtcbiAgICAgICAgcHJldkRhdGEuY2hpbGRyZW4ucHVzaChkYXRhKTtcbiAgICAgICAgZGF0YS5wYXJlbnQgPSBwcmV2RGF0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChwcmV2RGF0YSkge1xuICAgICAgICAgICAgaWYgKHByZXZEYXRhLmxldmVsID09PSBkYXRhLmxldmVsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RGF0YSA9IHByZXZEYXRhLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEucHJldiA9IHByZXZEYXRhO1xuICAgICAgICAgICAgZGF0YS5wYXJlbnQgPSBwcmV2RGF0YS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoZGF0YS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnBhcmVudC5jaGlsZHJlbi5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTGlzdERhdGEocGFyYXMpIHtcbiAgICB2YXIgbGlzdERhdGEgPSBbXTtcbiAgICBwYXJhcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhLCBpbmRleCkge1xuICAgICAgICB2YXIgcHJldkxpc3RJdGVtRGF0YSA9IGxpc3REYXRhW2luZGV4IC0gMV07XG4gICAgICAgIHZhciBsaXN0SXRlbURhdGEgPSBjcmVhdGVMaXN0SXRlbURhdGFGcm9tUGFyYWdyYXBoKHBhcmEsIGluZGV4KTtcbiAgICAgICAgaWYgKGxpc3RJdGVtRGF0YSkge1xuICAgICAgICAgICAgaWYgKHByZXZMaXN0SXRlbURhdGEpIHtcbiAgICAgICAgICAgICAgICBhZGRMaXN0SXRlbURldGFpbERhdGEobGlzdEl0ZW1EYXRhLCBwcmV2TGlzdEl0ZW1EYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3REYXRhLnB1c2gobGlzdEl0ZW1EYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsaXN0RGF0YTtcbn1cbmZ1bmN0aW9uIG1ha2VMaXN0KGxpc3REYXRhKSB7XG4gICAgdmFyIGxpc3RUYWdOYW1lID0gbGlzdERhdGFbMF0udW5vcmRlcmVkID8gJ3VsJyA6ICdvbCc7XG4gICAgdmFyIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGxpc3RUYWdOYW1lKTtcbiAgICBsaXN0RGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGRhdGEuY2hpbGRyZW4sIGNvbnRlbnRzID0gZGF0YS5jb250ZW50cztcbiAgICAgICAgdmFyIGxpc3RJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgbGlzdEl0ZW0uaW5uZXJIVE1MID0gY29udGVudHM7XG4gICAgICAgIGxpc3QuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaXN0LmFwcGVuZENoaWxkKG1ha2VMaXN0KGNoaWxkcmVuKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGlzdDtcbn1cbmZ1bmN0aW9uIG1ha2VMaXN0RnJvbVBhcmFncmFwaHMocGFyYXMpIHtcbiAgICB2YXIgbGlzdERhdGEgPSBjcmVhdGVMaXN0RGF0YShwYXJhcyk7XG4gICAgdmFyIHJvb3RDaGlsZHJlbiA9IGxpc3REYXRhLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IF9hLnBhcmVudDtcbiAgICAgICAgcmV0dXJuICFwYXJlbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ha2VMaXN0KHJvb3RDaGlsZHJlbik7XG59XG5mdW5jdGlvbiBpc01zb0xpc3RQYXJhZ3JhcGhFbmQobm9kZSkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChpc0VsZW1Ob2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUgPyAhcmVNU09MaXN0Q2xhc3NOYW1lLnRlc3Qobm9kZS5jbGFzc05hbWUpIDogdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRNc29QYXJhZ3JhcGhzVG9MaXN0KGh0bWwpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgdmFyIHBhcmFzID0gW107XG4gICAgdmFyIGZvdW5kUGFyYXMgPSBmaW5kTm9kZXMoY29udGFpbmVyLCBNU09fQ0xBU1NfTkFNRV9MSVNUX1BBUkEpO1xuICAgIGZvdW5kUGFyYXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYSkge1xuICAgICAgICB2YXIgbXNvTGlzdFBhcmFFbmQgPSBpc01zb0xpc3RQYXJhZ3JhcGhFbmQocGFyYS5uZXh0U2libGluZyk7XG4gICAgICAgIHBhcmFzLnB1c2gocGFyYSk7XG4gICAgICAgIGlmIChtc29MaXN0UGFyYUVuZCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBtYWtlTGlzdEZyb21QYXJhZ3JhcGhzKHBhcmFzKTtcbiAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IHBhcmEubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVOb2RlKGxpc3QsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGVuZE5vZGVzKGNvbnRhaW5lciwgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZU5vZGUkMShwYXJhKTtcbiAgICB9KTtcbiAgICAvLyB3aXRob3V0IGA8cD48L3A+YCwgdGhlIGxpc3Qgc3RyaW5nIHdhcyBwYXJzZWQgYXMgYSBwYXJhZ3JhcGggbm9kZSBhbmQgYWRkZWRcbiAgICB2YXIgZXh0cmFIVE1MID0gZm91bmRQYXJhcy5sZW5ndGggPyAnPHA+PC9wPicgOiAnJztcbiAgICByZXR1cm4gXCJcIiArIGV4dHJhSFRNTCArIGNvbnRhaW5lci5pbm5lckhUTUw7XG59XG5cbnZhciBTVEFSVF9GUkFHTUVOVF9DT01NRU5UID0gJzwhLS1TdGFydEZyYWdtZW50LS0+JztcbnZhciBFTkRfRlJBR01FTlRfQ09NTUVOVCA9ICc8IS0tRW5kRnJhZ21lbnQtLT4nO1xuZnVuY3Rpb24gZ2V0Q29udGVudEJldHdlZW5GcmFnbWVudENvbW1lbnRzKGh0bWwpIHtcbiAgICB2YXIgc3RhcnRGcmFnbWVudEluZGV4ID0gaHRtbC5pbmRleE9mKFNUQVJUX0ZSQUdNRU5UX0NPTU1FTlQpO1xuICAgIHZhciBlbmRGcmFnbWVudEluZGV4ID0gaHRtbC5sYXN0SW5kZXhPZihFTkRfRlJBR01FTlRfQ09NTUVOVCk7XG4gICAgaWYgKHN0YXJ0RnJhZ21lbnRJbmRleCA+IC0xICYmIGVuZEZyYWdtZW50SW5kZXggPiAtMSkge1xuICAgICAgICBodG1sID0gaHRtbC5zbGljZShzdGFydEZyYWdtZW50SW5kZXggKyBTVEFSVF9GUkFHTUVOVF9DT01NRU5ULmxlbmd0aCwgZW5kRnJhZ21lbnRJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBodG1sLnJlcGxhY2UoLzxicltePl0qPi9nLCBBTFRFUk5BVElWRV9UQUdfRk9SX0JSKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRNc29UYWJsZVRvQ29tcGxldGVkVGFibGUoaHRtbCkge1xuICAgIC8vIHdyYXAgd2l0aCA8dHI+IGlmIGh0bWwgY29udGFpbnMgZGFuZ2xpbmcgPHRkPiB0YWdzXG4gICAgLy8gZGFuZ2xpbmcgPHRkPiB0YWcgaXMgdGhhdCB0YWcgZG9lcyBub3QgaGF2ZSA8dHI+IGFzIHBhcmVudCBub2RlXG4gICAgaWYgKC88XFwvdGQ+KCg/ITxcXC90cj4pW1xcc1xcU10pKiQvaS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIGh0bWwgPSBcIjx0cj5cIiArIGh0bWwgKyBcIjwvdHI+XCI7XG4gICAgfVxuICAgIC8vIHdyYXAgd2l0aCA8dGFibGU+IGlmIGh0bWwgY29udGFpbnMgZGFuZ2xpbmcgPHRyPiB0YWdzXG4gICAgLy8gZGFuZ2xpbmcgPHRyPiB0YWcgaXMgdGhhdCB0YWcgZG9lcyBub3QgaGF2ZSA8dGFibGU+IGFzIHBhcmVudCBub2RlXG4gICAgaWYgKC88XFwvdHI+KCg/ITxcXC90YWJsZT4pW1xcc1xcU10pKiQvaS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIGh0bWwgPSBcIjx0YWJsZT5cIiArIGh0bWwgKyBcIjwvdGFibGU+XCI7XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xufVxuZnVuY3Rpb24gY2hhbmdlUGFzdGVkSFRNTChodG1sKSB7XG4gICAgaHRtbCA9IGdldENvbnRlbnRCZXR3ZWVuRnJhZ21lbnRDb21tZW50cyhodG1sKTtcbiAgICBodG1sID0gY29udmVydE1zb1RhYmxlVG9Db21wbGV0ZWRUYWJsZShodG1sKTtcbiAgICBpZiAoaXNGcm9tTXNvKGh0bWwpKSB7XG4gICAgICAgIGh0bWwgPSBjb252ZXJ0TXNvUGFyYWdyYXBoc1RvTGlzdChodG1sKTtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG59XG5mdW5jdGlvbiBnZXRNYXhDb2x1bW5Db3VudChyb3dzKSB7XG4gICAgdmFyIHJvdyA9IHJvd3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2Um93LCBjdXJyZW50Um93KSB7XG4gICAgICAgIHJldHVybiBwcmV2Um93LmNoaWxkQ291bnQgPiBjdXJyZW50Um93LmNoaWxkQ291bnQgPyBwcmV2Um93IDogY3VycmVudFJvdztcbiAgICB9KTtcbiAgICByZXR1cm4gcm93LmNoaWxkQ291bnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxscyhvcmdSb3csIG1heENvbHVtbkNvdW50LCBjZWxsKSB7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgdmFyIGNlbGxDb3VudCA9IG9yZ1Jvdy5jaGlsZENvdW50O1xuICAgIGZvciAodmFyIGNvbElkeCA9IDA7IGNvbElkeCA8IGNlbGxDb3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgaWYgKCFvcmdSb3cuY2hpbGQoY29sSWR4KS5hdHRycy5leHRlbmRlZCkge1xuICAgICAgICAgICAgdmFyIGNvcGllZENlbGwgPSBjb2xJZHggPCBjZWxsQ291bnRcbiAgICAgICAgICAgICAgICA/IGNlbGwuY3JlYXRlKG9yZ1Jvdy5jaGlsZChjb2xJZHgpLmF0dHJzLCBvcmdSb3cuY2hpbGQoY29sSWR4KS5jb250ZW50KVxuICAgICAgICAgICAgICAgIDogY2VsbC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICAgICAgICBjZWxscy5wdXNoKGNvcGllZENlbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjZWxscztcbn1cbmZ1bmN0aW9uIGNvcHlUYWJsZUhlYWRSb3cob3JnUm93LCBtYXhDb2x1bW5Db3VudCwgc2NoZW1hKSB7XG4gICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZVJvdyA9IF9hLnRhYmxlUm93LCB0YWJsZUhlYWRDZWxsID0gX2EudGFibGVIZWFkQ2VsbDtcbiAgICB2YXIgY2VsbHMgPSBjcmVhdGVDZWxscyhvcmdSb3csIG1heENvbHVtbkNvdW50LCB0YWJsZUhlYWRDZWxsKTtcbiAgICByZXR1cm4gdGFibGVSb3cuY3JlYXRlKG51bGwsIGNlbGxzKTtcbn1cbmZ1bmN0aW9uIGNvcHlUYWJsZUJvZHlSb3cob3JnUm93LCBtYXhDb2x1bW5Db3VudCwgc2NoZW1hKSB7XG4gICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZVJvdyA9IF9hLnRhYmxlUm93LCB0YWJsZUJvZHlDZWxsID0gX2EudGFibGVCb2R5Q2VsbDtcbiAgICB2YXIgY2VsbHMgPSBjcmVhdGVDZWxscyhvcmdSb3csIG1heENvbHVtbkNvdW50LCB0YWJsZUJvZHlDZWxsKTtcbiAgICByZXR1cm4gdGFibGVSb3cuY3JlYXRlKG51bGwsIGNlbGxzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0VGFibGVCb2R5RHVtbXlSb3coY29sdW1uQ291bnQsIHNjaGVtYSkge1xuICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVSb3cgPSBfYS50YWJsZVJvdywgdGFibGVCb2R5Q2VsbCA9IF9hLnRhYmxlQm9keUNlbGw7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgZm9yICh2YXIgY29sdW1uSW5kZXggPSAwOyBjb2x1bW5JbmRleCA8IGNvbHVtbkNvdW50OyBjb2x1bW5JbmRleCArPSAxKSB7XG4gICAgICAgIHZhciBkdW1teUNlbGwgPSB0YWJsZUJvZHlDZWxsLmNyZWF0ZUFuZEZpbGwoKTtcbiAgICAgICAgY2VsbHMucHVzaChkdW1teUNlbGwpO1xuICAgIH1cbiAgICByZXR1cm4gdGFibGVSb3cuY3JlYXRlKHsgZHVtbXlSb3dGb3JQYXN0aW5nOiB0cnVlIH0sIGNlbGxzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvd3NGcm9tUGFzdGluZ1RhYmxlKHRhYmxlQ29udGVudCkge1xuICAgIHZhciB0YWJsZUhlYWRSb3dzID0gW107XG4gICAgdmFyIHRhYmxlQm9keVJvd3MgPSBbXTtcbiAgICBpZiAodGFibGVDb250ZW50LmZpcnN0Q2hpbGQudHlwZS5uYW1lID09PSAndGFibGVIZWFkJykge1xuICAgICAgICB2YXIgdGFibGVIZWFkID0gdGFibGVDb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRhYmxlSGVhZC5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHRhYmxlSGVhZFJvd3MucHVzaChyb3cpOyB9KTtcbiAgICB9XG4gICAgaWYgKHRhYmxlQ29udGVudC5sYXN0Q2hpbGQudHlwZS5uYW1lID09PSAndGFibGVCb2R5Jykge1xuICAgICAgICB2YXIgdGFibGVCb2R5ID0gdGFibGVDb250ZW50Lmxhc3RDaGlsZDtcbiAgICAgICAgdGFibGVCb2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gdGFibGVCb2R5Um93cy5wdXNoKHJvdyk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gX19zcHJlYWRBcnJheSQxKF9fc3ByZWFkQXJyYXkkMShbXSwgdGFibGVIZWFkUm93cyksIHRhYmxlQm9keVJvd3MpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVIZWFkKHRhYmxlSGVhZFJvdywgbWF4Q29sdW1uQ291bnQsIHNjaGVtYSkge1xuICAgIHZhciBjb3BpZWRSb3cgPSBjb3B5VGFibGVIZWFkUm93KHRhYmxlSGVhZFJvdywgbWF4Q29sdW1uQ291bnQsIHNjaGVtYSk7XG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlcy50YWJsZUhlYWQuY3JlYXRlKG51bGwsIGNvcGllZFJvdyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUJvZHkodGFibGVCb2R5Um93cywgbWF4Q29sdW1uQ291bnQsIHNjaGVtYSkge1xuICAgIHZhciBjb3BpZWRSb3dzID0gdGFibGVCb2R5Um93cy5tYXAoZnVuY3Rpb24gKHRhYmxlQm9keVJvdykge1xuICAgICAgICByZXR1cm4gY29weVRhYmxlQm9keVJvdyh0YWJsZUJvZHlSb3csIG1heENvbHVtbkNvdW50LCBzY2hlbWEpO1xuICAgIH0pO1xuICAgIGlmICghdGFibGVCb2R5Um93cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGR1bW15VGFibGVSb3cgPSBjcmVhdFRhYmxlQm9keUR1bW15Um93KG1heENvbHVtbkNvdW50LCBzY2hlbWEpO1xuICAgICAgICBjb3BpZWRSb3dzLnB1c2goZHVtbXlUYWJsZVJvdyk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEubm9kZXMudGFibGVCb2R5LmNyZWF0ZShudWxsLCBjb3BpZWRSb3dzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlRnJvbVBhc3RpbmdUYWJsZShyb3dzLCBzY2hlbWEsIHN0YXJ0RnJvbUJvZHksIGlzSW5UYWJsZSkge1xuICAgIHZhciBjb2x1bW5Db3VudCA9IGdldE1heENvbHVtbkNvdW50KHJvd3MpO1xuICAgIGlmIChzdGFydEZyb21Cb2R5ICYmIGlzSW5UYWJsZSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLm5vZGVzLnRhYmxlLmNyZWF0ZShudWxsLCBbY3JlYXRlVGFibGVCb2R5KHJvd3MsIGNvbHVtbkNvdW50LCBzY2hlbWEpXSk7XG4gICAgfVxuICAgIHZhciB0YWJsZUhlYWRSb3cgPSByb3dzWzBdO1xuICAgIHZhciB0YWJsZUJvZHlSb3dzID0gcm93cy5zbGljZSgxKTtcbiAgICB2YXIgbm9kZXMgPSBbY3JlYXRlVGFibGVIZWFkKHRhYmxlSGVhZFJvdywgY29sdW1uQ291bnQsIHNjaGVtYSldO1xuICAgIGlmICh0YWJsZUJvZHlSb3dzLmxlbmd0aCkge1xuICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZVRhYmxlQm9keSh0YWJsZUJvZHlSb3dzLCBjb2x1bW5Db3VudCwgc2NoZW1hKSk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEubm9kZXMudGFibGUuY3JlYXRlKG51bGwsIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIGNoYW5nZVBhc3RlZFNsaWNlKHNsaWNlLCBzY2hlbWEsIGlzSW5UYWJsZSkge1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBjb250ZW50ID0gc2xpY2UuY29udGVudCwgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kID0gc2xpY2Uub3BlbkVuZDtcbiAgICBjb250ZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSAndGFibGUnKSB7XG4gICAgICAgICAgICB2YXIgdGFibGVDb250ZW50ID0gZ2V0VGFibGVDb250ZW50RnJvbVNsaWNlKG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG4gICAgICAgICAgICBpZiAodGFibGVDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBjcmVhdGVSb3dzRnJvbVBhc3RpbmdUYWJsZSh0YWJsZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEZyb21Cb2R5ID0gdGFibGVDb250ZW50LmZpcnN0Q2hpbGQudHlwZS5uYW1lID09PSAndGFibGVCb2R5JztcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBjcmVhdGVUYWJsZUZyb21QYXN0aW5nVGFibGUocm93cywgc2NoZW1hLCBzdGFydEZyb21Cb2R5LCBpc0luVGFibGUpO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2godGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlcyksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbnZhciBEVU1NWV9DRUxMX1NJWkUgPSA0O1xudmFyIFRSX05PREVTX1NJWkUgPSAyO1xuZnVuY3Rpb24gZ2V0RHVtbXlDZWxsU2l6ZShkdW1teUNlbGxDb3VudCkge1xuICAgIHJldHVybiBkdW1teUNlbGxDb3VudCAqIERVTU1ZX0NFTExfU0laRTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhc3RpbmdDZWxscyh0YWJsZUNvbnRlbnQsIGN1clNlbGVjdGlvbkluZm8sIHNjaGVtYSkge1xuICAgIHZhciBwYXN0aW5nUm93cyA9IFtdO1xuICAgIHZhciBwYXN0aW5nVGFibGVSb3dzID0gY3JlYXRlUm93c0Zyb21QYXN0aW5nVGFibGUodGFibGVDb250ZW50KTtcbiAgICB2YXIgY29sdW1uQ291bnQgPSBwYXN0aW5nVGFibGVSb3dzWzBdLmNoaWxkQ291bnQ7XG4gICAgdmFyIHJvd0NvdW50ID0gcGFzdGluZ1RhYmxlUm93cy5sZW5ndGg7XG4gICAgdmFyIHN0YXJ0VG9UYWJsZUhlYWQgPSBjdXJTZWxlY3Rpb25JbmZvLnN0YXJ0Um93SWR4ID09PSAwO1xuICAgIHZhciBzbGljZWRSb3dzID0gcGFzdGluZ1RhYmxlUm93cy5zbGljZSgwLCByb3dDb3VudCk7XG4gICAgaWYgKHN0YXJ0VG9UYWJsZUhlYWQpIHtcbiAgICAgICAgdmFyIHRhYmxlSGVhZFJvdyA9IHNsaWNlZFJvd3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKHRhYmxlSGVhZFJvdykge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjb3B5VGFibGVIZWFkUm93KHRhYmxlSGVhZFJvdywgY29sdW1uQ291bnQsIHNjaGVtYSkuY29udGVudDtcbiAgICAgICAgICAgIHBhc3RpbmdSb3dzLnB1c2goY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2xpY2VkUm93cy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZUJvZHlSb3cpIHtcbiAgICAgICAgaWYgKCF0YWJsZUJvZHlSb3cuYXR0cnMuZHVtbXlSb3dGb3JQYXN0aW5nKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGNvcHlUYWJsZUJvZHlSb3codGFibGVCb2R5Um93LCBjb2x1bW5Db3VudCwgc2NoZW1hKS5jb250ZW50O1xuICAgICAgICAgICAgcGFzdGluZ1Jvd3MucHVzaChjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXN0aW5nUm93cztcbn1cbmZ1bmN0aW9uIGdldFBhc3RpbmdSYW5nZUluZm8obWFwLCBfYSwgcGFzdGluZ0NlbGxzKSB7XG4gICAgdmFyIHN0YXJ0Um93SWR4ID0gX2Euc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Euc3RhcnRDb2xJZHg7XG4gICAgdmFyIHBhc3RpbmdSb3dDb3VudCA9IHBhc3RpbmdDZWxscy5sZW5ndGg7XG4gICAgdmFyIHBhc3RpbmdDb2x1bW5Db3VudCA9IDA7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBwYXN0aW5nQ2VsbHNbaV0uY2hpbGRDb3VudDtcbiAgICAgICAgcGFzdGluZ0NlbGxzW2ldLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgIHZhciBjb2xzcGFuID0gYXR0cnMuY29sc3BhbjtcbiAgICAgICAgICAgIGlmIChjb2xzcGFuID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50ICs9IGNvbHNwYW4gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFzdGluZ0NvbHVtbkNvdW50ID0gTWF0aC5tYXgocGFzdGluZ0NvbHVtbkNvdW50LCBjb2x1bW5Db3VudCk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhc3RpbmdSb3dDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIF9sb29wXzEoaSk7XG4gICAgfVxuICAgIHZhciBlbmRSb3dJZHggPSBzdGFydFJvd0lkeCArIHBhc3RpbmdSb3dDb3VudCAtIDE7XG4gICAgdmFyIGVuZENvbElkeCA9IHN0YXJ0Q29sSWR4ICsgcGFzdGluZ0NvbHVtbkNvdW50IC0gMTtcbiAgICB2YXIgYWRkZWRSb3dDb3VudCA9IE1hdGgubWF4KGVuZFJvd0lkeCArIDEgLSBtYXAudG90YWxSb3dDb3VudCwgMCk7XG4gICAgdmFyIGFkZGVkQ29sdW1uQ291bnQgPSBNYXRoLm1heChlbmRDb2xJZHggKyAxIC0gbWFwLnRvdGFsQ29sdW1uQ291bnQsIDApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0Um93SWR4OiBzdGFydFJvd0lkeCxcbiAgICAgICAgc3RhcnRDb2xJZHg6IHN0YXJ0Q29sSWR4LFxuICAgICAgICBlbmRSb3dJZHg6IGVuZFJvd0lkeCxcbiAgICAgICAgZW5kQ29sSWR4OiBlbmRDb2xJZHgsXG4gICAgICAgIGFkZGVkUm93Q291bnQ6IGFkZGVkUm93Q291bnQsXG4gICAgICAgIGFkZGVkQ29sdW1uQ291bnQ6IGFkZGVkQ29sdW1uQ291bnQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZFJlcGxhY2VkT2Zmc2V0cyhfYSwgY2VsbHNPZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0Um93SWR4ID0gX2Euc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Euc3RhcnRDb2xJZHgsIGVuZFJvd0lkeCA9IF9hLmVuZFJvd0lkeCwgZW5kQ29sSWR4ID0gX2EuZW5kQ29sSWR4LCBhZGRlZFJvd0NvdW50ID0gX2EuYWRkZWRSb3dDb3VudCwgYWRkZWRDb2x1bW5Db3VudCA9IF9hLmFkZGVkQ29sdW1uQ291bnQ7XG4gICAgZm9yICh2YXIgcm93SWR4ID0gc3RhcnRSb3dJZHg7IHJvd0lkeCA8PSBlbmRSb3dJZHggLSBhZGRlZFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICBjZWxsc09mZnNldHMucHVzaCh7XG4gICAgICAgICAgICByb3dJZHg6IHJvd0lkeCxcbiAgICAgICAgICAgIHN0YXJ0Q29sSWR4OiBzdGFydENvbElkeCxcbiAgICAgICAgICAgIGVuZENvbElkeDogZW5kQ29sSWR4IC0gYWRkZWRDb2x1bW5Db3VudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXhwYW5kQ29sdW1ucyh0ciwgc2NoZW1hLCBtYXAsIF9hLCBjZWxsc09mZnNldHMpIHtcbiAgICB2YXIgc3RhcnRSb3dJZHggPSBfYS5zdGFydFJvd0lkeCwgc3RhcnRDb2xJZHggPSBfYS5zdGFydENvbElkeCwgZW5kUm93SWR4ID0gX2EuZW5kUm93SWR4LCBlbmRDb2xJZHggPSBfYS5lbmRDb2xJZHgsIGFkZGVkUm93Q291bnQgPSBfYS5hZGRlZFJvd0NvdW50LCBhZGRlZENvbHVtbkNvdW50ID0gX2EuYWRkZWRDb2x1bW5Db3VudDtcbiAgICB2YXIgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgdG90YWxSb3dDb3VudDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgZW5kQ29sSWR4IC0gYWRkZWRDb2x1bW5Db3VudCksIG9mZnNldCA9IF9iLm9mZnNldCwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZTtcbiAgICAgICAgdmFyIGluc2VydE9mZnNldCA9IHRyLm1hcHBpbmcubWFwKG9mZnNldCArIG5vZGVTaXplKTtcbiAgICAgICAgdmFyIGNlbGxzID0gY3JlYXRlRHVtbXlDZWxscyhhZGRlZENvbHVtbkNvdW50LCByb3dJZHgsIHNjaGVtYSk7XG4gICAgICAgIHRyLmluc2VydChpbnNlcnRPZmZzZXQsIGNlbGxzKTtcbiAgICAgICAgaWYgKHJvd0lkeCA+PSBzdGFydFJvd0lkeCAmJiByb3dJZHggPD0gZW5kUm93SWR4IC0gYWRkZWRSb3dDb3VudCkge1xuICAgICAgICAgICAgdmFyIGNlbGxJbmZvID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgZW5kQ29sSWR4IC0gYWRkZWRDb2x1bW5Db3VudCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRDZWxsT2Zmc2V0ID0gdHIubWFwcGluZy5tYXAoY2VsbEluZm8ub2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBlbmRDZWxsT2Zmc2V0ID0gaW5zZXJ0T2Zmc2V0ICsgZ2V0RHVtbXlDZWxsU2l6ZShhZGRlZENvbHVtbkNvdW50KTtcbiAgICAgICAgICAgIGNlbGxzT2Zmc2V0c1tpbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgcm93SWR4OiByb3dJZHgsXG4gICAgICAgICAgICAgICAgc3RhcnRDb2xJZHg6IHN0YXJ0Q29sSWR4LFxuICAgICAgICAgICAgICAgIGVuZENvbElkeDogZW5kQ29sSWR4LFxuICAgICAgICAgICAgICAgIGR1bW15T2Zmc2V0czogW3N0YXJ0Q2VsbE9mZnNldCwgZW5kQ2VsbE9mZnNldF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGV4cGFuZFJvd3ModHIsIHNjaGVtYSwgbWFwLCBfYSwgY2VsbHNPZmZzZXRzKSB7XG4gICAgdmFyIGFkZGVkUm93Q291bnQgPSBfYS5hZGRlZFJvd0NvdW50LCBhZGRlZENvbHVtbkNvdW50ID0gX2EuYWRkZWRDb2x1bW5Db3VudCwgc3RhcnRDb2xJZHggPSBfYS5zdGFydENvbElkeCwgZW5kQ29sSWR4ID0gX2EuZW5kQ29sSWR4O1xuICAgIHZhciBtYXBTdGFydCA9IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7XG4gICAgdmFyIHRhYmxlRW5kUG9zID0gbWFwLnRhYmxlRW5kT2Zmc2V0IC0gMjtcbiAgICB2YXIgcm93cyA9IGNyZWF0ZVRhYmxlQm9keVJvd3MoYWRkZWRSb3dDb3VudCwgbWFwLnRvdGFsQ29sdW1uQ291bnQgKyBhZGRlZENvbHVtbkNvdW50LCBzY2hlbWEpO1xuICAgIHZhciBzdGFydE9mZnNldCA9IHRhYmxlRW5kUG9zO1xuICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KS5tYXAoc3RhcnRPZmZzZXQpLCByb3dzKTtcbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgYWRkZWRSb3dDb3VudDsgcm93SW5kZXggKz0gMSkge1xuICAgICAgICB2YXIgc3RhcnRDZWxsT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBnZXREdW1teUNlbGxTaXplKHN0YXJ0Q29sSWR4KSArIDE7XG4gICAgICAgIHZhciBlbmRDZWxsT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBnZXREdW1teUNlbGxTaXplKGVuZENvbElkeCArIDEpICsgMTtcbiAgICAgICAgdmFyIG5leHRDZWxsT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBnZXREdW1teUNlbGxTaXplKG1hcC50b3RhbENvbHVtbkNvdW50ICsgYWRkZWRDb2x1bW5Db3VudCkgKyBUUl9OT0RFU19TSVpFO1xuICAgICAgICBjZWxsc09mZnNldHMucHVzaCh7XG4gICAgICAgICAgICByb3dJZHg6IHJvd0luZGV4ICsgbWFwLnRvdGFsUm93Q291bnQsXG4gICAgICAgICAgICBzdGFydENvbElkeDogc3RhcnRDb2xJZHgsXG4gICAgICAgICAgICBlbmRDb2xJZHg6IGVuZENvbElkeCxcbiAgICAgICAgICAgIGR1bW15T2Zmc2V0czogW3N0YXJ0Q2VsbE9mZnNldCwgZW5kQ2VsbE9mZnNldF0sXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydE9mZnNldCA9IG5leHRDZWxsT2Zmc2V0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VDZWxscyh0ciwgcGFzdGluZ1Jvd3MsIGNlbGxzT2Zmc2V0cywgbWFwKSB7XG4gICAgdmFyIG1hcFN0YXJ0ID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcbiAgICBjZWxsc09mZnNldHMuZm9yRWFjaChmdW5jdGlvbiAob2Zmc2V0cywgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJvd0lkeCA9IG9mZnNldHMucm93SWR4LCBzdGFydENvbElkeCA9IG9mZnNldHMuc3RhcnRDb2xJZHgsIGVuZENvbElkeCA9IG9mZnNldHMuZW5kQ29sSWR4LCBkdW1teU9mZnNldHMgPSBvZmZzZXRzLmR1bW15T2Zmc2V0cztcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KTtcbiAgICAgICAgdmFyIGNlbGxzID0gbmV3IFNsaWNlKHBhc3RpbmdSb3dzW2luZGV4XSwgMCwgMCk7XG4gICAgICAgIHZhciBmcm9tID0gZHVtbXlPZmZzZXRzID8gZHVtbXlPZmZzZXRzWzBdIDogbWFwLmdldENlbGxTdGFydE9mZnNldChyb3dJZHgsIHN0YXJ0Q29sSWR4KTtcbiAgICAgICAgdmFyIHRvID0gZHVtbXlPZmZzZXRzID8gZHVtbXlPZmZzZXRzWzFdIDogbWFwLmdldENlbGxFbmRPZmZzZXQocm93SWR4LCBlbmRDb2xJZHgpO1xuICAgICAgICB0ci5yZXBsYWNlKG1hcHBpbmcubWFwKGZyb20pLCBtYXBwaW5nLm1hcCh0byksIGNlbGxzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhc3RlVG9UYWJsZSh2aWV3LCBzbGljZSkge1xuICAgIHZhciBfYSA9IHZpZXcuc3RhdGUsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgc2NoZW1hID0gX2Euc2NoZW1hLCB0ciA9IF9hLnRyO1xuICAgIHZhciBfYiA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9iLmFuY2hvciwgaGVhZCA9IF9iLmhlYWQ7XG4gICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgIHZhciB0YWJsZUNvbnRlbnQgPSBnZXRUYWJsZUNvbnRlbnRGcm9tU2xpY2Uoc2xpY2UpO1xuICAgICAgICBpZiAoIXRhYmxlQ29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgdmFyIGN1clNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgdmFyIHBhc3RpbmdDZWxscyA9IGNyZWF0ZVBhc3RpbmdDZWxscyh0YWJsZUNvbnRlbnQsIGN1clNlbGVjdGlvbkluZm8sIHNjaGVtYSk7XG4gICAgICAgIHZhciBwYXN0aW5nSW5mbyA9IGdldFBhc3RpbmdSYW5nZUluZm8obWFwLCBjdXJTZWxlY3Rpb25JbmZvLCBwYXN0aW5nQ2VsbHMpO1xuICAgICAgICB2YXIgY2VsbHNPZmZzZXRzID0gW107XG4gICAgICAgIC8vIEBUT0RPOiB1bm1lcmdlIHRoZSBzcGFuIGFuZCBwYXN0ZSB0aGUgY2VsbFxuICAgICAgICBpZiAoY2FuTWVyZ2UobWFwLCBwYXN0aW5nSW5mbykpIHtcbiAgICAgICAgICAgIGFkZFJlcGxhY2VkT2Zmc2V0cyhwYXN0aW5nSW5mbywgY2VsbHNPZmZzZXRzKTtcbiAgICAgICAgICAgIGlmIChwYXN0aW5nSW5mby5hZGRlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kQ29sdW1ucyh0ciwgc2NoZW1hLCBtYXAsIHBhc3RpbmdJbmZvLCBjZWxsc09mZnNldHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhc3RpbmdJbmZvLmFkZGVkUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRSb3dzKHRyLCBzY2hlbWEsIG1hcCwgcGFzdGluZ0luZm8sIGNlbGxzT2Zmc2V0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlQ2VsbHModHIsIHBhc3RpbmdDZWxscywgY2VsbHNPZmZzZXRzLCBtYXApO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb24odmlldywgY2VsbHNPZmZzZXRzLCBtYXAuZ2V0Q2VsbEluZm8oMCwgMCkub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHZpZXcsIGNlbGxzT2Zmc2V0cywgcG9zKSB7XG4gICAgdmFyIF9hID0gdmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jO1xuICAgIC8vIGdldCBjaGFuZ2VkIGNlbGwgb2Zmc2V0c1xuICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoZG9jLnJlc29sdmUocG9zKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgdmFyIF9iID0gY2VsbHNPZmZzZXRzWzBdLCBzdGFydFJvd0lkeCA9IF9iLnJvd0lkeCwgc3RhcnRDb2xJZHggPSBfYi5zdGFydENvbElkeDtcbiAgICB2YXIgX2MgPSBsYXN0JDEoY2VsbHNPZmZzZXRzKSwgZW5kUm93SWR4ID0gX2Mucm93SWR4LCBlbmRDb2xJZHggPSBfYy5lbmRDb2xJZHg7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gbWFwLmdldENlbGxJbmZvKHN0YXJ0Um93SWR4LCBzdGFydENvbElkeCkub2Zmc2V0O1xuICAgIHZhciBlbmRPZmZzZXQgPSBtYXAuZ2V0Q2VsbEluZm8oZW5kUm93SWR4LCBlbmRDb2xJZHgpLm9mZnNldDtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihuZXcgQ2VsbFNlbGVjdGlvbihkb2MucmVzb2x2ZShzdGFydE9mZnNldCksIGRvYy5yZXNvbHZlKGVuZE9mZnNldCkpKSk7XG59XG5mdW5jdGlvbiBjYW5NZXJnZShtYXAsIHBhc3RpbmdJbmZvKSB7XG4gICAgdmFyIHJhbmdlcyA9IG1hcC5nZXRTcGFubmVkT2Zmc2V0cyhwYXN0aW5nSW5mbyk7XG4gICAgdmFyIF9hID0gZ2V0Um93QW5kQ29sdW1uQ291bnQocmFuZ2VzKSwgcm93Q291bnQgPSBfYS5yb3dDb3VudCwgY29sdW1uQ291bnQgPSBfYS5jb2x1bW5Db3VudDtcbiAgICB2YXIgX2IgPSBnZXRSb3dBbmRDb2x1bW5Db3VudChwYXN0aW5nSW5mbyksIHBhc3RpbmdSb3dDb3VudCA9IF9iLnJvd0NvdW50LCBwYXN0aW5nQ29sdW1uQ291bnQgPSBfYi5jb2x1bW5Db3VudDtcbiAgICByZXR1cm4gcm93Q291bnQgPT09IHBhc3RpbmdSb3dDb3VudCAmJiBjb2x1bW5Db3VudCA9PT0gcGFzdGluZ0NvbHVtbkNvdW50O1xufVxuXG52YXIgRG9jID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKERvYywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb2MoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvYy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvYy5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBEb2M7XG59KE5vZGUkMikpO1xuXG52YXIgUGFyYWdyYXBoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFBhcmFncmFwaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJhZ3JhcGgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFncmFwaC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdwYXJhZ3JhcGgnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFncmFwaC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdpbmxpbmUqJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7fSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbeyB0YWc6ICdwJyB9XSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydwJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBQYXJhZ3JhcGg7XG59KE5vZGUkMikpO1xuXG52YXIgcmVTb2Z0VGFiTGVuID0gL1xcc3sxLDR9JC87XG52YXIgVGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGV4dCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZXh0LnByb3RvdHlwZS5hZGRTcGFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyO1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmICFpc0luTGlzdE5vZGUoJGZyb20pICYmICFpc0luVGFibGVOb2RlKCRmcm9tKSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLmluc2VydFRleHQoJyAgICAnLCAkZnJvbS5wb3MsICR0by5wb3MpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnJlbW92ZVNwYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHI7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG8sIGZyb20gPSBzZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiAhaXNJbkxpc3ROb2RlKCRmcm9tKSAmJiAhaXNJblRhYmxlTm9kZSgkZnJvbSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUJlZm9yZSA9ICRmcm9tLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVCZWZvcmUgJiYgbm9kZUJlZm9yZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBub2RlQmVmb3JlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkU3BhY2VUZXh0ID0gdGV4dC5yZXBsYWNlKHJlU29mdFRhYkxlbiwgJycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2VzID0gdGV4dC5sZW5ndGggLSByZW1vdmVkU3BhY2VUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuZGVsZXRlKGZyb20gLSBzcGFjZXMsIGZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFRhYjogdGhpcy5hZGRTcGFjZXMoKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiB0aGlzLnJlbW92ZVNwYWNlcygpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRleHQ7XG59KE5vZGUkMikpO1xuXG52YXIgSGVhZGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShIZWFkaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRpbmcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRpbmcucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaGVhZGluZyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGluZy5wcm90b3R5cGUsIFwibGV2ZWxzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRpbmcucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlRE9NID0gdGhpcy5sZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogXCJoXCIgKyBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyBsZXZlbDogbGV2ZWwgfSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgbGV2ZWw6IHsgZGVmYXVsdDogMSB9LCBoZWFkaW5nVHlwZTogeyBkZWZhdWx0OiAnYXR4JyB9LCByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgY29udGVudDogJ2lubGluZSonLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGRlZmluaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBwYXJzZURPTSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiaFwiICsgYXR0cnMubGV2ZWwsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBIZWFkaW5nLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBzdGF0ZS5zY2hlbWEubm9kZXNbcGF5bG9hZC5sZXZlbCA/ICdoZWFkaW5nJyA6ICdwYXJhZ3JhcGgnXTtcbiAgICAgICAgICAgIHJldHVybiBzZXRCbG9ja1R5cGUobm9kZVR5cGUsIHBheWxvYWQpKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICByZXR1cm4gSGVhZGluZztcbn0oTm9kZSQyKSk7XG5cbnZhciBDb2RlQmxvY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ29kZUJsb2NrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGVCbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZUJsb2NrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvZGVCbG9jayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZUJsb2NrLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RleHQqJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IGxhbmd1YWdlOiB7IGRlZmF1bHQ6IG51bGwgfSwgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGNvZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVmaW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgbWFya3M6ICcnLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ3ByZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gZG9tLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgbGFuZ3VhZ2U6IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQuZ2V0QXR0cmlidXRlKCdkYXRhLWxhbmd1YWdlJykpIHx8IG51bGwgfSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMucmF3SFRNTCB8fCAncHJlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnY29kZScsIF9fYXNzaWduJDEoeyAnZGF0YS1sYW5ndWFnZSc6IGF0dHJzLmxhbmd1YWdlIH0sIGdldEN1c3RvbUF0dHJzKGF0dHJzKSksIDBdLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29kZUJsb2NrLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIHNldEJsb2NrVHlwZShzdGF0ZS5zY2hlbWEubm9kZXMuY29kZUJsb2NrKShzdGF0ZSwgZGlzcGF0Y2gpOyB9OyB9O1xuICAgIH07XG4gICAgQ29kZUJsb2NrLnByb3RvdHlwZS5tb3ZlQ3Vyc29yID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHRyID0gc3RhdGUudHIsIGRvYyA9IHN0YXRlLmRvYywgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBfdGhpcy5jb250ZXh0LnZpZXc7XG4gICAgICAgICAgICBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXJlY3Rpb24pICYmICRmcm9tLm5vZGUoKS50eXBlLm5hbWUgPT09ICdjb2RlQmxvY2snKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gJGZyb20ucGFyZW50LnRleHRDb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZGlyZWN0aW9uID09PSAndXAnID8gJGZyb20uc3RhcnQoKSA6ICRmcm9tLmVuZCgpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGRpcmVjdGlvbiA9PT0gJ3VwJ1xuICAgICAgICAgICAgICAgICAgICA/IFtvZmZzZXQsIGxpbmVzWzBdLmxlbmd0aCArIG9mZnNldF1cbiAgICAgICAgICAgICAgICAgICAgOiBbb2Zmc2V0IC0gbGFzdCQxKGxpbmVzKS5sZW5ndGgsIG9mZnNldF07XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGRvYy5yZXNvbHZlKGRpcmVjdGlvbiA9PT0gJ3VwJyA/ICRmcm9tLmJlZm9yZSgpIDogJGZyb20uYWZ0ZXIoKSk7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBkaXJlY3Rpb24gPT09ICd1cCcgPyBwb3Mubm9kZUJlZm9yZSA6IHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGJldHdlZW4kMSgkZnJvbS5wb3MsIHJhbmdlWzBdLCByYW5nZVsxXSkgJiYgIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1RyID0gYWRkUGFyYWdyYXBoKHRyLCBwb3MsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb2RlQmxvY2sucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2RlQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1NoaWZ0LU1vZC1wJzogY29kZUNvbW1hbmQsXG4gICAgICAgICAgICAnU2hpZnQtTW9kLVAnOiBjb2RlQ29tbWFuZCxcbiAgICAgICAgICAgIEFycm93VXA6IHRoaXMubW92ZUN1cnNvcigndXAnKSxcbiAgICAgICAgICAgIEFycm93RG93bjogdGhpcy5tb3ZlQ3Vyc29yKCdkb3duJyksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZUJsb2NrO1xufShOb2RlJDIpKTtcblxudmFyIEJ1bGxldExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQnVsbGV0TGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWxsZXRMaXN0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWxsZXRMaXN0LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2J1bGxldExpc3QnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1bGxldExpc3QucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnbGlzdEl0ZW0rJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW2NyZWF0ZURPTUluZm9QYXJzZWRSYXdIVE1MKCd1bCcpXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd1bCcsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCdWxsZXRMaXN0LnByb3RvdHlwZS5jaGFuZ2VMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gY2hhbmdlTGlzdChzdGF0ZS5zY2hlbWEubm9kZXMuYnVsbGV0TGlzdCkoc3RhdGUsIGRpc3BhdGNoKTsgfTtcbiAgICB9O1xuICAgIEJ1bGxldExpc3QucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVsbGV0TGlzdDogdGhpcy5jaGFuZ2VMaXN0LFxuICAgICAgICAgICAgdGFza0xpc3Q6IHRvZ2dsZVRhc2ssXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCdWxsZXRMaXN0LnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVsbGV0TGlzdENvbW1hbmQgPSB0aGlzLmNoYW5nZUxpc3QoKTtcbiAgICAgICAgdmFyIF9hID0gZ2V0V3dDb21tYW5kcygpLCBpbmRlbnQgPSBfYS5pbmRlbnQsIG91dGRlbnQgPSBfYS5vdXRkZW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC11JzogYnVsbGV0TGlzdENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLVUnOiBidWxsZXRMaXN0Q29tbWFuZCxcbiAgICAgICAgICAgIFRhYjogaW5kZW50KCksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogb3V0ZGVudCgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJ1bGxldExpc3Q7XG59KE5vZGUkMikpO1xuXG52YXIgT3JkZXJlZExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoT3JkZXJlZExpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3JkZXJlZExpc3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9yZGVyZWRMaXN0LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ29yZGVyZWRMaXN0JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcmRlcmVkTGlzdC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdsaXN0SXRlbSsnLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgb3JkZXI6IHsgZGVmYXVsdDogMSB9LCByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBkb20uZ2V0QXR0cmlidXRlKCdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgb3JkZXI6IGRvbS5oYXNBdHRyaWJ1dGUoJ3N0YXJ0JykgPyBOdW1iZXIoc3RhcnQpIDogMSB9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5yYXdIVE1MIHx8ICdvbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbiQxKHsgc3RhcnQ6IGF0dHJzLm9yZGVyID09PSAxID8gbnVsbCA6IGF0dHJzLm9yZGVyIH0sIGdldEN1c3RvbUF0dHJzKGF0dHJzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT3JkZXJlZExpc3QucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gY2hhbmdlTGlzdChzdGF0ZS5zY2hlbWEubm9kZXMub3JkZXJlZExpc3QpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBPcmRlcmVkTGlzdC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9yZGVyZWRMaXN0Q29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICB2YXIgX2EgPSBnZXRXd0NvbW1hbmRzKCksIGluZGVudCA9IF9hLmluZGVudCwgb3V0ZGVudCA9IF9hLm91dGRlbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLW8nOiBvcmRlcmVkTGlzdENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLU8nOiBvcmRlcmVkTGlzdENvbW1hbmQsXG4gICAgICAgICAgICBUYWI6IGluZGVudCgpLFxuICAgICAgICAgICAgJ1NoaWZ0LVRhYic6IG91dGRlbnQoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBPcmRlcmVkTGlzdDtcbn0oTm9kZSQyKSk7XG5cbnZhciBMaXN0SXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMaXN0SXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXN0SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdEl0ZW0ucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGlzdEl0ZW0nO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RJdGVtLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3BhcmFncmFwaCBibG9jayonLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2s6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlZmluaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2xpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyB0YXNrOiBkb20uaGFzQXR0cmlidXRlKCdkYXRhLXRhc2snKSwgY2hlY2tlZDogZG9tLmhhc0F0dHJpYnV0ZSgnZGF0YS10YXNrLWNoZWNrZWQnKSB9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gYXR0cnMudGFzaywgY2hlY2tlZCA9IGF0dHJzLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdHRycy5yYXdIVE1MIHx8ICdsaScsIDBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gWyd0YXNrLWxpc3QtaXRlbSddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdjaGVja2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnJhd0hUTUwgfHwgJ2xpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fYXNzaWduJDEoeyBjbGFzczogY2xhc3NOYW1lcy5qb2luKCcgJyksICdkYXRhLXRhc2snOiB0YXNrIH0sIChjaGVja2VkICYmIHsgJ2RhdGEtdGFzay1jaGVja2VkJzogY2hlY2tlZCB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLmxpZnRUb1ByZXZMaXN0SXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHIsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgZW1wdHkgPSBzZWxlY3Rpb24uZW1wdHk7XG4gICAgICAgICAgICB2YXIgbGlzdEl0ZW0gPSBzY2hlbWEubm9kZXMubGlzdEl0ZW07XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gJGZyb20ucGFyZW50O1xuICAgICAgICAgICAgdmFyIGxpc3RJdGVtUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgICAgICAgICBpZiAoZW1wdHkgJiYgIXBhcmVudC5jaGlsZENvdW50ICYmIGxpc3RJdGVtUGFyZW50LnR5cGUgPT09IGxpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byBwcmV2aW91cyBzaWJsaW5nIGxpc3QgaXRlbSB3aGVuIHRoZSBjdXJyZW50IGxpc3QgaXRlbSBpcyBub3QgdG9wIGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgIGlmICgkZnJvbS5pbmRleCgtMikgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgc3VidHJhY3QgJzEnIGZvciBjb25zaWRlcmluZyB0YWcgbGVuZ3RoKDxsaT4pXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSgkZnJvbS5zdGFydCgtMSkgLSAxLCAkZnJvbS5lbmQoLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdyYW5kUGFyZW50TGlzdEl0ZW0gPSAkZnJvbS5ub2RlKC0zKTtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRvIHBhcmVudCBsaXN0IGl0ZW0gd2hlbiB0aGUgY3VycmVudCBsaXN0IGl0ZW0gaXMgdG9wIGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgIGlmIChncmFuZFBhcmVudExpc3RJdGVtLnR5cGUgPT09IGxpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBzdWJ0cmFjdCAnMScgZm9yIGNvbnNpZGVyaW5nIHRhZyBsZW5ndGgoPHVsPilcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KC0yKSAtIDEsICRmcm9tLmVuZCgtMSkpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3BsaXQgPSBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRMaXN0SXRlbShzdGF0ZS5zY2hlbWEubm9kZXMubGlzdEl0ZW0pKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBCYWNrc3BhY2U6IHRoaXMubGlmdFRvUHJldkxpc3RJdGVtKCksXG4gICAgICAgICAgICBFbnRlcjogc3BsaXQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTGlzdEl0ZW07XG59KE5vZGUkMikpO1xuXG52YXIgQmxvY2tRdW90ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShCbG9ja1F1b3RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrUXVvdGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrUXVvdGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2tRdW90ZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvY2tRdW90ZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbY3JlYXRlRE9NSW5mb1BhcnNlZFJhd0hUTUwoJ2Jsb2NrcXVvdGUnKV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnYmxvY2txdW90ZScsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCbG9ja1F1b3RlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIHdyYXBJbihzdGF0ZS5zY2hlbWEubm9kZXMuYmxvY2tRdW90ZSkoc3RhdGUsIGRpc3BhdGNoKTsgfTsgfTtcbiAgICB9O1xuICAgIEJsb2NrUXVvdGUucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBibG9ja1F1dG9lQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ0FsdC1xJzogYmxvY2tRdXRvZUNvbW1hbmQsXG4gICAgICAgICAgICAnQWx0LVEnOiBibG9ja1F1dG9lQ29tbWFuZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja1F1b3RlO1xufShOb2RlJDIpKTtcblxudmFyIGNlbGxPZmZzZXRGbk1hcCA9IHtcbiAgICBsZWZ0OiBnZXRMZWZ0Q2VsbE9mZnNldCxcbiAgICByaWdodDogZ2V0UmlnaHRDZWxsT2Zmc2V0LFxuICAgIHVwOiBnZXRVcENlbGxPZmZzZXQsXG4gICAgZG93bjogZ2V0RG93bkNlbGxPZmZzZXQsXG59O1xuZnVuY3Rpb24gaXNJbkZpcnN0TGlzdEl0ZW0ocG9zLCBkb2MsIF9hKSB7XG4gICAgdmFyIHBhcmFEZXB0aCA9IF9hWzBdLCBsaXN0RGVwdGggPSBfYVsxXTtcbiAgICB2YXIgbGlzdEl0ZW1Ob2RlID0gZG9jLnJlc29sdmUocG9zLmJlZm9yZShwYXJhRGVwdGggLSAxKSk7XG4gICAgcmV0dXJuIGxpc3REZXB0aCA9PT0gcGFyYURlcHRoICYmICFsaXN0SXRlbU5vZGUubm9kZUJlZm9yZTtcbn1cbmZ1bmN0aW9uIGlzSW5MYXN0TGlzdEl0ZW0ocG9zKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBkZXB0aCA9IHBvcy5kZXB0aDtcbiAgICB2YXIgcGFyZW50Tm9kZTtcbiAgICB3aGlsZSAoZGVwdGgpIHtcbiAgICAgICAgcGFyZW50Tm9kZSA9IHBvcy5ub2RlKGRlcHRoKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUudHlwZS5uYW1lID09PSAndGFibGVCb2R5Q2VsbCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnROb2RlLnR5cGUubmFtZSA9PT0gJ2xpc3RJdGVtJykge1xuICAgICAgICAgICAgdmFyIGdyYW5kUGFyZW50ID0gcG9zLm5vZGUoZGVwdGggLSAxKTtcbiAgICAgICAgICAgIHZhciBsYXN0TGlzdEl0ZW0gPSBncmFuZFBhcmVudC5sYXN0Q2hpbGQgPT09IHBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgaGFzQ2hpbGRyZW4gPSAoKF9hID0gcGFyZW50Tm9kZS5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlLm5hbWUpICE9PSAncGFyYWdyYXBoJztcbiAgICAgICAgICAgIGlmICghbGFzdExpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFoYXNDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5Nb3ZlVG9CZWZvcmVDZWxsKGRpcmVjdGlvbiwgX2EsIGZyb20sIGRvYywgaW5MaXN0KSB7XG4gICAgdmFyIHBhcmFEZXB0aCA9IF9hWzBdLCBsaXN0RGVwdGggPSBfYVsxXSwgY3VyRGVwdGggPSBfYVsyXTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImxlZnRcIiAvKiBMRUZUICovIHx8IGRpcmVjdGlvbiA9PT0gXCJ1cFwiIC8qIFVQICovKSB7XG4gICAgICAgIGlmIChpbkxpc3QgJiYgIWlzSW5GaXJzdExpc3RJdGVtKGZyb20sIGRvYywgW3BhcmFEZXB0aCwgbGlzdERlcHRoXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZnJvbS5iZWZvcmUoY3VyRGVwdGgpO1xuICAgICAgICB2YXIgbm9kZUJlZm9yZSA9IGRvYy5yZXNvbHZlKGVuZE9mZnNldCkubm9kZUJlZm9yZTtcbiAgICAgICAgaWYgKG5vZGVCZWZvcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhbk1vdmVUb0FmdGVyQ2VsbChkaXJlY3Rpb24sIGN1ckRlcHRoLCBmcm9tLCBkb2MsIGluTGlzdCkge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwicmlnaHRcIiAvKiBSSUdIVCAqLyB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiIC8qIERPV04gKi8pIHtcbiAgICAgICAgaWYgKGluTGlzdCAmJiAhaXNJbkxhc3RMaXN0SXRlbShmcm9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBmcm9tLmFmdGVyKGN1ckRlcHRoKTtcbiAgICAgICAgdmFyIG5vZGVBZnRlciA9IGRvYy5yZXNvbHZlKGVuZE9mZnNldCkubm9kZUFmdGVyO1xuICAgICAgICBpZiAobm9kZUFmdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5Nb3ZlQmV0d2VlbkNlbGxzKGRpcmVjdGlvbiwgX2EsIGZyb20sIGRvYykge1xuICAgIHZhciBjZWxsRGVwdGggPSBfYVswXSwgcGFyYURlcHRoID0gX2FbMV07XG4gICAgdmFyIGxpc3REZXB0aCA9IGNlbGxEZXB0aCArIDM7IC8vIDMgaXMgcG9zaXRpb24gb2YgPHVsPjxsaT48cD5cbiAgICB2YXIgaW5MaXN0ID0gcGFyYURlcHRoID49IGxpc3REZXB0aDtcbiAgICB2YXIgY3VyRGVwdGggPSBpbkxpc3QgPyBjZWxsRGVwdGggKyAxIDogcGFyYURlcHRoO1xuICAgIHZhciBtb3ZlQmVmb3JlQ2VsbCA9IGNhbk1vdmVUb0JlZm9yZUNlbGwoZGlyZWN0aW9uLCBbcGFyYURlcHRoLCBsaXN0RGVwdGgsIGN1ckRlcHRoXSwgZnJvbSwgZG9jLCBpbkxpc3QpO1xuICAgIHZhciBtb3ZlQWZ0ZXJDZWxsID0gY2FuTW92ZVRvQWZ0ZXJDZWxsKGRpcmVjdGlvbiwgY3VyRGVwdGgsIGZyb20sIGRvYywgaW5MaXN0KTtcbiAgICByZXR1cm4gbW92ZUJlZm9yZUNlbGwgJiYgbW92ZUFmdGVyQ2VsbDtcbn1cbmZ1bmN0aW9uIGNhbkJlT3V0T2ZUYWJsZShkaXJlY3Rpb24sIG1hcCwgX2EpIHtcbiAgICB2YXIgcm93SWR4ID0gX2FbMF0sIGNvbElkeCA9IF9hWzFdO1xuICAgIHZhciByb3dzcGFuSW5mbyA9IG1hcC5nZXRSb3dzcGFuU3RhcnRJbmZvKHJvd0lkeCwgY29sSWR4KTtcbiAgICB2YXIgaW5GaXJzdFJvdyA9IGRpcmVjdGlvbiA9PT0gXCJ1cFwiIC8qIFVQICovICYmIHJvd0lkeCA9PT0gMDtcbiAgICB2YXIgaW5MYXN0Um93ID0gZGlyZWN0aW9uID09PSBcImRvd25cIiAvKiBET1dOICovICYmXG4gICAgICAgICgocm93c3BhbkluZm8gPT09IG51bGwgfHwgcm93c3BhbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd3NwYW5JbmZvLmNvdW50KSA+IDEgPyByb3dJZHggKyByb3dzcGFuSW5mby5jb3VudCAtIDEgOiByb3dJZHgpID09PSBtYXAudG90YWxSb3dDb3VudCAtIDE7XG4gICAgcmV0dXJuIGluRmlyc3RSb3cgfHwgaW5MYXN0Um93O1xufVxuZnVuY3Rpb24gYWRkUGFyYWdyYXBoQmVmb3JlVGFibGUodHIsIG1hcCwgc2NoZW1hKSB7XG4gICAgdmFyIHRhYmxlU3RhcnRQb3MgPSB0ci5kb2MucmVzb2x2ZShtYXAudGFibGVTdGFydE9mZnNldCAtIDEpO1xuICAgIGlmICghdGFibGVTdGFydFBvcy5ub2RlQmVmb3JlKSB7XG4gICAgICAgIHJldHVybiBhZGRQYXJhZ3JhcGgodHIsIHRhYmxlU3RhcnRQb3MsIHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodGFibGVTdGFydFBvcywgLTEpKTtcbn1cbmZ1bmN0aW9uIGFkZFBhcmFncmFwaEFmdGVyVGFibGUodHIsIG1hcCwgc2NoZW1hLCBmb3JjZWRBZGR0aW9uKSB7XG4gICAgaWYgKGZvcmNlZEFkZHRpb24gPT09IHZvaWQgMCkgeyBmb3JjZWRBZGR0aW9uID0gZmFsc2U7IH1cbiAgICB2YXIgdGFibGVFbmRQb3MgPSB0ci5kb2MucmVzb2x2ZShtYXAudGFibGVFbmRPZmZzZXQpO1xuICAgIGlmIChmb3JjZWRBZGR0aW9uIHx8ICF0YWJsZUVuZFBvcy5ub2RlQWZ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGFkZFBhcmFncmFwaCh0ciwgdGFibGVFbmRQb3MsIHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodGFibGVFbmRQb3MsIDEpKTtcbn1cbmZ1bmN0aW9uIGdldFJpZ2h0Q2VsbE9mZnNldChfYSwgbWFwKSB7XG4gICAgdmFyIHJvd0lkeCA9IF9hWzBdLCBjb2xJZHggPSBfYVsxXTtcbiAgICB2YXIgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50LCB0b3RhbENvbHVtbkNvdW50ID0gbWFwLnRvdGFsQ29sdW1uQ291bnQ7XG4gICAgdmFyIGxhc3RDZWxsSW5Sb3cgPSBjb2xJZHggPT09IHRvdGFsQ29sdW1uQ291bnQgLSAxO1xuICAgIHZhciBsYXN0Q2VsbEluVGFibGUgPSByb3dJZHggPT09IHRvdGFsUm93Q291bnQgLSAxICYmIGxhc3RDZWxsSW5Sb3c7XG4gICAgaWYgKCFsYXN0Q2VsbEluVGFibGUpIHtcbiAgICAgICAgdmFyIG5leHRDb2xJZHggPSBjb2xJZHggKyAxO1xuICAgICAgICB2YXIgY29sc3BhbkluZm8gPSBtYXAuZ2V0Q29sc3BhblN0YXJ0SW5mbyhyb3dJZHgsIGNvbElkeCk7XG4gICAgICAgIGlmICgoY29sc3BhbkluZm8gPT09IG51bGwgfHwgY29sc3BhbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHNwYW5JbmZvLmNvdW50KSA+IDEpIHtcbiAgICAgICAgICAgIG5leHRDb2xJZHggKz0gY29sc3BhbkluZm8uY291bnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Q2VsbEluUm93IHx8IG5leHRDb2xJZHggPT09IHRvdGFsQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHJvd0lkeCArPSAxO1xuICAgICAgICAgICAgbmV4dENvbElkeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIG5leHRDb2xJZHgpLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TGVmdENlbGxPZmZzZXQoX2EsIG1hcCkge1xuICAgIHZhciByb3dJZHggPSBfYVswXSwgY29sSWR4ID0gX2FbMV07XG4gICAgdmFyIHRvdGFsQ29sdW1uQ291bnQgPSBtYXAudG90YWxDb2x1bW5Db3VudDtcbiAgICB2YXIgZmlyc3RDZWxsSW5Sb3cgPSBjb2xJZHggPT09IDA7XG4gICAgdmFyIGZpcnN0Q2VsbEluVGFibGUgPSByb3dJZHggPT09IDAgJiYgZmlyc3RDZWxsSW5Sb3c7XG4gICAgaWYgKCFmaXJzdENlbGxJblRhYmxlKSB7XG4gICAgICAgIGNvbElkeCAtPSAxO1xuICAgICAgICBpZiAoZmlyc3RDZWxsSW5Sb3cpIHtcbiAgICAgICAgICAgIHJvd0lkeCAtPSAxO1xuICAgICAgICAgICAgY29sSWR4ID0gdG90YWxDb2x1bW5Db3VudCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgbm9kZVNpemUgLSAyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFVwQ2VsbE9mZnNldChfYSwgbWFwKSB7XG4gICAgdmFyIHJvd0lkeCA9IF9hWzBdLCBjb2xJZHggPSBfYVsxXTtcbiAgICBpZiAocm93SWR4ID4gMCkge1xuICAgICAgICB2YXIgX2IgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4IC0gMSwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgbm9kZVNpemUgLSAyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERvd25DZWxsT2Zmc2V0KF9hLCBtYXApIHtcbiAgICB2YXIgcm93SWR4ID0gX2FbMF0sIGNvbElkeCA9IF9hWzFdO1xuICAgIHZhciB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQ7XG4gICAgaWYgKHJvd0lkeCA8IHRvdGFsUm93Q291bnQgLSAxKSB7XG4gICAgICAgIHZhciBuZXh0Um93SWR4ID0gcm93SWR4ICsgMTtcbiAgICAgICAgdmFyIHJvd3NwYW5JbmZvID0gbWFwLmdldFJvd3NwYW5TdGFydEluZm8ocm93SWR4LCBjb2xJZHgpO1xuICAgICAgICBpZiAoKHJvd3NwYW5JbmZvID09PSBudWxsIHx8IHJvd3NwYW5JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3dzcGFuSW5mby5jb3VudCkgPiAxKSB7XG4gICAgICAgICAgICBuZXh0Um93SWR4ICs9IHJvd3NwYW5JbmZvLmNvdW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gbWFwLmdldENlbGxJbmZvKG5leHRSb3dJZHgsIGNvbElkeCkub2Zmc2V0O1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtb3ZlVG9DZWxsKGRpcmVjdGlvbiwgdHIsIGNlbGxJbmRleCwgbWFwKSB7XG4gICAgdmFyIGNlbGxPZmZzZXRGbiA9IGNlbGxPZmZzZXRGbk1hcFtkaXJlY3Rpb25dO1xuICAgIHZhciBvZmZzZXQgPSBjZWxsT2Zmc2V0Rm4oY2VsbEluZGV4LCBtYXApO1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgdmFyIGRpciA9IGRpcmVjdGlvbiA9PT0gXCJyaWdodFwiIC8qIFJJR0hUICovIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgLyogRE9XTiAqLyA/IDEgOiAtMTtcbiAgICAgICAgcmV0dXJuIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShvZmZzZXQpLCBkaXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjYW5TZWxlY3RUYWJsZU5vZGUoZGlyZWN0aW9uLCBtYXAsIF9hKSB7XG4gICAgdmFyIHJvd0lkeCA9IF9hWzBdLCBjb2xJZHggPSBfYVsxXTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIgLyogVVAgKi8gfHwgZGlyZWN0aW9uID09PSBcImRvd25cIiAvKiBET1dOICovKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRhYmxlU3RhcnRPZmZzZXQgPSBtYXAudGFibGVTdGFydE9mZnNldCwgdGFibGVFbmRPZmZzZXQgPSBtYXAudGFibGVFbmRPZmZzZXQ7XG4gICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgIHZhciBwb3MgPSBkaXJlY3Rpb24gPT09IFwibGVmdFwiIC8qIExFRlQgKi8gPyB0YWJsZVN0YXJ0T2Zmc2V0IDogdGFibGVFbmRPZmZzZXQ7XG4gICAgdmFyIGN1clBvcyA9IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgLyogTEVGVCAqLyA/IG9mZnNldCAtIDIgOiBvZmZzZXQgKyBub2RlU2l6ZSArIDM7XG4gICAgcmV0dXJuIHBvcyA9PT0gY3VyUG9zO1xufVxuZnVuY3Rpb24gc2VsZWN0Tm9kZSh0ciwgcG9zLCBkZXB0aCkge1xuICAgIHZhciB0YWJsZVBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcy5iZWZvcmUoZGVwdGggLSAzKSk7XG4gICAgcmV0dXJuIHRyLnNldFNlbGVjdGlvbihuZXcgTm9kZVNlbGVjdGlvbih0YWJsZVBvcykpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRSb3dJbmZvKGRpcmVjdGlvbiwgbWFwLCBzZWxlY3Rpb25JbmZvKSB7XG4gICAgdmFyIHRhcmdldFJvd0lkeDtcbiAgICB2YXIgaW5zZXJ0Q29sSWR4O1xuICAgIHZhciBub2RlU2l6ZTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIgLyogVVAgKi8pIHtcbiAgICAgICAgdGFyZ2V0Um93SWR4ID0gc2VsZWN0aW9uSW5mby5zdGFydFJvd0lkeDtcbiAgICAgICAgaW5zZXJ0Q29sSWR4ID0gMDtcbiAgICAgICAgbm9kZVNpemUgPSAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFJvd0lkeCA9IHNlbGVjdGlvbkluZm8uZW5kUm93SWR4O1xuICAgICAgICBpbnNlcnRDb2xJZHggPSBtYXAudG90YWxDb2x1bW5Db3VudCAtIDE7XG4gICAgICAgIG5vZGVTaXplID0gbWFwLmdldENlbGxJbmZvKHRhcmdldFJvd0lkeCwgaW5zZXJ0Q29sSWR4KS5ub2RlU2l6ZSArIDE7XG4gICAgfVxuICAgIHJldHVybiB7IHRhcmdldFJvd0lkeDogdGFyZ2V0Um93SWR4LCBpbnNlcnRDb2xJZHg6IGluc2VydENvbElkeCwgbm9kZVNpemU6IG5vZGVTaXplIH07XG59XG5mdW5jdGlvbiBnZXRSb3dSYW5nZXMobWFwLCByb3dJZHgsIHRvdGFsQ29sdW1uQ291bnQpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCAwKS5vZmZzZXQ7XG4gICAgdmFyIF9hID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgdG90YWxDb2x1bW5Db3VudCAtIDEpLCBvZmZzZXQgPSBfYS5vZmZzZXQsIG5vZGVTaXplID0gX2Eubm9kZVNpemU7XG4gICAgcmV0dXJuIHsgZnJvbTogc3RhcnRPZmZzZXQsIHRvOiBvZmZzZXQgKyBub2RlU2l6ZSB9O1xufVxudmFyIFRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGUucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGFibGVIZWFkezF9IHRhYmxlQm9keXsxfScsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtjcmVhdGVET01JbmZvUGFyc2VkUmF3SFRNTCgndGFibGUnKV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndGFibGUnLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGFibGUucHJvdG90eXBlLmFkZFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkID09PSB2b2lkIDApIHsgcGF5bG9hZCA9IHsgcm93Q291bnQ6IDIsIGNvbHVtbkNvdW50OiAxLCBkYXRhOiBbXSB9OyB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IHBheWxvYWQucm93Q291bnQsIGNvbHVtbkNvdW50ID0gcGF5bG9hZC5jb2x1bW5Db3VudCwgZGF0YSA9IHBheWxvYWQuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG8sICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICAgICAgICAgIHZhciBjb2xsYXBzZWQgPSBmcm9tID09PSB0bztcbiAgICAgICAgICAgICAgICBpZiAoY29sbGFwc2VkICYmICFpc0luVGFibGVOb2RlKCRmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBzY2hlbWEubm9kZXMsIHRhYmxlSGVhZCA9IF9hLnRhYmxlSGVhZCwgdGFibGVCb2R5ID0gX2EudGFibGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlYWREYXRhID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnNsaWNlKDAsIGNvbHVtbkNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRib2R5RGF0YSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5zbGljZShjb2x1bW5Db3VudCwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVIZWFkUm93ID0gY3JlYXRlVGFibGVIZWFkUm93KGNvbHVtbkNvdW50LCBzY2hlbWEsIHRoZWFkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUJvZHlSb3dzID0gY3JlYXRlVGFibGVCb2R5Um93cyhyb3dDb3VudCAtIDEsIGNvbHVtbkNvdW50LCBzY2hlbWEsIHRib2R5RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IHNjaGVtYS5ub2Rlcy50YWJsZS5jcmVhdGUobnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVIZWFkLmNyZWF0ZShudWxsLCB0YWJsZUhlYWRSb3cpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVCb2R5LmNyZWF0ZShudWxsLCB0YWJsZUJvZHlSb3dzKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHRhYmxlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLnJlbW92ZVRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoc2VsZWN0aW9uLiRhbmNob3IpO1xuICAgICAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZVN0YXJ0T2Zmc2V0ID0gbWFwLnRhYmxlU3RhcnRPZmZzZXQsIHRhYmxlRW5kT2Zmc2V0ID0gbWFwLnRhYmxlRW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IHRhYmxlU3RhcnRPZmZzZXQgLSAxO1xuICAgICAgICAgICAgICAgIHZhciBjdXJzb3JQb3MgPSBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLmRlbGV0ZShzdGFydE9mZnNldCwgdGFibGVFbmRPZmZzZXQpLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGN1cnNvclBvcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmFkZENvbHVtbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHIsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q29sSWR4ID0gZGlyZWN0aW9uID09PSBcImxlZnRcIiAvKiBMRUZUICovID8gc2VsZWN0aW9uSW5mby5zdGFydENvbElkeCA6IHNlbGVjdGlvbkluZm8uZW5kQ29sSWR4ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBnZXRSb3dBbmRDb2x1bW5Db3VudChzZWxlY3Rpb25JbmZvKS5jb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0lkeCA9IDA7IHJvd0lkeCA8IHRvdGFsUm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IGNyZWF0ZUR1bW15Q2VsbHMoY29sdW1uQ291bnQsIHJvd0lkeCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKG1hcC5wb3NBdChyb3dJZHgsIHRhcmdldENvbElkeCkpLCBjZWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5yZW1vdmVDb2x1bW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2EuYW5jaG9yLCBoZWFkID0gX2EuaGVhZDtcbiAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbENvbHVtbkNvdW50ID0gbWFwLnRvdGFsQ29sdW1uQ291bnQsIHRvdGFsUm93Q291bnQgPSBtYXAudG90YWxSb3dDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBnZXRSb3dBbmRDb2x1bW5Db3VudChzZWxlY3Rpb25JbmZvKS5jb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRBbGxDb2x1bW4gPSBjb2x1bW5Db3VudCA9PT0gdG90YWxDb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRBbGxDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb2xJZHggPSBzZWxlY3Rpb25JbmZvLnN0YXJ0Q29sSWR4LCBlbmRDb2xJZHggPSBzZWxlY3Rpb25JbmZvLmVuZENvbElkeDtcbiAgICAgICAgICAgICAgICB2YXIgbWFwU3RhcnQgPSB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0lkeCA9IDA7IHJvd0lkeCA8IHRvdGFsUm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IGVuZENvbElkeDsgY29sSWR4ID49IHN0YXJ0Q29sSWR4OyBjb2xJZHggLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KS5tYXAob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0byA9IGZyb20gKyBub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmFkZFJvdyA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsQ29sdW1uQ291bnQgPSBtYXAudG90YWxDb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpO1xuICAgICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IGdldFJvd0FuZENvbHVtbkNvdW50KHNlbGVjdGlvbkluZm8pLnJvd0NvdW50O1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGdldFRhcmdldFJvd0luZm8oZGlyZWN0aW9uLCBtYXAsIHNlbGVjdGlvbkluZm8pLCB0YXJnZXRSb3dJZHggPSBfYi50YXJnZXRSb3dJZHgsIGluc2VydENvbElkeCA9IF9iLmluc2VydENvbElkeCwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRUaGVhZCA9IHRhcmdldFJvd0lkeCA9PT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkVGhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0ci5tYXBwaW5nLm1hcChtYXAucG9zQXQodGFyZ2V0Um93SWR4LCBpbnNlcnRDb2xJZHgpKSArIG5vZGVTaXplO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gMDsgY29sSWR4IDwgdG90YWxDb2x1bW5Db3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzID0gY2VsbHMuY29uY2F0KGNyZWF0ZUR1bW15Q2VsbHMoMSwgdGFyZ2V0Um93SWR4LCBzY2hlbWEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChzY2hlbWEubm9kZXMudGFibGVSb3cuY3JlYXRlKG51bGwsIGNlbGxzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuaW5zZXJ0KGZyb20sIHJvd3MpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLnJlbW92ZVJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYS5hbmNob3IsIGhlYWQgPSBfYS5oZWFkO1xuICAgICAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQsIHRvdGFsQ29sdW1uQ291bnQgPSBtYXAudG90YWxDb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpO1xuICAgICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IGdldFJvd0FuZENvbHVtbkNvdW50KHNlbGVjdGlvbkluZm8pLnJvd0NvdW50O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFJvd0lkeCA9IHNlbGVjdGlvbkluZm8uc3RhcnRSb3dJZHgsIGVuZFJvd0lkeCA9IHNlbGVjdGlvbkluZm8uZW5kUm93SWR4O1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZFRoZWFkID0gc3RhcnRSb3dJZHggPT09IDA7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkQWxsVGJvZHlSb3cgPSByb3dDb3VudCA9PT0gdG90YWxSb3dDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkQWxsVGJvZHlSb3cgfHwgc2VsZWN0ZWRUaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0lkeCA9IGVuZFJvd0lkeDsgcm93SWR4ID49IHN0YXJ0Um93SWR4OyByb3dJZHggLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBnZXRSb3dSYW5nZXMobWFwLCByb3dJZHgsIHRvdGFsQ29sdW1uQ291bnQpLCBmcm9tID0gX2IuZnJvbSwgdG8gPSBfYi50bztcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRhYmxlIHJvd1xuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUoZnJvbSAtIDEsIHRvICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5hbGlnbkNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZCA9PT0gdm9pZCAwKSB7IHBheWxvYWQgPSB7IGFsaWduOiAnY2VudGVyJyB9OyB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciBhbGlnbiA9IHBheWxvYWQuYWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYS5hbmNob3IsIGhlYWQgPSBfYS5oZWFkO1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbmZvID0gbWFwLmdldFJlY3RPZmZzZXRzKGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydENvbElkeCA9IHNlbGVjdGlvbkluZm8uc3RhcnRDb2xJZHgsIGVuZENvbElkeCA9IHNlbGVjdGlvbkluZm8uZW5kQ29sSWR4O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByb3dJZHggPSAwOyByb3dJZHggPCB0b3RhbFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gc3RhcnRDb2xJZHg7IGNvbElkeCA8PSBlbmRDb2xJZHg7IGNvbElkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXAuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSAmJiAhbWFwLmV4dGVuZGVkQ29sc3Bhbihyb3dJZHgsIGNvbElkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gbWFwLmdldE5vZGVBbmRQb3Mocm93SWR4LCBjb2xJZHgpLCBub2RlID0gX2Iubm9kZSwgcG9zID0gX2IucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBzZXRBdHRycyhub2RlLCB7IGFsaWduOiBhbGlnbiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIG51bGwsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5tb3ZlVG9DZWxsID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50ciwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2EuYW5jaG9yLCBoZWFkID0gX2EuaGVhZDtcbiAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbEluZGV4ID0gbWFwLmdldENlbGxJbmRleChhbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdUciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVPdXRPZlRhYmxlKGRpcmVjdGlvbiwgbWFwLCBjZWxsSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbiBlbXB0eSBsaW5lKCdwYXJhZ3JhcGgnKSBpcyBjcmVhdGVkIGJ5IHByZXNzaW5nIHRoZSBhcnJvdyBrZXlzLlxuICAgICAgICAgICAgICAgICAgICBuZXdUciA9IGFkZFBhcmFncmFwaEFmdGVyVGFibGUodHIsIG1hcCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RyID0gbW92ZVRvQ2VsbChkaXJlY3Rpb24sIHRyLCBjZWxsSW5kZXgsIG1hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdUcikge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChuZXdUcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5tb3ZlSW5DZWxsID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50ciwgZG9jID0gc3RhdGUuZG9jLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb207XG4gICAgICAgICAgICB2YXIgdmlldyA9IF90aGlzLmNvbnRleHQudmlldztcbiAgICAgICAgICAgIGlmICghdmlldy5lbmRPZlRleHRibG9jayhkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNlbGwgPSBmaW5kTm9kZUJ5KCRmcm9tLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZENlbGwnIHx8IHR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keUNlbGwnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhID0gZmluZE5vZGVCeSgkZnJvbSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxEZXB0aCA9IGNlbGwuZGVwdGg7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmEgJiYgY2FuTW92ZUJldHdlZW5DZWxscyhkaXJlY3Rpb24sIFtjZWxsRGVwdGgsIHBhcmEuZGVwdGhdLCAkZnJvbSwgZG9jKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKS5hbmNob3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxJbmRleCA9IG1hcC5nZXRDZWxsSW5kZXgoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1RyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuU2VsZWN0VGFibGVOb2RlKGRpcmVjdGlvbiwgbWFwLCBjZWxsSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBjdXJzb3IgcG9zaXRpb24gaXMgYXQgdGhlIGVuZCBvZiB0aGUgY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0YWJsZSBpcyBzZWxlY3RlZCB3aGVuIHRoZSBsZWZ0IC8gcmlnaHQgYXJyb3cga2V5cyBhcmUgcHJlc3NlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyID0gc2VsZWN0Tm9kZSh0ciwgJGZyb20sIGNlbGxEZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FuQmVPdXRPZlRhYmxlKGRpcmVjdGlvbiwgbWFwLCBjZWxsSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGNvbnRlbnQgYmVmb3JlIG9yIGFmdGVyIHRoZSB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIGVtcHR5IGxpbmUoJ3BhcmFncmFwaCcpIGlzIGNyZWF0ZWQgYnkgcHJlc3NpbmcgdGhlIGFycm93IGtleXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIgLyogVVAgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUciA9IGFkZFBhcmFncmFwaEJlZm9yZVRhYmxlKHRyLCBtYXAsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwiZG93blwiIC8qIERPV04gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUciA9IGFkZFBhcmFncmFwaEFmdGVyVGFibGUodHIsIG1hcCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyID0gbW92ZVRvQ2VsbChkaXJlY3Rpb24sIHRyLCBjZWxsSW5kZXgsIG1hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChuZXdUcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5kZWxldGVDZWxscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICB2YXIgdGV4dFNlbGVjdGlvbiA9IHNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQgJiYgIXRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gbWFwLmdldFJlY3RPZmZzZXRzKGFuY2hvciwgaGVhZCksIHN0YXJ0Um93SWR4ID0gX2Iuc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Iuc3RhcnRDb2xJZHgsIGVuZFJvd0lkeCA9IF9iLmVuZFJvd0lkeCwgZW5kQ29sSWR4ID0gX2IuZW5kQ29sSWR4O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0lkeCA9IHN0YXJ0Um93SWR4OyByb3dJZHggPD0gZW5kUm93SWR4OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2xJZHggPSBzdGFydENvbElkeDsgY29sSWR4IDw9IGVuZENvbElkeDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWFwLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgJiYgIW1hcC5leHRlbmRlZENvbHNwYW4ocm93SWR4LCBjb2xJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gbWFwLmdldE5vZGVBbmRQb3Mocm93SWR4LCBjb2xJZHgpLCBub2RlID0gX2Mubm9kZSwgcG9zID0gX2MucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IGNyZWF0ZUR1bW15Q2VsbHMoMSwgcm93SWR4LCBzY2hlbWEsIG5vZGUuYXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHRyLm1hcHBpbmcubWFwKHBvcyksIHRyLm1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUpLCBjZWxscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmV4aXRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHIsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgICAgIHZhciBjZWxsID0gZmluZE5vZGVCeSgkZnJvbSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICd0YWJsZUhlYWRDZWxsJyB8fCB0eXBlLm5hbWUgPT09ICd0YWJsZUJvZHlDZWxsJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYSA9IGZpbmROb2RlQnkoJGZyb20sIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLmFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChhZGRQYXJhZ3JhcGhBZnRlclRhYmxlKHRyLCBtYXAsIHNjaGVtYSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRUYWJsZTogdGhpcy5hZGRUYWJsZSgpLFxuICAgICAgICAgICAgcmVtb3ZlVGFibGU6IHRoaXMucmVtb3ZlVGFibGUoKSxcbiAgICAgICAgICAgIGFkZENvbHVtblRvTGVmdDogdGhpcy5hZGRDb2x1bW4oXCJsZWZ0XCIgLyogTEVGVCAqLyksXG4gICAgICAgICAgICBhZGRDb2x1bW5Ub1JpZ2h0OiB0aGlzLmFkZENvbHVtbihcInJpZ2h0XCIgLyogUklHSFQgKi8pLFxuICAgICAgICAgICAgcmVtb3ZlQ29sdW1uOiB0aGlzLnJlbW92ZUNvbHVtbigpLFxuICAgICAgICAgICAgYWRkUm93VG9VcDogdGhpcy5hZGRSb3coXCJ1cFwiIC8qIFVQICovKSxcbiAgICAgICAgICAgIGFkZFJvd1RvRG93bjogdGhpcy5hZGRSb3coXCJkb3duXCIgLyogRE9XTiAqLyksXG4gICAgICAgICAgICByZW1vdmVSb3c6IHRoaXMucmVtb3ZlUm93KCksXG4gICAgICAgICAgICBhbGlnbkNvbHVtbjogdGhpcy5hbGlnbkNvbHVtbigpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWxldGVDZWxsQ29udGVudCA9IHRoaXMuZGVsZXRlQ2VsbHMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFRhYjogdGhpcy5tb3ZlVG9DZWxsKFwicmlnaHRcIiAvKiBSSUdIVCAqLyksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogdGhpcy5tb3ZlVG9DZWxsKFwibGVmdFwiIC8qIExFRlQgKi8pLFxuICAgICAgICAgICAgQXJyb3dVcDogdGhpcy5tb3ZlSW5DZWxsKFwidXBcIiAvKiBVUCAqLyksXG4gICAgICAgICAgICBBcnJvd0Rvd246IHRoaXMubW92ZUluQ2VsbChcImRvd25cIiAvKiBET1dOICovKSxcbiAgICAgICAgICAgIEFycm93TGVmdDogdGhpcy5tb3ZlSW5DZWxsKFwibGVmdFwiIC8qIExFRlQgKi8pLFxuICAgICAgICAgICAgQXJyb3dSaWdodDogdGhpcy5tb3ZlSW5DZWxsKFwicmlnaHRcIiAvKiBSSUdIVCAqLyksXG4gICAgICAgICAgICBCYWNrc3BhY2U6IGRlbGV0ZUNlbGxDb250ZW50LFxuICAgICAgICAgICAgJ01vZC1CYWNrc3BhY2UnOiBkZWxldGVDZWxsQ29udGVudCxcbiAgICAgICAgICAgIERlbGV0ZTogZGVsZXRlQ2VsbENvbnRlbnQsXG4gICAgICAgICAgICAnTW9kLURlbGV0ZSc6IGRlbGV0ZUNlbGxDb250ZW50LFxuICAgICAgICAgICAgJ01vZC1FbnRlcic6IHRoaXMuZXhpdFRhYmxlKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGU7XG59KE5vZGUkMikpO1xuXG52YXIgVGFibGVIZWFkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlSGVhZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUhlYWQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlSGVhZC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZUhlYWQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlSGVhZC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0YWJsZVJvd3sxfScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtjcmVhdGVET01JbmZvUGFyc2VkUmF3SFRNTCgndGhlYWQnKV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndGhlYWQnLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYmxlSGVhZDtcbn0oTm9kZSQyKSk7XG5cbnZhciBUYWJsZUJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGVCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVCb2R5LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RhYmxlQm9keSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVCb2R5LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RhYmxlUm93KycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAndGJvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKCd0cicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gcm93c1swXS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndGJvZHknLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYmxlQm9keTtcbn0oTm9kZSQyKSk7XG5cbnZhciBUYWJsZVJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZVJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZVJvdygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVSb3cucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGVSb3cnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlUm93LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJyh0YWJsZUhlYWRDZWxsIHwgdGFibGVCb2R5Q2VsbCkqJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICd0cicsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gZG9tLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7fSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd0cicsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFibGVSb3c7XG59KE5vZGUkMikpO1xuXG52YXIgVGFibGVIZWFkQ2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZUhlYWRDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlSGVhZENlbGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlSGVhZENlbGwucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGVIZWFkQ2VsbCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVIZWFkQ2VsbC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdwYXJhZ3JhcGgrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IGFsaWduOiB7IGRlZmF1bHQ6IG51bGwgfSwgY2xhc3NOYW1lOiB7IGRlZmF1bHQ6IG51bGwgfSwgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0sIGNvbHNwYW46IHsgZGVmYXVsdDogbnVsbCB9LCBleHRlbmRlZDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGlzb2xhdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW2NyZWF0ZVBhcnNlZENlbGxET00oJ3RoJyldLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsQXR0cnMgPSBjcmVhdGVDZWxsQXR0cnMoYXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd0aCcsIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgY2VsbEF0dHJzKSwgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFibGVIZWFkQ2VsbDtcbn0oTm9kZSQyKSk7XG5cbnZhciBUYWJsZUJvZHlDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlQm9keUNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVCb2R5Q2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVCb2R5Q2VsbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZUJvZHlDZWxsJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUJvZHlDZWxsLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJyhwYXJhZ3JhcGggfCBidWxsZXRMaXN0IHwgb3JkZXJlZExpc3QpKycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ246IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgY29sc3BhbjogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIHJvd3NwYW46IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZDogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc29sYXRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtjcmVhdGVQYXJzZWRDZWxsRE9NKCd0ZCcpXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbEF0dHJzID0gY3JlYXRlQ2VsbEF0dHJzKGF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndGQnLCBjZWxsQXR0cnMsIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYmxlQm9keUNlbGw7XG59KE5vZGUkMikpO1xuXG52YXIgSW1hZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSW1hZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW1hZ2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEltYWdlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2ltYWdlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbWFnZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IGltYWdlVXJsOiB7IGRlZmF1bHQ6ICcnIH0sIGFsdFRleHQ6IHsgZGVmYXVsdDogbnVsbCB9LCByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2ltZ1tzcmNdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZERPTSA9IHNhbml0aXplSFRNTChkb20sIHsgUkVUVVJOX0RPTV9GUkFHTUVOVDogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VVcmwgPSBzYW5pdGl6ZWRET00uZ2V0QXR0cmlidXRlKCdzcmMnKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IHNhbml0aXplZERPTS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWx0VGV4dCA9IHNhbml0aXplZERPTS5nZXRBdHRyaWJ1dGUoJ2FsdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgaW1hZ2VVcmw6IGltYWdlVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRUZXh0OiBhbHRUZXh0IH0sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnJhd0hUTUwgfHwgJ2ltZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoeyBzcmM6IGVzY2FwZVhtbCQxKGF0dHJzLmltYWdlVXJsKSB9LCAoYXR0cnMuYWx0VGV4dCAmJiB7IGFsdDogYXR0cnMuYWx0VGV4dCB9KSksIGdldEN1c3RvbUF0dHJzKGF0dHJzKSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBJbWFnZS5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IF9hLnNjaGVtYSwgdHIgPSBfYS50cjtcbiAgICAgICAgICAgIHZhciBfYiA9IHBheWxvYWQsIGltYWdlVXJsID0gX2IuaW1hZ2VVcmwsIGFsdFRleHQgPSBfYi5hbHRUZXh0O1xuICAgICAgICAgICAgaWYgKCFpbWFnZVVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gc2NoZW1hLm5vZGVzLmltYWdlLmNyZWF0ZUFuZEZpbGwoX19hc3NpZ24kMSh7IGltYWdlVXJsOiBpbWFnZVVybCB9LCAoYWx0VGV4dCAmJiB7IGFsdFRleHQ6IGFsdFRleHQgfSkpKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKG5vZGUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBJbWFnZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRJbWFnZTogdGhpcy5hZGRJbWFnZSgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEltYWdlO1xufShOb2RlJDIpKTtcblxudmFyIFJPT1RfQkxPQ0tfREVQVEggPSAxO1xudmFyIFRoZW1hdGljQnJlYWsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGhlbWF0aWNCcmVhaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaGVtYXRpY0JyZWFrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaGVtYXRpY0JyZWFrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoZW1hdGljQnJlYWsnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRoZW1hdGljQnJlYWsucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW3sgdGFnOiAnaHInIH1dLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgW2F0dHJzLnJhd0hUTUwgfHwgJ2hyJ11dO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGhlbWF0aWNCcmVhay5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBzdGF0ZS5zZWxlY3Rpb24sICRmcm9tID0gX2IuJGZyb20sICR0byA9IF9iLiR0bztcbiAgICAgICAgICAgIGlmICgkZnJvbSA9PT0gJHRvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IHN0YXRlLmRvYztcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBzdGF0ZS5zY2hlbWEubm9kZXMsIHRoZW1hdGljQnJlYWsgPSBfYy50aGVtYXRpY0JyZWFrLCBwYXJhZ3JhcGggPSBfYy5wYXJhZ3JhcGg7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gW3RoZW1hdGljQnJlYWsuY3JlYXRlKCldO1xuICAgICAgICAgICAgICAgIHZhciByb290QmxvY2sgPSAkZnJvbS5ub2RlKFJPT1RfQkxPQ0tfREVQVEgpO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0QmxvY2sgPSBkb2MuY2hpbGQoZG9jLmNoaWxkQ291bnQgLSAxKSA9PT0gcm9vdEJsb2NrO1xuICAgICAgICAgICAgICAgIHZhciBibG9ja0VuZCA9IGRvYy5yZXNvbHZlKCRmcm9tLmFmdGVyKFJPT1RfQkxPQ0tfREVQVEgpKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEhyID0gKChfYSA9ICRmcm9tLm5vZGVBZnRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUubmFtZSkgPT09IF90aGlzLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RCbG9jayB8fCBuZXh0SHIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChwYXJhZ3JhcGguY3JlYXRlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnQoYmxvY2tFbmQucG9zLCBub2Rlcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBUaGVtYXRpY0JyZWFrLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgaHI6IHRoaXMuaHIoKSB9O1xuICAgIH07XG4gICAgVGhlbWF0aWNCcmVhay5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhyQ29tbWFuZCA9IHRoaXMuaHIoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1sJzogaHJDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1MJzogaHJDb21tYW5kLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRoZW1hdGljQnJlYWs7XG59KE5vZGUkMikpO1xuXG52YXIgU3Ryb25nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFN0cm9uZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJvbmcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cm9uZy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdzdHJvbmcnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cm9uZy5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VET00gPSBbJ2InLCAnc3Ryb25nJ10ubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogcGFyc2VET00sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdHRycy5yYXdIVE1MIHx8ICdzdHJvbmcnLCBnZXRDdXN0b21BdHRycyhhdHRycyldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3Ryb25nLnByb3RvdHlwZS5ib2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gdG9nZ2xlTWFyayQxKHN0YXRlLnNjaGVtYS5tYXJrcy5zdHJvbmcpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBTdHJvbmcucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBib2xkOiB0aGlzLmJvbGQoKSB9O1xuICAgIH07XG4gICAgU3Ryb25nLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9sZENvbW1hbmQgPSB0aGlzLmJvbGQoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1iJzogYm9sZENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLUInOiBib2xkQ29tbWFuZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJvbmc7XG59KE1hcmspKTtcblxudmFyIEVtcGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoRW1waCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXBoKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbXBoLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2VtcGgnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtcGgucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlRE9NID0gWydpJywgJ2VtJ10ubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogcGFyc2VET00sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdHRycy5yYXdIVE1MIHx8ICdlbScsIGdldEN1c3RvbUF0dHJzKGF0dHJzKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFbXBoLnByb3RvdHlwZS5pdGFsaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiB0b2dnbGVNYXJrJDEoc3RhdGUuc2NoZW1hLm1hcmtzLmVtcGgpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBFbXBoLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgaXRhbGljOiB0aGlzLml0YWxpYygpIH07XG4gICAgfTtcbiAgICBFbXBoLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRhbGljQ29tbWFuZCA9IHRoaXMuaXRhbGljKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtaSc6IGl0YWxpY0NvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLUknOiBpdGFsaWNDb21tYW5kLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEVtcGg7XG59KE1hcmspKTtcblxudmFyIFN0cmlrZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShTdHJpa2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RyaWtlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpa2UucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3RyaWtlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpa2UucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlRE9NID0gWydzJywgJ2RlbCddLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IHBhcnNlRE9NLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXR0cnMucmF3SFRNTCB8fCAnZGVsJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0cmlrZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiB0b2dnbGVNYXJrJDEoc3RhdGUuc2NoZW1hLm1hcmtzLnN0cmlrZSkoc3RhdGUsIGRpc3BhdGNoKTsgfTsgfTtcbiAgICB9O1xuICAgIFN0cmlrZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0cmlrZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2Qtcyc6IHN0cmlrZUNvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLVMnOiBzdHJpa2VDb21tYW5kLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmlrZTtcbn0oTWFyaykpO1xuXG52YXIgTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmsobGlua0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGlua0F0dHJpYnV0ZXMgPSBsaW5rQXR0cmlidXRlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGluay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgbGlua1VybDogeyBkZWZhdWx0OiAnJyB9LCB0aXRsZTogeyBkZWZhdWx0OiBudWxsIH0sIHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2FbaHJlZl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkRE9NID0gc2FuaXRpemVIVE1MKGRvbSwgeyBSRVRVUk5fRE9NX0ZSQUdNRU5UOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBocmVmID0gc2FuaXRpemVkRE9NLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IHNhbml0aXplZERPTS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBzYW5pdGl6ZWRET00uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyBsaW5rVXJsOiBocmVmLCB0aXRsZTogdGl0bGUgfSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMucmF3SFRNTCB8fCAnYScsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoeyBocmVmOiBlc2NhcGVYbWwkMShhdHRycy5saW5rVXJsKSB9LCBfdGhpcy5saW5rQXR0cmlidXRlcyksIGdldEN1c3RvbUF0dHJzKGF0dHJzKSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMaW5rLnByb3RvdHlwZS5hZGRMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHBheWxvYWQsIGxpbmtVcmwgPSBfYS5saW5rVXJsLCBfYiA9IF9hLmxpbmtUZXh0LCBsaW5rVGV4dCA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgdHIgPSBzdGF0ZS50ciwgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgdmFyIGVtcHR5ID0gc2VsZWN0aW9uLmVtcHR5LCBmcm9tID0gc2VsZWN0aW9uLmZyb20sIHRvID0gc2VsZWN0aW9uLnRvO1xuICAgICAgICAgICAgaWYgKGZyb20gJiYgdG8gJiYgbGlua1VybCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IHsgbGlua1VybDogbGlua1VybCB9O1xuICAgICAgICAgICAgICAgIHZhciBtYXJrID0gc2NoZW1hLm1hcmsoJ2xpbmsnLCBhdHRycyk7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5ICYmIGxpbmtUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIGxpbmtUZXh0LCBtYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS50b2dnbGVMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2dnbGVNYXJrJDEoc3RhdGUuc2NoZW1hLm1hcmtzLmxpbmssIHBheWxvYWQpKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZExpbms6IHRoaXMuYWRkTGluaygpLFxuICAgICAgICAgICAgdG9nZ2xlTGluazogdGhpcy50b2dnbGVMaW5rKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTGluaztcbn0oTWFyaykpO1xuXG52YXIgQ29kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29kZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2NvZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7fSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2F0dHJzLnJhd0hUTUwgfHwgJ2NvZGUnLCBnZXRDdXN0b21BdHRycyhhdHRycyldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29kZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiB0b2dnbGVNYXJrJDEoc3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBDb2RlLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29kZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdTaGlmdC1Nb2QtYyc6IGNvZGVDb21tYW5kLFxuICAgICAgICAgICAgJ1NoaWZ0LU1vZC1DJzogY29kZUNvbW1hbmQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZTtcbn0oTWFyaykpO1xuXG52YXIgQ3VzdG9tQmxvY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ3VzdG9tQmxvY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUJsb2NrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2N1c3RvbUJsb2NrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21CbG9jay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0ZXh0KicsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhdG9tOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVmaW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnZGl2W2RhdGEtY3VzdG9tLWluZm9dJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLWN1c3RvbS1pbmZvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5mbzogaW5mbyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHsgJ2RhdGEtY3VzdG9tLWluZm8nOiBhdHRycy5pbmZvIHx8IG51bGwgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDdXN0b21CbG9jay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIChwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQuaW5mbylcbiAgICAgICAgICAgICAgICA/IHNldEJsb2NrVHlwZShzdGF0ZS5zY2hlbWEubm9kZXMuY3VzdG9tQmxvY2ssIHBheWxvYWQpKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbUJsb2NrO1xufShOb2RlJDIpKTtcblxudmFyIEZyb250TWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEZyb250TWF0dGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb250TWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcm9udE1hdHRlci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdmcm9udE1hdHRlcic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJvbnRNYXR0ZXIucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGV4dConLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGNvZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVmaW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdkaXZbZGF0YS1mcm9udC1tYXR0ZXJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHsgJ2RhdGEtZnJvbnQtbWF0dGVyJzogJ3RydWUnIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRnJvbnRNYXR0ZXIucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICAgICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soJ2Rvd24nKSAmJiAkZnJvbS5ub2RlKCkudHlwZS5uYW1lID09PSAnZnJvbnRNYXR0ZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXRDb2RlKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBGcm9udE1hdHRlci5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmNvbW1hbmRzKCkoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9udE1hdHRlcjtcbn0oTm9kZSQyKSk7XG5cbnZhciBIVE1MQ29tbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShIVE1MQ29tbWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIVE1MQ29tbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTENvbW1lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaHRtbENvbW1lbnQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxDb21tZW50LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RleHQqJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBjb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlZmluaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbeyBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJywgdGFnOiAnZGl2W2RhdGEtaHRtbC1jb21tZW50XScgfV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgeyAnZGF0YS1odG1sLWNvbW1lbnQnOiAndHJ1ZScgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBIVE1MQ29tbWVudC5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgICAgICBpZiAodmlldy5lbmRPZlRleHRibG9jaygnZG93bicpICYmICRmcm9tLm5vZGUoKS50eXBlLm5hbWUgPT09ICdodG1sQ29tbWVudCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpdENvZGUoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIEhUTUxDb21tZW50LnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRW50ZXI6IHRoaXMuY29tbWFuZHMoKSgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEhUTUxDb21tZW50O1xufShOb2RlJDIpKTtcblxuZnVuY3Rpb24gY3JlYXRlU3BlY3MobGlua0F0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFNwZWNNYW5hZ2VyKFtcbiAgICAgICAgbmV3IERvYygpLFxuICAgICAgICBuZXcgUGFyYWdyYXBoKCksXG4gICAgICAgIG5ldyBUZXh0KCksXG4gICAgICAgIG5ldyBIZWFkaW5nKCksXG4gICAgICAgIG5ldyBDb2RlQmxvY2soKSxcbiAgICAgICAgbmV3IEJ1bGxldExpc3QoKSxcbiAgICAgICAgbmV3IE9yZGVyZWRMaXN0KCksXG4gICAgICAgIG5ldyBMaXN0SXRlbSgpLFxuICAgICAgICBuZXcgQmxvY2tRdW90ZSgpLFxuICAgICAgICBuZXcgVGFibGUoKSxcbiAgICAgICAgbmV3IFRhYmxlSGVhZCgpLFxuICAgICAgICBuZXcgVGFibGVCb2R5KCksXG4gICAgICAgIG5ldyBUYWJsZVJvdygpLFxuICAgICAgICBuZXcgVGFibGVIZWFkQ2VsbCgpLFxuICAgICAgICBuZXcgVGFibGVCb2R5Q2VsbCgpLFxuICAgICAgICBuZXcgSW1hZ2UoKSxcbiAgICAgICAgbmV3IFRoZW1hdGljQnJlYWsoKSxcbiAgICAgICAgbmV3IFN0cm9uZygpLFxuICAgICAgICBuZXcgRW1waCgpLFxuICAgICAgICBuZXcgU3RyaWtlKCksXG4gICAgICAgIG5ldyBMaW5rKGxpbmtBdHRyaWJ1dGVzKSxcbiAgICAgICAgbmV3IENvZGUoKSxcbiAgICAgICAgbmV3IEN1c3RvbUJsb2NrKCksXG4gICAgICAgIG5ldyBGcm9udE1hdHRlcigpLFxuICAgICAgICBuZXcgV2lkZ2V0KCksXG4gICAgICAgIG5ldyBIVE1MQ29tbWVudCgpLFxuICAgIF0pO1xufVxuXG52YXIgQ09OVEVOVFNfQ0xBU1NfTkFNRSA9IGNscygnY29udGVudHMnKTtcbnZhciBXeXNpd3lnRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFd5c2l3eWdFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3lzaXd5Z0VkaXRvcihldmVudEVtaXR0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZXZlbnRFbWl0dGVyKSB8fCB0aGlzO1xuICAgICAgICB2YXIgdG9ET01BZGFwdG9yID0gb3B0aW9ucy50b0RPTUFkYXB0b3IsIF9hID0gb3B0aW9ucy5odG1sU2NoZW1hTWFwLCBodG1sU2NoZW1hTWFwID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9iID0gb3B0aW9ucy5saW5rQXR0cmlidXRlcywgbGlua0F0dHJpYnV0ZXMgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYiwgX2MgPSBvcHRpb25zLnVzZUNvbW1hbmRTaG9ydGN1dCwgdXNlQ29tbWFuZFNob3J0Y3V0ID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBvcHRpb25zLnd3UGx1Z2lucywgd3dQbHVnaW5zID0gX2QgPT09IHZvaWQgMCA/IFtdIDogX2QsIF9lID0gb3B0aW9ucy53d05vZGVWaWV3cywgd3dOb2RlVmlld3MgPSBfZSA9PT0gdm9pZCAwID8ge30gOiBfZTtcbiAgICAgICAgX3RoaXMuZWRpdG9yVHlwZSA9ICd3eXNpd3lnJztcbiAgICAgICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnd3ctbW9kZScpO1xuICAgICAgICBfdGhpcy50b0RPTUFkYXB0b3IgPSB0b0RPTUFkYXB0b3I7XG4gICAgICAgIF90aGlzLmxpbmtBdHRyaWJ1dGVzID0gbGlua0F0dHJpYnV0ZXM7XG4gICAgICAgIF90aGlzLmV4dHJhUGx1Z2lucyA9IHd3UGx1Z2lucztcbiAgICAgICAgX3RoaXMucGx1Z2luTm9kZVZpZXdzID0gd3dOb2RlVmlld3M7XG4gICAgICAgIF90aGlzLnNwZWNzID0gX3RoaXMuY3JlYXRlU3BlY3MoKTtcbiAgICAgICAgX3RoaXMuc2NoZW1hID0gX3RoaXMuY3JlYXRlU2NoZW1hKGh0bWxTY2hlbWFNYXApO1xuICAgICAgICBfdGhpcy5jb250ZXh0ID0gX3RoaXMuY3JlYXRlQ29udGV4dCgpO1xuICAgICAgICBfdGhpcy5rZXltYXBzID0gX3RoaXMuY3JlYXRlS2V5bWFwcyh1c2VDb21tYW5kU2hvcnRjdXQpO1xuICAgICAgICBfdGhpcy52aWV3ID0gX3RoaXMuY3JlYXRlVmlldygpO1xuICAgICAgICBfdGhpcy5jb21tYW5kcyA9IF90aGlzLmNyZWF0ZUNvbW1hbmRzKCk7XG4gICAgICAgIF90aGlzLnNwZWNzLnNldENvbnRleHQoX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBfdGhpcy5jb250ZXh0KSwgeyB2aWV3OiBfdGhpcy52aWV3IH0pKTtcbiAgICAgICAgX3RoaXMuaW5pdEV2ZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuY3JlYXRlU3BlY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTcGVjcyh0aGlzLmxpbmtBdHRyaWJ1dGVzKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiB0aGlzLmV2ZW50RW1pdHRlcixcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVNjaGVtYSA9IGZ1bmN0aW9uIChodG1sU2NoZW1hTWFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICAgICAgICAgIG5vZGVzOiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHRoaXMuc3BlY3Mubm9kZXMpLCBodG1sU2NoZW1hTWFwLm5vZGVzKSxcbiAgICAgICAgICAgIG1hcmtzOiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHRoaXMuc3BlY3MubWFya3MpLCBodG1sU2NoZW1hTWFwLm1hcmtzKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVQbHVnaW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheSQxKFtcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9uKCksXG4gICAgICAgICAgICB0YWJsZUNvbnRleHRNZW51KHRoaXMuZXZlbnRFbWl0dGVyKSxcbiAgICAgICAgICAgIHRhc2soKSxcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZUhpZ2hsaWdodCh0aGlzLmV2ZW50RW1pdHRlcilcbiAgICAgICAgXSwgdGhpcy5jcmVhdGVQbHVnaW5Qcm9wcygpKS5jb25jYXQodGhpcy5kZWZhdWx0UGx1Z2lucyk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVQbHVnaW5Ob2RlVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlciwgcGx1Z2luTm9kZVZpZXdzID0gX2EucGx1Z2luTm9kZVZpZXdzO1xuICAgICAgICB2YXIgcGx1Z2luTm9kZVZpZXdNYXAgPSB7fTtcbiAgICAgICAgaWYgKHBsdWdpbk5vZGVWaWV3cykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocGx1Z2luTm9kZVZpZXdzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5Ob2RlVmlld01hcFtrZXldID0gZnVuY3Rpb24gKG5vZGUsIHZpZXcsIGdldFBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luTm9kZVZpZXdzW2tleV0obm9kZSwgdmlldywgZ2V0UG9zLCBldmVudEVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGx1Z2luTm9kZVZpZXdNYXA7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB0b0RPTUFkYXB0b3IgPSBfYS50b0RPTUFkYXB0b3IsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JWaWV3KHRoaXMuZWwsIHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmNyZWF0ZVN0YXRlKCksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IENPTlRFTlRTX0NMQVNTX05BTUUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZVZpZXdzOiBfX2Fzc2lnbiQxKHsgY3VzdG9tQmxvY2s6IGZ1bmN0aW9uIChub2RlLCB2aWV3LCBnZXRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja1ZpZXcobm9kZSwgdmlldywgZ2V0UG9zLCB0b0RPTUFkYXB0b3IpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChub2RlLCB2aWV3LCBnZXRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbWFnZVZpZXcobm9kZSwgdmlldywgZ2V0UG9zLCBldmVudEVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29kZUJsb2NrOiBmdW5jdGlvbiAobm9kZSwgdmlldywgZ2V0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29kZUJsb2NrVmlldyhub2RlLCB2aWV3LCBnZXRQb3MsIGV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgICAgICAgfSwgd2lkZ2V0OiB3aWRnZXROb2RlVmlldyB9LCB0aGlzLmNyZWF0ZVBsdWdpbk5vZGVWaWV3cygpKSxcbiAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF90aGlzLnZpZXcuc3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdENoYW5nZUV2ZW50KHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdzZXRGb2N1c2VkTm9kZScsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5ub2RlKDEpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2Zvcm1QYXN0ZWRIVE1MOiBjaGFuZ2VQYXN0ZWRIVE1MLFxuICAgICAgICAgICAgdHJhbnNmb3JtUGFzdGVkOiBmdW5jdGlvbiAoc2xpY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlUGFzdGVkU2xpY2Uoc2xpY2UsIF90aGlzLnNjaGVtYSwgaXNJblRhYmxlTm9kZShfdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZVBhc3RlOiBmdW5jdGlvbiAodmlldywgXywgc2xpY2UpIHsgcmV0dXJuIHBhc3RlVG9UYWJsZSh2aWV3LCBzbGljZSk7IH0sXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgna2V5ZG93bicsIF90aGlzLmVkaXRvclR5cGUsIGV2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgcGFzdGU6IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcGJvYXJkRGF0YSA9IGV2LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGNsaXBib2FyZERhdGEgPT09IG51bGwgfHwgY2xpcGJvYXJkRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xpcGJvYXJkRGF0YS5pdGVtcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpblJ0Zkl0ZW0gPSB0b0FycmF5XzEoaXRlbXMpLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ua2luZCA9PT0gJ3N0cmluZycgJiYgaXRlbS50eXBlID09PSAndGV4dC9ydGYnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGNvbnRhaW5zIHJ0ZiwgaXQncyBtb3N0IGxpa2VseSBjb3B5IHBhc3RlIGZyb20gb2ZmaWNlIC0+IG5vIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5SdGZJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlQmxvYiA9IHBhc3RlSW1hZ2VPbmx5KGl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRJbWFnZUJsb2JIb29rKF90aGlzLmV2ZW50RW1pdHRlciwgaW1hZ2VCbG9iLCBldi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2V5dXA6IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgna2V5dXAnLCBfdGhpcy5lZGl0b3JUeXBlLCBldik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnc2Nyb2xsJywgJ2VkaXRvcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVDb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlY3MuY29tbWFuZHModGhpcy52aWV3LCBnZXRXd0NvbW1hbmRzKCkpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZ2V0SFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKHRoaXMudmlldy5kb20uaW5uZXJIVE1MKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmdldE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYztcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbiwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG87XG4gICAgICAgIHJldHVybiBbZnJvbSwgdG9dO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlLnNjaGVtYTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLnJlcGxhY2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHNjaGVtYSA9IF9hLnNjaGVtYSwgdHIgPSBfYS50cjtcbiAgICAgICAgdmFyIGxpbmVUZXh0cyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgcGFyYXMgPSBsaW5lVGV4dHMubWFwKGZ1bmN0aW9uIChsaW5lVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhcmFncmFwaChzY2hlbWEsIGNyZWF0ZU5vZGVzV2l0aFdpZGdldChsaW5lVGV4dCwgc2NoZW1hKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShwYXJhcyksIDEsIDEpO1xuICAgICAgICB2YXIgbmV3VHIgPSBpc051bWJlcl8xKHN0YXJ0KSAmJiBpc051bWJlcl8xKGVuZClcbiAgICAgICAgICAgID8gdHIucmVwbGFjZVJhbmdlKHN0YXJ0LCBlbmQsIHNsaWNlKVxuICAgICAgICAgICAgOiB0ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZGVsZXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHRyID0gdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICB2YXIgbmV3VHIgPSBpc051bWJlcl8xKHN0YXJ0KSAmJiBpc051bWJlcl8xKGVuZCkgPyB0ci5kZWxldGVSYW5nZShzdGFydCwgZW5kKSA6IHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2gobmV3VHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIGRvYyA9IF9hLmRvYywgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgZnJvbSA9IHNlbGVjdGlvbi5mcm9tLCB0byA9IHNlbGVjdGlvbi50bztcbiAgICAgICAgaWYgKGlzTnVtYmVyXzEoc3RhcnQpICYmIGlzTnVtYmVyXzEoZW5kKSkge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXJ0O1xuICAgICAgICAgICAgdG8gPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bywgJ1xcbicpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuc2V0TW9kZWwgPSBmdW5jdGlvbiAobmV3RG9jLCBjdXJzb3JUb0VuZCkge1xuICAgICAgICBpZiAoY3Vyc29yVG9FbmQgPT09IHZvaWQgMCkgeyBjdXJzb3JUb0VuZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgbmV3RG9jKSk7XG4gICAgICAgIGlmIChjdXJzb3JUb0VuZCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9FbmQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBzdGFydDsgfVxuICAgICAgICB2YXIgdHIgPSB0aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuYWRkV2lkZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIHN0eWxlLCBwb3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LCBkaXNwYXRjaCA9IF9hLmRpc3BhdGNoLCBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRNZXRhKCd3aWRnZXQnLCB7IHBvczogcG9zICE9PSBudWxsICYmIHBvcyAhPT0gdm9pZCAwID8gcG9zIDogc3RhdGUuc2VsZWN0aW9uLnRvLCBub2RlOiBub2RlLCBzdHlsZTogc3R5bGUgfSkpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUucmVwbGFjZVdpdGhXaWRnZXQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgdmFyIG5vZGVzID0gY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KHRleHQsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5yZXBsYWNlV2l0aChzdGFydCwgZW5kLCBub2RlcykpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZ2V0UmFuZ2VJbmZvT2ZOb2RlID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIGRvYyA9IF9hLmRvYywgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgJHBvcyA9IHBvcyA/IGRvYy5yZXNvbHZlKHBvcykgOiBzZWxlY3Rpb24uJGZyb207XG4gICAgICAgIHZhciBtYXJrcyA9ICRwb3MubWFya3MoKTtcbiAgICAgICAgdmFyIG5vZGUgPSAkcG9zLm5vZGUoKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gJHBvcy5zdGFydCgpO1xuICAgICAgICB2YXIgZW5kID0gJHBvcy5lbmQoKTtcbiAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKG1hcmtzLmxlbmd0aCB8fCB0eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgdmFyIG1hcmtfMSA9IG1hcmtzW21hcmtzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIG1heWJlSGFzTWFya18xID0gZnVuY3Rpb24gKG5vZGVNYXJrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlTWFya3MubGVuZ3RoID8gaW5jbHVkZXMobm9kZU1hcmtzLCBtYXJrXzEpIDogdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0eXBlID0gbWFya18xID8gbWFya18xLnR5cGUubmFtZSA6ICd0ZXh0JztcbiAgICAgICAgICAgIG5vZGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHZhciBpc1RleHQgPSBjaGlsZC5pc1RleHQsIG5vZGVTaXplID0gY2hpbGQubm9kZVNpemUsIG5vZGVNYXJrcyA9IGNoaWxkLm1hcmtzO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9ICRwb3MucG9zIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPD0gc3RhcnRPZmZzZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICsgbm9kZVNpemUgPj0gc3RhcnRPZmZzZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVIYXNNYXJrXzEobm9kZU1hcmtzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIG5vZGVTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBbc3RhcnQsIGVuZF0sIHR5cGU6IHR5cGUgfTtcbiAgICB9O1xuICAgIHJldHVybiBXeXNpd3lnRWRpdG9yO1xufShFZGl0b3JCYXNlKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBleGlzdGluZyBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZF8xO1xudmFyIGlzTnVsbCA9IGlzTnVsbF8xO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGV4aXN0aW5nIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBub3QgbnVsbCBhbmQgbm90IHVuZGVmaW5lZCwgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSBwYXJhbSAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBleGlzdHk/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBpc0V4aXN0eSBmcm9tICd0dWktY29kZS1zbmlwcGV0L3R5cGUvaXNFeGlzdHknKTtcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGlzRXhpc3R5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC90eXBlL2lzRXhpc3R5Jyk7XG4gKlxuICogaXNFeGlzdHkoJycpOyAvL3RydWVcbiAqIGlzRXhpc3R5KDApOyAvL3RydWVcbiAqIGlzRXhpc3R5KFtdKTsgLy90cnVlXG4gKiBpc0V4aXN0eSh7fSk7IC8vdHJ1ZVxuICogaXNFeGlzdHkobnVsbCk7IC8vZmFsc2VcbiAqIGlzRXhpc3R5KHVuZGVmaW5lZCk7IC8vZmFsc2VcbiovXG5mdW5jdGlvbiBpc0V4aXN0eSQxKHBhcmFtKSB7XG4gIHJldHVybiAhaXNVbmRlZmluZWQocGFyYW0pICYmICFpc051bGwocGFyYW0pO1xufVxuXG52YXIgaXNFeGlzdHlfMSA9IGlzRXhpc3R5JDE7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB0cnV0aHkgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzRXhpc3R5ID0gaXNFeGlzdHlfMTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB0cnV0aHkgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG5vdCBudWxsIG9yIG5vdCB1bmRlZmluZWQgb3Igbm90IGZhbHNlLCByZXR1cm5zIHRydWUuXG4gKiAoSXQgcmVnYXJkcyAwIGFzIHRydWUpXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyB0cnV0aHk/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNUcnV0aHkkMShvYmopIHtcbiAgcmV0dXJuIGlzRXhpc3R5KG9iaikgJiYgb2JqICE9PSBmYWxzZTtcbn1cblxudmFyIGlzVHJ1dGh5XzEgPSBpc1RydXRoeSQxO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZmFsc3kgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzVHJ1dGh5ID0gaXNUcnV0aHlfMTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBmYWxzeSBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgZmFsc2UsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIGZhbHN5P1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzRmFsc3kob2JqKSB7XG4gIHJldHVybiAhaXNUcnV0aHkob2JqKTtcbn1cblxudmFyIGlzRmFsc3lfMSA9IGlzRmFsc3k7XG5cbnZhciBldmVudFR5cGVMaXN0ID0gW1xuICAgICdhZnRlclByZXZpZXdSZW5kZXInLFxuICAgICd1cGRhdGVQcmV2aWV3JyxcbiAgICAnY2hhbmdlTW9kZScsXG4gICAgJ25lZWRDaGFuZ2VNb2RlJyxcbiAgICAnY29tbWFuZCcsXG4gICAgJ2NoYW5nZVByZXZpZXdTdHlsZScsXG4gICAgJ2NoYW5nZVByZXZpZXdUYWJQcmV2aWV3JyxcbiAgICAnY2hhbmdlUHJldmlld1RhYldyaXRlJyxcbiAgICAnc2Nyb2xsJyxcbiAgICAnY29udGV4dG1lbnUnLFxuICAgICdzaG93JyxcbiAgICAnaGlkZScsXG4gICAgJ2NoYW5nZUxhbmd1YWdlJyxcbiAgICAnY2hhbmdlVG9vbGJhclN0YXRlJyxcbiAgICAndG9nZ2xlU2Nyb2xsU3luYycsXG4gICAgJ21peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUnLFxuICAgICdzZXRGb2N1c2VkTm9kZScsXG4gICAgJ3JlbW92ZVBvcHVwV2lkZ2V0JyxcbiAgICAncXVlcnknLFxuICAgIC8vIHByb3ZpZGUgZXZlbnQgZm9yIHVzZXJcbiAgICAnb3BlblBvcHVwJyxcbiAgICAnY2xvc2VQb3B1cCcsXG4gICAgJ2FkZEltYWdlQmxvYkhvb2snLFxuICAgICdiZWZvcmVQcmV2aWV3UmVuZGVyJyxcbiAgICAnYmVmb3JlQ29udmVydFd5c2l3eWdUb01hcmtkb3duJyxcbiAgICAnbG9hZCcsXG4gICAgJ2xvYWRVSScsXG4gICAgJ2NoYW5nZScsXG4gICAgJ2NhcmV0Q2hhbmdlJyxcbiAgICAnZGVzdHJveScsXG4gICAgJ2ZvY3VzJyxcbiAgICAnYmx1cicsXG4gICAgJ2tleWRvd24nLFxuICAgICdrZXl1cCcsXG5dO1xuLyoqXG4gKiBDbGFzcyBFdmVudEVtaXR0ZXJcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IE1hcCQxKCk7XG4gICAgICAgIHRoaXMuZXZlbnRUeXBlcyA9IGV2ZW50VHlwZUxpc3QucmVkdWNlKGZ1bmN0aW9uICh0eXBlcywgdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgdHlwZXMpLCB7IHR5cGU6IHR5cGUgfSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy5ob2xkID0gZmFsc2U7XG4gICAgICAgIGV2ZW50VHlwZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBfdGhpcy5hZGRFdmVudFR5cGUoZXZlbnRUeXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbiBldmVudCBhbmQgYmluZCBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciB0eXBlSW5mbyA9IHRoaXMuZ2V0VHlwZUluZm8odHlwZSk7XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGVJbmZvLnR5cGUpIHx8IFtdO1xuICAgICAgICBpZiAoIXRoaXMuaGFzRXZlbnRUeXBlKHR5cGVJbmZvLnR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBldmVudCB0eXBlIFwiICsgdHlwZUluZm8udHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVJbmZvLm5hbWVzcGFjZSkge1xuICAgICAgICAgICAgaGFuZGxlci5uYW1lc3BhY2UgPSB0eXBlSW5mby5uYW1lc3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2ZW50cy5zZXQodHlwZUluZm8udHlwZSwgZXZlbnRIYW5kbGVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0IGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lIHRvIGVtaXRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGVJbmZvID0gdGhpcy5nZXRUeXBlSW5mbyh0eXBlKTtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZUluZm8udHlwZSk7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmICghdGhpcy5ob2xkICYmIGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZF8xKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0IGdpdmVuIGV2ZW50IGFuZCByZXR1cm4gcmVzdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lIHRvIGVtaXRcbiAgICAgKiBAcGFyYW0ge2FueX0gc291cmNlIFNvdXJjZSB0byBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdFJlZHVjZSA9IGZ1bmN0aW9uICh0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZSk7XG4gICAgICAgIGlmICghdGhpcy5ob2xkICYmIGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheSQxKFtzb3VyY2VdLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZhbHN5XzEocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBldmVudCB0eXBlIGFuZCBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7e3R5cGU6IHN0cmluZywgbmFtZXNwYWNlOiBzdHJpbmd9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRUeXBlSW5mbyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBzcGxpdGVkID0gdHlwZS5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogc3BsaXRlZFswXSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogc3BsaXRlZFsxXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgZXZlbnQgdHlwZSBleGlzdHMgb3Igbm90XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhhc0V2ZW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWRfMSh0aGlzLmV2ZW50VHlwZXNbdGhpcy5nZXRUeXBlSW5mbyh0eXBlKS50eXBlXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgZXZlbnQgdHlwZSB3aGVuIGdpdmVuIGV2ZW50IG5vdCBleGlzdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0V2ZW50VHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgYWxyZWFkeSBoYXZlIGV2ZW50IHR5cGUgXCIgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50VHlwZXNbdHlwZV0gPSB0eXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGhhbmRsZXIgZnJvbSBnaXZlbiBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRUeXBlSW5mbyhldmVudFR5cGUpLCB0eXBlID0gX2EudHlwZSwgbmFtZXNwYWNlID0gX2EubmFtZXNwYWNlO1xuICAgICAgICBpZiAodHlwZSAmJiBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhIYW5kbGVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgJiYgIW5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0eXBlICYmIG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoXywgZXZ0VHlwZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhUeXBlSW5mbyhldnRUeXBlLCBuYW1lc3BhY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSAmJiBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aFR5cGVJbmZvKHR5cGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudCBoYW5kbGVyIHdpdGggZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aEhhbmRsZXIgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVySW5kZXggPSBldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpID49IDApIHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXJzLnNwbGljZShoYW5kbGVySW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgaGFuZGxlciB3aXRoIGV2ZW50IHR5cGUgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIEV2ZW50IG5hbWVzcGFjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudEhhbmRsZXJXaXRoVHlwZUluZm8gPSBmdW5jdGlvbiAodHlwZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBoYW5kbGVyc1RvU3Vydml2ZSA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNUb1N1cnZpdmUucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMuc2V0KHR5cGUsIGhhbmRsZXJzVG9TdXJ2aXZlKTtcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhvbGRFdmVudEludm9rZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLmhvbGQgPSB0cnVlO1xuICAgICAgICBmbigpO1xuICAgICAgICB0aGlzLmhvbGQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCkpO1xuXG52YXIgQ29tbWFuZE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tbWFuZE1hbmFnZXIoZXZlbnRFbWl0dGVyLCBtZENvbW1hbmRzLCB3d0NvbW1hbmRzLCBnZXRFZGl0b3JUeXBlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLm1kQ29tbWFuZHMgPSBtZENvbW1hbmRzO1xuICAgICAgICB0aGlzLnd3Q29tbWFuZHMgPSB3d0NvbW1hbmRzO1xuICAgICAgICB0aGlzLmdldEVkaXRvclR5cGUgPSBnZXRFZGl0b3JUeXBlO1xuICAgICAgICB0aGlzLmluaXRFdmVudCgpO1xuICAgIH1cbiAgICBDb21tYW5kTWFuYWdlci5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NvbW1hbmQnLCBmdW5jdGlvbiAoY29tbWFuZCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgX3RoaXMuZXhlYyhjb21tYW5kLCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21tYW5kTWFuYWdlci5wcm90b3R5cGUuYWRkQ29tbWFuZCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBjb21tYW5kKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnbWFya2Rvd24nKSB7XG4gICAgICAgICAgICB0aGlzLm1kQ29tbWFuZHNbbmFtZV0gPSBjb21tYW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53d0NvbW1hbmRzW25hbWVdID0gY29tbWFuZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUNvbW1hbmQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ21hcmtkb3duJykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWRDb21tYW5kc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnd3Q29tbWFuZHNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKG5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmdldEVkaXRvclR5cGUoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtYXJrZG93bicpIHtcbiAgICAgICAgICAgIHRoaXMubWRDb21tYW5kc1tuYW1lXShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3dDb21tYW5kc1tuYW1lXShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbW1hbmRNYW5hZ2VyO1xufSgpKTtcblxuZnVuY3Rpb24gZ2V0VGV4dFdpdGhvdXRUcmFpbGluZ05ld2xpbmUodGV4dCkge1xuICAgIHJldHVybiB0ZXh0W3RleHQubGVuZ3RoIC0gMV0gPT09ICdcXG4nID8gdGV4dC5zbGljZSgwLCB0ZXh0Lmxlbmd0aCAtIDEpIDogdGV4dDtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tSFRNTElubGluZU5vZGUoX2EsIG5vZGUpIHtcbiAgICB2YXIgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgIHZhciBodG1sID0gbm9kZS5saXRlcmFsO1xuICAgIHZhciBtYXRjaGVkID0gaHRtbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHZhciBvcGVuVGFnTmFtZSA9IG1hdGNoZWRbMV0sIGNsb3NlVGFnTmFtZSA9IG1hdGNoZWRbM107XG4gICAgICAgIHZhciB0eXBlTmFtZSA9IChvcGVuVGFnTmFtZSB8fCBjbG9zZVRhZ05hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdodG1sSW5saW5lJyAmJiAhIShzY2hlbWEubWFya3NbdHlwZU5hbWVdIHx8IHNjaGVtYS5ub2Rlc1t0eXBlTmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lubGluZU5vZGUoX2EpIHtcbiAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgcmV0dXJuIGluY2x1ZGVzKFsndGV4dCcsICdzdHJvbmcnLCAnZW1waCcsICdzdHJpa2UnLCAnaW1hZ2UnLCAnbGluaycsICdjb2RlJ10sIHR5cGUpO1xufVxuZnVuY3Rpb24gaXNTb2Z0YnJlYWsobWROb2RlKSB7XG4gICAgcmV0dXJuIChtZE5vZGUgPT09IG51bGwgfHwgbWROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZE5vZGUudHlwZSkgPT09ICdzb2Z0YnJlYWsnO1xufVxuZnVuY3Rpb24gaXNMaXN0Tm9kZShfYSkge1xuICAgIHZhciB0eXBlID0gX2EudHlwZSwgbGl0ZXJhbCA9IF9hLmxpdGVyYWw7XG4gICAgdmFyIG1hdGNoZWQgPSB0eXBlID09PSAnaHRtbElubGluZScgJiYgbGl0ZXJhbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHZhciBvcGVuVGFnTmFtZSA9IG1hdGNoZWRbMV0sIGNsb3NlVGFnTmFtZSA9IG1hdGNoZWRbM107XG4gICAgICAgIHZhciB0YWdOYW1lID0gb3BlblRhZ05hbWUgfHwgY2xvc2VUYWdOYW1lO1xuICAgICAgICBpZiAodGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKFsndWwnLCAnb2wnLCAnbGknXSwgdGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbUF0dHJzKF9hKSB7XG4gICAgdmFyIGxpdGVyYWwgPSBfYS5saXRlcmFsO1xuICAgIHZhciB0YXNrID0gL2RhdGEtdGFzay8udGVzdChsaXRlcmFsKTtcbiAgICB2YXIgY2hlY2tlZCA9IC9kYXRhLXRhc2stY2hlY2tlZC8udGVzdChsaXRlcmFsKTtcbiAgICByZXR1cm4geyB0YXNrOiB0YXNrLCBjaGVja2VkOiBjaGVja2VkIH07XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVkQXR0cmlidXRlVmFsdWUocmF3SFRNTCkge1xuICAgIHZhciBhdHRyTmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhdHRyTmFtZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlci5pbm5lckhUTUwgPSBzYW5pdGl6ZUhUTUwocmF3SFRNTCk7XG4gICAgdmFyIGVsID0gd3JhcHBlci5maXJzdENoaWxkO1xuICAgIHJldHVybiBhdHRyTmFtZXMubWFwKGZ1bmN0aW9uIChhdHRyTmFtZSkgeyByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSB8fCAnJzsgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb252ZXJ0b3JzKGNvbnZlcnRvcnMpIHtcbiAgICB2YXIgY29udmVydG9yTWFwID0ge307XG4gICAgT2JqZWN0LmtleXMoY29udmVydG9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0YWdOYW1lcyA9IGtleS5zcGxpdCgnLCAnKTtcbiAgICAgICAgdGFnTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb252ZXJ0b3JNYXBbbmFtZV0gPSBjb252ZXJ0b3JzW2tleV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb252ZXJ0b3JNYXA7XG59XG52YXIgY29udmVydG9ycyA9IHtcbiAgICAnYiwgc3Ryb25nJzogZnVuY3Rpb24gKHN0YXRlLCBfLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICB2YXIgc3Ryb25nID0gc3RhdGUuc2NoZW1hLm1hcmtzLnN0cm9uZztcbiAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhzdHJvbmcuY3JlYXRlKHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKHN0cm9uZyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICdpLCBlbSc6IGZ1bmN0aW9uIChzdGF0ZSwgXywgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIGVtcGggPSBzdGF0ZS5zY2hlbWEubWFya3MuZW1waDtcbiAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhlbXBoLmNyZWF0ZSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhlbXBoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgJ3MsIGRlbCc6IGZ1bmN0aW9uIChzdGF0ZSwgXywgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIHN0cmlrZSA9IHN0YXRlLnNjaGVtYS5tYXJrcy5zdHJpa2U7XG4gICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsoc3RyaWtlLmNyZWF0ZSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhzdHJpa2UpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAoc3RhdGUsIF8sIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RhdGUuc2NoZW1hLm1hcmtzLmNvZGU7XG4gICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsoY29kZS5jcmVhdGUoeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoY29kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGE6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIHRhZyA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgdmFyIGxpbmsgPSBzdGF0ZS5zY2hlbWEubWFya3MubGluaztcbiAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICB2YXIgbGlua1VybCA9IGdldE1hdGNoZWRBdHRyaWJ1dGVWYWx1ZSh0YWcsICdocmVmJylbMF07XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhsaW5rLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbGlua1VybDogbGlua1VybCxcbiAgICAgICAgICAgICAgICByYXdIVE1MOiBvcGVuVGFnTmFtZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhsaW5rKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW1nOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciB0YWcgPSBub2RlLmxpdGVyYWw7XG4gICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0TWF0Y2hlZEF0dHJpYnV0ZVZhbHVlKHRhZywgJ3NyYycsICdhbHQnKSwgaW1hZ2VVcmwgPSBfYVswXSwgYWx0VGV4dCA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIGltYWdlID0gc3RhdGUuc2NoZW1hLm5vZGVzLmltYWdlO1xuICAgICAgICAgICAgc3RhdGUuYWRkTm9kZShpbWFnZSwgX19hc3NpZ24kMSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lLCBpbWFnZVVybDogaW1hZ2VVcmwgfSwgKGFsdFRleHQgJiYgeyBhbHRUZXh0OiBhbHRUZXh0IH0pKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhyOiBmdW5jdGlvbiAoc3RhdGUsIF8sIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHN0YXRlLmFkZE5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRoZW1hdGljQnJlYWssIHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSk7XG4gICAgfSxcbiAgICBicjogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIHZhciBwYXJhZ3JhcGggPSBzdGF0ZS5zY2hlbWEubm9kZXMucGFyYWdyYXBoO1xuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQsIHByZXYgPSBub2RlLnByZXYsIG5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgIGlmICgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnR5cGUpID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgLy8gc2hvdWxkIG9wZW4gYSBwYXJhZ3JhcGggbm9kZSB3aGVuIGxpbmUgdGV4dCBoYXMgb25seSA8YnI+IHRhZ1xuICAgICAgICAgICAgLy8gZXgpIGZpcnN0IGxpbmVcXG5cXG48YnI+XFxuZm91cnRoIGxpbmVcbiAgICAgICAgICAgIGlmIChpc1NvZnRicmVhayhwcmV2KSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzaG91bGQgY2xvc2UgYSBwYXJhZ3JhcGggbm9kZSB3aGVuIGxpbmUgdGV4dCBoYXMgb25seSA8YnI+IHRhZ1xuICAgICAgICAgICAgLy8gZXgpIGZpcnN0IGxpbmVcXG5cXG48YnI+XFxuZm91cnRoIGxpbmVcbiAgICAgICAgICAgIGlmIChpc1NvZnRicmVhayhuZXh0KSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBjbG9zZSBhIHBhcmFncmFwaCBub2RlIGFuZCBvcGVuIGEgcGFyYWdyYXBoIG5vZGUgdG8gc2VwYXJhdGUgYmV0d2VlbiBibG9ja3NcbiAgICAgICAgICAgICAgICAvLyB3aGVuIDxicj4gdGFnIGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHBhcmFncmFwaFxuICAgICAgICAgICAgICAgIC8vIGV4KSBmaXJzdCA8YnI+bGluZVxcbnRoaXJkIGxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQudHlwZSkgPT09ICd0YWJsZUNlbGwnKSB7XG4gICAgICAgICAgICBpZiAocHJldiAmJiAoaXNJbmxpbmVOb2RlKHByZXYpIHx8IGlzQ3VzdG9tSFRNTElubGluZU5vZGUoc3RhdGUsIHByZXYpKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgKGlzSW5saW5lTm9kZShuZXh0KSB8fCBpc0N1c3RvbUhUTUxJbmxpbmVOb2RlKHN0YXRlLCBuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmU6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gbm9kZS5saXRlcmFsO1xuICAgICAgICB2YXIgbGl0ZXJhbCA9IChfYiA9IChfYSA9IGNvbnRhaW5lci5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRleHRDb250ZW50O1xuICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMuY29kZUJsb2NrLCB7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pO1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KGdldFRleHRXaXRob3V0VHJhaWxpbmdOZXdsaW5lKGxpdGVyYWwpKTtcbiAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgfSxcbiAgICAndWwsIG9sJzogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICAvLyBpbiB0aGUgdGFibGUgY2VsbCwgJzx1bD4nLCAnPG9sPicgaXMgcGFyc2VkIGFzICdodG1sSW5saW5lJyBub2RlXG4gICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAndGFibGVDZWxsJykge1xuICAgICAgICAgICAgdmFyIF9hID0gc3RhdGUuc2NoZW1hLm5vZGVzLCBidWxsZXRMaXN0ID0gX2EuYnVsbGV0TGlzdCwgb3JkZXJlZExpc3QgPSBfYS5vcmRlcmVkTGlzdCwgcGFyYWdyYXBoID0gX2EucGFyYWdyYXBoO1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBvcGVuVGFnTmFtZSA9PT0gJ3VsJyA/IGJ1bGxldExpc3QgOiBvcmRlcmVkTGlzdDtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnByZXYgJiYgIWlzTGlzdE5vZGUobm9kZS5wcmV2KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUobGlzdCwgeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5leHQgJiYgIWlzTGlzdE5vZGUobm9kZS5uZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbGk6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBpbiB0aGUgdGFibGUgY2VsbCwgJzxsaT4nIGlzIHBhcnNlZCBhcyAnaHRtbElubGluZScgbm9kZVxuICAgICAgICBpZiAoKChfYSA9IG5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09ICd0YWJsZUNlbGwnKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBzdGF0ZS5zY2hlbWEubm9kZXMsIGxpc3RJdGVtID0gX2IubGlzdEl0ZW0sIHBhcmFncmFwaCA9IF9iLnBhcmFncmFwaDtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IGdldExpc3RJdGVtQXR0cnMobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucHJldiAmJiAhaXNMaXN0Tm9kZShub2RlLnByZXYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShsaXN0SXRlbSwgX19hc3NpZ24kMSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0sIGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmV4dCAmJiAhaXNMaXN0Tm9kZShub2RlLm5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucHJldiAmJiAhaXNMaXN0Tm9kZShub2RlLnByZXYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xudmFyIGh0bWxUb1d3Q29udmVydG9ycyA9IGNyZWF0ZUNvbnZlcnRvcnMoY29udmVydG9ycyk7XG5cbmZ1bmN0aW9uIGlzQlJUYWcobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdodG1sSW5saW5lJyAmJiByZUJSLnRlc3Qobm9kZS5saXRlcmFsKTtcbn1cbmZ1bmN0aW9uIGFkZFJhd0hUTUxBdHRyaWJ1dGVUb0RPTShwYXJlbnQpIHtcbiAgICB0b0FycmF5XzEocGFyZW50LmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChpc0VsZW1Ob2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgdmFyIG9wZW5UYWdOYW1lID0gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcsIG9wZW5UYWdOYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgYWRkUmF3SFRNTEF0dHJpYnV0ZVRvRE9NKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxudmFyIHRvV3dDb252ZXJ0b3JzID0ge1xuICAgIHRleHQ6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KG5vZGUubGl0ZXJhbCB8fCAnJyk7XG4gICAgfSxcbiAgICBwYXJhZ3JhcGg6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIHBhcmFncmFwaCA9IHN0YXRlLnNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGg7XG4gICAgICAgICAgICAvLyBUaGUgYFxcblxcbmAgZW50ZXJlZCBpbiBtYXJrZG93biBzZXBhcmF0ZXMgdGhlIHBhcmFncmFwaC5cbiAgICAgICAgICAgIC8vIFdoZW4gY2hhbmdpbmcgdG8gd3lzaXd5ZywgYSBuZXdsaW5lIGlzIGFkZGVkIGJldHdlZW4gdGhlIHR3byBwYXJhZ3JhcGhzLlxuICAgICAgICAgICAgaWYgKCgoX2IgPSBub2RlLnByZXYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgsIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCwgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhlYWRpbmc6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IG5vZGUsIGxldmVsID0gX2IubGV2ZWwsIGhlYWRpbmdUeXBlID0gX2IuaGVhZGluZ1R5cGU7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMuaGVhZGluZywgX19hc3NpZ24kMSh7IGxldmVsOiBsZXZlbCwgaGVhZGluZ1R5cGU6IGhlYWRpbmdUeXBlIH0sIGN1c3RvbUF0dHJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29kZUJsb2NrOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBjb2RlQmxvY2sgPSBzdGF0ZS5zY2hlbWEubm9kZXMuY29kZUJsb2NrO1xuICAgICAgICB2YXIgX2EgPSBub2RlLCBpbmZvID0gX2EuaW5mbywgbGl0ZXJhbCA9IF9hLmxpdGVyYWw7XG4gICAgICAgIHN0YXRlLm9wZW5Ob2RlKGNvZGVCbG9jaywgX19hc3NpZ24kMSh7IGxhbmd1YWdlOiBpbmZvIH0sIGN1c3RvbUF0dHJzKSk7XG4gICAgICAgIHN0YXRlLmFkZFRleHQoZ2V0VGV4dFdpdGhvdXRUcmFpbGluZ05ld2xpbmUobGl0ZXJhbCB8fCAnJykpO1xuICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICB9LFxuICAgIGxpc3Q6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IHN0YXRlLnNjaGVtYS5ub2RlcywgYnVsbGV0TGlzdCA9IF9iLmJ1bGxldExpc3QsIG9yZGVyZWRMaXN0ID0gX2Iub3JkZXJlZExpc3Q7XG4gICAgICAgICAgICB2YXIgX2MgPSBub2RlLmxpc3REYXRhLCB0eXBlID0gX2MudHlwZSwgc3RhcnQgPSBfYy5zdGFydDtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnYnVsbGV0Jykge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKGJ1bGxldExpc3QsIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKG9yZGVyZWRMaXN0LCBfX2Fzc2lnbiQxKHsgb3JkZXI6IHN0YXJ0IH0sIGN1c3RvbUF0dHJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBsaXN0SXRlbSA9IHN0YXRlLnNjaGVtYS5ub2Rlcy5saXN0SXRlbTtcbiAgICAgICAgdmFyIF9iID0gbm9kZS5saXN0RGF0YSwgdGFzayA9IF9iLnRhc2ssIGNoZWNrZWQgPSBfYi5jaGVja2VkO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCAodGFzayAmJiB7IHRhc2s6IHRhc2sgfSkpLCAoY2hlY2tlZCAmJiB7IGNoZWNrZWQ6IGNoZWNrZWQgfSkpLCBjdXN0b21BdHRycyk7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShsaXN0SXRlbSwgYXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJsb2NrUXVvdGU6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy5ibG9ja1F1b3RlLCBjdXN0b21BdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW1hZ2U6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBpbWFnZSA9IHN0YXRlLnNjaGVtYS5ub2Rlcy5pbWFnZTtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbiwgZmlyc3RDaGlsZCA9IF9iLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChlbnRlcmluZyAmJiBza2lwQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFkZE5vZGUoaW1hZ2UsIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7IGltYWdlVXJsOiBkZXN0aW5hdGlvbiB9LCAoZmlyc3RDaGlsZCAmJiB7IGFsdFRleHQ6IGZpcnN0Q2hpbGQubGl0ZXJhbCB9KSksIGN1c3RvbUF0dHJzKSk7XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF8sIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHN0YXRlLmFkZE5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRoZW1hdGljQnJlYWssIGN1c3RvbUF0dHJzKTtcbiAgICB9LFxuICAgIHN0cm9uZzogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBzdHJvbmcgPSBzdGF0ZS5zY2hlbWEubWFya3Muc3Ryb25nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKHN0cm9uZy5jcmVhdGUoY3VzdG9tQXR0cnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhzdHJvbmcpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbXBoOiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIGVtcGggPSBzdGF0ZS5zY2hlbWEubWFya3MuZW1waDtcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhlbXBoLmNyZWF0ZShjdXN0b21BdHRycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKGVtcGgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIGxpbmsgPSBzdGF0ZS5zY2hlbWEubWFya3MubGluaztcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbiwgdGl0bGUgPSBfYi50aXRsZTtcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBfX2Fzc2lnbiQxKHsgbGlua1VybDogZGVzdGluYXRpb24sIHRpdGxlOiB0aXRsZSB9LCBjdXN0b21BdHRycyk7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhsaW5rLmNyZWF0ZShhdHRycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKGxpbmspO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzb2Z0YnJlYWs6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gbm9kZS5wcmV2LCBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgIWlzQlJUYWcocHJldikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmICFpc0JSVGFnKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnBhcmFncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIEdGTSBzcGVjaWZpY2F0aW9ucyBub2RlXG4gICAgdGFibGU6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy50YWJsZSwgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlSGVhZDogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRhYmxlSGVhZCwgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlQm9keTogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRhYmxlQm9keSwgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlUm93OiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMudGFibGVSb3csIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0YWJsZUNlbGw6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmICghbm9kZS5pZ25vcmVkKSB7XG4gICAgICAgICAgICB2YXIgaGFzUGFyYU5vZGUgPSBmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZSAmJiAoaXNJbmxpbmVOb2RlKGNoaWxkTm9kZSkgfHwgaXNDdXN0b21IVE1MSW5saW5lTm9kZShzdGF0ZSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gc3RhdGUuc2NoZW1hLm5vZGVzLCB0YWJsZUhlYWRDZWxsID0gX2IudGFibGVIZWFkQ2VsbCwgdGFibGVCb2R5Q2VsbCA9IF9iLnRhYmxlQm9keUNlbGwsIHBhcmFncmFwaCA9IF9iLnBhcmFncmFwaDtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVQYXJ0ID0gbm9kZS5wYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGFibGVQYXJ0LnR5cGUgPT09ICd0YWJsZUhlYWQnID8gdGFibGVIZWFkQ2VsbCA6IHRhYmxlQm9keUNlbGw7XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gdGFibGVQYXJ0LnBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgYWxpZ24gPSAodGFibGUuY29sdW1uc1tub2RlLnN0YXJ0SWR4XSB8fCB7fSkuYWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX19hc3NpZ24kMSh7fSwgbm9kZS5hdHRycyk7XG4gICAgICAgICAgICAgICAgaWYgKGFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLmFsaWduID0gYWxpZ247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKGNlbGwsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGFyYU5vZGUobm9kZS5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQYXJhTm9kZShub2RlLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzdHJpa2U6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgc3RyaWtlID0gc3RhdGUuc2NoZW1hLm1hcmtzLnN0cmlrZTtcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhzdHJpa2UuY3JlYXRlKGN1c3RvbUF0dHJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoc3RyaWtlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29kZTogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgY29kZSA9IHN0YXRlLnNjaGVtYS5tYXJrcy5jb2RlO1xuICAgICAgICBzdGF0ZS5vcGVuTWFyayhjb2RlLmNyZWF0ZShjdXN0b21BdHRycykpO1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KGdldFRleHRXaXRob3V0VHJhaWxpbmdOZXdsaW5lKG5vZGUubGl0ZXJhbCB8fCAnJykpO1xuICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoY29kZSk7XG4gICAgfSxcbiAgICBjdXN0b21CbG9jazogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIHZhciBfYSA9IHN0YXRlLnNjaGVtYS5ub2RlcywgY3VzdG9tQmxvY2sgPSBfYS5jdXN0b21CbG9jaywgcGFyYWdyYXBoID0gX2EucGFyYWdyYXBoO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCBpbmZvID0gX2IuaW5mbywgbGl0ZXJhbCA9IF9iLmxpdGVyYWw7XG4gICAgICAgIHN0YXRlLm9wZW5Ob2RlKGN1c3RvbUJsb2NrLCB7IGluZm86IGluZm8gfSk7XG4gICAgICAgIHN0YXRlLmFkZFRleHQoZ2V0VGV4dFdpdGhvdXRUcmFpbGluZ05ld2xpbmUobGl0ZXJhbCB8fCAnJykpO1xuICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgLy8gYWRkIGVtcHR5IGxpbmUgdG8gZWRpdCB0aGUgY29udGVudCBpbiBuZXh0IGxpbmVcbiAgICAgICAgaWYgKCFub2RlLm5leHQpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZnJvbnRNYXR0ZXI6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMuZnJvbnRNYXR0ZXIpO1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KG5vZGUubGl0ZXJhbCk7XG4gICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgIH0sXG4gICAgaHRtbElubGluZTogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIHZhciBodG1sID0gbm9kZS5saXRlcmFsO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGh0bWwubWF0Y2gocmVIVE1MVGFnKTtcbiAgICAgICAgdmFyIG9wZW5UYWdOYW1lID0gbWF0Y2hlZFsxXSwgY2xvc2VUYWdOYW1lID0gbWF0Y2hlZFszXTtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gKG9wZW5UYWdOYW1lIHx8IGNsb3NlVGFnTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIG1hcmtUeXBlID0gc3RhdGUuc2NoZW1hLm1hcmtzW3R5cGVOYW1lXTtcbiAgICAgICAgdmFyIHNhbml0aXplZEhUTUwgPSBzYW5pdGl6ZUhUTUwoaHRtbCk7XG4gICAgICAgIC8vIGZvciB1c2VyIGRlZmluZWQgaHRtbCBzY2hlbWFcbiAgICAgICAgaWYgKG1hcmtUeXBlID09PSBudWxsIHx8IG1hcmtUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrVHlwZS5zcGVjLmF0dHJzLmh0bWxJbmxpbmUpIHtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sQXR0cnMgPSBnZXRIVE1MQXR0cnNCeUhUTUxTdHJpbmcoc2FuaXRpemVkSFRNTCk7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsobWFya1R5cGUuY3JlYXRlKHsgaHRtbEF0dHJzOiBodG1sQXR0cnMgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKG1hcmtUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBodG1sVG9Xd0NvbnZlcnRvciA9IGh0bWxUb1d3Q29udmVydG9yc1t0eXBlTmFtZV07XG4gICAgICAgICAgICBpZiAoaHRtbFRvV3dDb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICBodG1sVG9Xd0NvbnZlcnRvcihzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBodG1sQmxvY2s6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICB2YXIgaHRtbCA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgaXNIVE1MQ29tbWVudCA9IHJlSFRNTENvbW1lbnQudGVzdChodG1sKTtcbiAgICAgICAgaWYgKGlzSFRNTENvbW1lbnQpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy5odG1sQ29tbWVudCk7XG4gICAgICAgICAgICBzdGF0ZS5hZGRUZXh0KG5vZGUubGl0ZXJhbCk7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gaHRtbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgICAgICAgICAgdmFyIG9wZW5UYWdOYW1lID0gbWF0Y2hlZFsxXSwgY2xvc2VUYWdOYW1lID0gbWF0Y2hlZFszXTtcbiAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IChvcGVuVGFnTmFtZSB8fCBjbG9zZVRhZ05hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBzdGF0ZS5zY2hlbWEubm9kZXNbdHlwZU5hbWVdO1xuICAgICAgICAgICAgdmFyIHNhbml0aXplZEhUTUwgPSBzYW5pdGl6ZUhUTUwoaHRtbCk7XG4gICAgICAgICAgICAvLyBmb3IgdXNlciBkZWZpbmVkIGh0bWwgc2NoZW1hXG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IG51bGwgfHwgbm9kZVR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVUeXBlLnNwZWMuYXR0cnMuaHRtbEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxBdHRycyA9IGdldEhUTUxBdHRyc0J5SFRNTFN0cmluZyhzYW5pdGl6ZWRIVE1MKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5IVE1MID0gZ2V0Q2hpbGRyZW5IVE1MKG5vZGUsIHR5cGVOYW1lKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hZGROb2RlKG5vZGVUeXBlLCB7IGh0bWxBdHRyczogaHRtbEF0dHJzLCBjaGlsZHJlbkhUTUw6IGNoaWxkcmVuSFRNTCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIVE1MO1xuICAgICAgICAgICAgICAgIGFkZFJhd0hUTUxBdHRyaWJ1dGVUb0RPTShjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmNvbnZlcnRCeURPTVBhcnNlcihjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjdXN0b21JbmxpbmU6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIHNraXBDaGlsZHJlbiA9IF9hLnNraXBDaGlsZHJlbjtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgaW5mbyA9IF9iLmluZm8sIGZpcnN0Q2hpbGQgPSBfYi5maXJzdENoaWxkO1xuICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICBpZiAoaW5mby5pbmRleE9mKCd3aWRnZXQnKSAhPT0gLTEgJiYgZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gZ2V0V2lkZ2V0Q29udGVudChub2RlKTtcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICAgICAgc3RhdGUuYWRkTm9kZShzY2hlbWEubm9kZXMud2lkZ2V0LCB7IGluZm86IGluZm8gfSwgW1xuICAgICAgICAgICAgICAgIHNjaGVtYS50ZXh0KGNyZWF0ZVdpZGdldENvbnRlbnQoaW5mbywgY29udGVudCkpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9ICckJCc7XG4gICAgICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IGZpcnN0Q2hpbGQgPyBpbmZvICsgXCIgXCIgOiBpbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuYWRkVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlV3dDb252ZXJ0b3JzKGN1c3RvbUNvbnZlcnRvcnMpIHtcbiAgICB2YXIgY3VzdG9tQ29udmVydG9yVHlwZXMgPSBPYmplY3Qua2V5cyhjdXN0b21Db252ZXJ0b3JzKTtcbiAgICB2YXIgY29udmVydG9ycyA9IF9fYXNzaWduJDEoe30sIHRvV3dDb252ZXJ0b3JzKTtcbiAgICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgICBnZm06IHRydWUsXG4gICAgICAgIG5vZGVJZDogdHJ1ZSxcbiAgICAgICAgY29udmVydG9yczogY3VzdG9tQ29udmVydG9ycyxcbiAgICB9KTtcbiAgICB2YXIgb3JnQ29udmVydG9ycyA9IHJlbmRlcmVyLmdldENvbnZlcnRvcnMoKTtcbiAgICBjdXN0b21Db252ZXJ0b3JUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciB3d0NvbnZlcnRvciA9IHRvV3dDb252ZXJ0b3JzW3R5cGVdO1xuICAgICAgICBpZiAod3dDb252ZXJ0b3IgJiYgIWluY2x1ZGVzKFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXSwgdHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnZlcnRvcnNbdHlwZV0gPSBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9yaWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yZ0NvbnZlcnRvcnNbdHlwZV0obm9kZSwgY29udGV4dCwgb3JnQ29udmVydG9ycyk7IH07XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGN1c3RvbUNvbnZlcnRvcnNbdHlwZV0obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gQXJyYXkuaXNBcnJheSh0b2tlbnMpID8gdG9rZW5zWzBdIDogdG9rZW5zLCBodG1sQXR0cnMgPSBfYS5hdHRyaWJ1dGVzLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcztcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSB7IGh0bWxBdHRyczogaHRtbEF0dHJzLCBjbGFzc05hbWVzOiBjbGFzc05hbWVzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHd3Q29udmVydG9yKHN0YXRlLCBub2RlLCBjb250ZXh0LCBhdHRycyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnZlcnRvcnM7XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFya1RleHQoYSwgYikge1xuICAgIGlmIChhLmlzVGV4dCAmJiBiLmlzVGV4dCAmJiBNYXJrJDEuc2FtZVNldChhLm1hcmtzLCBiLm1hcmtzKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIHR5cGUgaXMgbm90IGRlZmluZWQgZm9yIFwid2l0aFRleHRcIiBpbiBwcm9zZW1pcnJvci1tb2RlbFxuICAgICAgICByZXR1cm4gYS53aXRoVGV4dChhLnRleHQgKyBiLnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG52YXIgVG9Xd0NvbnZlcnRvclN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvV3dDb252ZXJ0b3JTdGF0ZShzY2hlbWEsIGNvbnZlcnRvcnMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuY29udmVydG9ycyA9IGNvbnZlcnRvcnM7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbeyB0eXBlOiB0aGlzLnNjaGVtYS50b3BOb2RlVHlwZSwgYXR0cnM6IG51bGwsIGNvbnRlbnQ6IFtdIH1dO1xuICAgICAgICB0aGlzLm1hcmtzID0gTWFyayQxLm5vbmU7XG4gICAgfVxuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUudG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGFzdCQxKHRoaXMuc3RhY2spO1xuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRvcCgpLmNvbnRlbnQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5hZGRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMudG9wKCkuY29udGVudDtcbiAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IGxhc3QkMShub2Rlcyk7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc2NoZW1hLnRleHQodGV4dCwgdGhpcy5tYXJrcyk7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkID0gbGFzdE5vZGUgJiYgbWVyZ2VNYXJrVGV4dChsYXN0Tm9kZSwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0gPSBtZXJnZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLm9wZW5NYXJrID0gZnVuY3Rpb24gKG1hcmspIHtcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy5tYXJrcyk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNsb3NlTWFyayA9IGZ1bmN0aW9uIChtYXJrKSB7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5tYXJrcyk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiAodHlwZSwgYXR0cnMsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0eXBlLmNyZWF0ZUFuZEZpbGwoYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLm9wZW5Ob2RlID0gZnVuY3Rpb24gKHR5cGUsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh7IHR5cGU6IHR5cGUsIGF0dHJzOiBhdHRycywgY29udGVudDogW10gfSk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNsb3NlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtzID0gTWFyayQxLm5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGFjay5wb3AoKSwgdHlwZSA9IF9hLnR5cGUsIGF0dHJzID0gX2EuYXR0cnMsIGNvbnRlbnQgPSBfYS5jb250ZW50O1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlKHR5cGUsIGF0dHJzLCBjb250ZW50KTtcbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydEJ5RE9NUGFyc2VyID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRvYyA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHRoaXMuc2NoZW1hKS5wYXJzZShyb290KTtcbiAgICAgICAgZG9jLmNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMucHVzaChub2RlKTsgfSk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNsb3NlVW5tYXRjaGVkSFRNTElubGluZSA9IGZ1bmN0aW9uIChub2RlLCBlbnRlcmluZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZW50ZXJpbmcgJiYgbm9kZS50eXBlICE9PSAnaHRtbElubGluZScpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZW5ndGhfMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUluZm8gPSB0aGlzLnN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmICgoX2EgPSBub2RlSW5mby5hdHRycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJhd0hUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVJbmZvLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBwb3AgdXNlbGVzcyB1bm1hdGNoZWQgaHRtbCBpbmxpbmUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAobWROb2RlLCBpbmZvRm9yUG9zU3luYykge1xuICAgICAgICB2YXIgd2Fsa2VyID0gbWROb2RlLndhbGtlcigpO1xuICAgICAgICB2YXIgZXZlbnQgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzXzEuY29udmVydG9yc1tub2RlLnR5cGVdO1xuICAgICAgICAgICAgdmFyIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZW50ZXJpbmc6IGVudGVyaW5nLFxuICAgICAgICAgICAgICAgICAgICBsZWFmOiAhaXNDb250YWluZXIkMihub2RlKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW5UZXh0OiBnZXRDaGlsZHJlblRleHQkMSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogeyBnZm06IHRydWUsIG5vZGVJZDogZmFsc2UsIHRhZ0ZpbHRlcjogZmFsc2UsIHNvZnRicmVhazogJ1xcbicgfSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXNfMS5jbG9zZVVubWF0Y2hlZEhUTUxJbmxpbmUobm9kZSwgZW50ZXJpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnZlcnRvcih0aGlzXzEsIG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICgoaW5mb0ZvclBvc1N5bmMgPT09IG51bGwgfHwgaW5mb0ZvclBvc1N5bmMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm9Gb3JQb3NTeW5jLm5vZGUpID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzXzEuc3RhY2sucmVkdWNlKGZ1bmN0aW9uIChub2RlU2l6ZSwgc3RhY2tJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVNpemUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrSXRlbS5jb250ZW50LnJlZHVjZShmdW5jdGlvbiAoY29udGVudFNpemUsIHBtTm9kZSkgeyByZXR1cm4gY29udGVudFNpemUgKyBwbU5vZGUubm9kZVNpemU7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGluZm9Gb3JQb3NTeW5jLnNldE1hcHBlZFBvcyhwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLnJlc3VtZUF0KG5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGV2ZW50KSB7XG4gICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydE5vZGUgPSBmdW5jdGlvbiAobWROb2RlLCBpbmZvRm9yUG9zU3luYykge1xuICAgICAgICB0aGlzLmNvbnZlcnQobWROb2RlLCBpbmZvRm9yUG9zU3luYyk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVG9Xd0NvbnZlcnRvclN0YXRlO1xufSgpKTtcblxuZnVuY3Rpb24gY29udmVydFRvUmF3SFRNTEhhdmluZ0lubGluZXMoc3RhdGUsIG5vZGUsIF9hKSB7XG4gICAgdmFyIG9wZW5UYWcgPSBfYVswXSwgY2xvc2VUYWcgPSBfYVsxXTtcbiAgICBzdGF0ZS53cml0ZShvcGVuVGFnKTtcbiAgICBzdGF0ZS5jb252ZXJ0SW5saW5lKG5vZGUpO1xuICAgIHN0YXRlLndyaXRlKGNsb3NlVGFnKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1Jhd0hUTUxIYXZpbmdCbG9ja3Moc3RhdGUsIF9hLCBfYikge1xuICAgIHZhciBub2RlID0gX2Eubm9kZSwgcGFyZW50ID0gX2EucGFyZW50O1xuICAgIHZhciBvcGVuVGFnID0gX2JbMF0sIGNsb3NlVGFnID0gX2JbMV07XG4gICAgc3RhdGUuc3RvcE5ld2xpbmUgPSB0cnVlO1xuICAgIHN0YXRlLndyaXRlKG9wZW5UYWcpO1xuICAgIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpO1xuICAgIHN0YXRlLndyaXRlKGNsb3NlVGFnKTtcbiAgICBpZiAoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC50eXBlLm5hbWUpID09PSAnZG9jJykge1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgICAgICBzdGF0ZS5zdG9wTmV3bGluZSA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlSGVhZERlbGltKHRleHRDb250ZW50LCBjb2x1bW5BbGlnbikge1xuICAgIHZhciB0ZXh0TGVuID0gdGV4dENvbnRlbnQubGVuZ3RoO1xuICAgIHZhciBsZWZ0RGVsaW0gPSAnJztcbiAgICB2YXIgcmlnaHREZWxpbSA9ICcnO1xuICAgIGlmIChjb2x1bW5BbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGxlZnREZWxpbSA9ICc6JztcbiAgICAgICAgdGV4dExlbiAtPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2x1bW5BbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICByaWdodERlbGltID0gJzonO1xuICAgICAgICB0ZXh0TGVuIC09IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbHVtbkFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICBsZWZ0RGVsaW0gPSAnOic7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSAnOic7XG4gICAgICAgIHRleHRMZW4gLT0gMjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIgKyBsZWZ0RGVsaW0gKyByZXBlYXQkMSgnLScsIE1hdGgubWF4KHRleHRMZW4sIDMpKSArIHJpZ2h0RGVsaW07XG59XG52YXIgbm9kZVR5cGVXcml0ZXJzID0ge1xuICAgIHRleHQ6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciB0ZXh0ID0gKF9iID0gbm9kZS50ZXh0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgaWYgKChub2RlLm1hcmtzIHx8IFtdKS5zb21lKGZ1bmN0aW9uIChtYXJrKSB7IHJldHVybiBtYXJrLnR5cGUubmFtZSA9PT0gJ2xpbmsnOyB9KSkge1xuICAgICAgICAgICAgc3RhdGUudGV4dChlc2NhcGVUZXh0Rm9yTGluayh0ZXh0KSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGFyYWdyYXBoOiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZSwgcGFyZW50ID0gX2EucGFyZW50LCBfYiA9IF9hLmluZGV4LCBpbmRleCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2I7XG4gICAgICAgIGlmIChzdGF0ZS5zdG9wTmV3bGluZSkge1xuICAgICAgICAgICAgc3RhdGUuY29udmVydElubGluZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmaXJzdENoaWxkTm9kZSA9IGluZGV4ID09PSAwO1xuICAgICAgICAgICAgdmFyIHByZXZOb2RlID0gIWZpcnN0Q2hpbGROb2RlICYmIHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgdmFyIHByZXZFbXB0eU5vZGUgPSBwcmV2Tm9kZSAmJiBwcmV2Tm9kZS5jaGlsZENvdW50ID09PSAwO1xuICAgICAgICAgICAgdmFyIG5leHROb2RlID0gaW5kZXggPCBwYXJlbnQuY2hpbGRDb3VudCAtIDEgJiYgcGFyZW50LmNoaWxkKGluZGV4ICsgMSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhcmFOb2RlID0gbmV4dE5vZGUgJiYgbmV4dE5vZGUudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJztcbiAgICAgICAgICAgIHZhciBlbXB0eU5vZGUgPSBub2RlLmNoaWxkQ291bnQgPT09IDA7XG4gICAgICAgICAgICBpZiAoZW1wdHlOb2RlICYmIHByZXZFbXB0eU5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS53cml0ZSgnPGJyPlxcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW1wdHlOb2RlICYmICFwcmV2RW1wdHlOb2RlICYmICFmaXJzdENoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnR5cGUubmFtZSkgPT09ICdsaXN0SXRlbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZEZWxpbSA9IHN0YXRlLmdldERlbGltKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNldERlbGltKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGUoJzxicj4nKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2V0RGVsaW0ocHJldkRlbGltKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUud3JpdGUoJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY29udmVydElubGluZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFBhcmFOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBoZWFkaW5nOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltO1xuICAgICAgICB2YXIgaGVhZGluZ1R5cGUgPSBub2RlLmF0dHJzLmhlYWRpbmdUeXBlO1xuICAgICAgICBpZiAoaGVhZGluZ1R5cGUgPT09ICdhdHgnKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZShkZWxpbSArIFwiIFwiKTtcbiAgICAgICAgICAgIHN0YXRlLmNvbnZlcnRJbmxpbmUobm9kZSk7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY29udmVydElubGluZShub2RlKTtcbiAgICAgICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKGRlbGltKTtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZGVsaW0gPSBfYi5kZWxpbSwgdGV4dCA9IF9iLnRleHQ7XG4gICAgICAgIHZhciBfYyA9IGRlbGltLCBvcGVuRGVsaW0gPSBfY1swXSwgY2xvc2VEZWxpbSA9IF9jWzFdO1xuICAgICAgICBzdGF0ZS53cml0ZShvcGVuRGVsaW0pO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgIHN0YXRlLnRleHQodGV4dCwgZmFsc2UpO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgIHN0YXRlLndyaXRlKGNsb3NlRGVsaW0pO1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH0sXG4gICAgYmxvY2tRdW90ZTogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlLCBwYXJlbnQgPSBfYS5wYXJlbnQ7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltO1xuICAgICAgICBpZiAoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC50eXBlLm5hbWUpID09PSBub2RlLnR5cGUubmFtZSkge1xuICAgICAgICAgICAgc3RhdGUuZmx1c2hDbG9zZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cmFwQmxvY2soZGVsaW0sIG51bGwsIG5vZGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpOyB9KTtcbiAgICB9LFxuICAgIGJ1bGxldExpc3Q6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGRlbGltID0gX2IuZGVsaW07XG4gICAgICAgIC8vIHNvZnQtdGFiKDQpXG4gICAgICAgIHN0YXRlLmNvbnZlcnRMaXN0KG5vZGUsIHJlcGVhdCQxKCcgJywgNCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGltICsgXCIgXCI7IH0pO1xuICAgIH0sXG4gICAgb3JkZXJlZExpc3Q6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgc3RhcnQgPSBub2RlLmF0dHJzLm9yZGVyIHx8IDE7XG4gICAgICAgIC8vIHNvZnQtdGFiKDQpXG4gICAgICAgIHN0YXRlLmNvbnZlcnRMaXN0KG5vZGUsIHJlcGVhdCQxKCcgJywgNCksIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIG9yZGVyZWROdW0gPSBTdHJpbmcoc3RhcnQgKyBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gb3JkZXJlZE51bSArIFwiLiBcIjtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBsaXN0SXRlbTogZnVuY3Rpb24gKHN0YXRlLCBfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBfYiA9IG5vZGUuYXR0cnMsIHRhc2sgPSBfYi50YXNrLCBjaGVja2VkID0gX2IuY2hlY2tlZDtcbiAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKFwiW1wiICsgKGNoZWNrZWQgPyAneCcgOiAnICcpICsgXCJdIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTtcbiAgICB9LFxuICAgIGltYWdlOiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hKSB7XG4gICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICBzdGF0ZS53cml0ZShcIiFbXCIgKyAoYXR0cnMgPT09IG51bGwgfHwgYXR0cnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF0dHJzLmFsdFRleHQpICsgXCJdKFwiICsgKGF0dHJzID09PSBudWxsIHx8IGF0dHJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdHRycy5pbWFnZVVybCkgKyBcIilcIik7XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltO1xuICAgICAgICBzdGF0ZS53cml0ZShkZWxpbSk7XG4gICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgfSxcbiAgICB0YWJsZTogZnVuY3Rpb24gKHN0YXRlLCBfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpO1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH0sXG4gICAgdGFibGVIZWFkOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltO1xuICAgICAgICB2YXIgcm93ID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRlbGltICE9PSBudWxsICYmIGRlbGltICE9PSB2b2lkIDAgPyBkZWxpbSA6ICcnO1xuICAgICAgICBpZiAoIWRlbGltICYmIHJvdykge1xuICAgICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gX2EudGV4dENvbnRlbnQsIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWREZWxpbSA9IGNyZWF0ZVRhYmxlSGVhZERlbGltKHRleHRDb250ZW50LCBhdHRycy5hbGlnbik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwifCBcIiArIGhlYWREZWxpbSArIFwiIFwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUocmVzdWx0ICsgXCJ8XCIpO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgfSxcbiAgICB0YWJsZUJvZHk6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTtcbiAgICB9LFxuICAgIHRhYmxlUm93OiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgc3RhdGUuY29udmVydE5vZGUobm9kZSk7XG4gICAgICAgIHN0YXRlLndyaXRlKCd8Jyk7XG4gICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZENlbGw6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIF9jID0gX2IuZGVsaW0sIGRlbGltID0gX2MgPT09IHZvaWQgMCA/ICd8ICcgOiBfYztcbiAgICAgICAgc3RhdGUud3JpdGUoZGVsaW0pO1xuICAgICAgICBzdGF0ZS5jb252ZXJ0VGFibGVDZWxsKG5vZGUpO1xuICAgICAgICBzdGF0ZS53cml0ZSgnICcpO1xuICAgIH0sXG4gICAgdGFibGVCb2R5Q2VsbDogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgX2MgPSBfYi5kZWxpbSwgZGVsaW0gPSBfYyA9PT0gdm9pZCAwID8gJ3wgJyA6IF9jO1xuICAgICAgICBzdGF0ZS53cml0ZShkZWxpbSk7XG4gICAgICAgIHN0YXRlLmNvbnZlcnRUYWJsZUNlbGwobm9kZSk7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgJyk7XG4gICAgfSxcbiAgICBjdXN0b21CbG9jazogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZGVsaW0gPSBfYi5kZWxpbSwgdGV4dCA9IF9iLnRleHQ7XG4gICAgICAgIHZhciBfYyA9IGRlbGltLCBvcGVuRGVsaW0gPSBfY1swXSwgY2xvc2VEZWxpbSA9IF9jWzFdO1xuICAgICAgICBzdGF0ZS53cml0ZShvcGVuRGVsaW0pO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgIHN0YXRlLnRleHQodGV4dCwgZmFsc2UpO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgIHN0YXRlLndyaXRlKGNsb3NlRGVsaW0pO1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH0sXG4gICAgZnJvbnRNYXR0ZXI6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIHRleHQgPSBfYi50ZXh0O1xuICAgICAgICBzdGF0ZS50ZXh0KHRleHQsIGZhbHNlKTtcbiAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICB9LFxuICAgIHdpZGdldDogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSkge1xuICAgICAgICB2YXIgdGV4dCA9IF9hLnRleHQ7XG4gICAgICAgIHN0YXRlLndyaXRlKHRleHQpO1xuICAgIH0sXG4gICAgaHRtbDogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgdGV4dCA9IF9iLnRleHQ7XG4gICAgICAgIHN0YXRlLndyaXRlKHRleHQpO1xuICAgICAgICBpZiAobm9kZS5hdHRycy5odG1sQmxvY2spIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGh0bWxDb21tZW50OiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciB0ZXh0ID0gX2IudGV4dDtcbiAgICAgICAgc3RhdGUud3JpdGUodGV4dCk7XG4gICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB3cml0ZSh0eXBlLCBfYSkge1xuICAgIHZhciBzdGF0ZSA9IF9hLnN0YXRlLCBub2RlSW5mbyA9IF9hLm5vZGVJbmZvLCBwYXJhbXMgPSBfYS5wYXJhbXM7XG4gICAgdmFyIHJhd0hUTUwgPSBwYXJhbXMucmF3SFRNTDtcbiAgICBpZiAocmF3SFRNTCkge1xuICAgICAgICBpZiAoaW5BcnJheV8xKHR5cGUsIFsnaGVhZGluZycsICdjb2RlQmxvY2snXSkgPiAtMSkge1xuICAgICAgICAgICAgY29udmVydFRvUmF3SFRNTEhhdmluZ0lubGluZXMoc3RhdGUsIG5vZGVJbmZvLm5vZGUsIHJhd0hUTUwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluQXJyYXlfMSh0eXBlLCBbJ2ltYWdlJywgJ3RoZW1hdGljQnJlYWsnXSkgPiAtMSkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUocmF3SFRNTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb252ZXJ0VG9SYXdIVE1MSGF2aW5nQmxvY2tzKHN0YXRlLCBub2RlSW5mbywgcmF3SFRNTCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlV3JpdGVyc1t0eXBlXShzdGF0ZSwgbm9kZUluZm8sIHBhcmFtcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRCYWNrdGlja3Mobm9kZSwgc2lkZSkge1xuICAgIHZhciB0ZXh0ID0gbm9kZS50ZXh0O1xuICAgIHZhciB0aWNrcyA9IC9gKy9nO1xuICAgIHZhciBsZW4gPSAwO1xuICAgIGlmIChub2RlLmlzVGV4dCAmJiB0ZXh0KSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gdGlja3MuZXhlYyh0ZXh0KTtcbiAgICAgICAgd2hpbGUgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgbWF0Y2hlZFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgbWF0Y2hlZCA9IHRpY2tzLmV4ZWModGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGxlbiA+IDAgJiYgc2lkZSA+IDAgPyAnIGAnIDogJ2AnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdgJztcbiAgICB9XG4gICAgaWYgKGxlbiA+IDAgJiYgc2lkZSA8IDApIHtcbiAgICAgICAgcmVzdWx0ICs9ICcgJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFBhaXJSYXdIVE1MKHJhd0hUTUwpIHtcbiAgICByZXR1cm4gcmF3SFRNTCA/IFtcIjxcIiArIHJhd0hUTUwgKyBcIj5cIiwgXCI8L1wiICsgcmF3SFRNTCArIFwiPlwiXSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRPcGVuUmF3SFRNTChyYXdIVE1MKSB7XG4gICAgcmV0dXJuIHJhd0hUTUwgPyBcIjxcIiArIHJhd0hUTUwgKyBcIj5cIiA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRDbG9zZVJhd0hUTUwocmF3SFRNTCkge1xuICAgIHJldHVybiByYXdIVE1MID8gXCI8L1wiICsgcmF3SFRNTCArIFwiPlwiIDogbnVsbDtcbn1cbnZhciB0b01kQ29udmVydG9ycyA9IHtcbiAgICBoZWFkaW5nOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJzO1xuICAgICAgICB2YXIgbGV2ZWwgPSBhdHRycy5sZXZlbDtcbiAgICAgICAgdmFyIGRlbGltID0gcmVwZWF0JDEoJyMnLCBsZXZlbCk7XG4gICAgICAgIGlmIChhdHRycy5oZWFkaW5nVHlwZSA9PT0gJ3NldGV4dCcpIHtcbiAgICAgICAgICAgIGRlbGltID0gbGV2ZWwgPT09IDEgPyAnPT09JyA6ICctLS0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogZGVsaW0sXG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChhdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgYXR0cnMgPSBfYi5hdHRycywgdGV4dENvbnRlbnQgPSBfYi50ZXh0Q29udGVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiBbXCJgYGBcIiArIChhdHRycy5sYW5ndWFnZSB8fCAnJyksICdgYGAnXSxcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKGF0dHJzLnJhd0hUTUwpLFxuICAgICAgICAgICAgdGV4dDogdGV4dENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBibG9ja1F1b3RlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06ICc+ICcsXG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYnVsbGV0TGlzdDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBpblRhYmxlID0gX2IuaW5UYWJsZTtcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBub2RlLmF0dHJzLnJhd0hUTUw7XG4gICAgICAgIGlmIChpblRhYmxlKSB7XG4gICAgICAgICAgICByYXdIVE1MID0gcmF3SFRNTCB8fCAndWwnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogJyonLFxuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwocmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvcmRlcmVkTGlzdDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBpblRhYmxlID0gX2IuaW5UYWJsZTtcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBub2RlLmF0dHJzLnJhd0hUTUw7XG4gICAgICAgIGlmIChpblRhYmxlKSB7XG4gICAgICAgICAgICByYXdIVE1MID0gcmF3SFRNTCB8fCAnb2wnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGxpc3RJdGVtOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGluVGFibGUgPSBfYi5pblRhYmxlO1xuICAgICAgICB2YXIgX2MgPSBub2RlLmF0dHJzLCB0YXNrID0gX2MudGFzaywgY2hlY2tlZCA9IF9jLmNoZWNrZWQ7XG4gICAgICAgIHZhciByYXdIVE1MID0gbm9kZS5hdHRycy5yYXdIVE1MO1xuICAgICAgICBpZiAoaW5UYWJsZSkge1xuICAgICAgICAgICAgcmF3SFRNTCA9IHJhd0hUTUwgfHwgJ2xpJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGFzayA/IFwiIGNsYXNzPVxcXCJ0YXNrLWxpc3QtaXRlbVwiICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQnIDogJycpICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgdmFyIGRhdGFzZXQgPSB0YXNrID8gXCIgZGF0YS10YXNrXCIgKyAoY2hlY2tlZCA/IFwiIGRhdGEtdGFzay1jaGVja2VkXCIgOiAnJykgOiAnJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IHJhd0hUTUwgPyBbXCI8XCIgKyByYXdIVE1MICsgY2xhc3NOYW1lICsgZGF0YXNldCArIFwiPlwiLCBcIjwvXCIgKyByYXdIVE1MICsgXCI+XCJdIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZUJvZHk6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVSb3c6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVIZWFkQ2VsbDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZUJvZHlDZWxsOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGltYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJzO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IGF0dHJzLnJhd0hUTUwsIGFsdFRleHQgPSBhdHRycy5hbHRUZXh0O1xuICAgICAgICB2YXIgaW1hZ2VVcmwgPSBhdHRycy5pbWFnZVVybC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpO1xuICAgICAgICB2YXIgYWx0QXR0ciA9IGFsdFRleHQgPyBcIiBhbHQ9XFxcIlwiICsgZXNjYXBlWG1sJDEoYWx0VGV4dCkgKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogcmF3SFRNTCA/IFwiPFwiICsgcmF3SFRNTCArIFwiIHNyYz1cXFwiXCIgKyBlc2NhcGVYbWwkMShpbWFnZVVybCkgKyBcIlxcXCJcIiArIGFsdEF0dHIgKyBcIj5cIiA6IG51bGwsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGFsdFRleHQ6IGVzY2FwZVRleHRGb3JMaW5rKGFsdFRleHQgfHwgJycpLFxuICAgICAgICAgICAgICAgIGltYWdlVXJsOiBpbWFnZVVybCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06ICcqKionLFxuICAgICAgICAgICAgcmF3SFRNTDogZ2V0T3BlblJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGN1c3RvbUJsb2NrOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCBhdHRycyA9IF9iLmF0dHJzLCB0ZXh0Q29udGVudCA9IF9iLnRleHRDb250ZW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06IFtcIiQkXCIgKyBhdHRycy5pbmZvLCAnJCQnXSxcbiAgICAgICAgICAgIHRleHQ6IHRleHRDb250ZW50LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZnJvbnRNYXR0ZXI6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBub2RlLnRleHRDb250ZW50LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgd2lkZ2V0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogbm9kZS50ZXh0Q29udGVudCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHN0cm9uZzogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9iLmVudGVyaW5nO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IG5vZGUuYXR0cnMucmF3SFRNTDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiAnKionLFxuICAgICAgICAgICAgcmF3SFRNTDogZW50ZXJpbmcgPyBnZXRPcGVuUmF3SFRNTChyYXdIVE1MKSA6IGdldENsb3NlUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGVtcGg6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYi5lbnRlcmluZztcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBub2RlLmF0dHJzLnJhd0hUTUw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogJyonLFxuICAgICAgICAgICAgcmF3SFRNTDogZW50ZXJpbmcgPyBnZXRPcGVuUmF3SFRNTChyYXdIVE1MKSA6IGdldENsb3NlUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHN0cmlrZTogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9iLmVudGVyaW5nO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IG5vZGUuYXR0cnMucmF3SFRNTDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiAnfn4nLFxuICAgICAgICAgICAgcmF3SFRNTDogZW50ZXJpbmcgPyBnZXRPcGVuUmF3SFRNTChyYXdIVE1MKSA6IGdldENsb3NlUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYi5lbnRlcmluZztcbiAgICAgICAgdmFyIGF0dHJzID0gbm9kZS5hdHRycztcbiAgICAgICAgdmFyIHRpdGxlID0gYXR0cnMudGl0bGUsIHJhd0hUTUwgPSBhdHRycy5yYXdIVE1MO1xuICAgICAgICB2YXIgbGlua1VybCA9IGF0dHJzLmxpbmtVcmwucmVwbGFjZSgvJmFtcDsvZywgJyYnKTtcbiAgICAgICAgdmFyIHRpdGxlQXR0ciA9IHRpdGxlID8gXCIgdGl0bGU9XFxcIlwiICsgZXNjYXBlWG1sJDEodGl0bGUpICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRlbGltOiAnWycsXG4gICAgICAgICAgICAgICAgcmF3SFRNTDogcmF3SFRNTCA/IFwiPFwiICsgcmF3SFRNTCArIFwiIGhyZWY9XFxcIlwiICsgZXNjYXBlWG1sJDEobGlua1VybCkgKyBcIlxcXCJcIiArIHRpdGxlQXR0ciArIFwiPlwiIDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiBcIl0oXCIgKyBsaW5rVXJsICsgKHRpdGxlID8gXCIgXCIgKyBxdW90ZShlc2NhcGVUZXh0Rm9yTGluayh0aXRsZSkpIDogJycpICsgXCIpXCIsXG4gICAgICAgICAgICByYXdIVE1MOiBnZXRDbG9zZVJhd0hUTUwocmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZSwgcGFyZW50ID0gX2EucGFyZW50LCBfYyA9IF9hLmluZGV4LCBpbmRleCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2M7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9iLmVudGVyaW5nO1xuICAgICAgICB2YXIgZGVsaW0gPSBlbnRlcmluZ1xuICAgICAgICAgICAgPyBhZGRCYWNrdGlja3MocGFyZW50LmNoaWxkKGluZGV4KSwgLTEpXG4gICAgICAgICAgICA6IGFkZEJhY2t0aWNrcyhwYXJlbnQuY2hpbGQoaW5kZXggLSAxKSwgMSk7XG4gICAgICAgIHZhciByYXdIVE1MID0gZW50ZXJpbmdcbiAgICAgICAgICAgID8gZ2V0T3BlblJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKVxuICAgICAgICAgICAgOiBnZXRDbG9zZVJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiBkZWxpbSxcbiAgICAgICAgICAgIHJhd0hUTUw6IHJhd0hUTUwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBodG1sQ29tbWVudDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IG5vZGUudGV4dENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBodG1sIGlubGluZSBub2RlLCBodG1sIGJsb2NrIG5vZGVcbiAgICBodG1sOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2IuZW50ZXJpbmc7XG4gICAgICAgIHZhciB0YWdOYW1lID0gbm9kZS50eXBlLm5hbWU7XG4gICAgICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cnMuaHRtbEF0dHJzO1xuICAgICAgICB2YXIgb3BlblRhZyA9IFwiPFwiICsgdGFnTmFtZTtcbiAgICAgICAgdmFyIGNsb3NlVGFnID0gXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgYnJva2VuIGNvbnZlcnRpbmcgd2hlbiBhdHRyaWJ1dGVzIGhhcyBkb3VibGUgcXVvdGUgc3RyaW5nXG4gICAgICAgICAgICBvcGVuVGFnICs9IFwiIFwiICsgYXR0ck5hbWUgKyBcIj1cXFwiXCIgKyBhdHRyc1thdHRyTmFtZV0ucmVwbGFjZSgvXCIvZywgXCInXCIpICsgXCJcXFwiXCI7XG4gICAgICAgIH0pO1xuICAgICAgICBvcGVuVGFnICs9ICc+JztcbiAgICAgICAgaWYgKG5vZGUuYXR0cnMuaHRtbElubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByYXdIVE1MOiBlbnRlcmluZyA/IG9wZW5UYWcgOiBjbG9zZVRhZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIgKyBvcGVuVGFnICsgbm9kZS5hdHRycy5jaGlsZHJlbkhUTUwgKyBjbG9zZVRhZyxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbnZhciBtYXJrVHlwZU9wdGlvbnMgPSB7XG4gICAgc3Ryb25nOiB7XG4gICAgICAgIG1peGFibGU6IHRydWUsXG4gICAgICAgIHJlbW92ZWRFbmNsb3NpbmdXaGl0ZXNwYWNlOiB0cnVlLFxuICAgIH0sXG4gICAgZW1waDoge1xuICAgICAgICBtaXhhYmxlOiB0cnVlLFxuICAgICAgICByZW1vdmVkRW5jbG9zaW5nV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICB9LFxuICAgIHN0cmlrZToge1xuICAgICAgICBtaXhhYmxlOiB0cnVlLFxuICAgICAgICByZW1vdmVkRW5jbG9zaW5nV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICB9LFxuICAgIGNvZGU6IHtcbiAgICAgICAgZXNjYXBlOiBmYWxzZSxcbiAgICB9LFxuICAgIGxpbms6IG51bGwsXG4gICAgaHRtbDogbnVsbCxcbn07XG5mdW5jdGlvbiBjcmVhdGVOb2RlVHlwZUNvbnZlcnRvcnMoY29udmVydG9ycykge1xuICAgIHZhciBub2RlVHlwZUNvbnZlcnRvcnMgPSB7fTtcbiAgICB2YXIgbm9kZVR5cGVzID0gT2JqZWN0LmtleXMobm9kZVR5cGVXcml0ZXJzKTtcbiAgICBub2RlVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBub2RlVHlwZUNvbnZlcnRvcnNbdHlwZV0gPSBmdW5jdGlvbiAoc3RhdGUsIG5vZGVJbmZvKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVyID0gbm9kZVR5cGVXcml0ZXJzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSBjb252ZXJ0b3JzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBjb252ZXJ0b3JcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0b3Iobm9kZUluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluVGFibGU6IHN0YXRlLmluVGFibGUsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgICAgd3JpdGUodHlwZSwgeyBzdGF0ZTogc3RhdGUsIG5vZGVJbmZvOiBub2RlSW5mbywgcGFyYW1zOiBwYXJhbXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVUeXBlQ29udmVydG9ycztcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hcmtUeXBlQ29udmVydG9ycyhjb252ZXJ0b3JzKSB7XG4gICAgdmFyIG1hcmtUeXBlQ29udmVydG9ycyA9IHt9O1xuICAgIHZhciBtYXJrVHlwZXMgPSBPYmplY3Qua2V5cyhtYXJrVHlwZU9wdGlvbnMpO1xuICAgIG1hcmtUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIG1hcmtUeXBlQ29udmVydG9yc1t0eXBlXSA9IGZ1bmN0aW9uIChub2RlSW5mbywgZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBtYXJrT3B0aW9uID0gbWFya1R5cGVPcHRpb25zW3R5cGVdO1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IGNvbnZlcnRvcnNbdHlwZV07XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIHdheXMgdG8gY2FsbCB0aGUgbWFyayB0eXBlIGNvbnZlcnRlclxuICAgICAgICAgICAgLy8gaW4gdGhlIGB0b01kQ29udmVydG9yU3RhdGVgIG1vZHVsZS5cbiAgICAgICAgICAgIC8vIFdoZW4gY2FsbGluZyB0aGUgY29udmVydGVyIHdpdGhvdXQgdXNpbmcgYGRlbGltYCBhbmQgYHJhd0hUTUxgIHZhbHVlcyxcbiAgICAgICAgICAgIC8vIHRoZSBjb252ZXJ0ZXIgaXMgY2FsbGVkIHdpdGhvdXQgcGFyYW1ldGVycy5cbiAgICAgICAgICAgIHZhciBydW5Db252ZXJ0b3IgPSBjb252ZXJ0b3IgJiYgbm9kZUluZm8gJiYgIWlzVW5kZWZpbmVkXzEoZW50ZXJpbmcpO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHJ1bkNvbnZlcnRvciA/IGNvbnZlcnRvcihub2RlSW5mbywgeyBlbnRlcmluZzogZW50ZXJpbmcgfSkgOiB7fTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHBhcmFtcyksIG1hcmtPcHRpb24pO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJrVHlwZUNvbnZlcnRvcnM7XG59XG4vLyBTdGVwIDE6IENyZWF0ZSB0aGUgY29udmVydGVyIGJ5IG92ZXJyaWRpbmcgdGhlIGN1c3RvbSBjb252ZXJ0ZXJcbi8vICAgICAgICAgdG8gdGhlIG9yaWdpbmFsIGNvbnZlcnRlciBkZWZpbmVkIGluIHRoZSBgdG9NZENvbnZlcnRvcnNgIG1vZHVsZS5cbi8vICAgICAgICAgSWYgdGhlIG5vZGUgdHlwZSBpcyBkZWZpbmVkIGluIHRoZSBvcmlnaW5hbCBjb252ZXJ0ZXIsXG4vLyAgICAgICAgIHRoZSBgb3JpZ2luKClgIGZ1bmN0aW9uIGlzIGV4cG9ydGVkIHRvIHRoZSBwYXJhbXRlciBvZiB0aGUgY29udmVydGVyLlxuLy8gU3RlcCAyOiBDcmVhdGUgYSBjb252ZXJ0ZXIgZm9yIHRoZSBub2RlIHR5cGUgb2YgUHJvc2VNaXJyb3IgYnkgY29tYmluaW5nIHRoZSBjb252ZXJ0ZXJcbi8vICAgICAgICAgY3JlYXRlZCBpbiBTdGVwIDEgd2l0aCB0aGUgd3JpdGVycyBkZWZpbmVkIGluIHRoZWB0b01kTm9kZVR5cGVXcml0ZXJzYCBtb2R1bGUuXG4vLyAgICAgICAgIEVhY2ggd3JpdGVyIGNvbnZlcnRzIHRoZSBQcm9zZU1pcnJvcidzIG5vZGUgdG8gYSBzdHJpbmcgd2l0aCB0aGUgdmFsdWUgcmV0dXJuZWRcbi8vICAgICAgICAgYnkgdGhlIGNvbnZlcnRlciwgYW5kIHRoZW4gc3RvcmVzIHRoZSBzdGF0ZSBpbiB0aGVgdG9NZENvbnZlcnRlclN0YXRlYCBjbGFzcy5cbi8vIFN0ZXAgMzogQ3JlYXRlIGEgY29udmVydGVyIGZvciB0aGUgbWFyayB0eXBlIG9mIFByb3NlTWlycm9yIGJ5IGNvbWJpbmluZyB0aGUgY29udmVydGVyXG4vLyAgICAgICAgIGNyZWF0ZWQgaW4gU3RlcCAxIHdpdGggYG1hcmtUeXBlT3B0aW9uc2AuXG4vLyBTdGVwIDQ6IFRoZSBjcmVhdGVkIG5vZGUgdHlwZSBjb252ZXJ0ZXIgYW5kIG1hcmsgdHlwZSBjb252ZXJ0ZXIgYXJlIGluamVjdGVkXG4vLyAgICAgICAgIHdoZW4gY3JlYXRpbmcgYW4gaW5zdGFuY2Ugb2YgdGhlYHRvTWRDb252ZXJ0ZXJTdGF0ZWAgY2xhc3MuXG5mdW5jdGlvbiBjcmVhdGVNZENvbnZlcnRvcnMoY3VzdG9tQ29udmVydG9ycykge1xuICAgIHZhciBjdXN0b21Db252ZXJ0b3JUeXBlcyA9IE9iamVjdC5rZXlzKGN1c3RvbUNvbnZlcnRvcnMpO1xuICAgIGN1c3RvbUNvbnZlcnRvclR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGJhc2VDb252ZXJ0b3IgPSB0b01kQ29udmVydG9yc1t0eXBlXTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvcnNbdHlwZV07XG4gICAgICAgIGlmIChiYXNlQ29udmVydG9yKSB7XG4gICAgICAgICAgICB0b01kQ29udmVydG9yc1t0eXBlXSA9IGZ1bmN0aW9uIChub2RlSW5mbywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub3JpZ2luID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZUNvbnZlcnRvcihub2RlSW5mbywgY29udGV4dCk7IH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlSW5mbywgY29udGV4dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9NZENvbnZlcnRvcnNbdHlwZV0gPSBjdXN0b21Db252ZXJ0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGN1c3RvbUNvbnZlcnRvcnNbdHlwZV07XG4gICAgfSk7XG4gICAgdmFyIG5vZGVUeXBlQ29udmVydG9ycyA9IGNyZWF0ZU5vZGVUeXBlQ29udmVydG9ycyh0b01kQ29udmVydG9ycyk7XG4gICAgdmFyIG1hcmtUeXBlQ29udmVydG9ycyA9IGNyZWF0ZU1hcmtUeXBlQ29udmVydG9ycyh0b01kQ29udmVydG9ycyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGVDb252ZXJ0b3JzOiBub2RlVHlwZUNvbnZlcnRvcnMsXG4gICAgICAgIG1hcmtUeXBlQ29udmVydG9yczogbWFya1R5cGVDb252ZXJ0b3JzLFxuICAgIH07XG59XG5cbnZhciBUb01kQ29udmVydG9yU3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9NZENvbnZlcnRvclN0YXRlKF9hKSB7XG4gICAgICAgIHZhciBub2RlVHlwZUNvbnZlcnRvcnMgPSBfYS5ub2RlVHlwZUNvbnZlcnRvcnMsIG1hcmtUeXBlQ29udmVydG9ycyA9IF9hLm1hcmtUeXBlQ29udmVydG9ycztcbiAgICAgICAgdGhpcy5ub2RlVHlwZUNvbnZlcnRvcnMgPSBub2RlVHlwZUNvbnZlcnRvcnM7XG4gICAgICAgIHRoaXMubWFya1R5cGVDb252ZXJ0b3JzID0gbWFya1R5cGVDb252ZXJ0b3JzO1xuICAgICAgICB0aGlzLmRlbGltID0gJyc7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gJyc7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGlnaHRMaXN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RvcE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pblRhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuZ2V0TWFya0NvbnZlcnRvciA9IGZ1bmN0aW9uIChtYXJrKSB7XG4gICAgICAgIHZhciB0eXBlID0gbWFyay5hdHRycy5odG1sSW5saW5lID8gJ2h0bWwnIDogbWFyay50eXBlLm5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtUeXBlQ29udmVydG9yc1t0eXBlXTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuaXNJbkJsYW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLyhefFxcbikkLy50ZXN0KHRoaXMucmVzdWx0KTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUubWFya1RleHQgPSBmdW5jdGlvbiAobWFyaywgZW50ZXJpbmcsIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRvciA9IHRoaXMuZ2V0TWFya0NvbnZlcnRvcihtYXJrKTtcbiAgICAgICAgaWYgKGNvbnZlcnRvcikge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udmVydG9yKHsgbm9kZTogbWFyaywgcGFyZW50OiBwYXJlbnQsIGluZGV4OiBpbmRleCB9LCBlbnRlcmluZyksIGRlbGltID0gX2EuZGVsaW0sIHJhd0hUTUwgPSBfYS5yYXdIVE1MO1xuICAgICAgICAgICAgcmV0dXJuIHJhd0hUTUwgfHwgZGVsaW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5zZXREZWxpbSA9IGZ1bmN0aW9uIChkZWxpbSkge1xuICAgICAgICB0aGlzLmRlbGltID0gZGVsaW07XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmdldERlbGltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxpbTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuZmx1c2hDbG9zZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmICghdGhpcy5zdG9wTmV3bGluZSAmJiB0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5CbGFuaygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaXplID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWxpbU1pbiA9IHRoaXMuZGVsaW07XG4gICAgICAgICAgICAgICAgdmFyIHRyaW0gPSAvXFxzKyQvLmV4ZWMoZGVsaW1NaW4pO1xuICAgICAgICAgICAgICAgIGlmICh0cmltKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGltTWluID0gZGVsaW1NaW4uc2xpY2UoMCwgZGVsaW1NaW4ubGVuZ3RoIC0gdHJpbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNpemU7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBkZWxpbU1pbiArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS53cmFwQmxvY2sgPSBmdW5jdGlvbiAoZGVsaW0sIGZpcnN0RGVsaW0sIG5vZGUsIGZuKSB7XG4gICAgICAgIHZhciBvbGQgPSB0aGlzLmdldERlbGltKCk7XG4gICAgICAgIHRoaXMud3JpdGUoZmlyc3REZWxpbSB8fCBkZWxpbSk7XG4gICAgICAgIHRoaXMuc2V0RGVsaW0odGhpcy5nZXREZWxpbSgpICsgZGVsaW0pO1xuICAgICAgICBmbigpO1xuICAgICAgICB0aGlzLnNldERlbGltKG9sZCk7XG4gICAgICAgIHRoaXMuY2xvc2VCbG9jayhub2RlKTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuZW5zdXJlTmV3TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5CbGFuaygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50ID09PSB2b2lkIDApIHsgY29udGVudCA9ICcnOyB9XG4gICAgICAgIHRoaXMuZmx1c2hDbG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5kZWxpbSAmJiB0aGlzLmlzSW5CbGFuaygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSB0aGlzLmRlbGltO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmNsb3NlQmxvY2sgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IG5vZGU7XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAodGV4dCwgZXNjYXBlZCkge1xuICAgICAgICBpZiAoZXNjYXBlZCA9PT0gdm9pZCAwKSB7IGVzY2FwZWQgPSB0cnVlOyB9XG4gICAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBlc2NhcGVkID8gZXNjYXBlJDEobGluZXNbaV0pIDogbGluZXNbaV07XG4gICAgICAgICAgICBpZiAoaSAhPT0gbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnRCbG9jayA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLm5hbWU7XG4gICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzLm5vZGVUeXBlQ29udmVydG9yc1t0eXBlXTtcbiAgICAgICAgdmFyIG5vZGVJbmZvID0geyBub2RlOiBub2RlLCBwYXJlbnQ6IHBhcmVudCwgaW5kZXg6IGluZGV4IH07XG4gICAgICAgIGlmIChub2RlLmF0dHJzLmh0bWxCbG9jaykge1xuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZUNvbnZlcnRvcnMuaHRtbCh0aGlzLCBub2RlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udmVydG9yKSB7XG4gICAgICAgICAgICBjb252ZXJ0b3IodGhpcywgbm9kZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnRJbmxpbmUgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhY3RpdmUgPSBbXTtcbiAgICAgICAgdmFyIHRyYWlsaW5nID0gJyc7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IGZ1bmN0aW9uIChub2RlLCBfLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIG1hcmtzID0gbm9kZSA/IG5vZGUubWFya3MgOiBbXTtcbiAgICAgICAgICAgIHZhciBsZWFkaW5nID0gdHJhaWxpbmc7XG4gICAgICAgICAgICB0cmFpbGluZyA9ICcnO1xuICAgICAgICAgICAgLy8gSWYgd2hpdGVzcGFjZSBoYXMgdG8gYmUgZXhwZWxsZWQgZnJvbSB0aGUgbm9kZSwgYWRqdXN0XG4gICAgICAgICAgICAvLyBsZWFkaW5nIGFuZCB0cmFpbGluZyBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgIHZhciByZW1vdmVkV2hpdGVzcGFjZSA9IG5vZGUgJiZcbiAgICAgICAgICAgICAgICBub2RlLmlzVGV4dCAmJlxuICAgICAgICAgICAgICAgIG1hcmtzLnNvbWUoZnVuY3Rpb24gKG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtDb252ZXJ0b3IgPSBfdGhpcy5nZXRNYXJrQ29udmVydG9yKG1hcmspO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IG1hcmtDb252ZXJ0b3IgJiYgbWFya0NvbnZlcnRvcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5mbyAmJiBpbmZvLnJlbW92ZWRFbmNsb3NpbmdXaGl0ZXNwYWNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWRXaGl0ZXNwYWNlICYmIG5vZGUgJiYgbm9kZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gL14oXFxzKikoLio/KShcXHMqKSQvbS5leGVjKG5vZGUudGV4dCksIGxlYWQgPSBfYVsxXSwgbWFyayA9IF9hWzJdLCB0cmFpbCA9IF9hWzNdO1xuICAgICAgICAgICAgICAgIGxlYWRpbmcgKz0gbGVhZDtcbiAgICAgICAgICAgICAgICB0cmFpbGluZyA9IHRyYWlsO1xuICAgICAgICAgICAgICAgIGlmIChsZWFkIHx8IHRyYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSBpcyBub3QgZGVmaW5lZCBmb3IgXCJ3aXRoVGV4dFwiIGluIHByb3NlbWlycm9yLW1vZGVsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBtYXJrID8gbm9kZS53aXRoVGV4dChtYXJrKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBhY3RpdmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGFzdE1hcmsgPSBtYXJrcy5sZW5ndGggJiYgbGFzdCQxKG1hcmtzKTtcbiAgICAgICAgICAgIHZhciBtYXJrQ29udmVydG9yID0gbGFzdE1hcmsgJiYgX3RoaXMuZ2V0TWFya0NvbnZlcnRvcihsYXN0TWFyayk7XG4gICAgICAgICAgICB2YXIgbWFya1R5cGUgPSBtYXJrQ29udmVydG9yICYmIG1hcmtDb252ZXJ0b3IoKTtcbiAgICAgICAgICAgIHZhciBub0VzY2FwZSA9IG1hcmtUeXBlICYmIG1hcmtUeXBlLmVzY2FwZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbGVuID0gbWFya3MubGVuZ3RoIC0gKG5vRXNjYXBlID8gMSA6IDApO1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHJlb3JkZXIgJ21peGFibGUnIG1hcmtzLCBzdWNoIGFzIGVtIGFuZCBzdHJvbmcsIHdoaWNoXG4gICAgICAgICAgICAvLyBpbiBNYXJrZG93biBtYXkgYmUgb3BlbmVkIGFuZCBjbG9zZWQgaW4gZGlmZmVyZW50IG9yZGVyLCBzb1xuICAgICAgICAgICAgLy8gdGhhdCBvcmRlciBvZiB0aGUgbWFya3MgZm9yIHRoZSB0b2tlbiBtYXRjaGVzIHRoZSBvcmRlciBpblxuICAgICAgICAgICAgLy8gYWN0aXZlLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrID0gbWFya3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmICFtYXJrVHlwZS5taXhhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFjdGl2ZS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBhY3RpdmVbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiAhbWFya1R5cGUubWl4YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmsuZXEob3RoZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hcmspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobWFya3Muc2xpY2UoaiwgaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobWFya3Muc2xpY2UoaSArIDEsIGxlbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hcmtzLnNsaWNlKGkgKyAxLCBqKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXJrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hcmtzLnNsaWNlKGosIGxlbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBwcmVmaXggb2YgdGhlIG1hcmsgc2V0IHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgdmFyIGtlZXAgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBNYXRoLm1pbihhY3RpdmUubGVuZ3RoLCBsZW4pICYmIG1hcmtzW2tlZXBdLmVxKGFjdGl2ZVtrZWVwXSkpIHtcbiAgICAgICAgICAgICAgICBrZWVwICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbG9zZSB0aGUgbWFya3MgdGhhdCBuZWVkIHRvIGJlIGNsb3NlZFxuICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZWRNYXJrID0gYWN0aXZlLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVkTWFyaykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXh0KF90aGlzLm1hcmtUZXh0KGFjdGl2ZWRNYXJrLCBmYWxzZSwgcGFyZW50LCBpbmRleCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdXRwdXQgYW55IHByZXZpb3VzbHkgZXhwZWxsZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvdXRzaWRlIHRoZSBtYXJrc1xuICAgICAgICAgICAgaWYgKGxlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50ZXh0KGxlYWRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3BlbiB0aGUgbWFya3MgdGhhdCBuZWVkIHRvIGJlIG9wZW5lZFxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYWN0aXZlLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFyayA9IG1hcmtzW2FjdGl2ZS5sZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaChtYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGV4dChfdGhpcy5tYXJrVGV4dChtYXJrLCB0cnVlLCBwYXJlbnQsIGluZGV4KSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIG5vZGUuIFNwZWNpYWwgY2FzZSBjb2RlIG1hcmtzLCBzaW5jZSB0aGVpciBjb250ZW50XG4gICAgICAgICAgICAgICAgLy8gbWF5IG5vdCBiZSBlc2NhcGVkLlxuICAgICAgICAgICAgICAgIGlmIChub0VzY2FwZSAmJiBub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXh0KF90aGlzLm1hcmtUZXh0KGxhc3RNYXJrLCB0cnVlLCBwYXJlbnQsIGluZGV4KSArXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRleHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFya1RleHQobGFzdE1hcmssIGZhbHNlLCBwYXJlbnQsIGluZGV4ICsgMSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnZlcnRCbG9jayhub2RlLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBhcmVudC5mb3JFYWNoKHByb2dyZXNzKTtcbiAgICAgICAgcHJvZ3Jlc3MobnVsbCwgbnVsbCwgcGFyZW50LmNoaWxkQ291bnQpO1xuICAgIH07XG4gICAgLy8gUmVuZGVyIGEgbm9kZSdzIGNvbnRlbnQgYXMgYSBsaXN0LiBgZGVsaW1gIHNob3VsZCBiZSB0aGUgZXh0cmFcbiAgICAvLyBpbmRlbnRhdGlvbiBhZGRlZCB0byBhbGwgbGluZXMgZXhjZXB0IHRoZSBmaXJzdCBpbiBhbiBpdGVtLFxuICAgIC8vIGBmaXJzdERlbGltRm5gIGlzIGEgZnVuY3Rpb24gZ29pbmcgZnJvbSBhbiBpdGVtIGluZGV4IHRvIGFcbiAgICAvLyBkZWxpbWl0ZXIgZm9yIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBpdGVtLlxuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydExpc3QgPSBmdW5jdGlvbiAobm9kZSwgZGVsaW0sIGZpcnN0RGVsaW1Gbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCAmJiB0aGlzLmNsb3NlZC50eXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDbG9zZSgzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRpZ2h0TGlzdCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaENsb3NlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aWdodCA9IChfYSA9IG5vZGUuYXR0cnMudGlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgIHZhciBwcmV2VGlnaHQgPSB0aGlzLnRpZ2h0TGlzdDtcbiAgICAgICAgdGhpcy50aWdodExpc3QgPSB0aWdodDtcbiAgICAgICAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgXywgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCAmJiB0aWdodCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZsdXNoQ2xvc2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy53cmFwQmxvY2soZGVsaW0sIGZpcnN0RGVsaW1GbihpbmRleCksIG5vZGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbnZlcnRCbG9jayhjaGlsZCwgbm9kZSwgaW5kZXgpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGlnaHRMaXN0ID0gcHJldlRpZ2h0O1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jb252ZXJ0VGFibGVDZWxsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdG9wTmV3bGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5UYWJsZSA9IHRydWU7XG4gICAgICAgIG5vZGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIF8sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZXMoWydidWxsZXRMaXN0JywgJ29yZGVyZWRMaXN0J10sIGNoaWxkLnR5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb252ZXJ0QmxvY2soY2hpbGQsIG5vZGUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnZlcnRJbmxpbmUoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IG5vZGUuY2hpbGRDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5vZGUuY2hpbGQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy53cml0ZSgnPGJyPicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdG9wTmV3bGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluVGFibGUgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydE5vZGUgPSBmdW5jdGlvbiAocGFyZW50LCBpbmZvRm9yUG9zU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgXywgaW5kZXgpIHtcbiAgICAgICAgICAgIF90aGlzLmNvbnZlcnRCbG9jayhub2RlLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICgoaW5mb0ZvclBvc1N5bmMgPT09IG51bGwgfHwgaW5mb0ZvclBvc1N5bmMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm9Gb3JQb3NTeW5jLm5vZGUpID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVUZXh0cyA9IF90aGlzLnJlc3VsdC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgaW5mb0ZvclBvc1N5bmMuc2V0TWFwcGVkUG9zKFtsaW5lVGV4dHMubGVuZ3RoLCBsYXN0JDEobGluZVRleHRzKS5sZW5ndGggKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gVG9NZENvbnZlcnRvclN0YXRlO1xufSgpKTtcblxudmFyIENvbnZlcnRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252ZXJ0b3Ioc2NoZW1hLCB0b01kQ29udmVydG9ycywgdG9IVE1MQ29udmVydG9ycywgZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2V0TWFwcGVkUG9zID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgX3RoaXMubWFwcGVkUG9zV2hlbkNvbnZlcnRpbmcgPSBwb3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5mb2N1c2VkTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWFwcGVkUG9zV2hlbkNvbnZlcnRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLnRvV3dDb252ZXJ0b3JzID0gY3JlYXRlV3dDb252ZXJ0b3JzKHRvSFRNTENvbnZlcnRvcnMpO1xuICAgICAgICB0aGlzLnRvTWRDb252ZXJ0b3JzID0gY3JlYXRlTWRDb252ZXJ0b3JzKHRvTWRDb252ZXJ0b3JzIHx8IHt9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdzZXRGb2N1c2VkTm9kZScsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAoX3RoaXMuZm9jdXNlZE5vZGUgPSBub2RlKTsgfSk7XG4gICAgfVxuICAgIENvbnZlcnRvci5wcm90b3R5cGUuZ2V0TWFwcGVkUG9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBwZWRQb3NXaGVuQ29udmVydGluZztcbiAgICB9O1xuICAgIENvbnZlcnRvci5wcm90b3R5cGUuZ2V0SW5mb0ZvclBvc1N5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuZm9jdXNlZE5vZGUsIHNldE1hcHBlZFBvczogdGhpcy5zZXRNYXBwZWRQb3MgfTtcbiAgICB9O1xuICAgIENvbnZlcnRvci5wcm90b3R5cGUudG9XeXNpd3lnTW9kZWwgPSBmdW5jdGlvbiAobWROb2RlKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IG5ldyBUb1d3Q29udmVydG9yU3RhdGUodGhpcy5zY2hlbWEsIHRoaXMudG9Xd0NvbnZlcnRvcnMpO1xuICAgICAgICByZXR1cm4gc3RhdGUuY29udmVydE5vZGUobWROb2RlLCB0aGlzLmdldEluZm9Gb3JQb3NTeW5jKCkpO1xuICAgIH07XG4gICAgQ29udmVydG9yLnByb3RvdHlwZS50b01hcmtkb3duVGV4dCA9IGZ1bmN0aW9uICh3d05vZGUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gbmV3IFRvTWRDb252ZXJ0b3JTdGF0ZSh0aGlzLnRvTWRDb252ZXJ0b3JzKTtcbiAgICAgICAgdmFyIG1hcmtkb3duVGV4dCA9IHN0YXRlLmNvbnZlcnROb2RlKHd3Tm9kZSwgdGhpcy5nZXRJbmZvRm9yUG9zU3luYygpKTtcbiAgICAgICAgbWFya2Rvd25UZXh0ID0gdGhpcy5ldmVudEVtaXR0ZXIuZW1pdFJlZHVjZSgnYmVmb3JlQ29udmVydFd5c2l3eWdUb01hcmtkb3duJywgbWFya2Rvd25UZXh0KTtcbiAgICAgICAgcmV0dXJuIG1hcmtkb3duVGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBDb252ZXJ0b3I7XG59KCkpO1xuXG5mdW5jdGlvbiBleGVjUGx1Z2luKHBsdWdpbkluZm8pIHtcbiAgICB2YXIgcGx1Z2luID0gcGx1Z2luSW5mby5wbHVnaW4sIGV2ZW50RW1pdHRlciA9IHBsdWdpbkluZm8uZXZlbnRFbWl0dGVyLCB1c2FnZVN0YXRpc3RpY3MgPSBwbHVnaW5JbmZvLnVzYWdlU3RhdGlzdGljcywgaW5zdGFuY2UgPSBwbHVnaW5JbmZvLmluc3RhbmNlO1xuICAgIHZhciBwbVN0YXRlID0geyBQbHVnaW46IFBsdWdpbiwgUGx1Z2luS2V5OiBQbHVnaW5LZXksIFNlbGVjdGlvbjogU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uOiBUZXh0U2VsZWN0aW9uIH07XG4gICAgdmFyIHBtVmlldyA9IHsgRGVjb3JhdGlvbjogRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldDogRGVjb3JhdGlvblNldCB9O1xuICAgIHZhciBwbU1vZGVsID0geyBGcmFnbWVudDogRnJhZ21lbnQgfTtcbiAgICB2YXIgcG1SdWxlcyA9IHsgSW5wdXRSdWxlOiBJbnB1dFJ1bGUsIGlucHV0UnVsZXM6IGlucHV0UnVsZXMsIHVuZG9JbnB1dFJ1bGU6IHVuZG9JbnB1dFJ1bGUgfTtcbiAgICB2YXIgcG1LZXltYXAgPSB7IGtleW1hcDoga2V5bWFwIH07XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgIGV2ZW50RW1pdHRlcjogZXZlbnRFbWl0dGVyLFxuICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICBwbVN0YXRlOiBwbVN0YXRlLFxuICAgICAgICBwbVZpZXc6IHBtVmlldyxcbiAgICAgICAgcG1Nb2RlbDogcG1Nb2RlbCxcbiAgICAgICAgcG1SdWxlczogcG1SdWxlcyxcbiAgICAgICAgcG1LZXltYXA6IHBtS2V5bWFwLFxuICAgICAgICBpMThuOiBpMThuLFxuICAgIH07XG4gICAgaWYgKGlzQXJyYXlfMShwbHVnaW4pKSB7XG4gICAgICAgIHZhciBwbHVnaW5GbiA9IHBsdWdpblswXSwgX2EgPSBwbHVnaW5bMV0sIG9wdGlvbnMgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYTtcbiAgICAgICAgcmV0dXJuIHBsdWdpbkZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luKGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0UGx1Z2luSW5mbyhwbHVnaW5zSW5mbykge1xuICAgIHZhciBwbHVnaW5zID0gcGx1Z2luc0luZm8ucGx1Z2lucywgZXZlbnRFbWl0dGVyID0gcGx1Z2luc0luZm8uZXZlbnRFbWl0dGVyLCB1c2FnZVN0YXRpc3RpY3MgPSBwbHVnaW5zSW5mby51c2FnZVN0YXRpc3RpY3MsIGluc3RhbmNlID0gcGx1Z2luc0luZm8uaW5zdGFuY2U7XG4gICAgZXZlbnRFbWl0dGVyLmxpc3RlbignbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZScsIG1peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUpO1xuICAgIHJldHVybiAocGx1Z2lucyAhPT0gbnVsbCAmJiBwbHVnaW5zICE9PSB2b2lkIDAgPyBwbHVnaW5zIDogW10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbHVnaW4pIHtcbiAgICAgICAgdmFyIHBsdWdpbkluZm9SZXN1bHQgPSBleGVjUGx1Z2luKHtcbiAgICAgICAgICAgIHBsdWdpbjogcGx1Z2luLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiBldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcGx1Z2luSW5mb1Jlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRlZCBwbHVnaW4gaXMgZW1wdHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmtkb3duUGFyc2VycyA9IHBsdWdpbkluZm9SZXN1bHQubWFya2Rvd25QYXJzZXJzLCB0b0hUTUxSZW5kZXJlcnMgPSBwbHVnaW5JbmZvUmVzdWx0LnRvSFRNTFJlbmRlcmVycywgdG9NYXJrZG93blJlbmRlcmVycyA9IHBsdWdpbkluZm9SZXN1bHQudG9NYXJrZG93blJlbmRlcmVycywgbWFya2Rvd25QbHVnaW5zID0gcGx1Z2luSW5mb1Jlc3VsdC5tYXJrZG93blBsdWdpbnMsIHd5c2l3eWdQbHVnaW5zID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnUGx1Z2lucywgd3lzaXd5Z05vZGVWaWV3cyA9IHBsdWdpbkluZm9SZXN1bHQud3lzaXd5Z05vZGVWaWV3cywgbWFya2Rvd25Db21tYW5kcyA9IHBsdWdpbkluZm9SZXN1bHQubWFya2Rvd25Db21tYW5kcywgd3lzaXd5Z0NvbW1hbmRzID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnQ29tbWFuZHMsIHRvb2xiYXJJdGVtcyA9IHBsdWdpbkluZm9SZXN1bHQudG9vbGJhckl0ZW1zO1xuICAgICAgICBpZiAodG9IVE1MUmVuZGVyZXJzKSB7XG4gICAgICAgICAgICBhY2MudG9IVE1MUmVuZGVyZXJzID0gZGVlcE1lcmdlZENvcHkoYWNjLnRvSFRNTFJlbmRlcmVycywgdG9IVE1MUmVuZGVyZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9NYXJrZG93blJlbmRlcmVycykge1xuICAgICAgICAgICAgYWNjLnRvTWFya2Rvd25SZW5kZXJlcnMgPSBkZWVwTWVyZ2VkQ29weShhY2MudG9NYXJrZG93blJlbmRlcmVycywgdG9NYXJrZG93blJlbmRlcmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtkb3duUGx1Z2lucykge1xuICAgICAgICAgICAgYWNjLm1kUGx1Z2lucyA9IGFjYy5tZFBsdWdpbnMuY29uY2F0KG1hcmtkb3duUGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHd5c2l3eWdQbHVnaW5zKSB7XG4gICAgICAgICAgICBhY2Mud3dQbHVnaW5zID0gYWNjLnd3UGx1Z2lucy5jb25jYXQod3lzaXd5Z1BsdWdpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3eXNpd3lnTm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBhY2Mud3dOb2RlVmlld3MgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGFjYy53d05vZGVWaWV3cyksIHd5c2l3eWdOb2RlVmlld3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZG93bkNvbW1hbmRzKSB7XG4gICAgICAgICAgICBhY2MubWRDb21tYW5kcyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYWNjLm1kQ29tbWFuZHMpLCBtYXJrZG93bkNvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3lzaXd5Z0NvbW1hbmRzKSB7XG4gICAgICAgICAgICBhY2Mud3dDb21tYW5kcyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYWNjLnd3Q29tbWFuZHMpLCB3eXNpd3lnQ29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29sYmFySXRlbXMpIHtcbiAgICAgICAgICAgIGFjYy50b29sYmFySXRlbXMgPSBhY2MudG9vbGJhckl0ZW1zLmNvbmNhdCh0b29sYmFySXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZG93blBhcnNlcnMpIHtcbiAgICAgICAgICAgIGFjYy5tYXJrZG93blBhcnNlcnMgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGFjYy5tYXJrZG93blBhcnNlcnMpLCBtYXJrZG93blBhcnNlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge1xuICAgICAgICB0b0hUTUxSZW5kZXJlcnM6IHt9LFxuICAgICAgICB0b01hcmtkb3duUmVuZGVyZXJzOiB7fSxcbiAgICAgICAgbWRQbHVnaW5zOiBbXSxcbiAgICAgICAgd3dQbHVnaW5zOiBbXSxcbiAgICAgICAgd3dOb2RlVmlld3M6IHt9LFxuICAgICAgICBtZENvbW1hbmRzOiB7fSxcbiAgICAgICAgd3dDb21tYW5kczoge30sXG4gICAgICAgIHRvb2xiYXJJdGVtczogW10sXG4gICAgICAgIG1hcmtkb3duUGFyc2Vyczoge30sXG4gICAgfSk7XG59XG5cbnZhciBUQVNLX0FUVFJfTkFNRSA9ICdkYXRhLXRhc2snO1xudmFyIERJU0FCTEVEX1RBU0tfQVRUUl9OQU1FID0gJ2RhdGEtdGFzay1kaXNhYmxlZCc7XG52YXIgVEFTS19DSEVDS0VEX0NMQVNTX05BTUUgPSAnY2hlY2tlZCc7XG5mdW5jdGlvbiByZWdpc3RlckhUTUxUYWdUb1doaXRlbGlzdChjb252ZXJ0b3JNYXApIHtcbiAgICBbJ2h0bWxCbG9jaycsICdodG1sSW5saW5lJ10uZm9yRWFjaChmdW5jdGlvbiAoaHRtbFR5cGUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pIHtcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRhZyB3aGl0ZSBsaXN0IGZvciBwcmV2ZW50aW5nIHRvIHJlbW92ZSB0aGUgaHRtbCBpbiBzYW5pdGl6ZXJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHJlZ2lzdGVyVGFnV2hpdGVsaXN0SWZQb3NzaWJsZSh0eXBlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQ2xhc3MgVG9hc3RVSUVkaXRvclZpZXdlclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uIG9iamVjdFxuICogICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuZWwgLSBjb250YWluZXIgZWxlbWVudFxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbml0aWFsVmFsdWVdIEVkaXRvcidzIGluaXRpYWwgdmFsdWVcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXZlbnRzXSAtIEV2ZW50c1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMubG9hZF0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGZ1bGx5IGxvYWRcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmNoYW5nZV0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gY29udGVudCBjaGFuZ2VkXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5jYXJldENoYW5nZV0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZm9ybWF0IGNoYW5nZSBieSBjdXJzb3IgcG9zaXRpb25cbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmZvY3VzXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgZ2V0IGZvY3VzXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5ibHVyXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgbG9vc2UgZm9jdXNcbiAqICAgICBAcGFyYW0ge0FycmF5LjxmdW5jdGlvbnxBcnJheT59IFtvcHRpb25zLnBsdWdpbnNdIC0gQXJyYXkgb2YgcGx1Z2lucy4gQSBwbHVnaW4gY2FuIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5IGluIHRoZSBmb3JtIG9mIFtmdW5jdGlvbiwgb3B0aW9uc10uXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuZGVkQXV0b2xpbmtzXSAtIFVzaW5nIGV4dGVuZGVkIEF1dG9saW5rcyBzcGVjaWZpZWQgaW4gR0ZNIHNwZWNcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGlua0F0dHJpYnV0ZXNdIC0gQXR0cmlidXRlcyBvZiBhbmNob3IgZWxlbWVudCB0aGF0IHNob3VsZCBiZSByZWwsIHRhcmdldCwgaHJlZmxhbmcsIHR5cGVcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyPW51bGxdIC0gT2JqZWN0IGNvbnRhaW5pbmcgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9ucyBjb3JyZXNwb25kIHRvIGNoYW5nZSBtYXJrZG93biBub2RlIHRvIHByZXZpZXcgSFRNTCBvciB3eXNpd3lnIG5vZGVcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb249ZmFsc2VdIC0gd2hldGhlciB1c2UgdGhlIHNwZWNpZmljYXRpb24gb2YgbGluayByZWZlcmVuY2UgZGVmaW5pdGlvblxuICogICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmN1c3RvbUhUTUxTYW5pdGl6ZXI9bnVsbF0gLSBjdXN0b20gSFRNTCBzYW5pdGl6ZXJcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZyb250TWF0dGVyPWZhbHNlXSAtIHdoZXRoZXIgdXNlIHRoZSBmcm9udCBtYXR0ZXJcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGhlbWVdIC0gVGhlIHRoZW1lIHRvIHN0eWxlIHRoZSB2aWV3ZXIgd2l0aC4gVGhlIGRlZmF1bHQgaXMgaW5jbHVkZWQgaW4gdG9hc3R1aS1lZGl0b3IuY3NzLlxuICovXG52YXIgVG9hc3RVSUVkaXRvclZpZXdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2FzdFVJRWRpdG9yVmlld2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kXzEoe1xuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXM6IG51bGwsXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZmFsc2UsXG4gICAgICAgICAgICBjdXN0b21IVE1MUmVuZGVyZXI6IG51bGwsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxTYW5pdGl6ZXI6IG51bGwsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZmFsc2UsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHRydWUsXG4gICAgICAgICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB2YXIgbGlua0F0dHJpYnV0ZXMgPSBzYW5pdGl6ZUxpbmtBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmxpbmtBdHRyaWJ1dGVzKTtcbiAgICAgICAgdmFyIF9hID0gZ2V0UGx1Z2luSW5mbyh7XG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLm9wdGlvbnMucGx1Z2lucyxcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlcjogdGhpcy5ldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHRoaXMub3B0aW9ucy51c2FnZVN0YXRpc3RpY3MsXG4gICAgICAgICAgICBpbnN0YW5jZTogdGhpcyxcbiAgICAgICAgfSkgfHwge30sIHRvSFRNTFJlbmRlcmVycyA9IF9hLnRvSFRNTFJlbmRlcmVycywgbWFya2Rvd25QYXJzZXJzID0gX2EubWFya2Rvd25QYXJzZXJzO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLm9wdGlvbnMsIGN1c3RvbUhUTUxSZW5kZXJlciA9IF9iLmN1c3RvbUhUTUxSZW5kZXJlciwgZXh0ZW5kZWRBdXRvbGlua3MgPSBfYi5leHRlbmRlZEF1dG9saW5rcywgcmVmZXJlbmNlRGVmaW5pdGlvbiA9IF9iLnJlZmVyZW5jZURlZmluaXRpb24sIGZyb250TWF0dGVyID0gX2IuZnJvbnRNYXR0ZXIsIGN1c3RvbUhUTUxTYW5pdGl6ZXIgPSBfYi5jdXN0b21IVE1MU2FuaXRpemVyO1xuICAgICAgICB2YXIgcmVuZGVyZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXM6IGxpbmtBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFJlbmRlcmVyOiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHRvSFRNTFJlbmRlcmVycyksIGN1c3RvbUhUTUxSZW5kZXJlciksXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZXh0ZW5kZWRBdXRvbGlua3MsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiByZWZlcmVuY2VEZWZpbml0aW9uLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyLFxuICAgICAgICAgICAgc2FuaXRpemVyOiBjdXN0b21IVE1MU2FuaXRpemVyIHx8IHNhbml0aXplSFRNTCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVnaXN0ZXJIVE1MVGFnVG9XaGl0ZWxpc3QocmVuZGVyZXJPcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlcik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgICAgICBmb3JFYWNoT3duUHJvcGVydGllc18xKHRoaXMub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub24oa2V5LCBmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSB0aGlzLm9wdGlvbnMsIGVsID0gX2MuZWwsIGluaXRpYWxWYWx1ZSA9IF9jLmluaXRpYWxWYWx1ZSwgdGhlbWUgPSBfYy50aGVtZTtcbiAgICAgICAgdmFyIGV4aXN0aW5nSFRNTCA9IGVsLmlubmVySFRNTDtcbiAgICAgICAgaWYgKHRoZW1lICE9PSAnbGlnaHQnKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyh0aGVtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLnRvYXN0TWFyayA9IG5ldyBUb2FzdE1hcmsoJycsIHtcbiAgICAgICAgICAgIGRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzOiBbJ2JyJywgJ2ltZyddLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGRpc2FsbG93RGVlcEhlYWRpbmc6IHRydWUsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG4gICAgICAgICAgICBjdXN0b21QYXJzZXI6IG1hcmtkb3duUGFyc2VycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJldmlldyA9IG5ldyBNYXJrZG93blByZXZpZXcodGhpcy5ldmVudEVtaXR0ZXIsIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgcmVuZGVyZXJPcHRpb25zKSwgeyBpc1ZpZXdlcjogdHJ1ZSB9KSk7XG4gICAgICAgIG9uXzEodGhpcy5wcmV2aWV3LnByZXZpZXdDb250ZW50LCAnbW91c2Vkb3duJywgdGhpcy50b2dnbGVUYXNrLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1hcmtkb3duKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmdIVE1MKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuc2V0SFRNTChleGlzdGluZ0hUTUwpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMucHJldmlldy5wcmV2aWV3Q29udGVudCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2xvYWQnLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRhc2sgYnkgZGV0ZWN0aW5nIG1vdXNlZG93biBldmVudC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2IC0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLnRvZ2dsZVRhc2sgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBldi50YXJnZXQ7XG4gICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJzpiZWZvcmUnKTtcbiAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShESVNBQkxFRF9UQVNLX0FUVFJfTkFNRSkgJiZcbiAgICAgICAgICAgIGVsZW1lbnQuaGFzQXR0cmlidXRlKFRBU0tfQVRUUl9OQU1FKSAmJlxuICAgICAgICAgICAgaXNQb3NpdGlvbkluQm94KHN0eWxlLCBldi5vZmZzZXRYLCBldi5vZmZzZXRZKSkge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZWxlbWVudCwgVEFTS19DSEVDS0VEX0NMQVNTX05BTUUpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogJ3ZpZXdlcicsXG4gICAgICAgICAgICAgICAgZGF0ZTogZXYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGNvbnRlbnQgZm9yIHByZXZpZXdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya2Rvd24gTWFya2Rvd24gdGV4dFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLnNldE1hcmtkb3duID0gZnVuY3Rpb24gKG1hcmtkb3duKSB7XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSB0aGlzLnRvYXN0TWFyay5nZXRMaW5lVGV4dHMoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpbmVUZXh0cy5sZW5ndGg7XG4gICAgICAgIHZhciBsYXN0TGluZSA9IGxhc3QkMShsaW5lVGV4dHMpO1xuICAgICAgICB2YXIgZW5kU291cmNlcG9zID0gW2xlbmd0aCwgbGFzdExpbmUubGVuZ3RoICsgMV07XG4gICAgICAgIHZhciBlZGl0UmVzdWx0ID0gdGhpcy50b2FzdE1hcmsuZWRpdE1hcmtkb3duKFsxLCAxXSwgZW5kU291cmNlcG9zLCBtYXJrZG93biB8fCAnJyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3VwZGF0ZVByZXZpZXcnLCBlZGl0UmVzdWx0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJpbmQgZXZlbnRIYW5kbGVyIHRvIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4odHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmJpbmQgZXZlbnRIYW5kbGVyIGZyb20gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgaG9vayB0byBUVUlFZGl0b3IgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuYWRkSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcih0eXBlKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIFZpZXdlciBwcmV2aWV3IGZyb20gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZfMSh0aGlzLnByZXZpZXcuZWwsICdtb3VzZWRvd24nLCB0aGlzLnRvZ2dsZVRhc2suYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucHJldmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNWaWV3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNNYXJrZG93bk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmlzV3lzaXd5Z01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdFVJRWRpdG9yVmlld2VyO1xufSgpKTtcblxuZnVuY3Rpb24gaXNQbU5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSQzO1xufVxuZnVuY3Rpb24gaXNDb250YWluZXIodHlwZSkge1xuICAgIHZhciBjb250YWluZXJUeXBlcyA9IFtcbiAgICAgICAgJ2RvY3VtZW50JyxcbiAgICAgICAgJ2Jsb2NrUXVvdGUnLFxuICAgICAgICAnYnVsbGV0TGlzdCcsXG4gICAgICAgICdvcmRlcmVkTGlzdCcsXG4gICAgICAgICdsaXN0SXRlbScsXG4gICAgICAgICdwYXJhZ3JhcGgnLFxuICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICdlbXBoJyxcbiAgICAgICAgJ3N0cm9uZycsXG4gICAgICAgICdzdHJpa2UnLFxuICAgICAgICAnbGluaycsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICd0YWJsZScsXG4gICAgICAgICd0YWJsZUhlYWQnLFxuICAgICAgICAndGFibGVCb2R5JyxcbiAgICAgICAgJ3RhYmxlUm93JyxcbiAgICAgICAgJ3RhYmxlSGVhZENlbGwnLFxuICAgICAgICAndGFibGVCb2R5Q2VsbCcsXG4gICAgXTtcbiAgICByZXR1cm4gaW5jbHVkZXMoY29udGFpbmVyVHlwZXMsIHR5cGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWRMaWtlTm9kZShub2RlKSB7XG4gICAgdmFyIGF0dHJzID0gbm9kZS5hdHRycywgdHlwZSA9IG5vZGUudHlwZTtcbiAgICB2YXIgbm9kZVR5cGUgPSB0eXBlLm5hbWU7XG4gICAgdmFyIG1kTGlrZU5vZGUgPSB7XG4gICAgICAgIHR5cGU6IG5vZGVUeXBlLFxuICAgICAgICB3eXNpd3lnTm9kZTogdHJ1ZSxcbiAgICAgICAgbGl0ZXJhbDogIWlzQ29udGFpbmVyKG5vZGVUeXBlKSAmJiBpc1BtTm9kZShub2RlKSA/IG5vZGUudGV4dENvbnRlbnQgOiBudWxsLFxuICAgIH07XG4gICAgdmFyIG5vZGVUeXBlTWFwID0ge1xuICAgICAgICBoZWFkaW5nOiB7IGxldmVsOiBhdHRycy5sZXZlbCB9LFxuICAgICAgICBsaW5rOiB7IGRlc3RpbmF0aW9uOiBhdHRycy5saW5rVXJsLCB0aXRsZTogYXR0cnMudGl0bGUgfSxcbiAgICAgICAgaW1hZ2U6IHsgZGVzdGluYXRpb246IGF0dHJzLmltYWdlVXJsIH0sXG4gICAgICAgIGNvZGVCbG9jazogeyBpbmZvOiBhdHRycy5sYW5ndWFnZSB9LFxuICAgICAgICBidWxsZXRMaXN0OiB7IHR5cGU6ICdsaXN0JywgbGlzdERhdGE6IHsgdHlwZTogJ2J1bGxldCcgfSB9LFxuICAgICAgICBvcmRlcmVkTGlzdDogeyB0eXBlOiAnbGlzdCcsIGxpc3REYXRhOiB7IHR5cGU6ICdvcmRlcmVkJywgc3RhcnQ6IGF0dHJzLm9yZGVyIH0gfSxcbiAgICAgICAgbGlzdEl0ZW06IHsgdHlwZTogJ2l0ZW0nLCBsaXN0RGF0YTogeyB0YXNrOiBhdHRycy50YXNrLCBjaGVja2VkOiBhdHRycy5jaGVja2VkIH0gfSxcbiAgICAgICAgdGFibGVIZWFkQ2VsbDogeyB0eXBlOiAndGFibGVDZWxsJywgY2VsbFR5cGU6ICdoZWFkJywgYWxpZ246IGF0dHJzLmFsaWduIH0sXG4gICAgICAgIHRhYmxlQm9keUNlbGw6IHsgdHlwZTogJ3RhYmxlQ2VsbCcsIGNlbGxUeXBlOiAnYm9keScsIGFsaWduOiBhdHRycy5hbGlnbiB9LFxuICAgICAgICBjdXN0b21CbG9jazogeyBpbmZvOiBhdHRycy5pbmZvIH0sXG4gICAgfTtcbiAgICB2YXIgbm9kZUluZm8gPSBub2RlVHlwZU1hcFtub2RlVHlwZV07XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIG1kTGlrZU5vZGUpLCBub2RlSW5mbyk7XG4gICAgLy8gaHRtbCBibG9jaywgaW5saW5lIG5vZGVcbiAgICB2YXIgX2EgPSBub2RlLmF0dHJzLCBodG1sQXR0cnMgPSBfYS5odG1sQXR0cnMsIGNoaWxkcmVuSFRNTCA9IF9hLmNoaWxkcmVuSFRNTDtcbiAgICBpZiAoaHRtbEF0dHJzKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGF0dHJpYnV0ZXMpLCB7IGF0dHJzOiBodG1sQXR0cnMsIGNoaWxkcmVuSFRNTDogY2hpbGRyZW5IVE1MIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn1cblxudmFyIHRva2VuVG9ET01Ob2RlID0ge1xuICAgIG9wZW5UYWc6IGZ1bmN0aW9uICh0b2tlbiwgc3RhY2spIHtcbiAgICAgICAgdmFyIF9hID0gdG9rZW4sIHRhZ05hbWUgPSBfYS50YWdOYW1lLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcywgYXR0cmlidXRlcyA9IF9hLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGF0dHJzID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhdHRycyksIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHNldEF0dHJpYnV0ZXMoYXR0cnMsIGVsKTtcbiAgICAgICAgc3RhY2sucHVzaChlbCk7XG4gICAgfSxcbiAgICBjbG9zZVRhZzogZnVuY3Rpb24gKF8sIHN0YWNrKSB7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3QkMShzdGFjaykuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBodG1sOiBmdW5jdGlvbiAodG9rZW4sIHN0YWNrKSB7XG4gICAgICAgIGxhc3QkMShzdGFjaykuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB0b2tlbi5jb250ZW50KTtcbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uICh0b2tlbiwgc3RhY2spIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4uY29udGVudCk7XG4gICAgICAgIGxhc3QkMShzdGFjaykuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIH0sXG59O1xudmFyIFd3VG9ET01BZGFwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFd3VG9ET01BZGFwdG9yKGxpbmtBdHRyaWJ1dGVzLCBjdXN0b21SZW5kZXJlcikge1xuICAgICAgICB2YXIgY29udmVydG9ycyA9IGdldEhUTUxSZW5kZXJDb252ZXJ0b3JzKGxpbmtBdHRyaWJ1dGVzLCBjdXN0b21SZW5kZXJlcik7XG4gICAgICAgIHZhciBjdXN0b21IVE1MQ29udmVydG9yID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBjdXN0b21SZW5kZXJlci5odG1sQmxvY2spLCBjdXN0b21SZW5kZXJlci5odG1sSW5saW5lKTtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgaHRtbCBibG9jaywgaW5saW5lIGNvbnZlcnRvciB0byBvdGhlciBjdXN0b20gY29udmVydG9yc1xuICAgICAgICB0aGlzLmN1c3RvbUNvbnZlcnRvcktleXMgPSBPYmplY3Qua2V5cyhjdXN0b21SZW5kZXJlcikuY29uY2F0KE9iamVjdC5rZXlzKGN1c3RvbUhUTUxDb252ZXJ0b3IpKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcih7XG4gICAgICAgICAgICBnZm06IHRydWUsXG4gICAgICAgICAgICBjb252ZXJ0b3JzOiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGNvbnZlcnRvcnMpLCBjdXN0b21IVE1MQ29udmVydG9yKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29udmVydG9ycyA9IHRoaXMucmVuZGVyZXIuZ2V0Q29udmVydG9ycygpO1xuICAgIH1cbiAgICBXd1RvRE9NQWRhcHRvci5wcm90b3R5cGUuZ2VuZXJhdGVUb2tlbnMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbWRMaWtlTm9kZSA9IGNyZWF0ZU1kTGlrZU5vZGUobm9kZSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgZW50ZXJpbmc6IHRydWUsXG4gICAgICAgICAgICBsZWFmOiBpc1BtTm9kZShub2RlKSA/IG5vZGUuaXNMZWFmIDogZmFsc2UsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLnJlbmRlcmVyLmdldE9wdGlvbnMoKSxcbiAgICAgICAgICAgIGdldENoaWxkcmVuVGV4dDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKGlzUG1Ob2RlKG5vZGUpID8gbm9kZS50ZXh0Q29udGVudCA6ICcnKTsgfSxcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzLmNvbnZlcnRvcnNbbm9kZS50eXBlLm5hbWVdO1xuICAgICAgICB2YXIgY29udmVydGVkID0gY29udmVydG9yKG1kTGlrZU5vZGUsIGNvbnRleHQsIHRoaXMuY29udmVydG9ycyk7XG4gICAgICAgIHZhciB0b2tlbnMgPSBpc0FycmF5XzEoY29udmVydGVkKSA/IGNvbnZlcnRlZCA6IFtjb252ZXJ0ZWRdO1xuICAgICAgICBpZiAoaXNDb250YWluZXIobm9kZS50eXBlLm5hbWUpIHx8IG5vZGUuYXR0cnMuaHRtbElubGluZSkge1xuICAgICAgICAgICAgY29udGV4dC5lbnRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IGlzUG1Ob2RlKG5vZGUpID8gbm9kZS50ZXh0Q29udGVudCA6ICcnIH0pO1xuICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChjb252ZXJ0b3IobWRMaWtlTm9kZSwgY29udGV4dCwgdGhpcy5jb252ZXJ0b3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuICAgIFd3VG9ET01BZGFwdG9yLnByb3RvdHlwZS50b0RPTU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5nZW5lcmF0ZVRva2Vucyhub2RlKTtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5Ub0RPTU5vZGVbdG9rZW4udHlwZV0odG9rZW4sIHN0YWNrKTsgfSk7XG4gICAgICAgIHJldHVybiBzdGFja1swXTtcbiAgICB9O1xuICAgIFd3VG9ET01BZGFwdG9yLnByb3RvdHlwZS5nZXRUb0RPTU5vZGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5jdXN0b21Db252ZXJ0b3JLZXlzLCBuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9ET01Ob2RlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gV3dUb0RPTUFkYXB0b3I7XG59KCkpO1xuXG52YXIgQU5JTUFUSU9OX1RJTUUgPSAxMDA7XG52YXIgU0NST0xMX0JMT0NLSU5HX1JFU0VUX0RFTEFZID0gMTU7XG52YXIgY3VycmVudFRpbWVvdXRJZCA9IG51bGw7XG52YXIgcmVsZWFzZVRpbWVyID0gbnVsbDtcbmZ1bmN0aW9uIHJ1bihkZWx0YVNjcm9sbFRvcCwgX2EpIHtcbiAgICB2YXIgc3luY1Njcm9sbFRvcCA9IF9hLnN5bmNTY3JvbGxUb3AsIHJlbGVhc2VFdmVudEJsb2NrID0gX2EucmVsZWFzZUV2ZW50QmxvY2s7XG4gICAgaWYgKHJlbGVhc2VUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQocmVsZWFzZVRpbWVyKTtcbiAgICB9XG4gICAgc3luY1Njcm9sbFRvcChkZWx0YVNjcm9sbFRvcCk7XG4gICAgcmVsZWFzZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbGVhc2VFdmVudEJsb2NrKCk7XG4gICAgfSwgU0NST0xMX0JMT0NLSU5HX1JFU0VUX0RFTEFZKTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGUoY3VyU2Nyb2xsVG9wLCB0YXJnZXRTY3JvbGxUb3AsIHN5bmNDYWxsYmFja3MpIHtcbiAgICB2YXIgZGlmZiA9IHRhcmdldFNjcm9sbFRvcCAtIGN1clNjcm9sbFRvcDtcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHByb2dyZXNzID0gKHN0ZXBUaW1lIC0gc3RhcnRUaW1lKSAvIEFOSU1BVElPTl9USU1FO1xuICAgICAgICB2YXIgZGVsdGFWYWx1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjdXJyZW50VGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgICAgICBkZWx0YVZhbHVlID0gY3VyU2Nyb2xsVG9wICsgZGlmZiAqIE1hdGguY29zKCgoMSAtIHByb2dyZXNzKSAqIE1hdGguUEkpIC8gMik7XG4gICAgICAgICAgICBydW4oTWF0aC5jZWlsKGRlbHRhVmFsdWUpLCBzeW5jQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcnVuKHRhcmdldFNjcm9sbFRvcCwgc3luY0NhbGxiYWNrcyk7XG4gICAgICAgICAgICBjdXJyZW50VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc3RlcCgpO1xufVxuXG52YXIgRURJVE9SX0JPVFRPTV9QQURESU5HID0gMTg7XG52YXIgU2Nyb2xsU3luYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxTeW5jKG1kRWRpdG9yLCBwcmV2aWV3LCBldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgdGhpcy5sYXRlc3RFZGl0b3JTY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFByZXZpZXdTY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICB0aGlzLmJsb2NrZWRTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgcHJldmlld1Jvb3QgPSBwcmV2aWV3LnByZXZpZXdDb250ZW50LCBwcmV2aWV3RWwgPSBwcmV2aWV3LmVsO1xuICAgICAgICB0aGlzLnByZXZpZXdSb290ID0gcHJldmlld1Jvb3Q7XG4gICAgICAgIHRoaXMucHJldmlld0VsID0gcHJldmlld0VsO1xuICAgICAgICB0aGlzLm1kRWRpdG9yID0gbWRFZGl0b3I7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldyA9IG1kRWRpdG9yLnZpZXc7XG4gICAgICAgIHRoaXMudG9hc3RNYXJrID0gbWRFZGl0b3IuZ2V0VG9hc3RNYXJrKCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmFkZFNjcm9sbFN5bmNFdmVudCgpO1xuICAgIH1cbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5hZGRTY3JvbGxTeW5jRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignYWZ0ZXJQcmV2aWV3UmVuZGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdhZnRlclByZXZpZXdSZW5kZXInIGV2ZW50IGhhcyBvY2N1cnJlZCxcbiAgICAgICAgICAgIC8vIGJyb3dzZXIgcmVuZGVyaW5nIGlzIG5vdCB5ZXQgY29tcGxldGUuXG4gICAgICAgICAgICAvLyBTbyB0aGUgc2l6ZSBvZiBlbGVtZW50cyBjYW4gbm90IGJlIGFjY3VyYXRlbHkgbWVhc3VyZWQuXG4gICAgICAgICAgICBfdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN5bmNQcmV2aWV3U2Nyb2xsVG9wKHRydWUpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbignc2Nyb2xsJywgZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2VkaXRvcicgJiYgX3RoaXMuYmxvY2tlZFNjcm9sbCAhPT0gJ2VkaXRvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3luY1ByZXZpZXdTY3JvbGxUb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3ByZXZpZXcnICYmIF90aGlzLmJsb2NrZWRTY3JvbGwgIT09ICdwcmV2aWV3Jykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zeW5jRWRpdG9yU2Nyb2xsVG9wKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbigndG9nZ2xlU2Nyb2xsU3luYycsIGZ1bmN0aW9uIChhY3RpdmUpIHtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5nZXRNZE5vZGVBdFBvcyA9IGZ1bmN0aW9uIChkb2MsIHBvc0luZm8pIHtcbiAgICAgICAgdmFyIGluZGV4SW5mbyA9IGRvYy5jb250ZW50LmZpbmRJbmRleChwb3NJbmZvLnBvcyk7XG4gICAgICAgIHZhciBsaW5lID0gaW5kZXhJbmZvLmluZGV4O1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShsaW5lICsgMSk7XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5nZXRTY3JvbGxUb3BCeUNhcmV0UG9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5tZEVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIGZpcnN0TWROb2RlID0gdGhpcy50b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShwb3NbMF1bMF0pO1xuICAgICAgICB2YXIgcHJldmlld0hlaWdodCA9IHRoaXMucHJldmlld0VsLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGVsID0gZ2V0UGFyZW50Tm9kZU9iaih0aGlzLnByZXZpZXdSb290LCBmaXJzdE1kTm9kZSkuZWw7XG4gICAgICAgIHZhciB0b3RhbE9mZnNldFRvcCA9IGdldFRvdGFsT2Zmc2V0VG9wKGVsLCB0aGlzLnByZXZpZXdSb290KSB8fCBlbC5vZmZzZXRUb3A7XG4gICAgICAgIHZhciBub2RlSGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAvLyBtdWx0aXBseSAwLjUgZm9yIGNhbGN1bGF0aW5nIHRoZSBwb3NpdGlvbiBpbiB0aGUgbWlkZGxlIG9mIHByZXZpZXcgYXJlYVxuICAgICAgICB2YXIgdGFyZ2V0U2Nyb2xsVG9wID0gdG90YWxPZmZzZXRUb3AgKyBub2RlSGVpZ2h0IC0gcHJldmlld0hlaWdodCAqIDAuNTtcbiAgICAgICAgdGhpcy5sYXRlc3RFZGl0b3JTY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICB2YXIgZGlmZiA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHRoaXMucHJldmlld0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCBwcmV2aWV3SGVpZ2h0ID8gbnVsbCA6IHRhcmdldFNjcm9sbFRvcDtcbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLnN5bmNQcmV2aWV3U2Nyb2xsVG9wID0gZnVuY3Rpb24gKGVkaXRpbmcpIHtcbiAgICAgICAgaWYgKGVkaXRpbmcgPT09IHZvaWQgMCkgeyBlZGl0aW5nID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgZWRpdG9yVmlldyA9IF9hLmVkaXRvclZpZXcsIHByZXZpZXdFbCA9IF9hLnByZXZpZXdFbCwgcHJldmlld1Jvb3QgPSBfYS5wcmV2aWV3Um9vdDtcbiAgICAgICAgdmFyIF9iID0gZWRpdG9yVmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxlZnQgPSBfYi5sZWZ0LCB0b3AgPSBfYi50b3A7XG4gICAgICAgIHZhciBwb3NJbmZvID0gZWRpdG9yVmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH0pO1xuICAgICAgICB2YXIgZG9jID0gZWRpdG9yVmlldy5zdGF0ZS5kb2M7XG4gICAgICAgIHZhciBmaXJzdE1kTm9kZSA9IHRoaXMuZ2V0TWROb2RlQXRQb3MoZG9jLCBwb3NJbmZvKTtcbiAgICAgICAgaWYgKCFmaXJzdE1kTm9kZSB8fCBpc0hUTUxOb2RlKGZpcnN0TWROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJTY3JvbGxUb3AgPSBwcmV2aWV3RWwuc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgX2MgPSBlZGl0b3JWaWV3LmRvbSwgc2Nyb2xsVG9wID0gX2Muc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQgPSBfYy5zY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCA9IF9jLmNsaWVudEhlaWdodCwgY2hpbGRyZW4gPSBfYy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGlzQm90dG9tUG9zID0gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIDw9IGNsaWVudEhlaWdodCArIEVESVRPUl9CT1RUT01fUEFERElORztcbiAgICAgICAgdmFyIHRhcmdldFNjcm9sbFRvcCA9IGlzQm90dG9tUG9zID8gcHJldmlld0VsLnNjcm9sbEhlaWdodCA6IDA7XG4gICAgICAgIGlmIChzY3JvbGxUb3AgJiYgIWlzQm90dG9tUG9zKSB7XG4gICAgICAgICAgICBpZiAoZWRpdGluZykge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3BCeUVkaXRpbmcgPSB0aGlzLmdldFNjcm9sbFRvcEJ5Q2FyZXRQb3MoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjcm9sbFRvcEJ5RWRpdGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldFNjcm9sbFRvcCA9IHNjcm9sbFRvcEJ5RWRpdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IGdldFBhcmVudE5vZGVPYmoodGhpcy5wcmV2aWV3Um9vdCwgZmlyc3RNZE5vZGUpLCBlbCA9IF9kLmVsLCBtZE5vZGUgPSBfZC5tZE5vZGU7XG4gICAgICAgICAgICAgICAgdmFyIF9lID0gZ2V0RWRpdG9yUmFuZ2VIZWlnaHRJbmZvKGRvYywgbWROb2RlLCBjaGlsZHJlbiksIGhlaWdodCA9IF9lLmhlaWdodCwgcmVjdCA9IF9lLnJlY3Q7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsT2Zmc2V0VG9wID0gZ2V0VG90YWxPZmZzZXRUb3AoZWwsIHByZXZpZXdSb290KSB8fCBlbC5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVIZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gdG9wID4gcmVjdC50b3AgPyBNYXRoLm1pbigodG9wIC0gcmVjdC50b3ApIC8gaGVpZ2h0LCAxKSA6IDA7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsVG9wID0gdG90YWxPZmZzZXRUb3AgKyBub2RlSGVpZ2h0ICogcmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRTY3JvbGxUb3AgPSB0aGlzLmdldFJlc29sdmVkU2Nyb2xsVG9wKCdlZGl0b3InLCBzY3JvbGxUb3AsIHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0RWRpdG9yU2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRTY3JvbGxUb3AgIT09IGN1clNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5ydW4oJ2VkaXRvcicsIHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUuc3luY0VkaXRvclNjcm9sbFRvcCA9IGZ1bmN0aW9uICh0YXJnZXROb2RlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaywgZWRpdG9yVmlldyA9IF9hLmVkaXRvclZpZXcsIHByZXZpZXdSb290ID0gX2EucHJldmlld1Jvb3QsIHByZXZpZXdFbCA9IF9hLnByZXZpZXdFbDtcbiAgICAgICAgdmFyIGRvbSA9IGVkaXRvclZpZXcuZG9tLCBzdGF0ZSA9IGVkaXRvclZpZXcuc3RhdGU7XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSBwcmV2aWV3RWwuc2Nyb2xsVG9wLCBjbGllbnRIZWlnaHQgPSBwcmV2aWV3RWwuY2xpZW50SGVpZ2h0LCBzY3JvbGxIZWlnaHQgPSBwcmV2aWV3RWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB2YXIgaXNCb3R0b21Qb3MgPSBzY3JvbGxIZWlnaHQgLSBzY3JvbGxUb3AgPD0gY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgY3VyU2Nyb2xsVG9wID0gZG9tLnNjcm9sbFRvcDtcbiAgICAgICAgdmFyIHRhcmdldFNjcm9sbFRvcCA9IGlzQm90dG9tUG9zID8gZG9tLnNjcm9sbEhlaWdodCA6IDA7XG4gICAgICAgIGlmIChzY3JvbGxUb3AgJiYgdGFyZ2V0Tm9kZSAmJiAhaXNCb3R0b21Qb3MpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSBmaW5kQW5jZXN0b3JIYXZpbmdJZCh0YXJnZXROb2RlLCBwcmV2aWV3Um9vdCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZG9tLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIG1kTm9kZUlkID0gTnVtYmVyKHRhcmdldE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpKTtcbiAgICAgICAgICAgIHZhciBfYiA9IGdldFBhcmVudE5vZGVPYmoodGhpcy5wcmV2aWV3Um9vdCwgdG9hc3RNYXJrLmZpbmROb2RlQnlJZChtZE5vZGVJZCkpLCBtZE5vZGUgPSBfYi5tZE5vZGUsIGVsID0gX2IuZWw7XG4gICAgICAgICAgICB2YXIgbWROb2RlU3RhcnRMaW5lID0gZ2V0TWRTdGFydExpbmUobWROb2RlKTtcbiAgICAgICAgICAgIHRhcmdldFNjcm9sbFRvcCA9IGNoaWxkcmVuW21kTm9kZVN0YXJ0TGluZSAtIDFdLm9mZnNldFRvcDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBnZXRFZGl0b3JSYW5nZUhlaWdodEluZm8oc3RhdGUuZG9jLCBtZE5vZGUsIGNoaWxkcmVuKS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgX2MgPSBnZXRBbmRTYXZlT2Zmc2V0SW5mbyhlbCwgcHJldmlld1Jvb3QsIG1kTm9kZUlkKSwgbm9kZUhlaWdodCA9IF9jLm5vZGVIZWlnaHQsIG9mZnNldFRvcCA9IF9jLm9mZnNldFRvcDtcbiAgICAgICAgICAgIHRhcmdldFNjcm9sbFRvcCArPSBnZXRBZGRpdGlvbmFsUG9zKHNjcm9sbFRvcCwgb2Zmc2V0VG9wLCBub2RlSGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsVG9wID0gdGhpcy5nZXRSZXNvbHZlZFNjcm9sbFRvcCgncHJldmlldycsIHNjcm9sbFRvcCwgdGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RQcmV2aWV3U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRTY3JvbGxUb3AgIT09IGN1clNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5ydW4oJ3ByZXZpZXcnLCB0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLmdldFJlc29sdmVkU2Nyb2xsVG9wID0gZnVuY3Rpb24gKGZyb20sIHNjcm9sbFRvcCwgdGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApIHtcbiAgICAgICAgdmFyIGxhdGVzdFNjcm9sbFRvcCA9IGZyb20gPT09ICdlZGl0b3InID8gdGhpcy5sYXRlc3RFZGl0b3JTY3JvbGxUb3AgOiB0aGlzLmxhdGVzdFByZXZpZXdTY3JvbGxUb3A7XG4gICAgICAgIGlmIChsYXRlc3RTY3JvbGxUb3AgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRTY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhdGVzdFNjcm9sbFRvcCA8IHNjcm9sbFRvcFxuICAgICAgICAgICAgPyBNYXRoLm1heCh0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcClcbiAgICAgICAgICAgIDogTWF0aC5taW4odGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApO1xuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZyb20sIHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIGlmIChmcm9tID09PSAnZWRpdG9yJykge1xuICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gdGhpcy5wcmV2aWV3RWw7XG4gICAgICAgICAgICB0aGlzLmJsb2NrZWRTY3JvbGwgPSAncHJldmlldyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSB0aGlzLmVkaXRvclZpZXcuZG9tO1xuICAgICAgICAgICAgdGhpcy5ibG9ja2VkU2Nyb2xsID0gJ2VkaXRvcic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN5bmNDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBzeW5jU2Nyb2xsVG9wOiBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7IHJldHVybiAoc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCA9IHNjcm9sbFRvcCk7IH0sXG4gICAgICAgICAgICByZWxlYXNlRXZlbnRCbG9jazogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmJsb2NrZWRTY3JvbGwgPSBudWxsKTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgYW5pbWF0ZShjdXJTY3JvbGxUb3AsIHRhcmdldFNjcm9sbFRvcCwgc3luY0NhbGxiYWNrcyk7XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5jbGVhclRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIoJ3Njcm9sbCcpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIoJ2FmdGVyUHJldmlld1JlbmRlcicpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbFN5bmM7XG59KCkpO1xuXG52YXIgcXVlcnlNYXAgPSB7XG4gICAgZ2V0UG9wdXBJbml0aWFsVmFsdWVzOiBmdW5jdGlvbiAoZWRpdG9yLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBwb3B1cE5hbWUgPSBwYXlsb2FkLnBvcHVwTmFtZTtcbiAgICAgICAgcmV0dXJuIHBvcHVwTmFtZSA9PT0gJ2xpbmsnID8geyBsaW5rVGV4dDogZWRpdG9yLmdldFNlbGVjdGVkVGV4dCgpIH0gOiB7fTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGJ1aWxkUXVlcnkoZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3F1ZXJ5JywgZnVuY3Rpb24gKHF1ZXJ5LCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBxdWVyeU1hcFtxdWVyeV0oZWRpdG9yLCBwYXlsb2FkKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBUb2FzdFVJRWRpdG9yQ29yZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uIG9iamVjdFxuICogICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuZWwgLSBjb250YWluZXIgZWxlbWVudFxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5oZWlnaHQ9JzMwMHB4J10gLSBFZGl0b3IncyBoZWlnaHQgc3R5bGUgdmFsdWUuIEhlaWdodCBpcyBhcHBsaWVkIGFzIGJvcmRlci1ib3ggZXgpICczMDBweCcsICcxMDAlJywgJ2F1dG8nXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1pbkhlaWdodD0nMjAwcHgnXSAtIEVkaXRvcidzIG1pbi1oZWlnaHQgc3R5bGUgdmFsdWUgaW4gcGl4ZWwgZXgpICczMDBweCdcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5pdGlhbFZhbHVlXSAtIEVkaXRvcidzIGluaXRpYWwgdmFsdWVcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJldmlld1N0eWxlXSAtIE1hcmtkb3duIGVkaXRvcidzIHByZXZpZXcgc3R5bGUgKHRhYiwgdmVydGljYWwpXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcmV2aWV3SGlnaGxpZ2h0ID0gdHJ1ZV0gLSBIaWdobGlnaHQgYSBwcmV2aWV3IGVsZW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIGN1cnNvciBwb3NpdGlvbiBpbiB0aGUgbWFya2Rvd24gZWRpdG9yXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmluaXRpYWxFZGl0VHlwZV0gLSBJbml0aWFsIGVkaXRvciB0eXBlIChtYXJrZG93biwgd3lzaXd5ZylcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXZlbnRzXSAtIEV2ZW50c1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMubG9hZF0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGZ1bGx5IGxvYWRcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmNoYW5nZV0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gY29udGVudCBjaGFuZ2VkXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5jYXJldENoYW5nZV0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZm9ybWF0IGNoYW5nZSBieSBjdXJzb3IgcG9zaXRpb25cbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmZvY3VzXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgZ2V0IGZvY3VzXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5ibHVyXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgbG9vc2UgZm9jdXNcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmtleWRvd25dIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIHRoZSBrZXkgaXMgcHJlc3NlZCBpbiBlZGl0b3JcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmtleXVwXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiB0aGUga2V5IGlzIHJlbGVhc2VkIGluIGVkaXRvclxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuYmVmb3JlUHJldmlld1JlbmRlcl0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIGJlZm9yZSByZW5kZXJpbmcgdGhlIG1hcmtkb3duIHByZXZpZXcgd2l0aCBodG1sIHN0cmluZ1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuYmVmb3JlQ29udmVydFd5c2l3eWdUb01hcmtkb3duXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgYmVmb3JlIGNvbnZlcnRpbmcgd3lzaXd5ZyB0byBtYXJrZG93biB3aXRoIG1hcmtkb3duIHRleHRcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaG9va3NdIC0gSG9va3NcbiAqICAgICAgICAgQHBhcmFtIHthZGRJbWFnZUJsb2JIb29rfSBbb3B0aW9ucy5ob29rcy5hZGRJbWFnZUJsb2JIb29rXSAtIGhvb2sgZm9yIGltYWdlIHVwbG9hZFxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nZW4tVVMnXSAtIGxhbmd1YWdlXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VDb21tYW5kU2hvcnRjdXQ9dHJ1ZV0gLSB3aGV0aGVyIHVzZSBrZXlib2FyZCBzaG9ydGN1dHMgdG8gcGVyZm9ybSBjb21tYW5kc1xuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudXNhZ2VTdGF0aXN0aWNzPXRydWVdIC0gc2VuZCBob3N0bmFtZSB0byBnb29nbGUgYW5hbHl0aWNzXG4gKiAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nfHRvb2xiYXJJdGVtc1ZhbHVlPn0gW29wdGlvbnMudG9vbGJhckl0ZW1zXSAtIHRvb2xiYXIgaXRlbXMuXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5oaWRlTW9kZVN3aXRjaD1mYWxzZV0gLSBoaWRlIG1vZGUgc3dpdGNoIHRhYiBiYXJcbiAqICAgICBAcGFyYW0ge0FycmF5LjxmdW5jdGlvbnxBcnJheT59IFtvcHRpb25zLnBsdWdpbnNdIC0gQXJyYXkgb2YgcGx1Z2lucy4gQSBwbHVnaW4gY2FuIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5IGluIHRoZSBmb3JtIG9mIFtmdW5jdGlvbiwgb3B0aW9uc10uXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuZGVkQXV0b2xpbmtzXSAtIFVzaW5nIGV4dGVuZGVkIEF1dG9saW5rcyBzcGVjaWZpZWQgaW4gR0ZNIHNwZWNcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGxhY2Vob2xkZXJdIC0gVGhlIHBsYWNlaG9sZGVyIHRleHQgb2YgdGhlIGVkaXRhYmxlIGVsZW1lbnQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxpbmtBdHRyaWJ1dGVzXSAtIEF0dHJpYnV0ZXMgb2YgYW5jaG9yIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVsLCB0YXJnZXQsIGhyZWZsYW5nLCB0eXBlXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlcj1udWxsXSAtIE9iamVjdCBjb250YWluaW5nIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbnMgY29ycmVzcG9uZCB0byBjaGFuZ2UgbWFya2Rvd24gbm9kZSB0byBwcmV2aWV3IEhUTUwgb3Igd3lzaXd5ZyBub2RlXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmN1c3RvbU1hcmtkb3duUmVuZGVyZXI9bnVsbF0gLSBPYmplY3QgY29udGFpbmluZyBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb25zIGNvcnJlc3BvbmQgdG8gY2hhbmdlIHd5c2l3eWcgbm9kZSB0byBtYXJrZG93biB0ZXh0XG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uPWZhbHNlXSAtIHdoZXRoZXIgdXNlIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGxpbmsgcmVmZXJlbmNlIGRlZmluaXRpb25cbiAqICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5jdXN0b21IVE1MU2FuaXRpemVyPW51bGxdIC0gY3VzdG9tIEhUTUwgc2FuaXRpemVyXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcmV2aWV3SGlnaGxpZ2h0PWZhbHNlXSAtIHdoZXRoZXIgaGlnaGxpZ2h0IHByZXZpZXcgYXJlYVxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZnJvbnRNYXR0ZXI9ZmFsc2VdIC0gd2hldGhlciB1c2UgdGhlIGZyb250IG1hdHRlclxuICogICAgIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IFtvcHRpb25zLndpZGdldFJ1bGVzPVtdXSAtIFRoZSBydWxlcyBmb3IgcmVwbGFjaW5nIHRoZSB0ZXh0IHdpdGggd2lkZ2V0IG5vZGVcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGhlbWVdIC0gVGhlIHRoZW1lIHRvIHN0eWxlIHRoZSBlZGl0b3Igd2l0aC4gVGhlIGRlZmF1bHQgaXMgaW5jbHVkZWQgaW4gdG9hc3R1aS1lZGl0b3IuY3NzLlxuICogICAgIEBwYXJhbSB7YXV0b2ZvY3VzfSBbb3B0aW9ucy5hdXRvZm9jdXM9dHJ1ZV0gLSBhdXRvbWF0aWNhbGx5IGZvY3VzIHRoZSBlZGl0b3Igb24gY3JlYXRpb24uXG4gKi9cbnZhciBUb2FzdFVJRWRpdG9yQ29yZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2FzdFVJRWRpdG9yQ29yZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5pdGlhbEhUTUwgPSBvcHRpb25zLmVsLmlubmVySFRNTDtcbiAgICAgICAgb3B0aW9ucy5lbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kXzEoe1xuICAgICAgICAgICAgcHJldmlld1N0eWxlOiAndGFiJyxcbiAgICAgICAgICAgIHByZXZpZXdIaWdobGlnaHQ6IHRydWUsXG4gICAgICAgICAgICBpbml0aWFsRWRpdFR5cGU6ICdtYXJrZG93bicsXG4gICAgICAgICAgICBoZWlnaHQ6ICczMDBweCcsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6ICcyMDBweCcsXG4gICAgICAgICAgICBsYW5ndWFnZTogJ2VuLVVTJyxcbiAgICAgICAgICAgIHVzZUNvbW1hbmRTaG9ydGN1dDogdHJ1ZSxcbiAgICAgICAgICAgIHVzYWdlU3RhdGlzdGljczogdHJ1ZSxcbiAgICAgICAgICAgIHRvb2xiYXJJdGVtczogW1xuICAgICAgICAgICAgICAgIFsnaGVhZGluZycsICdib2xkJywgJ2l0YWxpYycsICdzdHJpa2UnXSxcbiAgICAgICAgICAgICAgICBbJ2hyJywgJ3F1b3RlJ10sXG4gICAgICAgICAgICAgICAgWyd1bCcsICdvbCcsICd0YXNrJywgJ2luZGVudCcsICdvdXRkZW50J10sXG4gICAgICAgICAgICAgICAgWyd0YWJsZScsICdpbWFnZScsICdsaW5rJ10sXG4gICAgICAgICAgICAgICAgWydjb2RlJywgJ2NvZGVibG9jayddLFxuICAgICAgICAgICAgICAgIFsnc2Nyb2xsU3luYyddLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGhpZGVNb2RlU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBudWxsLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFJlbmRlcmVyOiBudWxsLFxuICAgICAgICAgICAgY3VzdG9tTWFya2Rvd25SZW5kZXJlcjogbnVsbCxcbiAgICAgICAgICAgIHJlZmVyZW5jZURlZmluaXRpb246IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFNhbml0aXplcjogbnVsbCxcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmYWxzZSxcbiAgICAgICAgICAgIHdpZGdldFJ1bGVzOiBbXSxcbiAgICAgICAgICAgIHRoZW1lOiAnbGlnaHQnLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiB0cnVlLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBjdXN0b21IVE1MUmVuZGVyZXIgPSBfYS5jdXN0b21IVE1MUmVuZGVyZXIsIGV4dGVuZGVkQXV0b2xpbmtzID0gX2EuZXh0ZW5kZWRBdXRvbGlua3MsIHJlZmVyZW5jZURlZmluaXRpb24gPSBfYS5yZWZlcmVuY2VEZWZpbml0aW9uLCBmcm9udE1hdHRlciA9IF9hLmZyb250TWF0dGVyLCBjdXN0b21NYXJrZG93blJlbmRlcmVyID0gX2EuY3VzdG9tTWFya2Rvd25SZW5kZXJlciwgdXNlQ29tbWFuZFNob3J0Y3V0ID0gX2EudXNlQ29tbWFuZFNob3J0Y3V0LCBpbml0aWFsRWRpdFR5cGUgPSBfYS5pbml0aWFsRWRpdFR5cGUsIHdpZGdldFJ1bGVzID0gX2Eud2lkZ2V0UnVsZXMsIGN1c3RvbUhUTUxTYW5pdGl6ZXIgPSBfYS5jdXN0b21IVE1MU2FuaXRpemVyO1xuICAgICAgICB0aGlzLm1vZGUgPSBpbml0aWFsRWRpdFR5cGUgfHwgJ21hcmtkb3duJztcbiAgICAgICAgdGhpcy5tZFByZXZpZXdTdHlsZSA9IHRoaXMub3B0aW9ucy5wcmV2aWV3U3R5bGU7XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgICAgIHRoaXMuaTE4bi5zZXRDb2RlKHRoaXMub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBzZXRXaWRnZXRSdWxlcyh3aWRnZXRSdWxlcyk7XG4gICAgICAgIHZhciBsaW5rQXR0cmlidXRlcyA9IHNhbml0aXplTGlua0F0dHJpYnV0ZSh0aGlzLm9wdGlvbnMubGlua0F0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLnBsdWdpbkluZm8gPSBnZXRQbHVnaW5JbmZvKHtcbiAgICAgICAgICAgIHBsdWdpbnM6IHRoaXMub3B0aW9ucy5wbHVnaW5zLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiB0aGlzLmV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgIHVzYWdlU3RhdGlzdGljczogdGhpcy5vcHRpb25zLnVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5wbHVnaW5JbmZvLCB0b0hUTUxSZW5kZXJlcnMgPSBfYi50b0hUTUxSZW5kZXJlcnMsIHRvTWFya2Rvd25SZW5kZXJlcnMgPSBfYi50b01hcmtkb3duUmVuZGVyZXJzLCBtZFBsdWdpbnMgPSBfYi5tZFBsdWdpbnMsIHd3UGx1Z2lucyA9IF9iLnd3UGx1Z2lucywgd3dOb2RlVmlld3MgPSBfYi53d05vZGVWaWV3cywgbWRDb21tYW5kcyA9IF9iLm1kQ29tbWFuZHMsIHd3Q29tbWFuZHMgPSBfYi53d0NvbW1hbmRzLCBtYXJrZG93blBhcnNlcnMgPSBfYi5tYXJrZG93blBhcnNlcnM7XG4gICAgICAgIHZhciByZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBsaW5rQXR0cmlidXRlczogbGlua0F0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjdXN0b21IVE1MUmVuZGVyZXI6IGRlZXBNZXJnZWRDb3B5KHRvSFRNTFJlbmRlcmVycywgY3VzdG9tSFRNTFJlbmRlcmVyKSxcbiAgICAgICAgICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBleHRlbmRlZEF1dG9saW5rcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZURlZmluaXRpb246IHJlZmVyZW5jZURlZmluaXRpb24sXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG4gICAgICAgICAgICBzYW5pdGl6ZXI6IGN1c3RvbUhUTUxTYW5pdGl6ZXIgfHwgc2FuaXRpemVIVE1MLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgd3dUb0RPTUFkYXB0b3IgPSBuZXcgV3dUb0RPTUFkYXB0b3IobGlua0F0dHJpYnV0ZXMsIHJlbmRlcmVyT3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXIpO1xuICAgICAgICB2YXIgaHRtbFNjaGVtYU1hcCA9IGNyZWF0ZUhUTUxTY2hlbWFNYXAocmVuZGVyZXJPcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlciwgcmVuZGVyZXJPcHRpb25zLnNhbml0aXplciwgd3dUb0RPTUFkYXB0b3IpO1xuICAgICAgICB0aGlzLnRvYXN0TWFyayA9IG5ldyBUb2FzdE1hcmsoJycsIHtcbiAgICAgICAgICAgIGRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzOiBbJ2JyJywgJ2ltZyddLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGRpc2FsbG93RGVlcEhlYWRpbmc6IHRydWUsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG4gICAgICAgICAgICBjdXN0b21QYXJzZXI6IG1hcmtkb3duUGFyc2VycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWRFZGl0b3IgPSBuZXcgTWRFZGl0b3IodGhpcy5ldmVudEVtaXR0ZXIsIHtcbiAgICAgICAgICAgIHRvYXN0TWFyazogdGhpcy50b2FzdE1hcmssXG4gICAgICAgICAgICB1c2VDb21tYW5kU2hvcnRjdXQ6IHVzZUNvbW1hbmRTaG9ydGN1dCxcbiAgICAgICAgICAgIG1kUGx1Z2luczogbWRQbHVnaW5zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcmV2aWV3ID0gbmV3IE1hcmtkb3duUHJldmlldyh0aGlzLmV2ZW50RW1pdHRlciwgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCByZW5kZXJlck9wdGlvbnMpLCB7IGlzVmlld2VyOiBmYWxzZSwgaGlnaGxpZ2h0OiB0aGlzLm9wdGlvbnMucHJldmlld0hpZ2hsaWdodCB9KSk7XG4gICAgICAgIHRoaXMud3dFZGl0b3IgPSBuZXcgV3lzaXd5Z0VkaXRvcih0aGlzLmV2ZW50RW1pdHRlciwge1xuICAgICAgICAgICAgdG9ET01BZGFwdG9yOiB3d1RvRE9NQWRhcHRvcixcbiAgICAgICAgICAgIHVzZUNvbW1hbmRTaG9ydGN1dDogdXNlQ29tbWFuZFNob3J0Y3V0LFxuICAgICAgICAgICAgaHRtbFNjaGVtYU1hcDogaHRtbFNjaGVtYU1hcCxcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBsaW5rQXR0cmlidXRlcyxcbiAgICAgICAgICAgIHd3UGx1Z2luczogd3dQbHVnaW5zLFxuICAgICAgICAgICAgd3dOb2RlVmlld3M6IHd3Tm9kZVZpZXdzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb252ZXJ0b3IgPSBuZXcgQ29udmVydG9yKHRoaXMud3dFZGl0b3IuZ2V0U2NoZW1hKCksIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgdG9NYXJrZG93blJlbmRlcmVycyksIGN1c3RvbU1hcmtkb3duUmVuZGVyZXIpLCBnZXRIVE1MUmVuZGVyQ29udmVydG9ycyhsaW5rQXR0cmlidXRlcywgcmVuZGVyZXJPcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlciksIHRoaXMuZXZlbnRFbWl0dGVyKTtcbiAgICAgICAgdGhpcy5zZXRNaW5IZWlnaHQodGhpcy5vcHRpb25zLm1pbkhlaWdodCk7XG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KHRoaXMub3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICB0aGlzLnNldE1hcmtkb3duKHRoaXMub3B0aW9ucy5pbml0aWFsVmFsdWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlcih0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRIVE1MKHRoaXMuaW5pdGlhbEhUTUwsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKHRoaXMuZXZlbnRFbWl0dGVyLCB0aGlzLm1kRWRpdG9yLmNvbW1hbmRzLCB0aGlzLnd3RWRpdG9yLmNvbW1hbmRzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tb2RlOyB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2FnZVN0YXRpc3RpY3MpIHtcbiAgICAgICAgICAgIHNlbmRIb3N0TmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsU3luYyA9IG5ldyBTY3JvbGxTeW5jKHRoaXMubWRFZGl0b3IsIHRoaXMucHJldmlldywgdGhpcy5ldmVudEVtaXR0ZXIpO1xuICAgICAgICB0aGlzLmFkZEluaXRFdmVudCgpO1xuICAgICAgICB0aGlzLmFkZEluaXRDb21tYW5kKG1kQ29tbWFuZHMsIHd3Q29tbWFuZHMpO1xuICAgICAgICBidWlsZFF1ZXJ5KHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvb2tzKSB7XG4gICAgICAgICAgICBmb3JFYWNoT3duUHJvcGVydGllc18xKHRoaXMub3B0aW9ucy5ob29rcywgZnVuY3Rpb24gKGZuLCBrZXkpIHsgcmV0dXJuIF90aGlzLmFkZEhvb2soa2V5LCBmbik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgICAgICBmb3JFYWNoT3duUHJvcGVydGllc18xKHRoaXMub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uIChmbiwga2V5KSB7IHJldHVybiBfdGhpcy5vbihrZXksIGZuKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnbG9hZCcsIHRoaXMpO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1N0YXJ0KHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpO1xuICAgIH1cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuYWRkSW5pdEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uKCduZWVkQ2hhbmdlTW9kZScsIHRoaXMuY2hhbmdlTW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbignbG9hZFVJJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmhlaWdodCAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgLy8gNzVweCBlcXVhbHMgZGVmYXVsdCBlZGl0b3IgdWkgaGVpZ2h0IC0gdGhlIGVkaXRpbmcgYXJlYSBoZWlnaHRcbiAgICAgICAgICAgICAgICB2YXIgbWluSGVpZ2h0ID0gTWF0aC5taW4ocGFyc2VJbnQoX3RoaXMubWluSGVpZ2h0LCAxMCksIHBhcnNlSW50KF90aGlzLmhlaWdodCwgMTApIC0gNzUpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldE1pbkhlaWdodChtaW5IZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWRkRGVmYXVsdEltYWdlQmxvYkhvb2sodGhpcy5ldmVudEVtaXR0ZXIpO1xuICAgIH07XG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmFkZEluaXRDb21tYW5kID0gZnVuY3Rpb24gKG1kQ29tbWFuZHMsIHd3Q29tbWFuZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFkZFBsdWdpbkNvbW1hbmRzID0gZnVuY3Rpb24gKHR5cGUsIGNvbW1hbmRNYXApIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbW1hbmRNYXApLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRDb21tYW5kKHR5cGUsIG5hbWUsIGNvbW1hbmRNYXBbbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCgnbWFya2Rvd24nLCAndG9nZ2xlU2Nyb2xsU3luYycsIGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndG9nZ2xlU2Nyb2xsU3luYycsIHBheWxvYWQuYWN0aXZlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkUGx1Z2luQ29tbWFuZHMoJ21hcmtkb3duJywgbWRDb21tYW5kcyk7XG4gICAgICAgIGFkZFBsdWdpbkNvbW1hbmRzKCd3eXNpd3lnJywgd3dDb21tYW5kcyk7XG4gICAgfTtcbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0Q3VycmVudE1vZGVFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc01hcmtkb3duTW9kZSgpID8gdGhpcy5tZEVkaXRvciA6IHRoaXMud3dFZGl0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBtZXRob2QgZm9yIEVkaXRvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbiBmb3IgaW5pdGlhbGl6ZSBUVUlFZGl0b3JcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUb2FzdFVJRWRpdG9yQ29yZSBvciBUb2FzdFVJRWRpdG9yVmlld2VyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUuZmFjdG9yeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnZpZXdlciA/IG5ldyBUb2FzdFVJRWRpdG9yVmlld2VyKG9wdGlvbnMpIDogbmV3IFRvYXN0VUlFZGl0b3JDb3JlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGxhbmd1YWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNvZGUgLSBjb2RlIGZvciBJMThOIGxhbmd1YWdlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBsYW5ndWFnZSBzZXRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5zZXRMYW5ndWFnZSA9IGZ1bmN0aW9uIChjb2RlLCBkYXRhKSB7XG4gICAgICAgIGkxOG4uc2V0TGFuZ3VhZ2UoY29kZSwgZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjaGFuZ2UgcHJldmlldyBzdHlsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSAtICd0YWInfCd2ZXJ0aWNhbCdcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuY2hhbmdlUHJldmlld1N0eWxlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm1kUHJldmlld1N0eWxlICE9PSBzdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5tZFByZXZpZXdTdHlsZSA9IHN0eWxlO1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlUHJldmlld1N0eWxlJywgc3R5bGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBleGVjdXRlIGVkaXRvciBjb21tYW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBjb21tYW5kIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BheWxvYWRdIC0gcGF5bG9hZCBmb3IgY29tbWFuZFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKG5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kTWFuYWdlci5leGVjKG5hbWUsIHBheWxvYWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBlZGl0b3IgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gY29tbWFuZCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tbWFuZCAtIGNvbW1hbmQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5hZGRDb21tYW5kID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbW1hbmRIb2MgPSBmdW5jdGlvbiAocGF5bGFvZCkge1xuICAgICAgICAgICAgaWYgKHBheWxhb2QgPT09IHZvaWQgMCkgeyBwYXlsYW9kID0ge307IH1cbiAgICAgICAgICAgIHZhciB2aWV3ID0gKHR5cGUgPT09ICdtYXJrZG93bicgPyBfdGhpcy5tZEVkaXRvciA6IF90aGlzLnd3RWRpdG9yKS52aWV3O1xuICAgICAgICAgICAgY29tbWFuZChwYXlsYW9kLCB2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb21tYW5kTWFuYWdlci5hZGRDb21tYW5kKHR5cGUsIG5hbWUsIGNvbW1hbmRIb2MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmluZCBldmVudEhhbmRsZXIgdG8gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4odHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmJpbmQgZXZlbnRIYW5kbGVyIGZyb20gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGhvb2sgdG8gVFVJRWRpdG9yIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5hZGRIb29rID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4odHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgaG9vayBmcm9tIFRVSUVkaXRvciBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUucmVtb3ZlSG9vayA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcih0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBmb2N1cyB0byBjdXJyZW50IEVkaXRvclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmZvY3VzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZm9jdXMgb2YgY3VycmVudCBFZGl0b3JcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmJsdXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBjdXJzb3IgcG9zaXRpb24gdG8gZW5kXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZm9jdXNdIC0gYXV0b21hdGljYWxseSBmb2N1cyB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLm1vdmVDdXJzb3JUb0VuZCA9IGZ1bmN0aW9uIChmb2N1cykge1xuICAgICAgICBpZiAoZm9jdXMgPT09IHZvaWQgMCkgeyBmb2N1cyA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLm1vdmVDdXJzb3JUb0VuZChmb2N1cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgY3Vyc29yIHBvc2l0aW9uIHRvIHN0YXJ0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZm9jdXNdIC0gYXV0b21hdGljYWxseSBmb2N1cyB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLm1vdmVDdXJzb3JUb1N0YXJ0ID0gZnVuY3Rpb24gKGZvY3VzKSB7XG4gICAgICAgIGlmIChmb2N1cyA9PT0gdm9pZCAwKSB7IGZvY3VzID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkubW92ZUN1cnNvclRvU3RhcnQoZm9jdXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG1hcmtkb3duIHN5bnRheCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZG93biAtIG1hcmtkb3duIHN5bnRheCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2N1cnNvclRvRW5kPXRydWVdIC0gbW92ZSBjdXJzb3IgdG8gY29udGVudHMgZW5kXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldE1hcmtkb3duID0gZnVuY3Rpb24gKG1hcmtkb3duLCBjdXJzb3JUb0VuZCkge1xuICAgICAgICBpZiAobWFya2Rvd24gPT09IHZvaWQgMCkgeyBtYXJrZG93biA9ICcnOyB9XG4gICAgICAgIGlmIChjdXJzb3JUb0VuZCA9PT0gdm9pZCAwKSB7IGN1cnNvclRvRW5kID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLm1kRWRpdG9yLnNldE1hcmtkb3duKG1hcmtkb3duLCBjdXJzb3JUb0VuZCk7XG4gICAgICAgIGlmICh0aGlzLmlzV3lzaXd5Z01vZGUoKSkge1xuICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRoaXMudG9hc3RNYXJrLmdldFJvb3ROb2RlKCk7XG4gICAgICAgICAgICB2YXIgd3dOb2RlID0gdGhpcy5jb252ZXJ0b3IudG9XeXNpd3lnTW9kZWwobWROb2RlKTtcbiAgICAgICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0TW9kZWwod3dOb2RlLCBjdXJzb3JUb0VuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBodG1sIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIC0gaHRtbCBzeW50YXggdGV4dFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2N1cnNvclRvRW5kPXRydWVdIC0gbW92ZSBjdXJzb3IgdG8gY29udGVudHMgZW5kXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldEhUTUwgPSBmdW5jdGlvbiAoaHRtbCwgY3Vyc29yVG9FbmQpIHtcbiAgICAgICAgaWYgKGh0bWwgPT09IHZvaWQgMCkgeyBodG1sID0gJyc7IH1cbiAgICAgICAgaWYgKGN1cnNvclRvRW5kID09PSB2b2lkIDApIHsgY3Vyc29yVG9FbmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgLy8gdGhlIGBicmAgdGFnIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGVtcHR5IGJsb2NrIHRvIHNlcGFyYXRlIGJldHdlZW4gYmxvY2tzXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSByZXBsYWNlQlJXaXRoRW1wdHlCbG9jayhodG1sKTtcbiAgICAgICAgdmFyIHd3Tm9kZSA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHRoaXMud3dFZGl0b3Iuc2NoZW1hKS5wYXJzZShjb250YWluZXIpO1xuICAgICAgICBpZiAodGhpcy5pc01hcmtkb3duTW9kZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1kRWRpdG9yLnNldE1hcmtkb3duKHRoaXMuY29udmVydG9yLnRvTWFya2Rvd25UZXh0KHd3Tm9kZSksIGN1cnNvclRvRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0TW9kZWwod3dOb2RlLCBjdXJzb3JUb0VuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBjb250ZW50IHRvIG1hcmtkb3duXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbWFya2Rvd24gdGV4dFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRNYXJrZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXJrZG93bk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWRFZGl0b3IuZ2V0TWFya2Rvd24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0b3IudG9NYXJrZG93blRleHQodGhpcy53d0VkaXRvci5nZXRNb2RlbCgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBjb250ZW50IHRvIGh0bWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBodG1sIHN0cmluZ1xuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5ob2xkRXZlbnRJbnZva2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzTWFya2Rvd25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gX3RoaXMudG9hc3RNYXJrLmdldFJvb3ROb2RlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHd3Tm9kZSA9IF90aGlzLmNvbnZlcnRvci50b1d5c2l3eWdNb2RlbChtZE5vZGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLnd3RWRpdG9yLnNldE1vZGVsKHd3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaHRtbCA9IHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKHRoaXMud3dFZGl0b3Iudmlldy5kb20uaW5uZXJIVE1MKTtcbiAgICAgICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHZhciByZVBsYWNlaG9sZGVyID0gbmV3IFJlZ0V4cChcIjxzcGFuIGNsYXNzPVxcXCJwbGFjZWhvbGRlcltePl0rPlwiICsgdGhpcy5wbGFjZWhvbGRlciArIFwiPC9zcGFuPlwiLCAnaScpO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShyZVBsYWNlaG9sZGVyLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgdGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCBjb250ZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmluc2VydFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkucmVwbGFjZVNlbGVjdGlvbih0ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gc3RhcnQgLSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBlbmQgLSBlbmQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLnNldFNlbGVjdGlvbihzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2Ugc2VsZWN0aW9uIHJhbmdlIHdpdGggZ2l2ZW4gdGV4dCBjb250ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW3N0YXJ0XSAtIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtlbmRdIC0gZW5kIHBvc2l0aW9uXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnJlcGxhY2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkucmVwbGFjZVNlbGVjdGlvbih0ZXh0LCBzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgY29udGVudCBvZiBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW3N0YXJ0XSAtIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtlbmRdIC0gZW5kIHBvc2l0aW9uXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5kZWxldGVTZWxlY3Rpb24oc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgc2VsZWN0ZWQgdGV4dCBjb250ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtzdGFydF0gLSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbZW5kXSAtIGVuZCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gc2VsZWN0ZWQgdGV4dCBjb250ZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldFNlbGVjdGVkVGV4dCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuZ2V0U2VsZWN0ZWRUZXh0KHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHJhbmdlIG9mIHRoZSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtwb3NdIC0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcltdPnxBcnJheS48bnVtYmVyPn0gLSBub2RlIFtzdGFydCwgZW5kXSByYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTWFya2Rvd24gbW9kZVxuICAgICAqIGNvbnN0IHJhbmdlSW5mbyA9IGVkaXRvci5nZXRSYW5nZUluZm9PZk5vZGUoKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHJhbmdlSW5mbyk7IC8vIHsgcmFuZ2U6IFtbc3RhcnRMaW5lT2Zmc2V0LCBzdGFydEN1cm9yT2Zmc2V0XSwgW2VuZExpbmVPZmZzZXQsIGVuZEN1cm9yT2Zmc2V0XV0sIHR5cGU6ICdlbXBoJyB9XG4gICAgICpcbiAgICAgKiAvLyBXWVNJV1lHIG1vZGVcbiAgICAgKiBjb25zdCByYW5nZUluZm8gPSBlZGl0b3IuZ2V0UmFuZ2VJbmZvT2ZOb2RlKCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhyYW5nZUluZm8pOyAvLyB7IHJhbmdlOiBbc3RhcnRDdXJzb3JPZmZzZXQsIGVuZEN1cnNvck9mZnNldF0sIHR5cGU6ICdlbXBoJyB9XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldFJhbmdlSW5mb09mTm9kZSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5nZXRSYW5nZUluZm9PZk5vZGUocG9zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCB3aWRnZXQgdG8gc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gd2lkZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3R5bGUgLSBBZGRpbmcgc3R5bGUgXCJ0b3BcIiBvciBcImJvdHRvbVwiXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtwb3NdIC0gcG9zaXRpb25cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuYWRkV2lkZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIHN0eWxlLCBwb3MpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmFkZFdpZGdldChub2RlLCBzdHlsZSwgcG9zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2Ugbm9kZSB3aXRoIHdpZGdldCB0byByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBzdGFydCAtIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IGVuZCAtIGVuZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gd2lkZ2V0IHRleHQgY29udGVudFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5yZXBsYWNlV2l0aFdpZGdldCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5yZXBsYWNlV2l0aFdpZGdldChzdGFydCwgZW5kLCB0ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBlZGl0b3IgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAtIGVkaXRvciBoZWlnaHQgaW4gcGl4ZWxcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLm9wdGlvbnMuZWw7XG4gICAgICAgIGlmIChpc1N0cmluZ18xKGhlaWdodCkpIHtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzXzEoZWwsICdhdXRvLWhlaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMShlbCwgJ2F1dG8taGVpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldE1pbkhlaWdodCh0aGlzLmdldE1pbkhlaWdodCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjc3NfMShlbCwgeyBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgZWRpdG9yIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGVkaXRvciBoZWlnaHQgaW4gcGl4ZWxcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbWluaW11bSBoZWlnaHQgdG8gZWRpdG9yIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWluSGVpZ2h0IC0gbWluIGNvbnRlbnQgaGVpZ2h0IGluIHBpeGVsXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldE1pbkhlaWdodCA9IGZ1bmN0aW9uIChtaW5IZWlnaHQpIHtcbiAgICAgICAgaWYgKG1pbkhlaWdodCAhPT0gdGhpcy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCB8fCB0aGlzLm9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGhlaWdodCAhPT0gJ2F1dG8nICYmIHRoaXMub3B0aW9ucy5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgY2xzKCdtYWluJykpKSB7XG4gICAgICAgICAgICAgICAgLy8gNzVweCBlcXVhbHMgZGVmYXVsdCBlZGl0b3IgdWkgaGVpZ2h0IC0gdGhlIGVkaXRpbmcgYXJlYSBoZWlnaHRcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQgPSBNYXRoLm1pbihwYXJzZUludChtaW5IZWlnaHQsIDEwKSwgcGFyc2VJbnQoaGVpZ2h0LCAxMCkgLSA3NSkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluSGVpZ2h0TnVtID0gcGFyc2VJbnQobWluSGVpZ2h0LCAxMCk7XG4gICAgICAgICAgICB0aGlzLm1pbkhlaWdodCA9IG1pbkhlaWdodDtcbiAgICAgICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0TWluSGVpZ2h0KG1pbkhlaWdodE51bSk7XG4gICAgICAgICAgICB0aGlzLm1kRWRpdG9yLnNldE1pbkhlaWdodChtaW5IZWlnaHROdW0pO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnNldE1pbkhlaWdodChtaW5IZWlnaHROdW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgbWluaW11bSBoZWlnaHQgb2YgZWRpdG9yIGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBtaW4gaGVpZ2h0IGluIHBpeGVsXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldE1pbkhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluSGVpZ2h0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgY3VycmVudCBlZGl0b3IgbW9kZSBpcyBNYXJrZG93blxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5pc01hcmtkb3duTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gJ21hcmtkb3duJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGN1cnJlbnQgZWRpdG9yIG1vZGUgaXMgV1lTSVdZR1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5pc1d5c2l3eWdNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAnd3lzaXd5Zyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuaXNWaWV3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IE1hcmtkb3duIGVkaXRvcidzIHByZXZpZXcgc3R5bGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRDdXJyZW50UHJldmlld1N0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZFByZXZpZXdTdHlsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoYW5nZSBlZGl0b3IncyBtb2RlIHRvIGdpdmVuIG1vZGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBFZGl0b3IgbW9kZSBuYW1lIG9mIHdhbnQgdG8gY2hhbmdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbd2l0aG91dEZvY3VzXSAtIENoYW5nZSBtb2RlIHdpdGhvdXQgZm9jdXNcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuY2hhbmdlTW9kZSA9IGZ1bmN0aW9uIChtb2RlLCB3aXRob3V0Rm9jdXMpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gbW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIGlmICh0aGlzLmlzV3lzaXd5Z01vZGUoKSkge1xuICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRoaXMudG9hc3RNYXJrLmdldFJvb3ROb2RlKCk7XG4gICAgICAgICAgICB2YXIgd3dOb2RlID0gdGhpcy5jb252ZXJ0b3IudG9XeXNpd3lnTW9kZWwobWROb2RlKTtcbiAgICAgICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0TW9kZWwod3dOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB3d05vZGUgPSB0aGlzLnd3RWRpdG9yLmdldE1vZGVsKCk7XG4gICAgICAgICAgICB0aGlzLm1kRWRpdG9yLnNldE1hcmtkb3duKHRoaXMuY29udmVydG9yLnRvTWFya2Rvd25UZXh0KHd3Tm9kZSksICF3aXRob3V0Rm9jdXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3JlbW92ZVBvcHVwV2lkZ2V0Jyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZU1vZGUnLCBtb2RlKTtcbiAgICAgICAgaWYgKCF3aXRob3V0Rm9jdXMpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmNvbnZlcnRvci5nZXRNYXBwZWRQb3MoKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzV3lzaXd5Z01vZGUoKSAmJiBpc051bWJlcl8xKHBvcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnd3RWRpdG9yLnNldFNlbGVjdGlvbihwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwb3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZEVkaXRvci5zZXRTZWxlY3Rpb24ocG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBUVUlFZGl0b3IgZnJvbSBkb2N1bWVudFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnd3RWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tZEVkaXRvci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucHJldmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3luYy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZ2V0RXZlbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoXywgdHlwZSkgeyByZXR1cm4gX3RoaXMub2ZmKHR5cGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhpZGUgVFVJRWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2hpZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3cgVFVJRWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Nob3cnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgb24gc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHNjcm9sbFRvcCB2YWx1ZSBvZiBlZGl0b3IgY29udGFpbmVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuc2V0U2Nyb2xsVG9wKHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBzY3JvbGwgcG9zaXRpb24gdmFsdWUgb2YgZWRpdG9yIGNvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHNjcm9sbFRvcCB2YWx1ZSBvZiBlZGl0b3IgY29udGFpbmVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5nZXRTY3JvbGxUb3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0IFRVSUVkaXRvclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53d0VkaXRvci5zZXRNb2RlbChbXSk7XG4gICAgICAgIHRoaXMubWRFZGl0b3Iuc2V0TWFya2Rvd24oJycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgc2VsZWN0aW9uIHJhbmdlXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXJbXT58QXJyYXkuPG51bWJlcj59IFJldHVybnMgdGhlIHJhbmdlIG9mIHRoZSBzZWxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBlZGl0b3IgbW9kZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTWFya2Rvd24gbW9kZVxuICAgICAqIGNvbnN0IG1kU2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cobWRTZWxlY3Rpb24pOyAvLyBbW3N0YXJ0TGluZU9mZnNldCwgc3RhcnRDdXJvck9mZnNldF0sIFtlbmRMaW5lT2Zmc2V0LCBlbmRDdXJvck9mZnNldF1dXG4gICAgICpcbiAgICAgKiAvLyBXWVNJV1lHIG1vZGVcbiAgICAgKiBjb25zdCB3d1NlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHd3U2VsZWN0aW9uKTsgLy8gW3N0YXJ0Q3Vyc29yT2Zmc2V0LCBlbmRDdXJzb3JPZmZzZXRdXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5nZXRTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGxhY2Vob2xkZXIgb24gYWxsIGVkaXRvcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGxhY2Vob2xkZXIgLSBwbGFjZWhvbGRlciB0byBzZXRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICB0aGlzLm1kRWRpdG9yLnNldFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgdGhpcy53d0VkaXRvci5zZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgbWFya2Rvd24gZWRpdG9yLCBwcmV2aWV3LCB3eXNpd3lnIGVkaXRvciBET00gZWxlbWVudHNcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0RWRpdG9yRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZEVkaXRvcjogdGhpcy5tZEVkaXRvci5nZXRFbGVtZW50KCksXG4gICAgICAgICAgICBtZFByZXZpZXc6IHRoaXMucHJldmlldy5nZXRFbGVtZW50KCksXG4gICAgICAgICAgICB3d0VkaXRvcjogdGhpcy53d0VkaXRvci5nZXRFbGVtZW50KCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHBvc2l0aW9uIHRvIG1hdGNoIGVkaXRvciBtb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHN0YXJ0IC0gc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gZW5kIC0gZW5kIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBFZGl0b3IgbW9kZSBuYW1lIG9mIHdhbnQgdG8gbWF0Y2ggY29udmVydGVkIHBvc2l0aW9uIHRvXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmNvbnZlcnRQb3NUb01hdGNoRWRpdG9yTW9kZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtb2RlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBzdGFydDsgfVxuICAgICAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSB7IG1vZGUgPSB0aGlzLm1vZGU7IH1cbiAgICAgICAgdmFyIGRvYyA9IHRoaXMubWRFZGl0b3Iudmlldy5zdGF0ZS5kb2M7XG4gICAgICAgIHZhciBpc0Zyb21BcnJheSA9IEFycmF5LmlzQXJyYXkoc3RhcnQpO1xuICAgICAgICB2YXIgaXNUb0FycmF5ID0gQXJyYXkuaXNBcnJheShlbmQpO1xuICAgICAgICB2YXIgY29udmVydGVkRnJvbSA9IHN0YXJ0O1xuICAgICAgICB2YXIgY29udmVydGVkVG8gPSBlbmQ7XG4gICAgICAgIGlmIChpc0Zyb21BcnJheSAhPT0gaXNUb0FycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGVzIG9mIGFyZ3VtZW50cyBtdXN0IGJlIHNhbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZSA9PT0gJ21hcmtkb3duJyAmJiAhaXNGcm9tQXJyYXkgJiYgIWlzVG9BcnJheSkge1xuICAgICAgICAgICAgX2EgPSBnZXRFZGl0b3JUb01kUG9zKGRvYywgc3RhcnQsIGVuZCksIGNvbnZlcnRlZEZyb20gPSBfYVswXSwgY29udmVydGVkVG8gPSBfYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnd3lzaXd5ZycgJiYgaXNGcm9tQXJyYXkgJiYgaXNUb0FycmF5KSB7XG4gICAgICAgICAgICBfYiA9IGdldE1kVG9FZGl0b3JQb3MoZG9jLCBzdGFydCwgZW5kKSwgY29udmVydGVkRnJvbSA9IF9iWzBdLCBjb252ZXJ0ZWRUbyA9IF9iWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY29udmVydGVkRnJvbSwgY29udmVydGVkVG9dO1xuICAgIH07XG4gICAgcmV0dXJuIFRvYXN0VUlFZGl0b3JDb3JlO1xufSgpKTtcblxuLy8gQFRPRE86IGNoYW5nZSBzeW50YXggd2l0aCBvdXIgY29udmVudGlvblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmZ1bmN0aW9uIGh0bWwkMSAobikge1xuICBmb3IgKFxuICAgIHZhciBsLFxuICAgICAgZSxcbiAgICAgIHMgPSBhcmd1bWVudHMsXG4gICAgICB0ID0gMSxcbiAgICAgIHIgPSAnJyxcbiAgICAgIHUgPSAnJyxcbiAgICAgIGEgPSBbMF0sXG4gICAgICBjID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdCA9PT0gMSAmJiAobiB8fCAociA9IHIucmVwbGFjZSgvXlxccypcXG5cXHMqfFxccypcXG5cXHMqJC9nLCAnJykpKVxuICAgICAgICAgID8gYS5wdXNoKG4gPyBzW25dIDogcilcbiAgICAgICAgICA6IHQgPT09IDMgJiYgKG4gfHwgcilcbiAgICAgICAgICA/ICgoYVsxXSA9IG4gPyBzW25dIDogciksICh0ID0gMikpXG4gICAgICAgICAgOiB0ID09PSAyICYmIHIgPT09ICcuLi4nICYmIG5cbiAgICAgICAgICA/IChhWzJdID0gYXNzaWduKGFbMl0gfHwge30sIHNbbl0pKVxuICAgICAgICAgIDogdCA9PT0gMiAmJiByICYmICFuXG4gICAgICAgICAgPyAoKGFbMl0gPSBhWzJdIHx8IHt9KVtyXSA9ICEwKVxuICAgICAgICAgIDogdCA+PSA1ICYmXG4gICAgICAgICAgICAodCA9PT0gNVxuICAgICAgICAgICAgICA/ICgoKGFbMl0gPSBhWzJdIHx8IHt9KVtlXSA9IG4gPyAociA/IHIgKyBzW25dIDogc1tuXSkgOiByKSwgKHQgPSA2KSlcbiAgICAgICAgICAgICAgOiAobiB8fCByKSAmJiAoYVsyXVtlXSArPSBuID8gciArIHNbbl0gOiByKSksXG4gICAgICAgICAgKHIgPSAnJyk7XG4gICAgICB9LFxuICAgICAgaCA9IDA7XG4gICAgaCA8IG4ubGVuZ3RoO1xuICAgIGgrK1xuICApIHtcbiAgICBoICYmICh0ID09PSAxICYmIGMoKSwgYyhoKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuW2hdLmxlbmd0aDsgaSsrKVxuICAgICAgKGwgPSBuW2hdW2ldKSxcbiAgICAgICAgdCA9PT0gMVxuICAgICAgICAgID8gbCA9PT0gJzwnXG4gICAgICAgICAgICA/IChjKCksIChhID0gW2EsICcnLCBudWxsXSksICh0ID0gMykpXG4gICAgICAgICAgICA6IChyICs9IGwpXG4gICAgICAgICAgOiB0ID09PSA0XG4gICAgICAgICAgPyByID09PSAnLS0nICYmIGwgPT09ICc+J1xuICAgICAgICAgICAgPyAoKHQgPSAxKSwgKHIgPSAnJykpXG4gICAgICAgICAgICA6IChyID0gbCArIHJbMF0pXG4gICAgICAgICAgOiB1XG4gICAgICAgICAgPyBsID09PSB1XG4gICAgICAgICAgICA/ICh1ID0gJycpXG4gICAgICAgICAgICA6IChyICs9IGwpXG4gICAgICAgICAgOiBsID09PSAnXCInIHx8IGwgPT09IFwiJ1wiXG4gICAgICAgICAgPyAodSA9IGwpXG4gICAgICAgICAgOiBsID09PSAnPidcbiAgICAgICAgICA/IChjKCksICh0ID0gMSkpXG4gICAgICAgICAgOiB0ICYmXG4gICAgICAgICAgICAobCA9PT0gJz0nXG4gICAgICAgICAgICAgID8gKCh0ID0gNSksIChlID0gciksIChyID0gJycpKVxuICAgICAgICAgICAgICA6IGwgPT09ICcvJyAmJiAodCA8IDUgfHwgbltoXVtpICsgMV0gPT09ICc+JylcbiAgICAgICAgICAgICAgPyAoYygpLFxuICAgICAgICAgICAgICAgIHQgPT09IDMgJiYgKGEgPSBhWzBdKSxcbiAgICAgICAgICAgICAgICAodCA9IGEpLFxuICAgICAgICAgICAgICAgIChhID0gYVswXSkucHVzaCh0aGlzLmFwcGx5KG51bGwsIHQuc2xpY2UoMSkpKSxcbiAgICAgICAgICAgICAgICAodCA9IDApKVxuICAgICAgICAgICAgICA6IGwgPT09ICcgJyB8fCBsID09PSAnXFx0JyB8fCBsID09PSAnXFxuJyB8fCBsID09PSAnXFxyJ1xuICAgICAgICAgICAgICA/IChjKCksICh0ID0gMikpXG4gICAgICAgICAgICAgIDogKHIgKz0gbCkpLFxuICAgICAgICB0ID09PSAzICYmIHIgPT09ICchLS0nICYmICgodCA9IDQpLCAoYSA9IGFbMF0pKTtcbiAgfVxuICByZXR1cm4gYygpLCBhLmxlbmd0aCA+IDIgPyBhLnNsaWNlKDEpIDogYVsxXTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBib29sZWFuIG9yIG5vdC5cbiAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBib29sZWFuLCByZXR1cm4gdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIGJvb2xlYW4/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nIHx8IG9iaiBpbnN0YW5jZW9mIEJvb2xlYW47XG59XG5cbnZhciBpc0Jvb2xlYW5fMSA9IGlzQm9vbGVhbjtcblxudmFyIFZOb2RlV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZOb2RlV2Fsa2VyKGN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5yb290ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgfVxuICAgIFZOb2RlV2Fsa2VyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBjdXIgPSBfYS5jdXJyZW50O1xuICAgICAgICBpZiAoIWN1cikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBpZiAoY3VyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIgPT09IHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLm5leHQ7XG4gICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdm5vZGU6IGN1ciwgZW50ZXJpbmc6IGVudGVyaW5nIH07XG4gICAgfTtcbiAgICByZXR1cm4gVk5vZGVXYWxrZXI7XG59KCkpO1xudmFyIFZOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMub2xkID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5za2lwID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIGlmIChwcm9wcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmID0gcHJvcHMucmVmO1xuICAgICAgICAgICAgZGVsZXRlIHByb3BzLnJlZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMua2V5KSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IHByb3BzLmtleTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wcy5rZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVk5vZGUucHJvdG90eXBlLndhbGtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWTm9kZVdhbGtlcih0aGlzKTtcbiAgICB9O1xuICAgIFZOb2RlLnJlbW92YWxOb2RlcyA9IFtdO1xuICAgIHJldHVybiBWTm9kZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKCdURVhUX05PREUnLCB7IG5vZGVWYWx1ZTogdGV4dCB9LCBbXSk7XG59XG5mdW5jdGlvbiBleGNsdWRlVW5uZWNlc3NhcnlDaGlsZChjaGlsZCwgZmxhdHRlZCkge1xuICAgIHZhciB2bm9kZSA9IGNoaWxkO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgIGlmIChpc0Jvb2xlYW5fMShjaGlsZCkgfHwgY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICB2bm9kZSA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nXzEoY2hpbGQpIHx8IGlzTnVtYmVyXzEoY2hpbGQpKSB7XG4gICAgICAgIHZub2RlID0gY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNoaWxkKSk7XG4gICAgfVxuICAgIGlmICh2bm9kZSkge1xuICAgICAgICBmbGF0dGVkLnB1c2godm5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjaGlsZHJlbltfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGZsYXR0ZWQgPSBbXTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZVVubmVjZXNzYXJ5Q2hpbGQodm5vZGUsIGZsYXR0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGNsdWRlVW5uZWNlc3NhcnlDaGlsZChjaGlsZCwgZmxhdHRlZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFZOb2RlKHR5cGUsIHByb3BzIHx8IHt9LCBmbGF0dGVkKTtcbn1cbi8vIEB0cy1pZ25vcmVcbnZhciBodG1sID0gaHRtbCQxLmJpbmQoaCk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIG9iamVjdCwgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBvYmplY3Q/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0O1xuXG4vLyBAVE9ETzogY2xlYXJmeSB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciBDU1NEZWNsYXJhdGlvblxuZnVuY3Rpb24gY3JlYXRlTm9kZSh2bm9kZSkge1xuICAgIHZhciBub2RlO1xuICAgIGlmICh2bm9kZS50eXBlID09PSAnVEVYVF9OT0RFJykge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodm5vZGUucHJvcHMubm9kZVZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHZub2RlLnR5cGUpO1xuICAgICAgICBzZXRQcm9wcyhub2RlLCB7fSwgdm5vZGUucHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIHBhcmVudE5vZGUpIHtcbiAgICBpZiAodm5vZGUubm9kZSkge1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHZub2RlLm5vZGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5maXJzdENoaWxkLCBwYXJlbnROb2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbm5lckRpZmYobm9kZSwgcHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIGlmICgvXm9uLy50ZXN0KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgaWYgKCFuZXh0UHJvcHNbcHJvcE5hbWVdIHx8IHByZXZQcm9wc1twcm9wTmFtZV0gIT09IG5leHRQcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gcHJvcE5hbWUuc2xpY2UoMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBwcmV2UHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSAhPT0gJ2NoaWxkcmVuJyAmJiAhbmV4dFByb3BzW3Byb3BOYW1lXSAmJiAhaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2V0UHJvcHMobm9kZSwgcHJldlByb3BzLCBuZXh0UHJvcHMsIGZ1bmN0aW9uIChwcm9wTmFtZSkgeyByZXR1cm4gIXNoYWxsb3dFcXVhbChwcmV2UHJvcHNbcHJvcE5hbWVdLCBuZXh0UHJvcHNbcHJvcE5hbWVdKTsgfSk7XG59XG52YXIgcmVOb25EaW1lbnNpb24gPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmQvaTtcbmZ1bmN0aW9uIHNldFByb3BzKG5vZGUsIHByZXZQcm9wcywgcHJvcHMsIGNvbmRpdGlvbikge1xuICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbiB8fCBjb25kaXRpb24ocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoL15vbi8udGVzdChwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gcHJvcE5hbWUuc2xpY2UoMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcE5hbWUgPT09ICdub2RlVmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ3N0eWxlJyAmJiBpc09iamVjdF8xKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBzZXRTdHlsZVByb3BzKG5vZGUsIHByZXZQcm9wc1twcm9wTmFtZV0sIHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSAhPT0gJ2NoaWxkcmVuJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKHByb3BOYW1lLCBwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0U3R5bGVQcm9wcyhub2RlLCBwcmV2U3R5bGVQcm9wcywgc3R5bGVQcm9wcykge1xuICAgIGlmIChwcmV2U3R5bGVQcm9wcykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcmV2U3R5bGVQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVQcm9wKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBub2RlLnN0eWxlW3N0eWxlUHJvcF0gPSAnJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHN0eWxlUHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlUHJvcCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVByb3BzW3N0eWxlUHJvcF07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbm9kZS5zdHlsZVtzdHlsZVByb3BdID1cbiAgICAgICAgICAgIGlzTnVtYmVyXzEodmFsdWUpICYmICFyZU5vbkRpbWVuc2lvbi50ZXN0KHN0eWxlUHJvcCkgPyB2YWx1ZSArIFwicHhcIiA6IHZhbHVlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjb21taXQodm5vZGUpIHtcbiAgICBWTm9kZS5yZW1vdmFsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAocmVtb3ZhbE5vZGUpIHsgcmV0dXJuIGRpZmYocmVtb3ZhbE5vZGUpOyB9KTtcbiAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG4gICAgICAgIHZhciB3YWxrZXIgPSB2bm9kZS53YWxrZXIoKTtcbiAgICAgICAgd2hpbGUgKChuZXh0ID0gd2Fsa2VyLndhbGsoKSkpIHtcbiAgICAgICAgICAgIHZub2RlID0gbmV4dC52bm9kZTtcbiAgICAgICAgICAgIGlmIChuZXh0LmVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgZGlmZih2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uXzEodm5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcCA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAvLyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgICAgICAgICAgICAgaWYgKCF2bm9kZS5vbGQgJiYgY29tcC5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAubW91bnRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodm5vZGUub2xkICYmIGNvbXAudXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY29tcC5wcmV2UHJvcHMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbXAudXBkYXRlZChwcmV2UHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUodm5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gdm5vZGUucGFyZW50O1xuICAgIHdoaWxlICghcGFyZW50Lm5vZGUpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudC5ub2RlO1xufVxuZnVuY3Rpb24gZGlmZih2bm9kZSkge1xuICAgIGlmICghdm5vZGUgfHwgIXZub2RlLnBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2bm9kZS5ub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZSh2bm9kZSk7XG4gICAgICAgIGlmICh2bm9kZS5lZmZlY3QgPT09ICdBJykge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh2bm9kZS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2bm9kZS5lZmZlY3QgPT09ICdVJykge1xuICAgICAgICAgICAgaW5uZXJEaWZmKHZub2RlLm5vZGUsIHZub2RlLm9sZC5wcm9wcywgdm5vZGUucHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2bm9kZS5lZmZlY3QgPT09ICdEJykge1xuICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHdhbGtlciA9IHZub2RlLndhbGtlcigpO1xuICAgICAgICB3aGlsZSAoKG5leHQgPSB3YWxrZXIud2FsaygpKSkge1xuICAgICAgICAgICAgdm5vZGUgPSBuZXh0LnZub2RlO1xuICAgICAgICAgICAgaWYgKCFuZXh0LmVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMSh2bm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcCA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlmZWN5Y2xlIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcC5iZWZvcmVEZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wLmJlZm9yZURlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZSh2bm9kZSwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFwcGx5IHJlZlxuICAgIGlmICh2bm9kZS5yZWYpIHtcbiAgICAgICAgaWYgKHZub2RlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgdm5vZGUucmVmKHZub2RlLmNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodm5vZGUubm9kZSkge1xuICAgICAgICAgICAgdm5vZGUucmVmKHZub2RlLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoQ29tcCwgdm5vZGUpIHtcbiAgICB2YXIgcHJvcHMgPSB2bm9kZS5wcm9wcywgY29tcG9uZW50ID0gdm5vZGUuY29tcG9uZW50O1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgY29tcG9uZW50LnByZXZQcm9wcyA9IGNvbXBvbmVudC5wcm9wcztcbiAgICAgICAgY29tcG9uZW50LnByb3BzID0gdm5vZGUucHJvcHM7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29tcChwcm9wcyk7XG59XG5mdW5jdGlvbiBidWlsZFZOb2RlKHZub2RlKSB7XG4gICAgdmFyIHJvb3QgPSB2bm9kZTtcbiAgICB3aGlsZSAodm5vZGUgJiYgIXZub2RlLnNraXApIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMSh2bm9kZS50eXBlKSkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50KHZub2RlLnR5cGUsIHZub2RlKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnZub2RlID0gdm5vZGU7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIHZub2RlLnByb3BzLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4gPSBbaW5zdGFuY2UucmVuZGVyKCldO1xuICAgICAgICAgICAgYnVpbGRDaGlsZHJlblZOb2RlKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdm5vZGUubm9kZSkge1xuICAgICAgICAgICAgICAgIHZub2RlLm5vZGUgPSBjcmVhdGVOb2RlKHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1aWxkQ2hpbGRyZW5WTm9kZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHZub2RlID0gdm5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICh2bm9kZSAmJiB2bm9kZS5wYXJlbnQgJiYgIXZub2RlLm5leHQpIHtcbiAgICAgICAgICAgICAgICB2bm9kZSA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUgPSB2bm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTYW1lVHlwZShvbGQsIHZub2RlKSB7XG4gICAgcmV0dXJuIG9sZCAmJiB2bm9kZSAmJiB2bm9kZS50eXBlID09PSBvbGQudHlwZSAmJiAoIXZub2RlLmtleSB8fCB2bm9kZS5rZXkgPT09IG9sZC5rZXkpO1xufVxuLy8gQFRPRE86IGFkZCBrZXkgZGlmZiBhbGdvcml0aG1cbmZ1bmN0aW9uIGJ1aWxkQ2hpbGRyZW5WTm9kZShwYXJlbnQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgdmFyIG9sZCA9IHBhcmVudC5vbGQgPyBwYXJlbnQub2xkLmZpcnN0Q2hpbGQgOiBudWxsO1xuICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICh2bm9kZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHNhbWVUeXBlID0gaXNTYW1lVHlwZShvbGQsIHZub2RlKTtcbiAgICAgICAgaWYgKHNhbWVUeXBlKSB7XG4gICAgICAgICAgICB2bm9kZS5vbGQgPSBvbGQ7XG4gICAgICAgICAgICB2bm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB2bm9kZS5ub2RlID0gb2xkLm5vZGU7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBvbGQuY29tcG9uZW50O1xuICAgICAgICAgICAgdm5vZGUuZWZmZWN0ID0gJ1UnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZSAmJiAhc2FtZVR5cGUpIHtcbiAgICAgICAgICAgIHZub2RlLm9sZCA9IG51bGw7XG4gICAgICAgICAgICB2bm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB2bm9kZS5ub2RlID0gbnVsbDtcbiAgICAgICAgICAgIHZub2RlLmVmZmVjdCA9ICdBJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkICYmICFzYW1lVHlwZSkge1xuICAgICAgICAgICAgVk5vZGUucmVtb3ZhbE5vZGVzLnB1c2gob2xkKTtcbiAgICAgICAgICAgIG9sZC5lZmZlY3QgPSAnRCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZCkge1xuICAgICAgICAgICAgb2xkID0gb2xkLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBwYXJlbnQuZmlyc3RDaGlsZCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZub2RlKSB7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gdm5vZGU7XG4gICAgfSk7XG4gICAgdmFyIGxhc3RDaGlsZCA9IGxhc3QkMShjaGlsZHJlbik7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKG9sZCkge1xuICAgICAgICAgICAgVk5vZGUucmVtb3ZhbE5vZGVzLnB1c2gob2xkKTtcbiAgICAgICAgICAgIG9sZC5lZmZlY3QgPSAnRCc7XG4gICAgICAgICAgICBvbGQgPSBvbGQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAob2xkICYmIGxhc3RDaGlsZCkge1xuICAgICAgICBpZiAob2xkICYmIGxhc3RDaGlsZC5vbGQgIT09IG9sZCkge1xuICAgICAgICAgICAgVk5vZGUucmVtb3ZhbE5vZGVzLnB1c2gob2xkKTtcbiAgICAgICAgICAgIG9sZC5lZmZlY3QgPSAnRCc7XG4gICAgICAgICAgICBvbGQgPSBvbGQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJveSh2bm9kZSkge1xuICAgIHZub2RlLmVmZmVjdCA9ICdEJztcbiAgICBWTm9kZS5yZW1vdmFsTm9kZXMgPSBbdm5vZGVdO1xuICAgIGNvbW1pdCgpO1xuICAgIFZOb2RlLnJlbW92YWxOb2RlcyA9IFtdO1xufVxuZnVuY3Rpb24gcmVyZW5kZXIoY29tcCkge1xuICAgIHZhciByb290ID0gY29tcC52bm9kZTtcbiAgICByb290LmVmZmVjdCA9ICdVJztcbiAgICByb290Lm9sZCA9IHJvb3Q7XG4gICAgLy8gc2tpcCBmb3IgdW5uZWNlc3NhcnkgcmVjb25jaWxpYXRpb25cbiAgICBpZiAocm9vdC5uZXh0KSB7XG4gICAgICAgIHJvb3QubmV4dC5za2lwID0gdHJ1ZTtcbiAgICB9XG4gICAgVk5vZGUucmVtb3ZhbE5vZGVzID0gW107XG4gICAgYnVpbGRWTm9kZShyb290KTtcbiAgICBjb21taXQocm9vdCk7XG4gICAgaWYgKHJvb3QubmV4dCkge1xuICAgICAgICByb290Lm5leHQuc2tpcCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcihjb250YWluZXIsIHZub2RlKSB7XG4gICAgdmFyIHJvb3QgPSBuZXcgVk5vZGUoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSwge30sIFt2bm9kZV0pO1xuICAgIHJvb3Qubm9kZSA9IGNvbnRhaW5lcjtcbiAgICBWTm9kZS5yZW1vdmFsTm9kZXMgPSBbXTtcbiAgICBidWlsZFZOb2RlKHJvb3QpO1xuICAgIGNvbW1pdChyb290KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVzdHJveShyb290LmZpcnN0Q2hpbGQpOyB9O1xufVxuXG52YXIgQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcykge1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCB0aGlzLnN0YXRlKSwgc3RhdGUpO1xuICAgICAgICBpZiAoIXNoYWxsb3dFcXVhbCh0aGlzLnN0YXRlLCBuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHJlcmVuZGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcG9uZW50O1xufSgpKTtcblxudmFyIFN3aXRjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShTd2l0Y2gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGhpZGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN3aXRjaC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhpZGU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgU3dpdGNoLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaGlkZTogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIFN3aXRjaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBlZGl0b3JUeXBlID0gX2EuZWRpdG9yVHlwZSwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGggfHwgKHRlbXBsYXRlT2JqZWN0XzEkaCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IFwiLCBcIlxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcInRhYi1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IFwiLCBcIlxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgb25DbGljaz1cIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgb25DbGljaz1cIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBjbHMoJ21vZGUtc3dpdGNoJyksIHRoaXMuc3RhdGUuaGlkZSA/ICdub25lJyA6ICdibG9jaycsIGVkaXRvclR5cGUgPT09ICdtYXJrZG93bicgPyAnIGFjdGl2ZScgOiAnJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ25lZWRDaGFuZ2VNb2RlJywgJ21hcmtkb3duJyk7XG4gICAgICAgIH0sIGkxOG4uZ2V0KCdNYXJrZG93bicpLCBlZGl0b3JUeXBlID09PSAnd3lzaXd5ZycgPyAnIGFjdGl2ZScgOiAnJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ25lZWRDaGFuZ2VNb2RlJywgJ3d5c2l3eWcnKTtcbiAgICAgICAgfSwgaTE4bi5nZXQoJ1dZU0lXWUcnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoO1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGg7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGZuIHVudGlsIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcyBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdWNlZCBmdW5jdGlvbiB3YXMgaW52b2tlZC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdC5uaG4uY29tPlxuICovXG5cbi8qKlxuICogQG1vZHVsZSB0cmlja3NcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgZm4gdW50aWwgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkXG4gKiBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdWNlZCBmdW5jdGlvbiB3YXMgaW52b2tlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXlcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQG1lbWJlcm9mIG1vZHVsZTp0cmlja3NcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBkZWJvdW5jZSBmcm9tICd0dWktY29kZS1zbmlwcGV0L3RyaWNrcy9kZWJvdW5jZSc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBkZWJvdW5jZSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvdHJpY2tzL2RlYm91bmNlJyk7XG4gKlxuICogZnVuY3Rpb24gc29tZU1ldGhvZFRvSW52b2tlRGVib3VuY2VkKCkge31cbiAqXG4gKiBjb25zdCBkZWJvdW5jZWQgPSBkZWJvdW5jZShzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQsIDMwMCk7XG4gKlxuICogLy8gaW52b2tlIHJlcGVhdGVkbHlcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTsgICAgLy8gbGFzdCBpbnZva2Ugb2YgZGVib3VuY2VkKClcbiAqXG4gKiAvLyBpbnZva2Ugc29tZU1ldGhvZFRvSW52b2tlRGVib3VuY2VkKCkgYWZ0ZXIgMzAwIG1pbGxpc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UkMShmbiwgZGVsYXkpIHtcbiAgdmFyIHRpbWVyLCBhcmdzO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfVxuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbnZhciBkZWJvdW5jZV8xID0gZGVib3VuY2UkMTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgZm4gYXQgbW9zdCBvbmNlIHBlciBldmVyeSBpbnRlcnZhbCBtaWxsaXNlY29uZHMuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHQubmhuLmNvbT5cbiAqL1xuXG52YXIgZGVib3VuY2UgPSBkZWJvdW5jZV8xO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgZm4gYXQgbW9zdCBvbmNlIHBlciBldmVyeSBpbnRlcnZhbCBtaWxsaXNlY29uZHMuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIHRocm90dGxlIHNob3J0IHRpbWUgcmVwZWF0ZWRseSBpbnZva2luZyBmdW5jdGlvbnMuIChlLmcgTW91c2VNb3ZlLCBSZXNpemUgLi4uKVxuICogaWYgeW91IG5lZWQgcmV1c2UgdGhyb3R0bGVkIG1ldGhvZC4geW91IG11c3QgcmVtb3ZlIHNsdWdzIChlLmcuIGZsYWcgdmFyaWFibGUpIHJlbGF0ZWQgd2l0aCB0aHJvdHRsaW5nLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gZnVuY3Rpb24gdG8gdGhyb3R0bGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZXJ2YWw9MF0gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTp0cmlja3NcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCB0aHJvdHRsZSBmcm9tICd0dWktY29kZS1zbmlwcGV0L3RyaWNrcy90aHJvdHRsZSc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvdHJpY2tzL3Rocm90dGxlJyk7XG4gKlxuICogZnVuY3Rpb24gc29tZU1ldGhvZFRvSW52b2tlVGhyb3R0bGVkKCkge31cbiAqXG4gKiBjb25zdCB0aHJvdHRsZWQgPSB0aHJvdHRsZShzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQsIDMwMCk7XG4gKlxuICogLy8gaW52b2tlIHJlcGVhdGVkbHlcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKGxlYWRpbmcpXG4gKiB0aHJvdHRsZWQoKTtcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKG5lYXIgMzAwIG1pbGxpc2Vjb25kcylcbiAqIHRocm90dGxlZCgpO1xuICogdGhyb3R0bGVkKCk7XG4gKiB0aHJvdHRsZWQoKTsgICAgLy8gaW52b2tlIChuZWFyIDYwMCBtaWxsaXNlY29uZHMpXG4gKiAvLyAuLi5cbiAqIC8vIGludm9rZSAodHJhaWxpbmcpXG4gKlxuICogLy8gaWYgeW91IG5lZWQgcmV1c2UgdGhyb3R0bGVkIG1ldGhvZC4gdGhlbiBpbnZva2UgcmVzZXQoKVxuICogdGhyb3R0bGVkLnJlc2V0KCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlJDEoZm4sIGludGVydmFsKSB7XG4gIHZhciBiYXNlO1xuICB2YXIgaXNMZWFkaW5nID0gdHJ1ZTtcbiAgdmFyIHRpY2sgPSBmdW5jdGlvbihfYXJncykge1xuICAgIGZuLmFwcGx5KG51bGwsIF9hcmdzKTtcbiAgICBiYXNlID0gbnVsbDtcbiAgfTtcbiAgdmFyIGRlYm91bmNlZCwgc3RhbXAsIGFyZ3M7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCAwO1xuXG4gIGRlYm91bmNlZCA9IGRlYm91bmNlKHRpY2ssIGludGVydmFsKTtcblxuICBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKGlzTGVhZGluZykge1xuICAgICAgdGljayhhcmdzKTtcbiAgICAgIGlzTGVhZGluZyA9IGZhbHNlO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhbXAgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cbiAgICBiYXNlID0gYmFzZSB8fCBzdGFtcDtcblxuICAgIC8vIHBhc3MgYXJyYXkgZGlyZWN0bHkgYmVjYXVzZSBgZGVib3VuY2UoKWAsIGB0aWNrKClgIGFyZSBhbHJlYWR5IHVzZVxuICAgIC8vIGBhcHBseSgpYCBtZXRob2QgdG8gaW52b2tlIGRldmVsb3BlcidzIGBmbmAgaGFuZGxlci5cbiAgICAvL1xuICAgIC8vIGFsc28sIHRoaXMgYGRlYm91bmNlZGAgbGluZSBpbnZva2VkIGV2ZXJ5IHRpbWUgZm9yIGltcGxlbWVudHNcbiAgICAvLyBgdHJhaWxpbmdgIGZlYXR1cmVzLlxuICAgIGRlYm91bmNlZChhcmdzKTtcblxuICAgIGlmICgoc3RhbXAgLSBiYXNlKSA+PSBpbnRlcnZhbCkge1xuICAgICAgdGljayhhcmdzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgaXNMZWFkaW5nID0gdHJ1ZTtcbiAgICBiYXNlID0gbnVsbDtcbiAgfVxuXG4gIHRocm90dGxlZC5yZXNldCA9IHJlc2V0O1xuXG4gIHJldHVybiB0aHJvdHRsZWQ7XG59XG5cbnZhciB0aHJvdHRsZV8xID0gdGhyb3R0bGUkMTtcblxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MsIHZhbGlkLWpzZG9jICovXHJcbnZhciBNYXBTaGltID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBNYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5kZXggaW4gcHJvdmlkZWQgYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAtMTtcclxuICAgICAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+Z2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbY3R4PW51bGxdXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChjdHggPT09IHZvaWQgMCkgeyBjdHggPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgfSgpKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gKi9cclxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDtcblxuLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cclxudmFyIGdsb2JhbCQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAqL1xyXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXHJcbiAgICAgICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXHJcbiAgICAgICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTsgfSwgMTAwMCAvIDYwKTsgfTtcclxufSkoKTtcblxuLy8gRGVmaW5lcyBtaW5pbXVtIHRpbWVvdXQgYmVmb3JlIGFkZGluZyBhIHRyYWlsaW5nIGNhbGwuXHJcbnZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggZW5zdXJlcyB0aGF0IHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmVcclxuICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGRlbGF5IHBlcmlvZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcbiAgICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSwgdHJhaWxpbmdDYWxsID0gZmFsc2UsIGxhc3RDYWxsVGltZSA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBwcm94eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuICAgICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJveHkoKSB7XHJcbiAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgY2FsbHMuXHJcbiAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgXCJ0cmFuc2l0aW9uc1wiIHdoaWNoIG5ldmVyIGFjdHVhbGx5IHN0YXJ0XHJcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXHJcbiAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm94eTtcclxufVxuXG4vLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxudmFyIFJFRlJFU0hfREVMQVkgPSAyMDtcclxuLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcclxuLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcbnZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddO1xyXG4vLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cclxudmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gY29udHJvbGxlciBjbGFzcyB3aGljaCBoYW5kbGVzIHVwZGF0ZXMgb2YgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge011dGF0aW9uT2JzZXJ2ZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcclxuICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XHJcbiAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXHJcbiAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGlmICghb2JzZXJ2ZXJzLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgICAqIGl0IGRldGVjdHMgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcclxuICAgICAgICAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcclxuICAgICAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxyXG4gICAgICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAgICogZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgaXQncyBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxyXG4gICAgICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcclxuICAgICAgICAvLyBSZXNpemVPYnNlcnZlciBhcmUgdHJhY2tpbmcgdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIGNhbGxiYWNrIG9mIG9uZVxyXG4gICAgICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXHJcbiAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIuYnJvYWRjYXN0QWN0aXZlKCk7IH0pO1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXHJcbiAgICAgICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxyXG4gICAgICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldmVudFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICovXHJcbnZhciBkZWZpbmVDb25maWd1cmFibGUgPSAoZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufSk7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqL1xyXG52YXIgZ2V0V2luZG93T2YgPSAoZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxyXG4gICAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXHJcbiAgICAvLyBjb3JyZXNwb25kaW5nIGdsb2JhbCBvYmplY3QuXHJcbiAgICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxyXG4gICAgLy8gcHJvdmlkZWQgZWxlbWVudC5cclxuICAgIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcclxufSk7XG5cbi8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG52YXIgZW1wdHlSZWN0ID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBib3JkZXJzIHNpemUgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwb3NpdGlvbnMgLSBCb3JkZXJzIHBvc2l0aW9ucyAodG9wLCByaWdodCwgLi4uKVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1snYm9yZGVyLScgKyBwb3NpdGlvbiArICctd2lkdGgnXTtcclxuICAgICAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfSwgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xyXG4gICAgdmFyIHBhZGRpbmdzID0ge307XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ3BhZGRpbmctJyArIHBvc2l0aW9uXTtcclxuICAgICAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYWRkaW5ncztcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxyXG4gICAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXHJcbiAgICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcclxuICAgIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcclxuICAgIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXHJcbiAgICAvL1xyXG4gICAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXHJcbiAgICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXHJcbiAgICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcclxuICAgIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cclxuICAgIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcbiAgICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xyXG4gICAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xyXG4gICAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XHJcbiAgICAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcclxuICAgIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcclxuICAgIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcclxuICAgIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cclxuICAgIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzLndpZHRoKSwgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTtcclxuICAgIC8vIFdpZHRoICYgaGVpZ2h0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgd2hlbiB0aGUgJ2JvcmRlci1ib3gnIGJveFxyXG4gICAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXHJcbiAgICBpZiAoc3R5bGVzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XHJcbiAgICAgICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxyXG4gICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxyXG4gICAgICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxyXG4gICAgICAgIC8vIGFueXRoaW5nLCBvciBhbiBlbGVtZW50IG1lcmVseSBkb2Vzbid0IGhhdmUgcGFkZGluZ3MvYm9yZGVycyBzdHlsZXMuXHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcclxuICAgIC8vIGNsaWVudFtXaWR0aC9IZWlnaHRdIHByb3BlcnRpZXMgcmVwcmVzZW50IHZpZXdwb3J0IGFyZWEgb2YgdGhlIHdpbmRvdy5cclxuICAgIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXHJcbiAgICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXHJcbiAgICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcclxuICAgICAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxyXG4gICAgICAgIC8vIGJhcnMgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiByb3VuZGVkIGRpbWVuc2lvbnMgKyBwYWRkaW5nc1xyXG4gICAgICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXHJcbiAgICAgICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIGhvcml6U2Nyb2xsYmFyID0gTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAtIGNsaWVudEhlaWdodDtcclxuICAgICAgICAvLyBDaHJvbWUgaGFzIGEgcmF0aGVyIHdlaXJkIHJvdW5kaW5nIG9mIFwiY2xpZW50XCIgcHJvcGVydGllcy5cclxuICAgICAgICAvLyBFLmcuIGZvciBhbiBlbGVtZW50IHdpdGggY29udGVudCB3aWR0aCBvZiAzMTQuMnB4IGl0IHNvbWV0aW1lcyBnaXZlc1xyXG4gICAgICAgIC8vIHRoZSBjbGllbnQgd2lkdGggb2YgMzE1cHggYW5kIGZvciB0aGUgd2lkdGggb2YgMzE0LjdweCBpdCBtYXkgZ2l2ZVxyXG4gICAgICAgIC8vIDMxNHB4LiBBbmQgaXQgZG9lc24ndCBoYXBwZW4gYWxsIHRoZSB0aW1lLiBTbyBqdXN0IGlnbm9yZSB0aGlzIGRlbHRhXHJcbiAgICAgICAgLy8gYXMgYSBub24tcmVsZXZhbnQuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZlcnRTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdChwYWRkaW5ncy5sZWZ0LCBwYWRkaW5ncy50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxyXG4gICAgLy8gaW50ZXJmYWNlLlxyXG4gICAgaWYgKHR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50OyB9O1xyXG4gICAgfVxyXG4gICAgLy8gSWYgaXQncyBzbywgdGhlbiBjaGVjayB0aGF0IGVsZW1lbnQgaXMgYXQgbGVhc3QgYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0VsZW1lbnQgJiZcclxuICAgICAgICB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbicpOyB9O1xyXG59KSgpO1xyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIGlmICghaXNCcm93c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVhZE9ubHlSZWN0KF9hKSB7XHJcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cclxuICAgIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcclxuICAgIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcclxuICAgIC8vIFJlY3RhbmdsZSdzIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUuXHJcbiAgICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xyXG4gICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgdG9wOiB5LFxyXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcbiAgICAgICAgYm90dG9tOiBoZWlnaHQgKyB5LFxyXG4gICAgICAgIGxlZnQ6IHhcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZGljdGRlZi1kb21yZWN0aW5pdFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbn1cblxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGF0aW9ucyBvZiB0aGUgY29udGVudCByZWN0YW5nbGUgb2ZcclxuICogcHJvdmlkZWQgRE9NIGVsZW1lbnQgYW5kIGZvciBrZWVwaW5nIHRyYWNrIG9mIGl0J3MgY2hhbmdlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRDb250ZW50UmVjdCh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSByZWN0O1xyXG4gICAgICAgIHJldHVybiAocmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fFxyXG4gICAgICAgICAgICByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAnYnJvYWRjYXN0V2lkdGgnIGFuZCAnYnJvYWRjYXN0SGVpZ2h0JyBwcm9wZXJ0aWVzIHdpdGggYSBkYXRhXHJcbiAgICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fSBMYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0LCByZWN0SW5pdCkge1xyXG4gICAgICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7XHJcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGVcclxuICAgICAgICAvLyBhbmQgYXJlIGFsc28gbm90IGVudW1lcmFibGUgaW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IGJlaW5nIHVzZWQgYXMgdGhleSdkIHJlcXVpcmUgdG8gZGVmaW5lIGFcclxuICAgICAgICAvLyBwcml2YXRlIFdlYWtNYXAgc3RvcmFnZSB3aGljaCBtYXkgY2F1c2UgbWVtb3J5IGxlYWtzIGluIGJyb3dzZXJzIHRoYXRcclxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHRoaXMgdHlwZSBvZiBjb2xsZWN0aW9ucy5cclxuICAgICAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQ6IHRhcmdldCwgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlclNQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXHJcbiAgICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICAgKiAgICAgIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgdXBkYXRlcyBvZiBvYnNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgICAgICogb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TWFwPEVsZW1lbnQsIFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDdHhfID0gY2FsbGJhY2tDdHg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAob2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLnNldCh0YXJnZXQsIG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgYWxsIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcclxuICAgICAgICAvLyBDcmVhdGUgUmVzaXplT2JzZXJ2ZXJFbnRyeSBpbnN0YW5jZSBmb3IgZXZlcnkgYWN0aXZlIG9ic2VydmF0aW9uLlxyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XHJcbn0oKSk7XG5cbi8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cclxuLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxyXG4vLyBjYW4ndCBiZSBmdWxseSBwb2x5ZmlsbGVkIGFueXdheS5cclxudmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xyXG4vKipcclxuICogUmVzaXplT2JzZXJ2ZXIgQVBJLiBFbmNhcHN1bGF0ZXMgdGhlIFJlc2l6ZU9ic2VydmVyIFNQSSBpbXBsZW1lbnRhdGlvblxyXG4gKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XHJcbiAgICAgICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0oKSk7XHJcbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cclxuW1xyXG4gICAgJ29ic2VydmUnLFxyXG4gICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAnZGlzY29ubmVjdCdcclxuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn0pO1xuXG52YXIgaW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KSgpO1xuXG52YXIgSGVhZGluZ1BvcHVwQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShIZWFkaW5nUG9wdXBCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRpbmdQb3B1cEJvZHkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSGVhZGluZ1BvcHVwQm9keS5wcm90b3R5cGUuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGVsID0gY2xvc2VzdChldi50YXJnZXQsICdsaScpO1xuICAgICAgICB0aGlzLnByb3BzLmV4ZWNDb21tYW5kKCdoZWFkaW5nJywge1xuICAgICAgICAgICAgbGV2ZWw6IE51bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGV2ZWwnKSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVhZGluZ1BvcHVwQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDggfHwgKHRlbXBsYXRlT2JqZWN0XzIkOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDx1bFxcbiAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgIGFyaWEtcm9sZT1cXFwibWVudVxcXCJcXG4gICAgICAgIGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCJcXG4gICAgICA+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICAgIDxsaSBkYXRhLXR5cGU9XFxcIlBhcmFncmFwaFxcXCIgYXJpYS1yb2xlPVxcXCJtZW51aXRlbVxcXCI+XFxuICAgICAgICAgIDxkaXY+XCIsIFwiPC9kaXY+XFxuICAgICAgICA8L2xpPlxcbiAgICAgIDwvdWw+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPHVsXFxuICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgYXJpYS1yb2xlPVxcXCJtZW51XFxcIlxcbiAgICAgICAgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgID5cXG4gICAgICAgIFwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgIDxsaSBkYXRhLXR5cGU9XFxcIlBhcmFncmFwaFxcXCIgYXJpYS1yb2xlPVxcXCJtZW51aXRlbVxcXCI+XFxuICAgICAgICAgIDxkaXY+XCIsIFwiPC9kaXY+XFxuICAgICAgICA8L2xpPlxcbiAgICAgIDwvdWw+XFxuICAgIFwiXSkpLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmV4ZWNDb21tYW5kKGV2KTsgfSwgaTE4bi5nZXQoJ0hlYWRpbmdzJyksIFsxLCAyLCAzLCA0LCA1LCA2XS5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGcgfHwgKHRlbXBsYXRlT2JqZWN0XzEkZyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgICAgPGxpIGRhdGEtbGV2ZWw9XFxcIlwiLCBcIlxcXCIgZGF0YS10eXBlPVxcXCJIZWFkaW5nXFxcIiBhcmlhLXJvbGU9XFxcIm1lbnVpdGVtXFxcIj5cXG4gICAgICAgICAgICAgICAgPFwiLCBcIj5cIiwgXCIgXCIsIFwiPC8kPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICAgICAgPGxpIGRhdGEtbGV2ZWw9XFxcIlwiLCBcIlxcXCIgZGF0YS10eXBlPVxcXCJIZWFkaW5nXFxcIiBhcmlhLXJvbGU9XFxcIm1lbnVpdGVtXFxcIj5cXG4gICAgICAgICAgICAgICAgPFwiLCBcIj5cIiwgXCIgXCIsIFwiPC8kPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICBcIl0pKSwgbGV2ZWwsIFwiaFwiICsgbGV2ZWwsIGkxOG4uZ2V0KCdIZWFkaW5nJyksIGxldmVsKTtcbiAgICAgICAgfSksIGkxOG4uZ2V0KCdQYXJhZ3JhcGgnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVhZGluZ1BvcHVwQm9keTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRnLCB0ZW1wbGF0ZU9iamVjdF8yJDg7XG5cbnZhciBUYWJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFicygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJzLnByb3RvdHlwZS50b2dnbGVUYWIgPSBmdW5jdGlvbiAoZXYsIGFjdGl2ZVRhYikge1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2soZXYsIGFjdGl2ZVRhYik7XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzIkNyB8fCAodGVtcGxhdGVPYmplY3RfMiQ3ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBhcmlhLXJvbGU9XFxcInRhYnBhbmVsXFxcIj5cXG4gICAgICAgIFwiLCBcIlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgYXJpYS1yb2xlPVxcXCJ0YWJwYW5lbFxcXCI+XFxuICAgICAgICBcIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBjbHMoJ3RhYnMnKSwgdGhpcy5wcm9wcy50YWJzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdGV4dCA9IF9hLnRleHQ7XG4gICAgICAgICAgICB2YXIgaXNBY3RpdmUgPSBfdGhpcy5wcm9wcy5hY3RpdmVUYWIgPT09IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGYgfHwgKHRlbXBsYXRlT2JqZWN0XzEkZiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgICBhcmlhLXJvbGU9XFxcInRhYlxcXCJcXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIHRhYmluZGV4PVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcInRhYi1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgICAgIGFyaWEtcm9sZT1cXFwidGFiXFxcIlxcbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgdGFiaW5kZXg9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgXCJdKSksIGlzQWN0aXZlID8gJyBhY3RpdmUnIDogJycsIGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMudG9nZ2xlVGFiKGV2LCBuYW1lKTsgfSwgaTE4bi5nZXQodGV4dCksIGlzQWN0aXZlID8gJ3RydWUnIDogJ2ZhbHNlJywgaXNBY3RpdmUgPyAnMCcgOiAnLTEnLCBpMThuLmdldCh0ZXh0KSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJzO1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGYsIHRlbXBsYXRlT2JqZWN0XzIkNztcblxudmFyIFRZUEVfVUkgPSAndWknO1xudmFyIEltYWdlUG9wdXBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEltYWdlUG9wdXBCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEltYWdlUG9wdXBCb2R5KHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbml0aWFsaXplID0gZnVuY3Rpb24gKGFjdGl2ZVRhYikge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVRhYiA9PT0gdm9pZCAwKSB7IGFjdGl2ZVRhYiA9ICdmaWxlJzsgfVxuICAgICAgICAgICAgdmFyIHVybEVsID0gX3RoaXMucmVmcy51cmw7XG4gICAgICAgICAgICB1cmxFbC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgX3RoaXMucmVmcy5hbHRUZXh0LnZhbHVlID0gJyc7XG4gICAgICAgICAgICBfdGhpcy5yZWZzLmZpbGUudmFsdWUgPSAnJztcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzXzEodXJsRWwsICd3cm9uZycpO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBhY3RpdmVUYWI6IGFjdGl2ZVRhYiwgZmlsZTogbnVsbCwgZmlsZU5hbWVFbENsYXNzTmFtZTogJycgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmV4ZWNDb21tYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmFjdGl2ZVRhYiA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdEFkZEltYWdlQmxvYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdEFkZEltYWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRvZ2dsZVRhYiA9IGZ1bmN0aW9uIChfLCBhY3RpdmVUYWIpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVUYWIgIT09IF90aGlzLnN0YXRlLmFjdGl2ZVRhYikge1xuICAgICAgICAgICAgICAgIF90aGlzLmluaXRpYWxpemUoYWN0aXZlVGFiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2hvd0ZpbGVTZWxlY3RCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWZzLmZpbGUuY2xpY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2hhbmdlRmlsZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGZpbGVzID0gZXYudGFyZ2V0LmZpbGVzO1xuICAgICAgICAgICAgaWYgKGZpbGVzID09PSBudWxsIHx8IGZpbGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGZpbGU6IGZpbGVzWzBdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgYWN0aXZlVGFiOiAnZmlsZScsIGZpbGU6IG51bGwsIGZpbGVOYW1lRWxDbGFzc05hbWU6ICcnIH07XG4gICAgICAgIF90aGlzLnRhYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdmaWxlJywgdGV4dDogJ0ZpbGUnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd1cmwnLCB0ZXh0OiAnVVJMJyB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEltYWdlUG9wdXBCb2R5LnByb3RvdHlwZS5lbWl0QWRkSW1hZ2VCbG9iID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmlsZXMgPSB0aGlzLnJlZnMuZmlsZS5maWxlcztcbiAgICAgICAgdmFyIGFsdFRleHRFbCA9IHRoaXMucmVmcy5hbHRUZXh0O1xuICAgICAgICB2YXIgZmlsZU5hbWVFbENsYXNzTmFtZSA9ICcgd3JvbmcnO1xuICAgICAgICBpZiAoZmlsZXMgPT09IG51bGwgfHwgZmlsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZmlsZU5hbWVFbENsYXNzTmFtZSA9ICcnO1xuICAgICAgICAgICAgdmFyIGltYWdlRmlsZSA9IGZpbGVzLml0ZW0oMCk7XG4gICAgICAgICAgICB2YXIgaG9va0NhbGxiYWNrID0gZnVuY3Rpb24gKHVybCwgdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5leGVjQ29tbWFuZCgnYWRkSW1hZ2UnLCB7IGltYWdlVXJsOiB1cmwsIGFsdFRleHQ6IHRleHQgfHwgYWx0VGV4dEVsLnZhbHVlIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZXZlbnRFbWl0dGVyLmVtaXQoJ2FkZEltYWdlQmxvYkhvb2snLCBpbWFnZUZpbGUsIGhvb2tDYWxsYmFjaywgVFlQRV9VSSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVOYW1lRWxDbGFzc05hbWU6IGZpbGVOYW1lRWxDbGFzc05hbWUgfSk7XG4gICAgfTtcbiAgICBJbWFnZVBvcHVwQm9keS5wcm90b3R5cGUuZW1pdEFkZEltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW1hZ2VVcmxFbCA9IHRoaXMucmVmcy51cmw7XG4gICAgICAgIHZhciBhbHRUZXh0RWwgPSB0aGlzLnJlZnMuYWx0VGV4dDtcbiAgICAgICAgdmFyIGltYWdlVXJsID0gaW1hZ2VVcmxFbC52YWx1ZTtcbiAgICAgICAgdmFyIGFsdFRleHQgPSBhbHRUZXh0RWwudmFsdWUgfHwgJ2ltYWdlJztcbiAgICAgICAgcmVtb3ZlQ2xhc3NfMShpbWFnZVVybEVsLCAnd3JvbmcnKTtcbiAgICAgICAgaWYgKCFpbWFnZVVybC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZENsYXNzXzEoaW1hZ2VVcmxFbCwgJ3dyb25nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlVXJsKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmV4ZWNDb21tYW5kKCdhZGRJbWFnZScsIHsgaW1hZ2VVcmw6IGltYWdlVXJsLCBhbHRUZXh0OiBhbHRUZXh0IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVBvcHVwQm9keS5wcm90b3R5cGUucHJldmVudFNlbGVjdFN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBJbWFnZVBvcHVwQm9keS5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLnNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVBvcHVwQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBhY3RpdmVUYWIgPSBfYS5hY3RpdmVUYWIsIGZpbGUgPSBfYS5maWxlLCBmaWxlTmFtZUVsQ2xhc3NOYW1lID0gX2EuZmlsZU5hbWVFbENsYXNzTmFtZTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRlIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8XCIsIFwiIHRhYnM9XCIsIFwiIGFjdGl2ZVRhYj1cIiwgXCIgb25DbGljaz1cIiwgXCIgLz5cXG4gICAgICAgIDxkaXYgc3R5bGU9XFxcImRpc3BsYXk6XCIsIFwiXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUltYWdlVXJsSW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpSW1hZ2VVcmxJbnB1dFxcXCJcXG4gICAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBzdHlsZT1cXFwiZGlzcGxheTpcIiwgXCI7cG9zaXRpb246IHJlbGF0aXZlO1xcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlJbWFnZUZpbGVJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgICAgPHNwYW5cXG4gICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgb25TZWxlY3RzdGFydD1cIiwgXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICBpZD1cXFwidG9hc3R1aUltYWdlRmlsZUlucHV0XFxcIlxcbiAgICAgICAgICAgIHR5cGU9XFxcImZpbGVcXFwiXFxuICAgICAgICAgICAgYWNjZXB0PVxcXCJpbWFnZS8qXFxcIlxcbiAgICAgICAgICAgIG9uQ2hhbmdlPVwiLCBcIlxcbiAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUFsdFRleHRJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICBpZD1cXFwidG9hc3R1aUFsdFRleHRJbnB1dFxcXCJcXG4gICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8XCIsIFwiIHRhYnM9XCIsIFwiIGFjdGl2ZVRhYj1cIiwgXCIgb25DbGljaz1cIiwgXCIgLz5cXG4gICAgICAgIDxkaXYgc3R5bGU9XFxcImRpc3BsYXk6XCIsIFwiXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUltYWdlVXJsSW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpSW1hZ2VVcmxJbnB1dFxcXCJcXG4gICAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBzdHlsZT1cXFwiZGlzcGxheTpcIiwgXCI7cG9zaXRpb246IHJlbGF0aXZlO1xcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlJbWFnZUZpbGVJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgICAgPHNwYW5cXG4gICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgb25TZWxlY3RzdGFydD1cIiwgXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICBpZD1cXFwidG9hc3R1aUltYWdlRmlsZUlucHV0XFxcIlxcbiAgICAgICAgICAgIHR5cGU9XFxcImZpbGVcXFwiXFxuICAgICAgICAgICAgYWNjZXB0PVxcXCJpbWFnZS8qXFxcIlxcbiAgICAgICAgICAgIG9uQ2hhbmdlPVwiLCBcIlxcbiAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUFsdFRleHRJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICBpZD1cXFwidG9hc3R1aUFsdFRleHRJbnB1dFxcXCJcXG4gICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGkxOG4uZ2V0KCdJbnNlcnQgaW1hZ2UnKSwgVGFicywgdGhpcy50YWJzLCBhY3RpdmVUYWIsIHRoaXMudG9nZ2xlVGFiLCBhY3RpdmVUYWIgPT09ICd1cmwnID8gJ2Jsb2NrJyA6ICdub25lJywgaTE4bi5nZXQoJ0ltYWdlIFVSTCcpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnVybCA9IGVsKTsgfSwgYWN0aXZlVGFiID09PSAnZmlsZScgPyAnYmxvY2snIDogJ25vbmUnLCBpMThuLmdldCgnU2VsZWN0IGltYWdlIGZpbGUnKSwgY2xzKCdmaWxlLW5hbWUnKSwgZmlsZSA/ICcgaGFzLWZpbGUnIDogZmlsZU5hbWVFbENsYXNzTmFtZSwgdGhpcy5zaG93RmlsZVNlbGVjdEJveCwgdGhpcy5wcmV2ZW50U2VsZWN0U3RhcnQsIGZpbGUgPyBmaWxlLm5hbWUgOiBpMThuLmdldCgnTm8gZmlsZScpLCBjbHMoJ2ZpbGUtc2VsZWN0LWJ1dHRvbicpLCB0aGlzLnNob3dGaWxlU2VsZWN0Qm94LCBpMThuLmdldCgnQ2hvb3NlIGEgZmlsZScpLCB0aGlzLmNoYW5nZUZpbGUsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZmlsZSA9IGVsKTsgfSwgaTE4bi5nZXQoJ0Rlc2NyaXB0aW9uJyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuYWx0VGV4dCA9IGVsKTsgfSwgY2xzKCdidXR0b24tY29udGFpbmVyJyksIGNscygnY2xvc2UtYnV0dG9uJyksIHRoaXMucHJvcHMuaGlkZVBvcHVwLCBpMThuLmdldCgnQ2FuY2VsJyksIGNscygnb2stYnV0dG9uJyksIHRoaXMuZXhlY0NvbW1hbmQsIGkxOG4uZ2V0KCdPSycpKTtcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVBvcHVwQm9keTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRlO1xuXG52YXIgTGlua1BvcHVwQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMaW5rUG9wdXBCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmtQb3B1cEJvZHkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsaW5rVXJsRWwgPSBfdGhpcy5yZWZzLnVybDtcbiAgICAgICAgICAgIHZhciBsaW5rVGV4dEVsID0gX3RoaXMucmVmcy50ZXh0O1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMShsaW5rVXJsRWwsICd3cm9uZycpO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMShsaW5rVGV4dEVsLCAnd3JvbmcnKTtcbiAgICAgICAgICAgIGlmIChsaW5rVXJsRWwudmFsdWUubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzXzEobGlua1VybEVsLCAnd3JvbmcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hlY2tMaW5rVGV4dCA9IGlzVW5kZWZpbmVkXzEoX3RoaXMucHJvcHMuaW5pdGlhbFZhbHVlcy5saW5rVXJsKTtcbiAgICAgICAgICAgIGlmIChjaGVja0xpbmtUZXh0ICYmIGxpbmtUZXh0RWwudmFsdWUubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzXzEobGlua1RleHRFbCwgJ3dyb25nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucHJvcHMuZXhlY0NvbW1hbmQoJ2FkZExpbmsnLCB7XG4gICAgICAgICAgICAgICAgbGlua1VybDogbGlua1VybEVsLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxpbmtUZXh0OiBsaW5rVGV4dEVsLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGlua1BvcHVwQm9keS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcy5pbml0aWFsVmFsdWVzLCBsaW5rVXJsID0gX2EubGlua1VybCwgbGlua1RleHQgPSBfYS5saW5rVGV4dDtcbiAgICAgICAgdmFyIGxpbmtVcmxFbCA9IHRoaXMucmVmcy51cmw7XG4gICAgICAgIHZhciBsaW5rVGV4dEVsID0gdGhpcy5yZWZzLnRleHQ7XG4gICAgICAgIHJlbW92ZUNsYXNzXzEobGlua1VybEVsLCAnd3JvbmcnKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3NfMShsaW5rVGV4dEVsLCAnd3JvbmcnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgbGlua1RleHRFbC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIGlmIChsaW5rVXJsKSB7XG4gICAgICAgICAgICBhZGRDbGFzc18xKGxpbmtUZXh0RWwsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgbGlua1RleHRFbC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGlua1VybEVsLnZhbHVlID0gbGlua1VybCB8fCAnJztcbiAgICAgICAgbGlua1RleHRFbC52YWx1ZSA9IGxpbmtUZXh0IHx8ICcnO1xuICAgIH07XG4gICAgTGlua1BvcHVwQm9keS5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfTtcbiAgICBMaW5rUG9wdXBCb2R5LnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAoIXByZXZQcm9wcy5zaG93ICYmIHRoaXMucHJvcHMuc2hvdykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtQb3B1cEJvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRkIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpTGlua1VybElucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpTGlua1VybElucHV0XFxcIlxcbiAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUxpbmtUZXh0SW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgaWQ9XFxcInRvYXN0dWlMaW5rVGV4dElucHV0XFxcIlxcbiAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlMaW5rVXJsSW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgaWQ9XFxcInRvYXN0dWlMaW5rVXJsSW5wdXRcXFwiXFxuICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpTGlua1RleHRJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICBpZD1cXFwidG9hc3R1aUxpbmtUZXh0SW5wdXRcXFwiXFxuICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBpMThuLmdldCgnSW5zZXJ0IGxpbmsnKSwgaTE4bi5nZXQoJ1VSTCcpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnVybCA9IGVsKTsgfSwgaTE4bi5nZXQoJ0xpbmsgdGV4dCcpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnRleHQgPSBlbCk7IH0sIGNscygnYnV0dG9uLWNvbnRhaW5lcicpLCBjbHMoJ2Nsb3NlLWJ1dHRvbicpLCB0aGlzLnByb3BzLmhpZGVQb3B1cCwgaTE4bi5nZXQoJ0NhbmNlbCcpLCBjbHMoJ29rLWJ1dHRvbicpLCB0aGlzLmV4ZWNDb21tYW5kLCBpMThuLmdldCgnT0snKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua1BvcHVwQm9keTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRkO1xuXG52YXIgQ0VMTF9XSURUSCA9IDIwO1xudmFyIENFTExfSEVJR0hUID0gMjA7XG52YXIgTUlOX1JPV19JTkRFWCA9IDU7XG52YXIgTUFYX1JPV19JTkRFWCA9IDE0O1xudmFyIE1JTl9DT0xfSU5ERVggPSA1O1xudmFyIE1BWF9DT0xfSU5ERVggPSA5O1xudmFyIE1JTl9ST1dfU0VMRUNUSU9OX0lOREVYID0gMTtcbnZhciBNSU5fQ09MX1NFTEVDVElPTl9JTkRFWCA9IDE7XG52YXIgQk9SREVSX1dJRFRIID0gMTtcbnZhciBUYWJsZVBvcHVwQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZVBvcHVwQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZVBvcHVwQm9keShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXh0ZW5kU2VsZWN0aW9uUmFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBwYWdlWCA9IF9hLnBhZ2VYLCBwYWdlWSA9IF9hLnBhZ2VZO1xuICAgICAgICAgICAgdmFyIHggPSBwYWdlWCAtIF90aGlzLm9mZnNldFJlY3QubGVmdDtcbiAgICAgICAgICAgIHZhciB5ID0gcGFnZVkgLSBfdGhpcy5vZmZzZXRSZWN0LnRvcDtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IF90aGlzLmdldFNlbGVjdGlvblJhbmdlQnlPZmZzZXQoeCwgeSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfX2Fzc2lnbiQxKHt9LCByYW5nZSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLmV4ZWNDb21tYW5kKCdhZGRUYWJsZScsIHtcbiAgICAgICAgICAgICAgICByb3dDb3VudDogX3RoaXMuc3RhdGUucm93SWR4ICsgMSxcbiAgICAgICAgICAgICAgICBjb2x1bW5Db3VudDogX3RoaXMuc3RhdGUuY29sSWR4ICsgMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJvd0lkeDogLTEsXG4gICAgICAgICAgICBjb2xJZHg6IC0xLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY29sSWR4ID09PSAtMSA/ICcnIDogdGhpcy5zdGF0ZS5jb2xJZHggKyAxICsgXCIgeCBcIiArICh0aGlzLnN0YXRlLnJvd0lkeCArIDEpO1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmdldEJvdW5kQnlSYW5nZSA9IGZ1bmN0aW9uIChjb2xJZHgsIHJvd0lkeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IChjb2xJZHggKyAxKSAqIENFTExfV0lEVEgsXG4gICAgICAgICAgICBoZWlnaHQ6IChyb3dJZHggKyAxKSAqIENFTExfSEVJR0hULFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmdldFJhbmdlQnlPZmZzZXQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sSWR4OiBNYXRoLmZsb29yKHggLyBDRUxMX1dJRFRIKSxcbiAgICAgICAgICAgIHJvd0lkeDogTWF0aC5mbG9vcih5IC8gQ0VMTF9IRUlHSFQpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmdldFRhYmxlUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIG9yZ0NvbElkeCA9IF9hLmNvbElkeCwgb3JnUm93SWR4ID0gX2Eucm93SWR4O1xuICAgICAgICB2YXIgY29sSWR4ID0gTWF0aC5tYXgob3JnQ29sSWR4LCBNSU5fQ09MX0lOREVYKTtcbiAgICAgICAgdmFyIHJvd0lkeCA9IE1hdGgubWF4KG9yZ1Jvd0lkeCwgTUlOX1JPV19JTkRFWCk7XG4gICAgICAgIGlmIChvcmdDb2xJZHggPj0gTUlOX0NPTF9JTkRFWCAmJiBjb2xJZHggPCBNQVhfQ09MX0lOREVYKSB7XG4gICAgICAgICAgICBjb2xJZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JnUm93SWR4ID49IE1JTl9ST1dfSU5ERVggJiYgcm93SWR4IDwgTUFYX1JPV19JTkRFWCkge1xuICAgICAgICAgICAgcm93SWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29sSWR4OiBjb2xJZHggKyAxLCByb3dJZHg6IHJvd0lkeCArIDEgfTtcbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5nZXRTZWxlY3Rpb25BcmVhQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0Qm91bmRCeVJhbmdlKHRoaXMuc3RhdGUuY29sSWR4LCB0aGlzLnN0YXRlLnJvd0lkeCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4geyBkaXNwbGF5OiAnbm9uZScgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB3aWR0aDogd2lkdGggLSBCT1JERVJfV0lEVEgsIGhlaWdodDogaGVpZ2h0IC0gQk9SREVSX1dJRFRILCBkaXNwbGF5OiAnYmxvY2snIH07XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uUmFuZ2VCeU9mZnNldCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2VCeU9mZnNldCh4LCB5KTtcbiAgICAgICAgcmFuZ2Uucm93SWR4ID0gTWF0aC5taW4oTWF0aC5tYXgocmFuZ2Uucm93SWR4LCBNSU5fUk9XX1NFTEVDVElPTl9JTkRFWCksIE1BWF9ST1dfSU5ERVgpO1xuICAgICAgICByYW5nZS5jb2xJZHggPSBNYXRoLm1pbihNYXRoLm1heChyYW5nZS5jb2xJZHgsIE1JTl9DT0xfU0VMRUNUSU9OX0lOREVYKSwgTUFYX0NPTF9JTkRFWCk7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuc2hvdykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbElkeDogLTEsIHJvd0lkeDogLTEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5jb2xJZHggPT09IC0xICYmIHRoaXMuc3RhdGUucm93SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5yZWZzLnRhYmxlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxlZnQgPSBfYS5sZWZ0LCB0b3BfMSA9IF9hLnRvcDtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0UmVjdCA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB3aW5kb3cucGFnZVhPZmZzZXQgKyBsZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0ICsgdG9wXzEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUuY3JlYXRlVGFibGVBcmVhID0gZnVuY3Rpb24gKHRhYmxlUmFuZ2UpIHtcbiAgICAgICAgdmFyIGNvbElkeCA9IHRhYmxlUmFuZ2UuY29sSWR4LCByb3dJZHggPSB0YWJsZVJhbmdlLnJvd0lkeDtcbiAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dJZHg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbElkeDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxDbGFzc05hbWVzID0gXCJcIiArIGNscygndGFibGUtY2VsbCcpICsgKGkgPiAwID8gJycgOiAnIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGMgfHwgKHRlbXBsYXRlT2JqZWN0XzEkYyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+PC9kaXY+XCJdLCBbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPjwvZGl2PlwiXSkpLCBjZWxsQ2xhc3NOYW1lcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93cy5wdXNoKGh0bWwodGVtcGxhdGVPYmplY3RfMiQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvZGl2PlwiXSwgW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L2Rpdj5cIl0pKSwgY2xzKCd0YWJsZS1yb3cnKSwgY2VsbHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8zJDIgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9kaXY+XCJdLCBbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvZGl2PlwiXSkpLCBjbHMoJ3RhYmxlJyksIHJvd3MpO1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRhYmxlUmFuZ2UgPSB0aGlzLmdldFRhYmxlUmFuZ2UoKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkFyZWFCb3VuZCA9IHRoaXMuZ2V0U2VsZWN0aW9uQXJlYUJvdW5kKCk7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzQkMSB8fCAodGVtcGxhdGVPYmplY3RfNCQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIG9uTW91c2Vtb3ZlPVwiLCBcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxwIGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvcD5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgb25Nb3VzZW1vdmU9XCIsIFwiXFxuICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPHAgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9wPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgaTE4bi5nZXQoJ0luc2VydCB0YWJsZScpLCBjbHMoJ3RhYmxlLXNlbGVjdGlvbicpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnRhYmxlRWwgPSBlbCk7IH0sIHRoaXMuZXh0ZW5kU2VsZWN0aW9uUmFuZ2UsIHRoaXMuZXhlY0NvbW1hbmQsIHRoaXMuY3JlYXRlVGFibGVBcmVhKHRhYmxlUmFuZ2UpLCBjbHMoJ3RhYmxlLXNlbGVjdGlvbi1sYXllcicpLCBzZWxlY3Rpb25BcmVhQm91bmQsIGNscygndGFibGUtZGVzY3JpcHRpb24nKSwgdGhpcy5nZXREZXNjcmlwdGlvbigpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZVBvcHVwQm9keTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRjLCB0ZW1wbGF0ZU9iamVjdF8yJDYsIHRlbXBsYXRlT2JqZWN0XzMkMiwgdGVtcGxhdGVPYmplY3RfNCQxO1xuXG52YXIgQ3VzdG9tUG9wdXBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEN1c3RvbVBvcHVwQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21Qb3B1cEJvZHkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ3VzdG9tUG9wdXBCb2R5LnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGN1c3RvbSBwb3B1cCBib2R5IGVsZW1lbnRcbiAgICAgICAgdGhpcy5yZWZzLmVsLmFwcGVuZENoaWxkKHRoaXMucHJvcHMuYm9keSk7XG4gICAgfTtcbiAgICBDdXN0b21Qb3B1cEJvZHkucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBjdXN0b20gcG9wdXAgZWxlbWVudFxuICAgICAgICB0aGlzLnJlZnMuZWwucmVwbGFjZUNoaWxkKHRoaXMucHJvcHMuYm9keSwgcHJldlByb3BzLmJvZHkpO1xuICAgIH07XG4gICAgQ3VzdG9tUG9wdXBCb2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkYiB8fCAodGVtcGxhdGVPYmplY3RfMSRiID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPGRpdiByZWY9XCIsIFwiPjwvZGl2PlwiXSwgW1wiPGRpdiByZWY9XCIsIFwiPjwvZGl2PlwiXSkpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVsID0gZWwpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21Qb3B1cEJvZHk7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkYjtcblxuZnVuY3Rpb24gY3JlYXRlVG9vbGJhckl0ZW1JbmZvKHR5cGUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh0eXBlKSA/IGNyZWF0ZURlZmF1bHRUb29sYmFySXRlbUluZm8odHlwZSkgOiB0eXBlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2Nyb2xsU3luY1Rvb2xiYXJJdGVtKCkge1xuICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB2YXIgdG9nZ2xlU3dpdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9ICdzY3JvbGwtc3luYyBhY3RpdmUnO1xuICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgIHRvZ2dsZVN3aXRjaC5jbGFzc05hbWUgPSAnc3dpdGNoJztcbiAgICB2YXIgb25Nb3VudGVkID0gZnVuY3Rpb24gKGV4ZWNDb21tYW5kKSB7XG4gICAgICAgIHJldHVybiBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjaGVja2VkID0gZXYudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzXzEobGFiZWwsICdhY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzXzEobGFiZWwsICdhY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4ZWNDb21tYW5kKCd0b2dnbGVTY3JvbGxTeW5jJywgeyBhY3RpdmU6IGNoZWNrZWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQoY2hlY2tib3gpO1xuICAgIGxhYmVsLmFwcGVuZENoaWxkKHRvZ2dsZVN3aXRjaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3Njcm9sbFN5bmMnLFxuICAgICAgICBlbDogbGFiZWwsXG4gICAgICAgIG9uTW91bnRlZDogb25Nb3VudGVkLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0VG9vbGJhckl0ZW1JbmZvKHR5cGUpIHtcbiAgICB2YXIgaW5mbztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdoZWFkaW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdoZWFkaW5nJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSGVhZGluZ3MnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib2xkJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnQm9sZCcpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnc3Ryb25nJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaXRhbGljJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2l0YWxpYycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnaXRhbGljJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnaXRhbGljJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSXRhbGljJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdlbXBoJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3N0cmlrZScsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnc3RyaWtlJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnc3RyaWtlJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnU3RyaWtlJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdHJpa2UnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdocic6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdocicsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnaHJsaW5lJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnaHInLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdMaW5lJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd0aGVtYXRpY0JyZWFrJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncXVvdGUnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAncXVvdGUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3F1b3RlJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnYmxvY2tRdW90ZScsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0Jsb2NrcXVvdGUnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2Jsb2NrUXVvdGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1bCc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd1bCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnYnVsbGV0LWxpc3QnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdidWxsZXRMaXN0JyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnVW5vcmRlcmVkIGxpc3QnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2J1bGxldExpc3QnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvbCc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdvbCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnb3JkZXJlZC1saXN0JyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnb3JkZXJlZExpc3QnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdPcmRlcmVkIGxpc3QnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ29yZGVyZWRMaXN0JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFzayc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0YXNrJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICd0YXNrLWxpc3QnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd0YXNrTGlzdCcsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ1Rhc2snKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3Rhc2tMaXN0JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAndGFibGUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSW5zZXJ0IHRhYmxlJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd0YWJsZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0luc2VydCBpbWFnZScpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdJbnNlcnQgbGluaycpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnQ29kZScpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnY29kZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvZGVibG9jayc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjb2RlYmxvY2snLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2NvZGVibG9jaycsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NvZGVCbG9jaycsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0luc2VydCBDb2RlQmxvY2snKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2NvZGVCbG9jaycsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luZGVudCc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdpbmRlbnQnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2luZGVudCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2luZGVudCcsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0luZGVudCcpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnaW5kZW50JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3V0ZGVudCc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdvdXRkZW50JyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdvdXRkZW50JyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnb3V0ZGVudCcsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ091dGRlbnQnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ291dGRlbnQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzY3JvbGxTeW5jJzpcbiAgICAgICAgICAgIGluZm8gPSBjcmVhdGVTY3JvbGxTeW5jVG9vbGJhckl0ZW0oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb3JlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ21vcmUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ21vcmUnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdNb3JlJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG4gICAgaWYgKGluZm8ubmFtZSAhPT0gJ3Njcm9sbFN5bmMnKSB7XG4gICAgICAgIGluZm8uY2xhc3NOYW1lICs9IFwiIFwiICsgY2xzKCd0b29sYmFyLWljb25zJyk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9wdXBJbmZvKHR5cGUsIHBheWxvYWQpIHtcbiAgICB2YXIgZWwgPSBwYXlsb2FkLmVsLCBwb3MgPSBwYXlsb2FkLnBvcywgcG9wdXAgPSBwYXlsb2FkLnBvcHVwLCBpbml0aWFsVmFsdWVzID0gcGF5bG9hZC5pbml0aWFsVmFsdWVzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRhIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0pKSwgSGVhZGluZ1BvcHVwQm9keSwgcHJvcHMpOyB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzKCdwb3B1cC1hZGQtaGVhZGluZycpLFxuICAgICAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMiQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0pKSwgTGlua1BvcHVwQm9keSwgcHJvcHMpOyB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzKCdwb3B1cC1hZGQtbGluaycpLFxuICAgICAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlczogaW5pdGlhbFZhbHVlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMyQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8zJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0pKSwgSW1hZ2VQb3B1cEJvZHksIHByb3BzKTsgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNscygncG9wdXAtYWRkLWltYWdlJyksXG4gICAgICAgICAgICAgICAgZnJvbUVsOiBlbCxcbiAgICAgICAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfNCB8fCAodGVtcGxhdGVPYmplY3RfNCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIgLi4uXCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSkpLCBUYWJsZVBvcHVwQm9keSwgcHJvcHMpOyB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzKCdwb3B1cC1hZGQtdGFibGUnKSxcbiAgICAgICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnY3VzdG9tUG9wdXBCb2R5JzpcbiAgICAgICAgICAgIGlmICghcG9wdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfNSB8fCAodGVtcGxhdGVPYmplY3RfNSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIgLi4uXCIsIFwiIGJvZHk9XCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIC4uLlwiLCBcIiBib2R5PVwiLCBcIiAvPlwiXSkpLCBDdXN0b21Qb3B1cEJvZHksIHByb3BzLCBwb3B1cC5ib2R5KTsgfSwgZnJvbUVsOiBlbCwgcG9zOiBwb3MgfSwgcG9wdXApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0R3JvdXBTdGF0ZShncm91cCkge1xuICAgIGdyb3VwLmhpZGRlbiA9IGdyb3VwLmxlbmd0aCA9PT0gZ3JvdXAuZmlsdGVyKGZ1bmN0aW9uIChpbmZvKSB7IHJldHVybiBpbmZvLmhpZGRlbjsgfSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gZ3JvdXBUb29sYmFySXRlbXModG9vbGJhckl0ZW1zLCBoaWRkZW5TY3JvbGxTeW5jKSB7XG4gICAgdmFyIHRvZ2dsZVNjcm9sbFN5bmNTdGF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW0uaGlkZGVuID0gaXRlbS5uYW1lID09PSAnc2Nyb2xsU3luYycgJiYgaGlkZGVuU2Nyb2xsU3luYztcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcbiAgICByZXR1cm4gdG9vbGJhckl0ZW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICAgIGFjYy5wdXNoKGl0ZW0ubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0b2dnbGVTY3JvbGxTeW5jU3RhdGUoY3JlYXRlVG9vbGJhckl0ZW1JbmZvKHR5cGUpKTsgfSkpO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhY2NbKGFjYy5sZW5ndGggfHwgMSkgLSAxXTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBzZXRHcm91cFN0YXRlKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVNjcm9sbFN5bmModG9vbGJhckl0ZW1zLCBoaWRkZW5TY3JvbGxTeW5jKSB7XG4gICAgdG9vbGJhckl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIChpdGVtLmhpZGRlbiA9IGl0ZW0ubmFtZSA9PT0gJ3Njcm9sbFN5bmMnICYmIGhpZGRlblNjcm9sbFN5bmMpOyB9KTtcbiAgICAgICAgc2V0R3JvdXBTdGF0ZShncm91cCk7XG4gICAgfSk7XG59XG52YXIgdGVtcGxhdGVPYmplY3RfMSRhLCB0ZW1wbGF0ZU9iamVjdF8yJDUsIHRlbXBsYXRlT2JqZWN0XzMkMSwgdGVtcGxhdGVPYmplY3RfNCwgdGVtcGxhdGVPYmplY3RfNTtcblxudmFyIE1BUkdJTl9GUk9NX1JJR0hUX1NJREUgPSAyMDtcbnZhciBQb3B1cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShQb3B1cCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3B1cCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0KGV2LnRhcmdldCwgXCIuXCIgKyBjbHMoJ3BvcHVwJykpICYmXG4gICAgICAgICAgICAgICAgIWNsb3Nlc3QoZXYudGFyZ2V0LCBfdGhpcy5wcm9wcy5pbmZvLmZyb21FbCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5oaWRlUG9wdXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb3B1cC5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZWRvd24pO1xuICAgICAgICB0aGlzLnByb3BzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2Nsb3NlUG9wdXAnLCB0aGlzLnByb3BzLmhpZGVQb3B1cCk7XG4gICAgfTtcbiAgICBQb3B1cC5wcm90b3R5cGUuYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZWRvd24pO1xuICAgIH07XG4gICAgUG9wdXAucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNob3cgPSBfYS5zaG93LCBpbmZvID0gX2EuaW5mbztcbiAgICAgICAgaWYgKHNob3cgJiYgaW5mby5wb3MgJiYgcHJldlByb3BzLnNob3cgIT09IHNob3cpIHtcbiAgICAgICAgICAgIHZhciBwb3B1cFBvcyA9IF9fYXNzaWduJDEoe30sIGluZm8ucG9zKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRXaWR0aCA9IHRoaXMucmVmcy5lbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciB0b29sYmFyRWwgPSBjbG9zZXN0KHRoaXMucmVmcy5lbCwgXCIuXCIgKyBjbHMoJ3Rvb2xiYXInKSk7XG4gICAgICAgICAgICB2YXIgdG9vbGJhck9mZnNldFdpZHRoID0gdG9vbGJhckVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgaWYgKHBvcHVwUG9zLmxlZnQgKyBvZmZzZXRXaWR0aCA+PSB0b29sYmFyT2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwb3B1cFBvcy5sZWZ0ID0gdG9vbGJhck9mZnNldFdpZHRoIC0gb2Zmc2V0V2lkdGggLSBNQVJHSU5fRlJPTV9SSUdIVF9TSURFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGFsbG93RXF1YWwodGhpcy5zdGF0ZS5wb3B1cFBvcywgcG9wdXBQb3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHBvcHVwUG9zOiBwb3B1cFBvcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wdXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgaW5mbyA9IF9hLmluZm8sIHNob3cgPSBfYS5zaG93LCBoaWRlUG9wdXAgPSBfYS5oaWRlUG9wdXAsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlciwgZXhlY0NvbW1hbmQgPSBfYS5leGVjQ29tbWFuZDtcbiAgICAgICAgdmFyIF9iID0gaW5mbyB8fCB7fSwgX2MgPSBfYi5jbGFzc05hbWUsIGNsYXNzTmFtZSA9IF9jID09PSB2b2lkIDAgPyAnJyA6IF9jLCBzdHlsZSA9IF9iLnN0eWxlLCByZW5kZXIgPSBfYi5yZW5kZXIsIF9kID0gX2IuaW5pdGlhbFZhbHVlcywgaW5pdGlhbFZhbHVlcyA9IF9kID09PSB2b2lkIDAgPyB7fSA6IF9kO1xuICAgICAgICB2YXIgcG9wdXBTdHlsZSA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7IGRpc3BsYXk6IHNob3cgPyAnYmxvY2snIDogJ25vbmUnIH0sIHN0eWxlKSwgdGhpcy5zdGF0ZS5wb3B1cFBvcyk7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkOSB8fCAodGVtcGxhdGVPYmplY3RfMSQ5ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcIlwiLCBcIiBcIiwgXCJcXFwiXFxuICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIGFyaWEtcm9sZT1cXFwiZGlhbG9nXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcIlwiLCBcIiBcIiwgXCJcXFwiXFxuICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIGFyaWEtcm9sZT1cXFwiZGlhbG9nXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBjbHMoJ3BvcHVwJyksIGNsYXNzTmFtZSwgcG9wdXBTdHlsZSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgY2xzKCdwb3B1cC1ib2R5JyksIHJlbmRlciAmJiByZW5kZXIoeyBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlciwgc2hvdzogc2hvdywgaGlkZVBvcHVwOiBoaWRlUG9wdXAsIGV4ZWNDb21tYW5kOiBleGVjQ29tbWFuZCwgaW5pdGlhbFZhbHVlczogaW5pdGlhbFZhbHVlcyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gUG9wdXA7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkOTtcblxudmFyIFRPT0xUSVBfSU5ERU5UID0gNjtcbmZ1bmN0aW9uIGNvbm5lY3RIT0MoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKEJ1dHRvbkhPQywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQnV0dG9uSE9DKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnNob3dUb29sdGlwID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXAgPSBfdGhpcy5wcm9wcy5pdGVtLnRvb2x0aXA7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5kaXNhYmxlZCAmJiB0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZCA9IF90aGlzLmdldEJvdW5kKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBib3VuZC5sZWZ0ICsgVE9PTFRJUF9JTkRFTlQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BfMSA9IGJvdW5kLnRvcCArIFRPT0xUSVBfSU5ERU5UICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBjc3NfMShfdGhpcy5wcm9wcy50b29sdGlwUmVmLmN1cnJlbnQsIHsgZGlzcGxheTogJ2Jsb2NrJywgbGVmdDogbGVmdCwgdG9wOiB0b3BfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMudG9vbHRpcFJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXh0JykudGV4dENvbnRlbnQgPSB0b29sdGlwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5oaWRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjc3NfMShfdGhpcy5wcm9wcy50b29sdGlwUmVmLmN1cnJlbnQsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgYWN0aXZlOiBmYWxzZSwgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkIH07XG4gICAgICAgICAgICBfdGhpcy5hZGRFdmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIEJ1dHRvbkhPQy5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgaXRlbSA9IF9hLml0ZW0sIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgICAgIGlmIChpdGVtLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlVG9vbGJhclN0YXRlJywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvb2xiYXJTdGF0ZSA9IF9hLnRvb2xiYXJTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gKF9iID0gdG9vbGJhclN0YXRlW2l0ZW0uc3RhdGVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSwgYWN0aXZlID0gX2MuYWN0aXZlLCBkaXNhYmxlZCA9IF9jLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZTogISFhY3RpdmUsIGRpc2FibGVkOiBkaXNhYmxlZCAhPT0gbnVsbCAmJiBkaXNhYmxlZCAhPT0gdm9pZCAwID8gZGlzYWJsZWQgOiBfdGhpcy5wcm9wcy5kaXNhYmxlZCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnV0dG9uSE9DLnByb3RvdHlwZS5nZXRCb3VuZCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0VG90YWxPZmZzZXQoZWwsIGNsb3Nlc3QoZWwsIFwiLlwiICsgY2xzKCd0b29sYmFyJykpKSwgb2Zmc2V0TGVmdCA9IF9hLm9mZnNldExlZnQsIG9mZnNldFRvcCA9IF9hLm9mZnNldFRvcDtcbiAgICAgICAgICAgIHJldHVybiB7IGxlZnQ6IG9mZnNldExlZnQsIHRvcDogZWwub2Zmc2V0SGVpZ2h0ICsgb2Zmc2V0VG9wIH07XG4gICAgICAgIH07XG4gICAgICAgIEJ1dHRvbkhPQy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQ4IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDggPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgIGFjdGl2ZT1cIiwgXCJcXG4gICAgICAgICAgc2hvd1Rvb2x0aXA9XCIsIFwiXFxuICAgICAgICAgIGhpZGVUb29sdGlwPVwiLCBcIlxcbiAgICAgICAgICBnZXRCb3VuZD1cIiwgXCJcXG4gICAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgIFwiXSwgW1wiXFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICBhY3RpdmU9XCIsIFwiXFxuICAgICAgICAgIHNob3dUb29sdGlwPVwiLCBcIlxcbiAgICAgICAgICBoaWRlVG9vbHRpcD1cIiwgXCJcXG4gICAgICAgICAgZ2V0Qm91bmQ9XCIsIFwiXFxuICAgICAgICAgIGRpc2FibGVkPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICBcIl0pKSwgV3JhcHBlZENvbXBvbmVudCwgdGhpcy5wcm9wcywgdGhpcy5zdGF0ZS5hY3RpdmUsIHRoaXMuc2hvd1Rvb2x0aXAsIHRoaXMuaGlkZVRvb2x0aXAsIHRoaXMuZ2V0Qm91bmQsIHRoaXMuc3RhdGUuZGlzYWJsZWQgfHwgdGhpcy5wcm9wcy5kaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCdXR0b25IT0M7XG4gICAgfShDb21wb25lbnQpKTtcbn1cbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDg7XG5cbnZhciBERUZBVUxUX1dJRFRIID0gODA7XG52YXIgVG9vbGJhckJ1dHRvbkNvbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVG9vbGJhckJ1dHRvbkNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9vbGJhckJ1dHRvbkNvbXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dUb29sdGlwKF90aGlzLnJlZnMuZWwpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBpdGVtID0gX2EuaXRlbSwgZXhlY0NvbW1hbmQgPSBfYS5leGVjQ29tbWFuZCwgc2V0UG9wdXBJbmZvID0gX2Euc2V0UG9wdXBJbmZvLCBnZXRCb3VuZCA9IF9hLmdldEJvdW5kLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXI7XG4gICAgICAgICAgICB2YXIgY29tbWFuZCA9IGl0ZW0uY29tbWFuZCwgbmFtZSA9IGl0ZW0ubmFtZSwgcG9wdXAgPSBpdGVtLnBvcHVwO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBleGVjQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwb3B1cE5hbWUgPSBwb3B1cCA/ICdjdXN0b21Qb3B1cEJvZHknIDogbmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFZhbHVlcyA9IGV2ZW50RW1pdHRlci5lbWl0KCdxdWVyeScsICdnZXRQb3B1cEluaXRpYWxWYWx1ZXMnLCB7IHBvcHVwTmFtZTogcG9wdXBOYW1lIH0pWzBdO1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gY3JlYXRlUG9wdXBJbmZvKHBvcHVwTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBlbDogX3RoaXMucmVmcy5lbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBnZXRCb3VuZChfdGhpcy5yZWZzLmVsKSxcbiAgICAgICAgICAgICAgICAgICAgcG9wdXA6IHBvcHVwLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWVzOiBpbml0aWFsVmFsdWVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFBvcHVwSW5mbyhpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbVdpZHRoKCk7XG4gICAgfTtcbiAgICBUb29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5pdGVtLm5hbWUgIT09IHRoaXMucHJvcHMuaXRlbS5uYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnNldEl0ZW1XaWR0aCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUuc2V0SXRlbVdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBzZXRJdGVtV2lkdGggPSBfYS5zZXRJdGVtV2lkdGgsIGl0ZW0gPSBfYS5pdGVtO1xuICAgICAgICAvLyBzZXQgd2lkdGggb25seSBpZiBpdCBpcyBub3QgYSBkcm9wZG93biB0b29sYmFyXG4gICAgICAgIGlmIChzZXRJdGVtV2lkdGgpIHtcbiAgICAgICAgICAgIHNldEl0ZW1XaWR0aChpdGVtLm5hbWUsIGdldE91dGVyV2lkdGgodGhpcy5yZWZzLmVsKSArIChpdGVtLmhpZGRlbiA/IERFRkFVTFRfV0lEVEggOiAwKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGhpZGVUb29sdGlwID0gX2EuaGlkZVRvb2x0aXAsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIGl0ZW0gPSBfYS5pdGVtLCBhY3RpdmUgPSBfYS5hY3RpdmU7XG4gICAgICAgIHZhciBzdHlsZSA9IF9fYXNzaWduJDEoeyBkaXNwbGF5OiBpdGVtLmhpZGRlbiA/ICdub25lJyA6IG51bGwgfSwgaXRlbS5zdHlsZSk7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gXCJcIiArIChpdGVtLmNsYXNzTmFtZSB8fCAnJykgKyAoYWN0aXZlID8gJyBhY3RpdmUnIDogJycpO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDcgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxidXR0b25cXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgY2xhc3M9XCIsIFwiXFxuICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW92ZXI9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3V0PVwiLCBcIlxcbiAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICBhcmlhLWxhYmVsPVwiLCBcIlxcbiAgICAgID5cXG4gICAgICAgIFwiLCBcIlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxidXR0b25cXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgY2xhc3M9XCIsIFwiXFxuICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW92ZXI9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3V0PVwiLCBcIlxcbiAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICBhcmlhLWxhYmVsPVwiLCBcIlxcbiAgICAgID5cXG4gICAgICAgIFwiLCBcIlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICBcIl0pKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgc3R5bGUsIGNsYXNzTmFtZXMsIHRoaXMuZXhlY0NvbW1hbmQsIHRoaXMuc2hvd1Rvb2x0aXAsIGhpZGVUb29sdGlwLCAhIWRpc2FibGVkLCBpdGVtLnRleHQgfHwgaXRlbS50b29sdGlwIHx8ICcnLCBpdGVtLnRleHQgfHwgJycpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXJCdXR0b25Db21wO1xufShDb21wb25lbnQpKTtcbnZhciBUb29sYmFyQnV0dG9uID0gY29ubmVjdEhPQyhUb29sYmFyQnV0dG9uQ29tcCk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQ3O1xuXG52YXIgQ3VzdG9tVG9vbGJhckl0ZW1Db21wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEN1c3RvbVRvb2xiYXJJdGVtQ29tcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21Ub29sYmFySXRlbUNvbXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dUb29sdGlwKF90aGlzLnJlZnMuZWwpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zaG93UG9wdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGNyZWF0ZVBvcHVwSW5mbygnY3VzdG9tUG9wdXBCb2R5Jywge1xuICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5yZWZzLmVsLFxuICAgICAgICAgICAgICAgIHBvczogX3RoaXMucHJvcHMuZ2V0Qm91bmQoX3RoaXMucmVmcy5lbCksXG4gICAgICAgICAgICAgICAgcG9wdXA6IF90aGlzLnByb3BzLml0ZW0ucG9wdXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2V0UG9wdXBJbmZvKGluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEN1c3RvbVRvb2xiYXJJdGVtQ29tcC5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgc2V0SXRlbVdpZHRoID0gX2Euc2V0SXRlbVdpZHRoLCBpdGVtID0gX2EuaXRlbTtcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBjdXN0b20gaHRtbCBlbGVtZW50XG4gICAgICAgIHRoaXMucmVmcy5lbC5hcHBlbmRDaGlsZChpdGVtLmVsKTtcbiAgICAgICAgLy8gc2V0IHdpZHRoIG9ubHkgaWYgaXQgaXMgbm90IGEgZHJvcGRvd24gdG9vbGJhclxuICAgICAgICBpZiAoc2V0SXRlbVdpZHRoKSB7XG4gICAgICAgICAgICBzZXRJdGVtV2lkdGgoaXRlbS5uYW1lLCBnZXRPdXRlcldpZHRoKHRoaXMucmVmcy5lbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLm9uTW91bnRlZCkge1xuICAgICAgICAgICAgaXRlbS5vbk1vdW50ZWQodGhpcy5wcm9wcy5leGVjQ29tbWFuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1c3RvbVRvb2xiYXJJdGVtQ29tcC5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnByb3BzLCBpdGVtID0gX2IuaXRlbSwgYWN0aXZlID0gX2IuYWN0aXZlLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkO1xuICAgICAgICBpZiAocHJldlByb3BzLmFjdGl2ZSAhPT0gYWN0aXZlIHx8IHByZXZQcm9wcy5kaXNhYmxlZCAhPT0gZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIChfYSA9IGl0ZW0ub25VcGRhdGVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpdGVtLCB7IGFjdGl2ZTogYWN0aXZlLCBkaXNhYmxlZDogZGlzYWJsZWQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1c3RvbVRvb2xiYXJJdGVtQ29tcC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBpdGVtID0gX2EuaXRlbTtcbiAgICAgICAgdmFyIHN0eWxlID0geyBkaXNwbGF5OiBpdGVtLmhpZGRlbiA/ICdub25lJyA6ICdpbmxpbmUtYmxvY2snIH07XG4gICAgICAgIHZhciBnZXRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gKGRpc2FibGVkID8gbnVsbCA6IGxpc3RlbmVyKTsgfTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2XFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgIGNsYXNzPVwiLCBcIlxcbiAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdmVyPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW91dD1cIiwgXCJcXG4gICAgICA+PC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICBjbGFzcz1cIiwgXCJcXG4gICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3Zlcj1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdXQ9XCIsIFwiXFxuICAgICAgPjwvZGl2PlxcbiAgICBcIl0pKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgc3R5bGUsIGNscygndG9vbGJhci1pdGVtLXdyYXBwZXInKSwgZ2V0TGlzdGVuZXIodGhpcy5zaG93UG9wdXApLCBnZXRMaXN0ZW5lcih0aGlzLnNob3dUb29sdGlwKSwgZ2V0TGlzdGVuZXIodGhpcy5wcm9wcy5oaWRlVG9vbHRpcCkpO1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbVRvb2xiYXJJdGVtQ29tcDtcbn0oQ29tcG9uZW50KSk7XG52YXIgQ3VzdG9tVG9vbGJhckl0ZW0gPSBjb25uZWN0SE9DKEN1c3RvbVRvb2xiYXJJdGVtQ29tcCk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQ2O1xuXG52YXIgVG9vbGJhckdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRvb2xiYXJHcm91cCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVG9vbGJhckdyb3VwLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGdyb3VwID0gX2EuZ3JvdXAsIGhpZGRlbkRpdmlkZXIgPSBfYS5oaWRkZW5EaXZpZGVyO1xuICAgICAgICB2YXIgZ3JvdXBTdHlsZSA9IGdyb3VwLmhpZGRlbiA/IHsgZGlzcGxheTogJ25vbmUnIH0gOiBudWxsO1xuICAgICAgICB2YXIgZGl2aWRlclN0eWxlID0gaGlkZGVuRGl2aWRlciA/IHsgZGlzcGxheTogJ25vbmUnIH0gOiBudWxsO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDQgfHwgKHRlbXBsYXRlT2JqZWN0XzIkNCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPlxcbiAgICAgICAgXCIsIFwiXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj5cXG4gICAgICAgIFwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPjwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgY2xzKCd0b29sYmFyLWdyb3VwJyksIGdyb3VwU3R5bGUsIGdyb3VwLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIENvbXAgPSBpdGVtLmVsID8gQ3VzdG9tVG9vbGJhckl0ZW0gOiBUb29sYmFyQnV0dG9uO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIGtleT1cIiwgXCIgLi4uXCIsIFwiIGl0ZW09XCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIGtleT1cIiwgXCIgLi4uXCIsIFwiIGl0ZW09XCIsIFwiIC8+XCJdKSksIENvbXAsIGl0ZW0ubmFtZSwgX3RoaXMucHJvcHMsIGl0ZW0pO1xuICAgICAgICB9KSwgY2xzKCd0b29sYmFyLWRpdmlkZXInKSwgZGl2aWRlclN0eWxlKTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyR3JvdXA7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkNSwgdGVtcGxhdGVPYmplY3RfMiQ0O1xuXG52YXIgUE9QVVBfSU5ERU5UID0gNDtcbnZhciBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgICAgICAgICAgIGlmICghY2xvc2VzdCh0YXJnZXQsIFwiLlwiICsgY2xzKCdkcm9wZG93bi10b29sYmFyJykpICYmXG4gICAgICAgICAgICAgICAgIWNsb3Nlc3QodGFyZ2V0LCAnLm1vcmUnKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2hvd0Ryb3Bkb3duOiBmYWxzZSwgZHJvcGRvd25Qb3M6IG51bGwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNob3dUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1Rvb2x0aXAoX3RoaXMucmVmcy5lbCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0geyBzaG93RHJvcGRvd246IGZhbHNlLCBkcm9wZG93blBvczogbnVsbCB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLmdldEJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMucHJvcHMuZ2V0Qm91bmQodGhpcy5yZWZzLmVsKTtcbiAgICAgICAgcmVjdC50b3AgKz0gUE9QVVBfSU5ERU5UO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCByZWN0KSwgeyBsZWZ0OiBudWxsLCByaWdodDogMTAgfSk7XG4gICAgfTtcbiAgICBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCk7XG4gICAgfTtcbiAgICBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zaG93RHJvcGRvd24gJiYgIXRoaXMuc3RhdGUuZHJvcGRvd25Qb3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBkcm9wZG93blBvczogdGhpcy5nZXRCb3VuZCgpIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5iZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCk7XG4gICAgfTtcbiAgICBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIHNob3dEcm9wZG93biA9IF9hLnNob3dEcm9wZG93biwgZHJvcGRvd25Qb3MgPSBfYS5kcm9wZG93blBvcztcbiAgICAgICAgdmFyIF9iID0gdGhpcy5wcm9wcywgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZCwgaXRlbSA9IF9iLml0ZW0sIGl0ZW1zID0gX2IuaXRlbXMsIGhpZGVUb29sdGlwID0gX2IuaGlkZVRvb2x0aXA7XG4gICAgICAgIHZhciB2aXNpYmxlSXRlbXMgPSBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGRyb3Bkb3duSXRlbSkgeyByZXR1cm4gIWRyb3Bkb3duSXRlbS5oaWRkZW47IH0pO1xuICAgICAgICB2YXIgZ3JvdXBTdHlsZSA9IHZpc2libGVJdGVtcy5sZW5ndGggPyBudWxsIDogeyBkaXNwbGF5OiAnbm9uZScgfTtcbiAgICAgICAgdmFyIGRyb3Bkb3duU3R5bGUgPSBzaG93RHJvcGRvd24gPyBudWxsIDogeyBkaXNwbGF5OiAnbm9uZScgfTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMiQzIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj5cXG4gICAgICAgIDxidXR0b25cXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgIGNsYXNzPVwiLCBcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICBvbk1vdXNlb3Zlcj1cIiwgXCJcXG4gICAgICAgICAgb25Nb3VzZW91dD1cIiwgXCJcXG4gICAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICA+PC9idXR0b24+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+XFxuICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgICBjbGFzcz1cIiwgXCJcXG4gICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgb25Nb3VzZW92ZXI9XCIsIFwiXFxuICAgICAgICAgIG9uTW91c2VvdXQ9XCIsIFwiXFxuICAgICAgICAgIGRpc2FibGVkPVwiLCBcIlxcbiAgICAgICAgPjwvYnV0dG9uPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGNscygndG9vbGJhci1ncm91cCcpLCBncm91cFN0eWxlLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVsID0gZWwpOyB9LCBpdGVtLmNsYXNzTmFtZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2V0U3RhdGUoeyBzaG93RHJvcGRvd246IHRydWUgfSk7IH0sIHRoaXMuc2hvd1Rvb2x0aXAsIGhpZGVUb29sdGlwLCBkaXNhYmxlZCwgY2xzKCdkcm9wZG93bi10b29sYmFyJyksIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgZHJvcGRvd25TdHlsZSksIGRyb3Bkb3duUG9zKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5kcm9wZG93bkVsID0gZWwpOyB9LCB2aXNpYmxlSXRlbXMubGVuZ3RoXG4gICAgICAgICAgICA/IHZpc2libGVJdGVtcy5tYXAoZnVuY3Rpb24gKGdyb3VwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDQgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwPVwiLCBcIlxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2aWRlcj1cIiwgXCJcXG4gICAgICAgICAgICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgICAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA9XCIsIFwiXFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXZpZGVyPVwiLFxuICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgXCJdKSksIFRvb2xiYXJHcm91cCwgZ3JvdXAsIGluZGV4ID09PSB2aXNpYmxlSXRlbXMubGVuZ3RoIC0gMSB8fFxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gdmlzaWJsZUl0ZW1zW2luZGV4ICsgMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRkZW4pLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wO1xufShDb21wb25lbnQpKTtcbnZhciBEcm9wZG93blRvb2xiYXJCdXR0b24gPSBjb25uZWN0SE9DKERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXApO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkNCwgdGVtcGxhdGVPYmplY3RfMiQzO1xuXG52YXIgSU5MSU5FX1BBRERJTkcgPSA1MDtcbnZhciBUb29sYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRvb2xiYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9vbGJhcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9nZ2xlVGFiID0gZnVuY3Rpb24gKF8sIGFjdGl2ZVRhYikge1xuICAgICAgICAgICAgdmFyIGV2ZW50RW1pdHRlciA9IF90aGlzLnByb3BzLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5hY3RpdmVUYWIgIT09IGFjdGl2ZVRhYikge1xuICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gYWN0aXZlVGFiID09PSAnd3JpdGUnID8gJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScgOiAnY2hhbmdlUHJldmlld1RhYlByZXZpZXcnO1xuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50XzEpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgYWN0aXZlVGFiOiBhY3RpdmVUYWIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEl0ZW1XaWR0aCA9IGZ1bmN0aW9uIChuYW1lLCB3aWR0aCkge1xuICAgICAgICAgICAgX3RoaXMuaXRlbVdpZHRoTWFwW25hbWVdID0gd2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFBvcHVwSW5mbyA9IGZ1bmN0aW9uIChwb3B1cEluZm8pIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2hvd1BvcHVwOiB0cnVlLCBwb3B1cEluZm86IHBvcHVwSW5mbyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub3BlblBvcHVwID0gZnVuY3Rpb24gKHBvcHVwTmFtZSwgaW5pdGlhbFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZXMgPT09IHZvaWQgMCkgeyBpbml0aWFsVmFsdWVzID0ge307IH1cbiAgICAgICAgICAgIHZhciBlbCA9IF90aGlzLnJlZnMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIGNscygndG9vbGJhci1ncm91cCcpICsgXCIgLlwiICsgcG9wdXBOYW1lKTtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGdldFRvdGFsT2Zmc2V0KGVsLCBjbG9zZXN0KGVsLCBcIi5cIiArIGNscygndG9vbGJhcicpKSksIG9mZnNldExlZnQgPSBfYS5vZmZzZXRMZWZ0LCBvZmZzZXRUb3AgPSBfYS5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBjcmVhdGVQb3B1cEluZm8ocG9wdXBOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiB7IGxlZnQ6IG9mZnNldExlZnQsIHRvcDogZWwub2Zmc2V0SGVpZ2h0ICsgb2Zmc2V0VG9wIH0sXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0UG9wdXBJbmZvKGluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGlkZVBvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnNob3dQb3B1cCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2hvd1BvcHVwOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50RW1pdHRlciA9IF90aGlzLnByb3BzLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjb21tYW5kJywgY29tbWFuZCwgcGF5bG9hZCk7XG4gICAgICAgICAgICBfdGhpcy5oaWRlUG9wdXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudGFicyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3dyaXRlJywgdGV4dDogJ1dyaXRlJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAncHJldmlldycsIHRleHQ6ICdQcmV2aWV3JyB9LFxuICAgICAgICBdO1xuICAgICAgICBfdGhpcy5pdGVtV2lkdGhNYXAgPSB7fTtcbiAgICAgICAgX3RoaXMuaW5pdGlhbEl0ZW1zID0gZ3JvdXBUb29sYmFySXRlbXMocHJvcHMudG9vbGJhckl0ZW1zIHx8IFtdLCBfdGhpcy5oaWRkZW5TY3JvbGxTeW5jKCkpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGl0ZW1zOiBfdGhpcy5pbml0aWFsSXRlbXMsXG4gICAgICAgICAgICBkcm9wZG93bkl0ZW1zOiBbXSxcbiAgICAgICAgICAgIHNob3dQb3B1cDogZmFsc2UsXG4gICAgICAgICAgICBwb3B1cEluZm86IHt9LFxuICAgICAgICAgICAgYWN0aXZlVGFiOiAnd3JpdGUnLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50b29sdGlwUmVmID0geyBjdXJyZW50OiBudWxsIH07XG4gICAgICAgIF90aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IGluZGV4KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmhhbmRsZVJlc2l6ZSgpOyB9KTtcbiAgICAgICAgX3RoaXMuYWRkRXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUb29sYmFyLnByb3RvdHlwZS5pbnNlcnRUb29sYmFySXRlbSA9IGZ1bmN0aW9uIChpbmRleExpc3QsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGdyb3VwSW5kZXggPSBpbmRleExpc3QuZ3JvdXBJbmRleCwgaXRlbUluZGV4ID0gaW5kZXhMaXN0Lml0ZW1JbmRleDtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5pbml0aWFsSXRlbXNbZ3JvdXBJbmRleF07XG4gICAgICAgIGl0ZW0gPSBjcmVhdGVUb29sYmFySXRlbUluZm8oaXRlbSk7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAuc3BsaWNlKGl0ZW1JbmRleCwgMCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxJdGVtcy5wdXNoKFtpdGVtXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmNsYXNzaWZ5VG9vbGJhckl0ZW1zKCkpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUucmVtb3ZlVG9vbGJhckl0ZW0gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBmb3JFYWNoQXJyYXlfMSh0aGlzLmluaXRpYWxJdGVtcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvckVhY2hBcnJheV8xKGdyb3VwLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX3RoaXMuY2xhc3NpZnlUb29sYmFySXRlbXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudEVtaXR0ZXIgPSB0aGlzLnByb3BzLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUgPSB0aHJvdHRsZV8xKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHRvb2xiYXIgaXRlbXMgdG8gcmUtbGF5b3V0IHRvb2xiYXIgaXRlbXMgd2l0aCBlYWNoIGNsaWVudFdpZHRoXG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGl0ZW1zOiBfdGhpcy5pbml0aWFsSXRlbXMsIGRyb3Bkb3duSXRlbXM6IFtdIH0pO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX3RoaXMuY2xhc3NpZnlUb29sYmFySXRlbXMoKSk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ29wZW5Qb3B1cCcsIHRoaXMub3BlblBvcHVwKTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLmFwcGVuZFRvb2x0aXBUb1Jvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b29sdGlwID0gXCI8ZGl2IGNsYXNzPVxcXCJcIiArIGNscygndG9vbHRpcCcpICsgXCJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmVcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRleHRcXFwiPjwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cIjtcbiAgICAgICAgdGhpcy50b29sdGlwUmVmLmN1cnJlbnQgPSBjcmVhdGVFbGVtZW50V2l0aCh0b29sdGlwLCB0aGlzLnJlZnMuZWwpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUuaGlkZGVuU2Nyb2xsU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZWRpdG9yVHlwZSA9PT0gJ3d5c2l3eWcnIHx8IHRoaXMucHJvcHMucHJldmlld1N0eWxlID09PSAndGFiJztcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLm1vdmVQcmV2SXRlbVRvRHJvcGRvd25Ub29sYmFyID0gZnVuY3Rpb24gKGl0ZW1JbmRleCwgaXRlbXMsIGdyb3VwLCBkcm9wZG93bkdyb3VwKSB7XG4gICAgICAgIHZhciBtb3ZlSXRlbSA9IGZ1bmN0aW9uICh0YXJnZXRHcm91cCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0YXJnZXRHcm91cC5wb3AoKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25Hcm91cC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXRlbUluZGV4ID4gMSkge1xuICAgICAgICAgICAgbW92ZUl0ZW0oZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZHcm91cCA9IGxhc3QkMShpdGVtcyk7XG4gICAgICAgICAgICBpZiAocHJldkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgbW92ZUl0ZW0ocHJldkdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUuY2xhc3NpZnlUb29sYmFySXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0b3RhbFdpZHRoID0gMDtcbiAgICAgICAgdmFyIGNsaWVudFdpZHRoID0gdGhpcy5yZWZzLmVsLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgZGl2aWRlciA9IHRoaXMucmVmcy5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgY2xzKCd0b29sYmFyLWRpdmlkZXInKSk7XG4gICAgICAgIHZhciBkaXZpZGVyV2lkdGggPSBkaXZpZGVyID8gZ2V0T3V0ZXJXaWR0aChkaXZpZGVyKSA6IDA7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICB2YXIgZHJvcGRvd25JdGVtcyA9IFtdO1xuICAgICAgICB2YXIgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdGlhbEdyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBbXTtcbiAgICAgICAgICAgIHZhciBkcm9wZG93bkdyb3VwID0gW107XG4gICAgICAgICAgICBpbml0aWFsR3JvdXAuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaXRlbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IF90aGlzLml0ZW1XaWR0aE1hcFtpdGVtLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxXaWR0aCA+IGNsaWVudFdpZHRoIC0gSU5MSU5FX1BBRERJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBtb3ZlIHRoZSBwcmV2IGl0ZW0gdG8gZHJvcGRvd24gdG9vbGJhciBmb3IgcGxhY2luZyB0aGUgbW9yZSBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb3ZlUHJldkl0ZW1Ub0Ryb3Bkb3duVG9vbGJhcihpdGVtSW5kZXgsIGl0ZW1zLCBncm91cCwgZHJvcGRvd25Hcm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd25Hcm91cC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldEdyb3VwU3RhdGUoZ3JvdXApO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyb3Bkb3duR3JvdXAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0R3JvdXBTdGF0ZShkcm9wZG93bkdyb3VwKTtcbiAgICAgICAgICAgICAgICBkcm9wZG93bkl0ZW1zLnB1c2goZHJvcGRvd25Hcm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgZGl2aWRlciB3aWR0aFxuICAgICAgICAgICAgaWYgKGdyb3VwSW5kZXggPCBfdGhpcy5zdGF0ZS5pdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdG90YWxXaWR0aCArPSBkaXZpZGVyV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBpdGVtczogaXRlbXMsIGRyb3Bkb3duSXRlbXM6IGRyb3Bkb3duSXRlbXMgfTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnByZXZpZXdTdHlsZSA9PT0gJ3RhYicpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsYXNzaWZ5IHRvb2xiYXIgYW5kIGRyb3Bkb3duIHRvb2xiYXIgYWZ0ZXIgRE9NIGhhcyBiZWVuIHJlbmRlcmVkXG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5jbGFzc2lmeVRvb2xiYXJJdGVtcygpKTtcbiAgICAgICAgdGhpcy5hcHBlbmRUb29sdGlwVG9Sb290KCk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnJlZnMuZWwpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZWRpdG9yVHlwZSA9IF9hLmVkaXRvclR5cGUsIHByZXZpZXdTdHlsZSA9IF9hLnByZXZpZXdTdHlsZSwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgICAgICB2YXIgY2hhbmdlZFN0eWxlID0gcHJldmlld1N0eWxlICE9PSBwcmV2UHJvcHMucHJldmlld1N0eWxlO1xuICAgICAgICB2YXIgY2hhbmdlZFR5cGUgPSBlZGl0b3JUeXBlICE9PSBwcmV2UHJvcHMuZWRpdG9yVHlwZTtcbiAgICAgICAgaWYgKGNoYW5nZWRTdHlsZSB8fCBjaGFuZ2VkVHlwZSkge1xuICAgICAgICAgICAgLy8gc2hvdyBvciBoaWRlIHNjcm9sbFN5bmMgYnV0dG9uXG4gICAgICAgICAgICB0b2dnbGVTY3JvbGxTeW5jKHRoaXMuaW5pdGlhbEl0ZW1zLCB0aGlzLmhpZGRlblNjcm9sbFN5bmMoKSk7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLmNsYXNzaWZ5VG9vbGJhckl0ZW1zKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFN0eWxlIHx8IChwcmV2aWV3U3R5bGUgPT09ICd0YWInICYmIGVkaXRvclR5cGUgPT09ICdtYXJrZG93bicpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScpO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlLmFjdGl2ZVRhYiA9ICd3cml0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUuYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJlbW92ZU5vZGUkMSh0aGlzLnRvb2x0aXBSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHByZXZpZXdTdHlsZSA9IF9hLnByZXZpZXdTdHlsZSwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyLCBlZGl0b3JUeXBlID0gX2EuZWRpdG9yVHlwZTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5zdGF0ZSwgcG9wdXBJbmZvID0gX2IucG9wdXBJbmZvLCBzaG93UG9wdXAgPSBfYi5zaG93UG9wdXAsIGFjdGl2ZVRhYiA9IF9iLmFjdGl2ZVRhYiwgaXRlbXMgPSBfYi5pdGVtcywgZHJvcGRvd25JdGVtcyA9IF9iLmRyb3Bkb3duSXRlbXM7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlcjogZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgdG9vbHRpcFJlZjogdGhpcy50b29sdGlwUmVmLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGVkaXRvclR5cGUgPT09ICdtYXJrZG93bicgJiYgcHJldmlld1N0eWxlID09PSAndGFiJyAmJiBhY3RpdmVUYWIgPT09ICdwcmV2aWV3JyxcbiAgICAgICAgICAgIGV4ZWNDb21tYW5kOiB0aGlzLmV4ZWNDb21tYW5kLFxuICAgICAgICAgICAgc2V0UG9wdXBJbmZvOiB0aGlzLnNldFBvcHVwSW5mbyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRvb2xiYXJTdHlsZSA9IHByZXZpZXdTdHlsZSA9PT0gJ3RhYicgPyB7IGJvcmRlclRvcExlZnRSYWRpdXM6IDAgfSA6IG51bGw7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzIkMiB8fCAodGVtcGxhdGVPYmplY3RfMiQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgc3R5bGU9XFxcImRpc3BsYXk6IFwiLCBcIlxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPFwiLCBcIiB0YWJzPVwiLCBcIiBhY3RpdmVUYWI9XCIsIFwiIG9uQ2xpY2s9XCIsIFwiIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgICBpdGVtPVwiLCBcIlxcbiAgICAgICAgICAgIGl0ZW1zPVwiLCBcIlxcbiAgICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIGluZm89XCIsIFwiXFxuICAgICAgICAgIHNob3c9XCIsIFwiXFxuICAgICAgICAgIGV2ZW50RW1pdHRlcj1cIiwgXCJcXG4gICAgICAgICAgaGlkZVBvcHVwPVwiLCBcIlxcbiAgICAgICAgICBleGVjQ29tbWFuZD1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgc3R5bGU9XFxcImRpc3BsYXk6IFwiLFxuICAgICAgICAgICAgXCJcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDxcIiwgXCIgdGFicz1cIiwgXCIgYWN0aXZlVGFiPVwiLCBcIiBvbkNsaWNrPVwiLCBcIiAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAgIGl0ZW09XCIsIFwiXFxuICAgICAgICAgICAgaXRlbXM9XCIsIFwiXFxuICAgICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgaW5mbz1cIiwgXCJcXG4gICAgICAgICAgc2hvdz1cIiwgXCJcXG4gICAgICAgICAgZXZlbnRFbWl0dGVyPVwiLCBcIlxcbiAgICAgICAgICBoaWRlUG9wdXA9XCIsIFwiXFxuICAgICAgICAgIGV4ZWNDb21tYW5kPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGNscygndG9vbGJhcicpLCBjbHMoJ21kLXRhYi1jb250YWluZXInKSwgZWRpdG9yVHlwZSA9PT0gJ3d5c2l3eWcnIHx8IHByZXZpZXdTdHlsZSA9PT0gJ3ZlcnRpY2FsJ1xuICAgICAgICAgICAgPyAnbm9uZSdcbiAgICAgICAgICAgIDogJ2Jsb2NrJywgVGFicywgdGhpcy50YWJzLCBhY3RpdmVUYWIsIHRoaXMudG9nZ2xlVGFiLCBjbHMoJ2RlZmF1bHRVSS10b29sYmFyJyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZWwgPSBlbCk7IH0sIHRvb2xiYXJTdHlsZSwgaXRlbXMubWFwKGZ1bmN0aW9uIChncm91cCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkMyB8fCAodGVtcGxhdGVPYmplY3RfMSQzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgICAgICAgIGdyb3VwPVwiLCBcIlxcbiAgICAgICAgICAgICAgICBoaWRkZW5EaXZpZGVyPVwiLCBcIlxcbiAgICAgICAgICAgICAgICBzZXRJdGVtV2lkdGg9XCIsIFwiXFxuICAgICAgICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAgICAgICBncm91cD1cIiwgXCJcXG4gICAgICAgICAgICAgICAgaGlkZGVuRGl2aWRlcj1cIiwgXCJcXG4gICAgICAgICAgICAgICAgc2V0SXRlbVdpZHRoPVwiLCBcIlxcbiAgICAgICAgICAgICAgICAuLi5cIiwgXCJcXG4gICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgXCJdKSksIFRvb2xiYXJHcm91cCwgZ3JvdXAsIGluZGV4ID09PSBpdGVtcy5sZW5ndGggLSAxIHx8ICgoX2EgPSBpdGVtc1tpbmRleCArIDFdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZGVuKSwgX3RoaXMuc2V0SXRlbVdpZHRoLCBwcm9wcyk7XG4gICAgICAgIH0pLCBEcm9wZG93blRvb2xiYXJCdXR0b24sIGNyZWF0ZVRvb2xiYXJJdGVtSW5mbygnbW9yZScpLCBkcm9wZG93bkl0ZW1zLCBwcm9wcywgUG9wdXAsIHBvcHVwSW5mbywgc2hvd1BvcHVwLCBldmVudEVtaXR0ZXIsIHRoaXMuaGlkZVBvcHVwLCB0aGlzLmV4ZWNDb21tYW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyO1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDMsIHRlbXBsYXRlT2JqZWN0XzIkMjtcblxudmFyIENvbnRleHRNZW51ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENvbnRleHRNZW51LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRleHRNZW51KHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGlja0RvY3VtZW50ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QoZXYudGFyZ2V0LCBcIi5cIiArIGNscygnY29udGV4dC1tZW51JykpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwb3M6IG51bGwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcG9zOiBudWxsLFxuICAgICAgICAgICAgbWVudUdyb3VwczogW10sXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFkZEV2ZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb3BzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gX2EucG9zLCBtZW51R3JvdXBzID0gX2EubWVudUdyb3VwcztcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgcG9zOiBwb3MsIG1lbnVHcm91cHM6IG1lbnVHcm91cHMgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0RvY3VtZW50KTtcbiAgICB9O1xuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5iZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCk7XG4gICAgfTtcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUuZ2V0TWVudUdyb3VwRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIHBvcyA9IF9hLnBvcywgbWVudUdyb3VwcyA9IF9hLm1lbnVHcm91cHM7XG4gICAgICAgIHJldHVybiBwb3NcbiAgICAgICAgICAgID8gbWVudUdyb3Vwcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVudUl0ZW0gPSBbXTtcbiAgICAgICAgICAgICAgICBncm91cC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBfYS5sYWJlbCwgX2IgPSBfYS5jbGFzc05hbWUsIGNsYXNzTmFtZSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBvbkNsaWNrID0gX2Eub25DbGljaztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHBvczogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbWVudUl0ZW0ucHVzaChodG1sKHRlbXBsYXRlT2JqZWN0XzEkMiB8fCAodGVtcGxhdGVPYmplY3RfMSQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgICAgICAgIDxsaVxcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcIm1lbnUtaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgICAgICBhcmlhLXJvbGU9XFxcIm1lbnVpdGVtXFxcIlxcbiAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgICAgICAgPGxpXFxuICAgICAgICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cXFwibWVudS1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgICAgIGFyaWEtcm9sZT1cXFwibWVudWl0ZW1cXFwiXFxuICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICBcIl0pKSwgaGFuZGxlQ2xpY2ssIGRpc2FibGVkID8gJyBkaXNhYmxlZCcgOiAnJywgY2xhc3NOYW1lLCBsYWJlbCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKGh0bWwodGVtcGxhdGVPYmplY3RfMiQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8dWwgY2xhc3M9XFxcIm1lbnUtZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgPC91bD5cIl0sIFtcIjx1bCBjbGFzcz1cXFwibWVudS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICA8L3VsPlwiXSkpLCBtZW51SXRlbSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgIDogW107XG4gICAgfTtcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBfX2Fzc2lnbiQxKHsgZGlzcGxheTogdGhpcy5zdGF0ZS5wb3MgPyAnYmxvY2snIDogJ25vbmUnIH0sIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMyB8fCAodGVtcGxhdGVPYmplY3RfMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiIGFyaWEtcm9sZT1cXFwibWVudVxcXCI+XFxuICAgICAgXCIsIFwiXFxuICAgIDwvZGl2PlwiXSwgW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCIgYXJpYS1yb2xlPVxcXCJtZW51XFxcIj5cXG4gICAgICBcIiwgXCJcXG4gICAgPC9kaXY+XCJdKSksIGNscygnY29udGV4dC1tZW51JyksIHN0eWxlLCB0aGlzLmdldE1lbnVHcm91cEVsZW1lbnRzKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRleHRNZW51O1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDIsIHRlbXBsYXRlT2JqZWN0XzIkMSwgdGVtcGxhdGVPYmplY3RfMztcblxudmFyIExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMYXlvdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGF5b3V0KHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jaGFuZ2VNb2RlID0gZnVuY3Rpb24gKGVkaXRvclR5cGUpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3JUeXBlICE9PSBfdGhpcy5zdGF0ZS5lZGl0b3JUeXBlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBlZGl0b3JUeXBlOiBlZGl0b3JUeXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jaGFuZ2VQcmV2aWV3U3R5bGUgPSBmdW5jdGlvbiAocHJldmlld1N0eWxlKSB7XG4gICAgICAgICAgICBpZiAocHJldmlld1N0eWxlICE9PSBfdGhpcy5zdGF0ZS5wcmV2aWV3U3R5bGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHByZXZpZXdTdHlsZTogcHJldmlld1N0eWxlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBoaWRlOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBoaWRlOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVkaXRvclR5cGUgPSBwcm9wcy5lZGl0b3JUeXBlLCBwcmV2aWV3U3R5bGUgPSBwcm9wcy5wcmV2aWV3U3R5bGU7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZWRpdG9yVHlwZTogZWRpdG9yVHlwZSxcbiAgICAgICAgICAgIHByZXZpZXdTdHlsZTogcHJldmlld1N0eWxlLFxuICAgICAgICAgICAgaGlkZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFkZEV2ZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGF5b3V0LnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLnNsb3RzLCB3d0VkaXRvciA9IF9hLnd3RWRpdG9yLCBtZEVkaXRvciA9IF9hLm1kRWRpdG9yLCBtZFByZXZpZXcgPSBfYS5tZFByZXZpZXc7XG4gICAgICAgIHRoaXMucmVmcy53d0NvbnRhaW5lci5hcHBlbmRDaGlsZCh3d0VkaXRvcik7XG4gICAgICAgIHRoaXMucmVmcy5tZENvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyYmVnaW4nLCBtZEVkaXRvcik7XG4gICAgICAgIHRoaXMucmVmcy5tZENvbnRhaW5lci5hcHBlbmRDaGlsZChtZFByZXZpZXcpO1xuICAgIH07XG4gICAgTGF5b3V0LnByb3RvdHlwZS5pbnNlcnRUb29sYmFySXRlbSA9IGZ1bmN0aW9uIChpbmRleExpc3QsIGl0ZW0pIHtcbiAgICAgICAgdGhpcy50b29sYmFyLmluc2VydFRvb2xiYXJJdGVtKGluZGV4TGlzdCwgaXRlbSk7XG4gICAgfTtcbiAgICBMYXlvdXQucHJvdG90eXBlLnJlbW92ZVRvb2xiYXJJdGVtID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy50b29sYmFyLnJlbW92ZVRvb2xiYXJJdGVtKG5hbWUpO1xuICAgIH07XG4gICAgTGF5b3V0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlciwgaGlkZU1vZGVTd2l0Y2ggPSBfYS5oaWRlTW9kZVN3aXRjaCwgdG9vbGJhckl0ZW1zID0gX2EudG9vbGJhckl0ZW1zLCB0aGVtZSA9IF9hLnRoZW1lO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnN0YXRlLCBoaWRlID0gX2IuaGlkZSwgcHJldmlld1N0eWxlID0gX2IucHJldmlld1N0eWxlLCBlZGl0b3JUeXBlID0gX2IuZWRpdG9yVHlwZTtcbiAgICAgICAgdmFyIGRpc3BsYXlDbGFzc05hbWUgPSBoaWRlID8gJyBoaWRkZW4nIDogJyc7XG4gICAgICAgIHZhciBlZGl0b3JUeXBlQ2xhc3NOYW1lID0gY2xzKGVkaXRvclR5cGUgPT09ICdtYXJrZG93bicgPyAnbWQtbW9kZScgOiAnd3ctbW9kZScpO1xuICAgICAgICB2YXIgcHJldmlld0NsYXNzTmFtZSA9IGNscygnbWQnKSArIFwiLVwiICsgcHJldmlld1N0eWxlICsgXCItc3R5bGVcIjtcbiAgICAgICAgdmFyIHRoZW1lQ2xhc3NOYW1lID0gY2xzKFt0aGVtZSAhPT0gJ2xpZ2h0JywgdGhlbWUgKyBcIiBcIl0pO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yIHx8ICh0ZW1wbGF0ZU9iamVjdF8yID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlwiLCBcIlwiLCBcIlxcXCJcXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICA+XFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgZXZlbnRFbWl0dGVyPVwiLCBcIlxcbiAgICAgICAgICBwcmV2aWV3U3R5bGU9XCIsIFwiXFxuICAgICAgICAgIHRvb2xiYXJJdGVtcz1cIiwgXCJcXG4gICAgICAgICAgZWRpdG9yVHlwZT1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCIgXCIsIFwiXFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIiBcIiwgXCJcXFwiXFxuICAgICAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICAgIDxcIiwgXCIgZXZlbnRFbWl0dGVyPVwiLCBcIiAvPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcIiwgXCJcIiwgXCJcXFwiXFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgPlxcbiAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIGV2ZW50RW1pdHRlcj1cIiwgXCJcXG4gICAgICAgICAgcHJldmlld1N0eWxlPVwiLCBcIlxcbiAgICAgICAgICB0b29sYmFySXRlbXM9XCIsIFwiXFxuICAgICAgICAgIGVkaXRvclR5cGU9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiIFwiLCBcIlxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCIgXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgXCIsXG4gICAgICAgICAgICBcIlxcbiAgICAgICAgPFwiLCBcIiBldmVudEVtaXR0ZXI9XCIsIFwiIC8+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCB0aGVtZUNsYXNzTmFtZSwgY2xzKCdkZWZhdWx0VUknKSwgZGlzcGxheUNsYXNzTmFtZSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgVG9vbGJhciwgZnVuY3Rpb24gKHRvb2xiYXIpIHsgcmV0dXJuIChfdGhpcy50b29sYmFyID0gdG9vbGJhcik7IH0sIGV2ZW50RW1pdHRlciwgcHJldmlld1N0eWxlLCB0b29sYmFySXRlbXMsIGVkaXRvclR5cGUsIGNscygnbWFpbicpLCBlZGl0b3JUeXBlQ2xhc3NOYW1lLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVkaXRvclNlY3Rpb24gPSBlbCk7IH0sIGNscygnbWFpbi1jb250YWluZXInKSwgY2xzKCdtZC1jb250YWluZXInKSwgcHJldmlld0NsYXNzTmFtZSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5tZENvbnRhaW5lciA9IGVsKTsgfSwgY2xzKCdtZC1zcGxpdHRlcicpLCBjbHMoJ3d3LWNvbnRhaW5lcicpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnd3Q29udGFpbmVyID0gZWwpOyB9LCAhaGlkZU1vZGVTd2l0Y2ggJiYgaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzEkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIgZXZlbnRFbWl0dGVyPVwiLCBcIiBlZGl0b3JUeXBlPVwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiBldmVudEVtaXR0ZXI9XCIsIFwiIGVkaXRvclR5cGU9XCIsIFwiIC8+XCJdKSksIFN3aXRjaCwgZXZlbnRFbWl0dGVyLCBlZGl0b3JUeXBlKSwgQ29udGV4dE1lbnUsIGV2ZW50RW1pdHRlcik7XG4gICAgfTtcbiAgICBMYXlvdXQucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXZlbnRFbWl0dGVyID0gdGhpcy5wcm9wcy5ldmVudEVtaXR0ZXI7XG4gICAgICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ2hpZGUnLCB0aGlzLmhpZGUpO1xuICAgICAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdzaG93JywgdGhpcy5zaG93KTtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlTW9kZScsIHRoaXMuY2hhbmdlTW9kZSk7XG4gICAgICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdTdHlsZScsIHRoaXMuY2hhbmdlUHJldmlld1N0eWxlKTtcbiAgICB9O1xuICAgIHJldHVybiBMYXlvdXQ7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkMSwgdGVtcGxhdGVPYmplY3RfMjtcblxuLyoqXG4gKiBUb2FzdFVJIEVkaXRvclxuICogQGV4dGVuZHMgVG9hc3RVSUVkaXRvckNvcmVcbiAqL1xudmFyIFRvYXN0VUlFZGl0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVG9hc3RVSUVkaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb2FzdFVJRWRpdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICB2YXIgbGF5b3V0Q29tcDtcbiAgICAgICAgdmFyIGRlc3Ryb3kgPSByZW5kZXIoX3RoaXMub3B0aW9ucy5lbCwgaHRtbCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgZXZlbnRFbWl0dGVyPVwiLCBcIlxcbiAgICAgICAgICBzbG90cz1cIiwgXCJcXG4gICAgICAgICAgaGlkZU1vZGVTd2l0Y2g9XCIsIFwiXFxuICAgICAgICAgIHRvb2xiYXJJdGVtcz1cIiwgXCJcXG4gICAgICAgICAgcHJldmlld1N0eWxlPVwiLCBcIlxcbiAgICAgICAgICBlZGl0b3JUeXBlPVwiLCBcIlxcbiAgICAgICAgICB0aGVtZT1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgXCJdLCBbXCJcXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBldmVudEVtaXR0ZXI9XCIsIFwiXFxuICAgICAgICAgIHNsb3RzPVwiLCBcIlxcbiAgICAgICAgICBoaWRlTW9kZVN3aXRjaD1cIiwgXCJcXG4gICAgICAgICAgdG9vbGJhckl0ZW1zPVwiLCBcIlxcbiAgICAgICAgICBwcmV2aWV3U3R5bGU9XCIsIFwiXFxuICAgICAgICAgIGVkaXRvclR5cGU9XCIsIFwiXFxuICAgICAgICAgIHRoZW1lPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICBcIl0pKSwgTGF5b3V0LCBmdW5jdGlvbiAobGF5b3V0KSB7IHJldHVybiAobGF5b3V0Q29tcCA9IGxheW91dCk7IH0sIF90aGlzLmV2ZW50RW1pdHRlciwgX3RoaXMuZ2V0RWRpdG9yRWxlbWVudHMoKSwgX3RoaXMub3B0aW9ucy5oaWRlTW9kZVN3aXRjaCwgX3RoaXMub3B0aW9ucy50b29sYmFySXRlbXMsIF90aGlzLm9wdGlvbnMucHJldmlld1N0eWxlLCBfdGhpcy5vcHRpb25zLmluaXRpYWxFZGl0VHlwZSwgX3RoaXMub3B0aW9ucy50aGVtZSkpO1xuICAgICAgICBfdGhpcy5zZXRNaW5IZWlnaHQoX3RoaXMub3B0aW9ucy5taW5IZWlnaHQpO1xuICAgICAgICBfdGhpcy5zZXRIZWlnaHQoX3RoaXMub3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICBfdGhpcy5kZWZhdWx0VUkgPSB7XG4gICAgICAgICAgICBpbnNlcnRUb29sYmFySXRlbTogbGF5b3V0Q29tcC5pbnNlcnRUb29sYmFySXRlbS5iaW5kKGxheW91dENvbXApLFxuICAgICAgICAgICAgcmVtb3ZlVG9vbGJhckl0ZW06IGxheW91dENvbXAucmVtb3ZlVG9vbGJhckl0ZW0uYmluZChsYXlvdXRDb21wKSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgIH07XG4gICAgICAgIChfYSA9IF90aGlzLnBsdWdpbkluZm8udG9vbGJhckl0ZW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChmdW5jdGlvbiAodG9vbGJhckl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBncm91cEluZGV4ID0gdG9vbGJhckl0ZW0uZ3JvdXBJbmRleCwgaXRlbUluZGV4ID0gdG9vbGJhckl0ZW0uaXRlbUluZGV4LCBpdGVtID0gdG9vbGJhckl0ZW0uaXRlbTtcbiAgICAgICAgICAgIF90aGlzLmRlZmF1bHRVSS5pbnNlcnRUb29sYmFySXRlbSh7IGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsIGl0ZW1JbmRleDogaXRlbUluZGV4IH0sIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2xvYWRVSScsIF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgRWRpdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uIGZvciBpbml0aWFsaXplIFRVSUVkaXRvclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRvYXN0VUlFZGl0b3Igb3IgVG9hc3RVSUVkaXRvclZpZXdlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3IuZmFjdG9yeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnZpZXdlciA/IG5ldyBUb2FzdFVJRWRpdG9yVmlld2VyKG9wdGlvbnMpIDogbmV3IFRvYXN0VUlFZGl0b3Iob3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBhZGQgdG9vbGJhciBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGluZGV4SW5mbyBncm91cCBpbmRleCBhbmQgaXRlbSBpbmRleCBvZiB0aGUgdG9vbGJhciBpdGVtXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBpdGVtIHRvb2xiYXIgaXRlbVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3IucHJvdG90eXBlLmluc2VydFRvb2xiYXJJdGVtID0gZnVuY3Rpb24gKGluZGV4SW5mbywgaXRlbSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRVSS5pbnNlcnRUb29sYmFySXRlbShpbmRleEluZm8sIGl0ZW0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRvb2xiYXIgaXRlbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtTmFtZSB0b29sYmFyIGl0ZW0gbmFtZVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3IucHJvdG90eXBlLnJlbW92ZVRvb2xiYXJJdGVtID0gZnVuY3Rpb24gKGl0ZW1OYW1lKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFVJLnJlbW92ZVRvb2xiYXJJdGVtKGl0ZW1OYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgVFVJRWRpdG9yIGZyb20gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VUkuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvYXN0VUlFZGl0b3I7XG59KFRvYXN0VUlFZGl0b3JDb3JlKSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEkxOE4gZm9yIEVuZ2xpc2hcbiAqIEBhdXRob3IgTkhOIENsb3VkIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5Ub2FzdFVJRWRpdG9yQ29yZS5zZXRMYW5ndWFnZShbJ2VuJywgJ2VuLVVTJ10sIHtcbiAgICBNYXJrZG93bjogJ01hcmtkb3duJyxcbiAgICBXWVNJV1lHOiAnV1lTSVdZRycsXG4gICAgV3JpdGU6ICdXcml0ZScsXG4gICAgUHJldmlldzogJ1ByZXZpZXcnLFxuICAgIEhlYWRpbmdzOiAnSGVhZGluZ3MnLFxuICAgIFBhcmFncmFwaDogJ1BhcmFncmFwaCcsXG4gICAgQm9sZDogJ0JvbGQnLFxuICAgIEl0YWxpYzogJ0l0YWxpYycsXG4gICAgU3RyaWtlOiAnU3RyaWtlJyxcbiAgICBDb2RlOiAnSW5saW5lIGNvZGUnLFxuICAgIExpbmU6ICdMaW5lJyxcbiAgICBCbG9ja3F1b3RlOiAnQmxvY2txdW90ZScsXG4gICAgJ1Vub3JkZXJlZCBsaXN0JzogJ1Vub3JkZXJlZCBsaXN0JyxcbiAgICAnT3JkZXJlZCBsaXN0JzogJ09yZGVyZWQgbGlzdCcsXG4gICAgVGFzazogJ1Rhc2snLFxuICAgIEluZGVudDogJ0luZGVudCcsXG4gICAgT3V0ZGVudDogJ091dGRlbnQnLFxuICAgICdJbnNlcnQgbGluayc6ICdJbnNlcnQgbGluaycsXG4gICAgJ0luc2VydCBDb2RlQmxvY2snOiAnSW5zZXJ0IGNvZGVCbG9jaycsXG4gICAgJ0luc2VydCB0YWJsZSc6ICdJbnNlcnQgdGFibGUnLFxuICAgICdJbnNlcnQgaW1hZ2UnOiAnSW5zZXJ0IGltYWdlJyxcbiAgICBIZWFkaW5nOiAnSGVhZGluZycsXG4gICAgJ0ltYWdlIFVSTCc6ICdJbWFnZSBVUkwnLFxuICAgICdTZWxlY3QgaW1hZ2UgZmlsZSc6ICdTZWxlY3QgaW1hZ2UgZmlsZScsXG4gICAgJ0Nob29zZSBhIGZpbGUnOiAnQ2hvb3NlIGEgZmlsZScsXG4gICAgJ05vIGZpbGUnOiAnTm8gZmlsZScsXG4gICAgRGVzY3JpcHRpb246ICdEZXNjcmlwdGlvbicsXG4gICAgT0s6ICdPSycsXG4gICAgTW9yZTogJ01vcmUnLFxuICAgIENhbmNlbDogJ0NhbmNlbCcsXG4gICAgRmlsZTogJ0ZpbGUnLFxuICAgIFVSTDogJ1VSTCcsXG4gICAgJ0xpbmsgdGV4dCc6ICdMaW5rIHRleHQnLFxuICAgICdBZGQgcm93IHRvIHVwJzogJ0FkZCByb3cgdG8gdXAnLFxuICAgICdBZGQgcm93IHRvIGRvd24nOiAnQWRkIHJvdyB0byBkb3duJyxcbiAgICAnQWRkIGNvbHVtbiB0byBsZWZ0JzogJ0FkZCBjb2x1bW4gdG8gbGVmdCcsXG4gICAgJ0FkZCBjb2x1bW4gdG8gcmlnaHQnOiAnQWRkIGNvbHVtbiB0byByaWdodCcsXG4gICAgJ1JlbW92ZSByb3cnOiAnUmVtb3ZlIHJvdycsXG4gICAgJ1JlbW92ZSBjb2x1bW4nOiAnUmVtb3ZlIGNvbHVtbicsXG4gICAgJ0FsaWduIGNvbHVtbiB0byBsZWZ0JzogJ0FsaWduIGNvbHVtbiB0byBsZWZ0JyxcbiAgICAnQWxpZ24gY29sdW1uIHRvIGNlbnRlcic6ICdBbGlnbiBjb2x1bW4gdG8gY2VudGVyJyxcbiAgICAnQWxpZ24gY29sdW1uIHRvIHJpZ2h0JzogJ0FsaWduIGNvbHVtbiB0byByaWdodCcsXG4gICAgJ1JlbW92ZSB0YWJsZSc6ICdSZW1vdmUgdGFibGUnLFxuICAgICdXb3VsZCB5b3UgbGlrZSB0byBwYXN0ZSBhcyB0YWJsZT8nOiAnV291bGQgeW91IGxpa2UgdG8gcGFzdGUgYXMgdGFibGU/JyxcbiAgICAnVGV4dCBjb2xvcic6ICdUZXh0IGNvbG9yJyxcbiAgICAnQXV0byBzY3JvbGwgZW5hYmxlZCc6ICdBdXRvIHNjcm9sbCBlbmFibGVkJyxcbiAgICAnQXV0byBzY3JvbGwgZGlzYWJsZWQnOiAnQXV0byBzY3JvbGwgZGlzYWJsZWQnLFxuICAgICdDaG9vc2UgbGFuZ3VhZ2UnOiAnQ2hvb3NlIGxhbmd1YWdlJyxcbn0pO1xuXG5leHBvcnQgeyBUb2FzdFVJRWRpdG9yIGFzIEVkaXRvciwgVG9hc3RVSUVkaXRvckNvcmUgYXMgRWRpdG9yQ29yZSwgVG9hc3RVSUVkaXRvciBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/editor/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * @toast-ui/editor\n * @version 3.2.2 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! prosemirror-inputrules */ \"(ssr)/./node_modules/prosemirror-inputrules/dist/index.cjs\"), __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.cjs\"), __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.cjs\"), __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.cjs\"), __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.cjs\"));\n\telse {}\n})(self, function(__WEBPACK_EXTERNAL_MODULE__479__, __WEBPACK_EXTERNAL_MODULE__481__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__814__, __WEBPACK_EXTERNAL_MODULE__311__) {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 368:\n/***/ (function(module) {\n\n/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */\n\n(function (global, factory) {\n    true ? module.exports = factory() :\n  0;\n}(this, function () { 'use strict';\n\n  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      getPrototypeOf = Object.getPrototypeOf,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n      seal = Object.seal,\n      create = Object.create; // eslint-disable-line import/no-mutable-exports\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n\n  var regExpTest = unapply(RegExp.prototype.test);\n\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n\n  /* Add properties to a lookup table */\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n    while (l--) {\n      var element = array[l];\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n\n  /* Shallow clone an object */\n  function clone(object) {\n    var newObject = create(null);\n\n    var property = void 0;\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n\n  /* IE10 doesn't support __lookupGetter__ so lets'\n   * simulate it. It also automatically checks\n   * if the prop is function or getter and behaves\n   * accordingly. */\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n  // SVG\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n  // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n  // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\n  var text = freeze(['#text']);\n\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  // eslint-disable-next-line unicorn/better-regex\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {Document} document The document object (to determine policy name suffix)\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported).\n   */\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n    DOMPurify.version = '2.3.3';\n\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        Element = window.Element,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        Text = window.Text,\n        Comment = window.Comment,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes;\n\n\n    var ElementPrototype = Element.prototype;\n\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        createDocumentFragment = _document.createDocumentFragment,\n        getElementsByTagName = _document.getElementsByTagName;\n    var importNode = originalDocument.importNode;\n\n\n    var documentMode = {};\n    try {\n      documentMode = clone(document).documentMode ? document.documentMode : {};\n    } catch (_) {}\n\n    var hooks = {};\n\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n    /* Allowed attribute names */\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n    var FORBID_TAGS = null;\n\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n    var FORBID_ATTR = null;\n\n    /* Decide if ARIA attributes are okay */\n    var ALLOW_ARIA_ATTR = true;\n\n    /* Decide if custom data attributes are okay */\n    var ALLOW_DATA_ATTR = true;\n\n    /* Decide if unknown protocols are okay */\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n    var SAFE_FOR_TEMPLATES = false;\n\n    /* Decide if document with <html>... should be returned */\n    var WHOLE_DOCUMENT = false;\n\n    /* Track whether config is already set on this instance of DOMPurify. */\n    var SET_CONFIG = false;\n\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n    var FORCE_BODY = false;\n\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n    var RETURN_DOM = false;\n\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n    var RETURN_DOM_FRAGMENT = false;\n\n    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n     * `Node` is imported into the current `Document`. If this flag is not enabled the\n     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n     * DOMPurify.\n     *\n     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n     * might cause XSS from attacks hidden in closed shadowroots in case the browser\n     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n     */\n    var RETURN_DOM_IMPORT = true;\n\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n    var RETURN_TRUSTED_TYPE = false;\n\n    /* Output should be free from DOM clobbering attacks? */\n    var SANITIZE_DOM = true;\n\n    /* Keep element content when removing element? */\n    var KEEP_CONTENT = true;\n\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n    var IN_PLACE = false;\n\n    /* Allow usage of profiles like html, svg and mathMl */\n    var USE_PROFILES = {};\n\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n    var FORBID_CONTENTS = null;\n    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n    /* Tags that are safe for data: URIs */\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n    /* Attributes safe for values like \"javascript:\" */\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n    var NAMESPACE = HTML_NAMESPACE;\n    var IS_EMPTY_INPUT = false;\n\n    /* Parsing of strict XHTML documents */\n    var PARSER_MEDIA_TYPE = void 0;\n    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    var transformCaseFunc = void 0;\n\n    /* Keep a reference to config to pass to hooks */\n    var CONFIG = null;\n\n    /* Ideally, do not touch anything below this line */\n    /* ______________________________________________ */\n\n    var formElement = document.createElement('form');\n\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      /* Shield configuration object from tampering */\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n\n      /* Shield configuration object from prototype pollution */\n      cfg = clone(cfg);\n\n      /* Set configuration parameters */\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n\n      PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n\n      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\n        return x;\n      } : stringToLowerCase;\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      /* Parse profile info */\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      /* Merge configuration parameters */\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n      }\n\n      /* Add #text in case KEEP_CONTENT is set to true */\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n    var ALL_SVG_TAGS = addToSet({}, svg);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n    var ALL_MATHML_TAGS = addToSet({}, mathMl);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element);\n\n      // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: HTML_NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        // The only way to switch from MathML to SVG is via\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erronously deleted from\n        // HTML namespace.\n        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n        // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG or MathML). Return false just in case.\n      return false;\n    };\n\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, { element: node });\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        try {\n          node.outerHTML = emptyHTML;\n        } catch (_) {\n          node.remove();\n        }\n      }\n    };\n\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n\n      // We void attribute values for unremovable \"is\"\" attributes\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n    var _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\n        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n\n      /* Use createHTMLDocument in case DOMParser is not available */\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n        } catch (_) {\n          // Syntax error if dirtyPayload is invalid xml\n        }\n      }\n\n      var body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n\n      /* Work on whole document or just its body */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n    var _isClobbered = function _isClobbered(elm) {\n      if (elm instanceof Text || elm instanceof Comment) {\n        return false;\n      }\n\n      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      /* Check if element is clobbered or can clobber */\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check if tagname contains Unicode */\n      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Now let's check the element's type and name */\n      var tagName = transformCaseFunc(currentNode.nodeName);\n\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      /* Detect mXSS attempts abusing namespace confusion */\n      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Mitigate a problem with templates inside select */\n      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove element if anything forbids its presence */\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            var childCount = childNodes.length;\n\n            for (var i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check whether element has a valid namespace */\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Sanitize element content to be template-safe */\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n          currentNode.textContent = content;\n        }\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        return false;\n\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n        return false;\n      }\n\n      return true;\n    };\n\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var l = void 0;\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n\n      /* Go backwards over all attributes; safely remove bad ones */\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n\n        value = stringTrim(attr.value);\n        lcName = transformCaseFunc(name);\n\n        /* Execute a hook if present */\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        /* Remove attribute */\n        _removeAttribute(name, currentNode);\n\n        /* Did the hooks approve of the attribute? */\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n\n        /* Work around a security issue in jQuery 3.0 */\n        if (regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Sanitize attribute content to be template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n\n        /* Is `value` valid for this attribute? */\n        var lcTag = transformCaseFunc(currentNode.nodeName);\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n\n        /* Handle invalid data-* attribute set by try-catching it */\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n      var shadowIterator = _createIterator(fragment);\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        /* Deep shadow DOM detected */\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(shadowNode);\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n      IS_EMPTY_INPUT = !dirty;\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n\n      /* Stringify, in case dirty is an object */\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        // eslint-disable-next-line no-negated-condition\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n\n      /* Check we can run. Otherwise fall back or ignore */\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n\n      /* Assign config vars */\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      /* Clean up removed elements */\n      DOMPurify.removed = [];\n\n      /* Check if dirty is correctly typed for IN_PLACE */\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) ; else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        /* Initialize the document to work on */\n        body = _initDocument(dirty);\n\n        /* Check we have a DOM node from the data */\n        if (!body) {\n          return RETURN_DOM ? null : emptyHTML;\n        }\n      }\n\n      /* Remove first element node (ours) if FORCE_BODY is set */\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      /* Get node iterator */\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n      /* Now start iterating over the created document */\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Fix IE's strange behavior with manipulated textNodes #89 */\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        /* Shadow DOM detected, sanitize it */\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n\n      /* If we sanitized `dirty` in-place, return it. */\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      /* Return sanitized string or DOM */\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (RETURN_DOM_IMPORT) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      /* Sanitize final string template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = transformCaseFunc(tag);\n      var lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     */\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n\n\n/***/ }),\n\n/***/ 928:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_57109__) {\n\n\"use strict\";\n/* eslint-disable complexity */\n/**\n * @fileoverview Returns the first index at which a given element can be found in the array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isArray = __nested_webpack_require_57109__(322);\n\n/**\n * @module array\n */\n\n/**\n * Returns the first index at which a given element can be found in the array\n * from start index(default 0), or -1 if it is not present.\n * It compares searchElement to elements of the Array using strict equality\n * (the same method used by the ===, or triple-equals, operator).\n * @param {*} searchElement Element to locate in the array\n * @param {Array} array Array that will be traversed.\n * @param {number} startIndex Start index in array for searching (default 0)\n * @returns {number} the First index at which a given element, or -1 if it is not present\n * @memberof module:array\n * @example\n * // ES6\n * import inArray from 'tui-code-snippet/array/inArray';\n * \n * // CommonJS\n * const inArray = require('tui-code-snippet/array/inArray');\n *\n * const arr = ['one', 'two', 'three', 'four'];\n * const idx1 = inArray('one', arr, 3); // -1\n * const idx2 = inArray('one', arr); // 0\n */\nfunction inArray(searchElement, array, startIndex) {\n  var i;\n  var length;\n  startIndex = startIndex || 0;\n\n  if (!isArray(array)) {\n    return -1;\n  }\n\n  if (Array.prototype.indexOf) {\n    return Array.prototype.indexOf.call(array, searchElement, startIndex);\n  }\n\n  length = array.length;\n  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {\n    if (array[i] === searchElement) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nmodule.exports = inArray;\n\n\n/***/ }),\n\n/***/ 690:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_58838__) {\n\n\"use strict\";\n/**\n * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isArray = __nested_webpack_require_58838__(322);\nvar forEachArray = __nested_webpack_require_58838__(893);\nvar forEachOwnProperties = __nested_webpack_require_58838__(956);\n\n/**\n * @module collection\n */\n\n/**\n * Execute the provided callback once for each property of object(or element of array) which actually exist.\n * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property(or The value of the element)\n *  2) The name of the property(or The index of the element)\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEach from 'tui-code-snippet/collection/forEach'; \n * \n * // CommonJS\n * const forEach = require('tui-code-snippet/collection/forEach'); \n *\n * let sum = 0;\n *\n * forEach([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n *\n * // In case of Array-like object\n * const array = Array.prototype.slice.call(arrayLike); // change to array\n * forEach(array, function(value){\n *   sum += value;\n * });\n */\nfunction forEach(obj, iteratee, context) {\n  if (isArray(obj)) {\n    forEachArray(obj, iteratee, context);\n  } else {\n    forEachOwnProperties(obj, iteratee, context);\n  }\n}\n\nmodule.exports = forEach;\n\n\n/***/ }),\n\n/***/ 893:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Execute the provided callback once for each element present\n * in the array(or Array-like object) in ascending order.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the element\n *  2) The index of the element\n *  3) The array(or Array-like object) being traversed\n * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachArray from 'tui-code-snippet/collection/forEachArray';\n * \n * // CommonJS\n * const forEachArray = require('tui-code-snippet/collection/forEachArray'); \n *\n * let sum = 0;\n *\n * forEachArray([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachArray(arr, iteratee, context) {\n  var index = 0;\n  var len = arr.length;\n\n  context = context || null;\n\n  for (; index < len; index += 1) {\n    if (iteratee.call(context, arr[index], index, arr) === false) {\n      break;\n    }\n  }\n}\n\nmodule.exports = forEachArray;\n\n\n/***/ }),\n\n/***/ 956:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Execute the provided callback once for each property of object which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Execute the provided callback once for each property of object which actually exist.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property\n *  2) The name of the property\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee  Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachOwnProperties from 'tui-code-snippet/collection/forEachOwnProperties';\n * \n * // CommonJS\n * const forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); \n *\n * let sum = 0;\n *\n * forEachOwnProperties({a:1,b:2,c:3}, function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachOwnProperties(obj, iteratee, context) {\n  var key;\n\n  context = context || null;\n\n  for (key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (iteratee.call(context, obj[key], key, obj) === false) {\n        break;\n      }\n    }\n  }\n}\n\nmodule.exports = forEachOwnProperties;\n\n\n/***/ }),\n\n/***/ 990:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_63561__) {\n\n\"use strict\";\n/**\n * @fileoverview Transform the Array-like object to Array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEachArray = __nested_webpack_require_63561__(893);\n\n/**\n * Transform the Array-like object to Array.\n * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.\n * @param {*} arrayLike Array-like object\n * @returns {Array} Array\n * @memberof module:collection\n * @example\n * // ES6\n * import toArray from 'tui-code-snippet/collection/toArray'; \n * \n * // CommonJS\n * const toArray = require('tui-code-snippet/collection/toArray'); \n *\n * const arrayLike = {\n *   0: 'one',\n *   1: 'two',\n *   2: 'three',\n *   3: 'four',\n *   length: 4\n * };\n * const result = toArray(arrayLike);\n *\n * alert(result instanceof Array); // true\n * alert(result); // one,two,three,four\n */\nfunction toArray(arrayLike) {\n  var arr;\n  try {\n    arr = Array.prototype.slice.call(arrayLike);\n  } catch (e) {\n    arr = [];\n    forEachArray(arrayLike, function(value) {\n      arr.push(value);\n    });\n  }\n\n  return arr;\n}\n\nmodule.exports = toArray;\n\n\n/***/ }),\n\n/***/ 755:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Get event collection for specific HTML element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar EVENT_KEY = '_feEventKey';\n\n/**\n * Get event collection for specific HTML element\n * @param {HTMLElement} element - HTML element\n * @param {string} type - event type\n * @returns {array}\n * @private\n */\nfunction safeEvent(element, type) {\n  var events = element[EVENT_KEY];\n  var handlers;\n\n  if (!events) {\n    events = element[EVENT_KEY] = {};\n  }\n\n  handlers = events[type];\n  if (!handlers) {\n    handlers = events[type] = [];\n  }\n\n  return handlers;\n}\n\nmodule.exports = safeEvent;\n\n\n/***/ }),\n\n/***/ 349:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_65445__) {\n\n\"use strict\";\n/**\n * @fileoverview Unbind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isString = __nested_webpack_require_65445__(758);\nvar forEach = __nested_webpack_require_65445__(690);\n\nvar safeEvent = __nested_webpack_require_65445__(755);\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {function} [handler] - handler function\n * @memberof module:domEvent\n * @example\n * // Following the example of domEvent#on\n * \n * // Unbind one event from an element.\n * off(div, 'click', toggle);\n * \n * // Unbind multiple events with a same handler from multiple elements at once.\n * // Use event names splitted by a space.\n * off(element, 'mouseenter mouseleave', changeColor);\n * \n * // Unbind multiple events with different handlers from an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * off(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Unbind events without handlers.\n * off(div, 'drag');\n */\nfunction off(element, types, handler) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      unbindEvent(element, type, handler);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    unbindEvent(element, type, func);\n  });\n}\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {string} type - events name\n * @param {function} [handler] - handler function\n * @private\n */\nfunction unbindEvent(element, type, handler) {\n  var events = safeEvent(element, type);\n  var index;\n\n  if (!handler) {\n    forEach(events, function(item) {\n      removeHandler(element, type, item.wrappedHandler);\n    });\n    events.splice(0, events.length);\n  } else {\n    forEach(events, function(item, idx) {\n      if (handler === item.handler) {\n        removeHandler(element, type, item.wrappedHandler);\n        index = idx;\n\n        return false;\n      }\n\n      return true;\n    });\n    events.splice(index, 1);\n  }\n}\n\n/**\n * Remove an event handler\n * @param {HTMLElement} element - An element to remove an event\n * @param {string} type - event type\n * @param {function} handler - event handler\n * @private\n */\nfunction removeHandler(element, type, handler) {\n  if ('removeEventListener' in element) {\n    element.removeEventListener(type, handler);\n  } else if ('detachEvent' in element) {\n    element.detachEvent('on' + type, handler);\n  }\n}\n\nmodule.exports = off;\n\n\n/***/ }),\n\n/***/ 348:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_68232__) {\n\n\"use strict\";\n/**\n * @fileoverview Bind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isString = __nested_webpack_require_68232__(758);\nvar forEach = __nested_webpack_require_68232__(690);\n\nvar safeEvent = __nested_webpack_require_68232__(755);\n\n/**\n * Bind DOM events.\n * @param {HTMLElement} element - element to bind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {(function|object)} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @memberof module:domEvent\n * @example\n * const div = document.querySelector('div');\n * \n * // Bind one event to an element.\n * on(div, 'click', toggle);\n * \n * // Bind multiple events with a same handler to multiple elements at once.\n * // Use event names splitted by a space.\n * on(div, 'mouseenter mouseleave', changeColor);\n * \n * // Bind multiple events with different handlers to an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * on(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Set a context for handler method.\n * const name = 'global';\n * const repository = {name: 'CodeSnippet'};\n * on(div, 'drag', function() {\n *   console.log(this.name);\n * }, repository);\n * // Result when you drag a div: \"CodeSnippet\"\n */\nfunction on(element, types, handler, context) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      bindEvent(element, type, handler, context);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    bindEvent(element, type, func, handler);\n  });\n}\n\n/**\n * Bind DOM events\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @private\n */\nfunction bindEvent(element, type, handler, context) {\n  /**\n     * Event handler\n     * @param {Event} e - event object\n     */\n  function eventHandler(e) {\n    handler.call(context || element, e || window.event);\n  }\n\n  if ('addEventListener' in element) {\n    element.addEventListener(type, eventHandler);\n  } else if ('attachEvent' in element) {\n    element.attachEvent('on' + type, eventHandler);\n  }\n  memorizeHandler(element, type, handler, eventHandler);\n}\n\n/**\n * Memorize DOM event handler for unbinding.\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function that user passed at on() use\n * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features\n * @private\n */\nfunction memorizeHandler(element, type, handler, wrappedHandler) {\n  var events = safeEvent(element, type);\n  var existInEvents = false;\n\n  forEach(events, function(obj) {\n    if (obj.handler === handler) {\n      existInEvents = true;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!existInEvents) {\n    events.push({\n      handler: handler,\n      wrappedHandler: wrappedHandler\n    });\n  }\n}\n\nmodule.exports = on;\n\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_71515__) {\n\n\"use strict\";\n/**\n * @fileoverview Set className value\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isArray = __nested_webpack_require_71515__(322);\nvar isUndefined = __nested_webpack_require_71515__(929);\n\n/**\n * Set className value\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {(string|string[])} cssClass - class names\n * @private\n */\nfunction setClassName(element, cssClass) {\n  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;\n\n  cssClass = cssClass.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n  if (isUndefined(element.className.baseVal)) {\n    element.className = cssClass;\n\n    return;\n  }\n\n  element.className.baseVal = cssClass;\n}\n\nmodule.exports = setClassName;\n\n\n/***/ }),\n\n/***/ 204:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_72332__) {\n\n\"use strict\";\n/**\n * @fileoverview Add css class to element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEach = __nested_webpack_require_72332__(690);\nvar inArray = __nested_webpack_require_72332__(928);\nvar getClass = __nested_webpack_require_72332__(902);\nvar setClassName = __nested_webpack_require_72332__(24);\n\n/**\n * domUtil module\n * @module domUtil\n */\n\n/**\n * Add css class to element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to add\n * @memberof module:domUtil\n */\nfunction addClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var newClass = [];\n  var origin;\n\n  if (classList) {\n    forEach(cssClass, function(name) {\n      element.classList.add(name);\n    });\n\n    return;\n  }\n\n  origin = getClass(element);\n\n  if (origin) {\n    cssClass = [].concat(origin.split(/\\s+/), cssClass);\n  }\n\n  forEach(cssClass, function(cls) {\n    if (inArray(cls, newClass) < 0) {\n      newClass.push(cls);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nmodule.exports = addClass;\n\n\n/***/ }),\n\n/***/ 522:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_73512__) {\n\n\"use strict\";\n/**\n * @fileoverview Setting element style\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isString = __nested_webpack_require_73512__(758);\nvar forEach = __nested_webpack_require_73512__(690);\n\n/**\n * Setting element style\n * @param {(HTMLElement|SVGElement)} element - element to setting style\n * @param {(string|object)} key - style prop name or {prop: value} pair object\n * @param {string} [value] - style value\n * @memberof module:domUtil\n */\nfunction css(element, key, value) {\n  var style = element.style;\n\n  if (isString(key)) {\n    style[key] = value;\n\n    return;\n  }\n\n  forEach(key, function(v, k) {\n    style[k] = v;\n  });\n}\n\nmodule.exports = css;\n\n\n/***/ }),\n\n/***/ 902:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_74279__) {\n\n\"use strict\";\n/**\n * @fileoverview Get HTML element's design classes.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isUndefined = __nested_webpack_require_74279__(929);\n\n/**\n * Get HTML element's design classes.\n * @param {(HTMLElement|SVGElement)} element target element\n * @returns {string} element css class name\n * @memberof module:domUtil\n */\nfunction getClass(element) {\n  if (!element || !element.className) {\n    return '';\n  }\n\n  if (isUndefined(element.className.baseVal)) {\n    return element.className;\n  }\n\n  return element.className.baseVal;\n}\n\nmodule.exports = getClass;\n\n\n/***/ }),\n\n/***/ 714:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_74973__) {\n\n\"use strict\";\n/**\n * @fileoverview Check element has specific css class\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar inArray = __nested_webpack_require_74973__(928);\nvar getClass = __nested_webpack_require_74973__(902);\n\n/**\n * Check element has specific css class\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {string} cssClass - css class\n * @returns {boolean}\n * @memberof module:domUtil\n */\nfunction hasClass(element, cssClass) {\n  var origin;\n\n  if (element.classList) {\n    return element.classList.contains(cssClass);\n  }\n\n  origin = getClass(element).split(/\\s+/);\n\n  return inArray(cssClass, origin) > -1;\n}\n\nmodule.exports = hasClass;\n\n\n/***/ }),\n\n/***/ 471:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_75740__) {\n\n\"use strict\";\n/**\n * @fileoverview Check element match selector\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar inArray = __nested_webpack_require_75740__(928);\nvar toArray = __nested_webpack_require_75740__(990);\n\nvar elProto = Element.prototype;\nvar matchSelector = elProto.matches ||\n    elProto.webkitMatchesSelector ||\n    elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector ||\n    function(selector) {\n      var doc = this.document || this.ownerDocument;\n\n      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;\n    };\n\n/**\n * Check element match selector\n * @param {HTMLElement} element - element to check\n * @param {string} selector - selector to check\n * @returns {boolean} is selector matched to element?\n * @memberof module:domUtil\n */\nfunction matches(element, selector) {\n  return matchSelector.call(element, selector);\n}\n\nmodule.exports = matches;\n\n\n/***/ }),\n\n/***/ 462:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_76721__) {\n\n\"use strict\";\n/**\n * @fileoverview Remove css class from element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEachArray = __nested_webpack_require_76721__(893);\nvar inArray = __nested_webpack_require_76721__(928);\nvar getClass = __nested_webpack_require_76721__(902);\nvar setClassName = __nested_webpack_require_76721__(24);\n\n/**\n * Remove css class from element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to remove\n * @memberof module:domUtil\n */\nfunction removeClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var origin, newClass;\n\n  if (classList) {\n    forEachArray(cssClass, function(name) {\n      classList.remove(name);\n    });\n\n    return;\n  }\n\n  origin = getClass(element).split(/\\s+/);\n  newClass = [];\n  forEachArray(origin, function(name) {\n    if (inArray(name, cssClass) < 0) {\n      newClass.push(name);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nmodule.exports = removeClass;\n\n\n/***/ }),\n\n/***/ 969:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Extend the target object from other objects.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * @module object\n */\n\n/**\n * Extend the target object from other objects.\n * @param {object} target - Object that will be extended\n * @param {...object} objects - Objects as sources\n * @returns {object} Extended object\n * @memberof module:object\n */\nfunction extend(target, objects) { // eslint-disable-line no-unused-vars\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n  var source, prop, i, len;\n\n  for (i = 1, len = arguments.length; i < len; i += 1) {\n    source = arguments[i];\n    for (prop in source) {\n      if (hasOwnProp.call(source, prop)) {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = extend;\n\n\n/***/ }),\n\n/***/ 254:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_78685__) {\n\n\"use strict\";\n/**\n * @fileoverview Request image ping.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEachOwnProperties = __nested_webpack_require_78685__(956);\n\n/**\n * @module request\n */\n\n/**\n * Request image ping.\n * @param {String} url url for ping request\n * @param {Object} trackingInfo infos for make query string\n * @returns {HTMLElement}\n * @memberof module:request\n * @example\n * // ES6\n * import imagePing from 'tui-code-snippet/request/imagePing';\n * \n * // CommonJS\n * const imagePing = require('tui-code-snippet/request/imagePing');\n *\n * imagePing('https://www.google-analytics.com/collect', {\n *   v: 1,\n *   t: 'event',\n *   tid: 'trackingid',\n *   cid: 'cid',\n *   dp: 'dp',\n *   dh: 'dh'\n * });\n */\nfunction imagePing(url, trackingInfo) {\n  var trackingElement = document.createElement('img');\n  var queryString = '';\n  forEachOwnProperties(trackingInfo, function(value, key) {\n    queryString += '&' + key + '=' + value;\n  });\n  queryString = queryString.substring(1);\n\n  trackingElement.src = url + '?' + queryString;\n\n  trackingElement.style.display = 'none';\n  document.body.appendChild(trackingElement);\n  document.body.removeChild(trackingElement);\n\n  return trackingElement;\n}\n\nmodule.exports = imagePing;\n\n\n/***/ }),\n\n/***/ 391:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_80027__) {\n\n\"use strict\";\n/**\n * @fileoverview Send hostname on DOMContentLoaded.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isUndefined = __nested_webpack_require_80027__(929);\nvar imagePing = __nested_webpack_require_80027__(254);\n\nvar ms7days = 7 * 24 * 60 * 60 * 1000;\n\n/**\n * Check if the date has passed 7 days\n * @param {number} date - milliseconds\n * @returns {boolean}\n * @private\n */\nfunction isExpired(date) {\n  var now = new Date().getTime();\n\n  return now - date > ms7days;\n}\n\n/**\n * Send hostname on DOMContentLoaded.\n * To prevent hostname set tui.usageStatistics to false.\n * @param {string} appName - application name\n * @param {string} trackingId - GA tracking ID\n * @ignore\n */\nfunction sendHostname(appName, trackingId) {\n  var url = 'https://www.google-analytics.com/collect';\n  var hostname = location.hostname;\n  var hitType = 'event';\n  var eventCategory = 'use';\n  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';\n  var date = window.localStorage.getItem(applicationKeyForStorage);\n\n  // skip if the flag is defined and is set to false explicitly\n  if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {\n    return;\n  }\n\n  // skip if not pass seven days old\n  if (date && !isExpired(date)) {\n    return;\n  }\n\n  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());\n\n  setTimeout(function() {\n    if (document.readyState === 'interactive' || document.readyState === 'complete') {\n      imagePing(url, {\n        v: 1,\n        t: hitType,\n        tid: trackingId,\n        cid: hostname,\n        dp: hostname,\n        dh: appName,\n        el: appName,\n        ec: eventCategory\n      });\n    }\n  }, 1000);\n}\n\nmodule.exports = sendHostname;\n\n\n/***/ }),\n\n/***/ 322:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is an instance of Array or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is an instance of Array or not.\n * If the given variable is an instance of Array, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is array instance?\n * @memberof module:type\n */\nfunction isArray(obj) {\n  return obj instanceof Array;\n}\n\nmodule.exports = isArray;\n\n\n/***/ }),\n\n/***/ 65:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_82401__) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is existing or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isUndefined = __nested_webpack_require_82401__(929);\nvar isNull = __nested_webpack_require_82401__(934);\n\n/**\n * Check whether the given variable is existing or not.\n * If the given variable is not null and not undefined, returns true.\n * @param {*} param - Target for checking\n * @returns {boolean} Is existy?\n * @memberof module:type\n * @example\n * // ES6\n * import isExisty from 'tui-code-snippet/type/isExisty');\n * \n * // CommonJS\n * const isExisty = require('tui-code-snippet/type/isExisty');\n *\n * isExisty(''); //true\n * isExisty(0); //true\n * isExisty([]); //true\n * isExisty({}); //true\n * isExisty(null); //false\n * isExisty(undefined); //false\n*/\nfunction isExisty(param) {\n  return !isUndefined(param) && !isNull(param);\n}\n\nmodule.exports = isExisty;\n\n\n/***/ }),\n\n/***/ 404:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_83394__) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is falsy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isTruthy = __nested_webpack_require_83394__(790);\n\n/**\n * Check whether the given variable is falsy or not.\n * If the given variable is null or undefined or false, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is falsy?\n * @memberof module:type\n */\nfunction isFalsy(obj) {\n  return !isTruthy(obj);\n}\n\nmodule.exports = isFalsy;\n\n\n/***/ }),\n\n/***/ 294:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is a function or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is a function or not.\n * If the given variable is a function, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is function?\n * @memberof module:type\n */\nfunction isFunction(obj) {\n  return obj instanceof Function;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n\n/***/ 934:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is null or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is null or not.\n * If the given variable(arguments[0]) is null, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is null?\n * @memberof module:type\n */\nfunction isNull(obj) {\n  return obj === null;\n}\n\nmodule.exports = isNull;\n\n\n/***/ }),\n\n/***/ 758:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is a string or not.\n * If the given variable is a string, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is string?\n * @memberof module:type\n */\nfunction isString(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\n\nmodule.exports = isString;\n\n\n/***/ }),\n\n/***/ 790:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_85531__) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is truthy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isExisty = __nested_webpack_require_85531__(65);\n\n/**\n * Check whether the given variable is truthy or not.\n * If the given variable is not null or not undefined or not false, returns true.\n * (It regards 0 as true)\n * @param {*} obj - Target for checking\n * @returns {boolean} Is truthy?\n * @memberof module:type\n */\nfunction isTruthy(obj) {\n  return isExisty(obj) && obj !== false;\n}\n\nmodule.exports = isTruthy;\n\n\n/***/ }),\n\n/***/ 929:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is undefined or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is undefined or not.\n * If the given variable is undefined, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is undefined?\n * @memberof module:type\n */\nfunction isUndefined(obj) {\n  return obj === undefined; // eslint-disable-line no-undefined\n}\n\nmodule.exports = isUndefined;\n\n\n/***/ }),\n\n/***/ 479:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__479__;\n\n/***/ }),\n\n/***/ 481:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__481__;\n\n/***/ }),\n\n/***/ 43:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__43__;\n\n/***/ }),\n\n/***/ 814:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__814__;\n\n/***/ }),\n\n/***/ 311:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__311__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_87464__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_87464__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t!function() {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_87464__.n = function(module) {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\tfunction() { return module['default']; } :\n/******/ \t\t\t\tfunction() { return module; };\n/******/ \t\t\t__nested_webpack_require_87464__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t!function() {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_87464__.d = function(exports, definition) {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_87464__.o(definition, key) && !__nested_webpack_require_87464__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/global */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_87464__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_87464__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }\n/******/ \t}();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n!function() {\n\"use strict\";\n\n// EXPORTS\n__nested_webpack_require_87464__.d(__nested_webpack_exports__, {\n  \"default\": function() { return /* binding */ indexViewer; }\n});\n\n;// CONCATENATED MODULE: ../../node_modules/tslib/tslib.es6.js\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar tslib_es6_assign = function() {\r\n    tslib_es6_assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return tslib_es6_assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n;// CONCATENATED MODULE: ../../libs/toastmark/dist/esm/index.js\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\nvar esm_extendStatics = function (d, b) {\n    esm_extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (Object.prototype.hasOwnProperty.call(b, p))\n                d[p] = b[p]; };\n    return esm_extendStatics(d, b);\n};\nfunction esm_extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    esm_extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar esm_assign = function () {\n    esm_assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s)\n                if (Object.prototype.hasOwnProperty.call(s, p))\n                    t[p] = s[p];\n        }\n        return t;\n    };\n    return esm_assign.apply(this, arguments);\n};\nfunction esm_spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n                if (!ar)\n                    ar = Array.prototype.slice.call(from, 0, i);\n                ar[i] = from[i];\n            }\n        }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __nested_webpack_require_87464__.g !== 'undefined' ? __nested_webpack_require_87464__.g : typeof self !== 'undefined' ? self : {};\nvar encodeCache = {};\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n    var i, ch, cache = encodeCache[exclude];\n    if (cache) {\n        return cache;\n    }\n    cache = encodeCache[exclude] = [];\n    for (i = 0; i < 128; i++) {\n        ch = String.fromCharCode(i);\n        if (/^[0-9a-z]$/i.test(ch)) {\n            // always allow unencoded alphanumeric characters\n            cache.push(ch);\n        }\n        else {\n            cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n        }\n    }\n    for (i = 0; i < exclude.length; i++) {\n        cache[exclude.charCodeAt(i)] = exclude[i];\n    }\n    return cache;\n}\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode$1(string, exclude, keepEscaped) {\n    var i, l, code, nextCode, cache, result = '';\n    if (typeof exclude !== 'string') {\n        // encode(string, keepEscaped)\n        keepEscaped = exclude;\n        exclude = encode$1.defaultChars;\n    }\n    if (typeof keepEscaped === 'undefined') {\n        keepEscaped = true;\n    }\n    cache = getEncodeCache(exclude);\n    for (i = 0, l = string.length; i < l; i++) {\n        code = string.charCodeAt(i);\n        if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n            if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n                result += string.slice(i, i + 3);\n                i += 2;\n                continue;\n            }\n        }\n        if (code < 128) {\n            result += cache[code];\n            continue;\n        }\n        if (code >= 0xD800 && code <= 0xDFFF) {\n            if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n                nextCode = string.charCodeAt(i + 1);\n                if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n                    result += encodeURIComponent(string[i] + string[i + 1]);\n                    i++;\n                    continue;\n                }\n            }\n            result += '%EF%BF%BD';\n            continue;\n        }\n        result += encodeURIComponent(string[i]);\n    }\n    return result;\n}\nencode$1.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\nencode$1.componentChars = \"-_.!~*'()\";\nvar encode_1 = encode$1;\nvar lib = {};\nvar decode = {};\nvar Aacute$1 = \"Á\";\nvar aacute$1 = \"á\";\nvar Abreve = \"Ă\";\nvar abreve = \"ă\";\nvar ac = \"∾\";\nvar acd = \"∿\";\nvar acE = \"∾̳\";\nvar Acirc$1 = \"Â\";\nvar acirc$1 = \"â\";\nvar acute$1 = \"´\";\nvar Acy = \"А\";\nvar acy = \"а\";\nvar AElig$1 = \"Æ\";\nvar aelig$1 = \"æ\";\nvar af = \"⁡\";\nvar Afr = \"𝔄\";\nvar afr = \"𝔞\";\nvar Agrave$1 = \"À\";\nvar agrave$1 = \"à\";\nvar alefsym = \"ℵ\";\nvar aleph = \"ℵ\";\nvar Alpha = \"Α\";\nvar alpha = \"α\";\nvar Amacr = \"Ā\";\nvar amacr = \"ā\";\nvar amalg = \"⨿\";\nvar amp$2 = \"&\";\nvar AMP$1 = \"&\";\nvar andand = \"⩕\";\nvar And = \"⩓\";\nvar and = \"∧\";\nvar andd = \"⩜\";\nvar andslope = \"⩘\";\nvar andv = \"⩚\";\nvar ang = \"∠\";\nvar ange = \"⦤\";\nvar angle = \"∠\";\nvar angmsdaa = \"⦨\";\nvar angmsdab = \"⦩\";\nvar angmsdac = \"⦪\";\nvar angmsdad = \"⦫\";\nvar angmsdae = \"⦬\";\nvar angmsdaf = \"⦭\";\nvar angmsdag = \"⦮\";\nvar angmsdah = \"⦯\";\nvar angmsd = \"∡\";\nvar angrt = \"∟\";\nvar angrtvb = \"⊾\";\nvar angrtvbd = \"⦝\";\nvar angsph = \"∢\";\nvar angst = \"Å\";\nvar angzarr = \"⍼\";\nvar Aogon = \"Ą\";\nvar aogon = \"ą\";\nvar Aopf = \"𝔸\";\nvar aopf = \"𝕒\";\nvar apacir = \"⩯\";\nvar ap = \"≈\";\nvar apE = \"⩰\";\nvar ape = \"≊\";\nvar apid = \"≋\";\nvar apos$1 = \"'\";\nvar ApplyFunction = \"⁡\";\nvar approx = \"≈\";\nvar approxeq = \"≊\";\nvar Aring$1 = \"Å\";\nvar aring$1 = \"å\";\nvar Ascr = \"𝒜\";\nvar ascr = \"𝒶\";\nvar Assign = \"≔\";\nvar ast = \"*\";\nvar asymp = \"≈\";\nvar asympeq = \"≍\";\nvar Atilde$1 = \"Ã\";\nvar atilde$1 = \"ã\";\nvar Auml$1 = \"Ä\";\nvar auml$1 = \"ä\";\nvar awconint = \"∳\";\nvar awint = \"⨑\";\nvar backcong = \"≌\";\nvar backepsilon = \"϶\";\nvar backprime = \"‵\";\nvar backsim = \"∽\";\nvar backsimeq = \"⋍\";\nvar Backslash = \"∖\";\nvar Barv = \"⫧\";\nvar barvee = \"⊽\";\nvar barwed = \"⌅\";\nvar Barwed = \"⌆\";\nvar barwedge = \"⌅\";\nvar bbrk = \"⎵\";\nvar bbrktbrk = \"⎶\";\nvar bcong = \"≌\";\nvar Bcy = \"Б\";\nvar bcy = \"б\";\nvar bdquo = \"„\";\nvar becaus = \"∵\";\nvar because = \"∵\";\nvar Because = \"∵\";\nvar bemptyv = \"⦰\";\nvar bepsi = \"϶\";\nvar bernou = \"ℬ\";\nvar Bernoullis = \"ℬ\";\nvar Beta = \"Β\";\nvar beta = \"β\";\nvar beth = \"ℶ\";\nvar between = \"≬\";\nvar Bfr = \"𝔅\";\nvar bfr = \"𝔟\";\nvar bigcap = \"⋂\";\nvar bigcirc = \"◯\";\nvar bigcup = \"⋃\";\nvar bigodot = \"⨀\";\nvar bigoplus = \"⨁\";\nvar bigotimes = \"⨂\";\nvar bigsqcup = \"⨆\";\nvar bigstar = \"★\";\nvar bigtriangledown = \"▽\";\nvar bigtriangleup = \"△\";\nvar biguplus = \"⨄\";\nvar bigvee = \"⋁\";\nvar bigwedge = \"⋀\";\nvar bkarow = \"⤍\";\nvar blacklozenge = \"⧫\";\nvar blacksquare = \"▪\";\nvar blacktriangle = \"▴\";\nvar blacktriangledown = \"▾\";\nvar blacktriangleleft = \"◂\";\nvar blacktriangleright = \"▸\";\nvar blank = \"␣\";\nvar blk12 = \"▒\";\nvar blk14 = \"░\";\nvar blk34 = \"▓\";\nvar block = \"█\";\nvar bne = \"=⃥\";\nvar bnequiv = \"≡⃥\";\nvar bNot = \"⫭\";\nvar bnot = \"⌐\";\nvar Bopf = \"𝔹\";\nvar bopf = \"𝕓\";\nvar bot = \"⊥\";\nvar bottom = \"⊥\";\nvar bowtie = \"⋈\";\nvar boxbox = \"⧉\";\nvar boxdl = \"┐\";\nvar boxdL = \"╕\";\nvar boxDl = \"╖\";\nvar boxDL = \"╗\";\nvar boxdr = \"┌\";\nvar boxdR = \"╒\";\nvar boxDr = \"╓\";\nvar boxDR = \"╔\";\nvar boxh = \"─\";\nvar boxH = \"═\";\nvar boxhd = \"┬\";\nvar boxHd = \"╤\";\nvar boxhD = \"╥\";\nvar boxHD = \"╦\";\nvar boxhu = \"┴\";\nvar boxHu = \"╧\";\nvar boxhU = \"╨\";\nvar boxHU = \"╩\";\nvar boxminus = \"⊟\";\nvar boxplus = \"⊞\";\nvar boxtimes = \"⊠\";\nvar boxul = \"┘\";\nvar boxuL = \"╛\";\nvar boxUl = \"╜\";\nvar boxUL = \"╝\";\nvar boxur = \"└\";\nvar boxuR = \"╘\";\nvar boxUr = \"╙\";\nvar boxUR = \"╚\";\nvar boxv = \"│\";\nvar boxV = \"║\";\nvar boxvh = \"┼\";\nvar boxvH = \"╪\";\nvar boxVh = \"╫\";\nvar boxVH = \"╬\";\nvar boxvl = \"┤\";\nvar boxvL = \"╡\";\nvar boxVl = \"╢\";\nvar boxVL = \"╣\";\nvar boxvr = \"├\";\nvar boxvR = \"╞\";\nvar boxVr = \"╟\";\nvar boxVR = \"╠\";\nvar bprime = \"‵\";\nvar breve = \"˘\";\nvar Breve = \"˘\";\nvar brvbar$1 = \"¦\";\nvar bscr = \"𝒷\";\nvar Bscr = \"ℬ\";\nvar bsemi = \"⁏\";\nvar bsim = \"∽\";\nvar bsime = \"⋍\";\nvar bsolb = \"⧅\";\nvar bsol = \"\\\\\";\nvar bsolhsub = \"⟈\";\nvar bull = \"•\";\nvar bullet = \"•\";\nvar bump = \"≎\";\nvar bumpE = \"⪮\";\nvar bumpe = \"≏\";\nvar Bumpeq = \"≎\";\nvar bumpeq = \"≏\";\nvar Cacute = \"Ć\";\nvar cacute = \"ć\";\nvar capand = \"⩄\";\nvar capbrcup = \"⩉\";\nvar capcap = \"⩋\";\nvar cap = \"∩\";\nvar Cap = \"⋒\";\nvar capcup = \"⩇\";\nvar capdot = \"⩀\";\nvar CapitalDifferentialD = \"ⅅ\";\nvar caps = \"∩︀\";\nvar caret = \"⁁\";\nvar caron = \"ˇ\";\nvar Cayleys = \"ℭ\";\nvar ccaps = \"⩍\";\nvar Ccaron = \"Č\";\nvar ccaron = \"č\";\nvar Ccedil$1 = \"Ç\";\nvar ccedil$1 = \"ç\";\nvar Ccirc = \"Ĉ\";\nvar ccirc = \"ĉ\";\nvar Cconint = \"∰\";\nvar ccups = \"⩌\";\nvar ccupssm = \"⩐\";\nvar Cdot = \"Ċ\";\nvar cdot = \"ċ\";\nvar cedil$1 = \"¸\";\nvar Cedilla = \"¸\";\nvar cemptyv = \"⦲\";\nvar cent$1 = \"¢\";\nvar centerdot = \"·\";\nvar CenterDot = \"·\";\nvar cfr = \"𝔠\";\nvar Cfr = \"ℭ\";\nvar CHcy = \"Ч\";\nvar chcy = \"ч\";\nvar check = \"✓\";\nvar checkmark = \"✓\";\nvar Chi = \"Χ\";\nvar chi = \"χ\";\nvar circ = \"ˆ\";\nvar circeq = \"≗\";\nvar circlearrowleft = \"↺\";\nvar circlearrowright = \"↻\";\nvar circledast = \"⊛\";\nvar circledcirc = \"⊚\";\nvar circleddash = \"⊝\";\nvar CircleDot = \"⊙\";\nvar circledR = \"®\";\nvar circledS = \"Ⓢ\";\nvar CircleMinus = \"⊖\";\nvar CirclePlus = \"⊕\";\nvar CircleTimes = \"⊗\";\nvar cir = \"○\";\nvar cirE = \"⧃\";\nvar cire = \"≗\";\nvar cirfnint = \"⨐\";\nvar cirmid = \"⫯\";\nvar cirscir = \"⧂\";\nvar ClockwiseContourIntegral = \"∲\";\nvar CloseCurlyDoubleQuote = \"”\";\nvar CloseCurlyQuote = \"’\";\nvar clubs = \"♣\";\nvar clubsuit = \"♣\";\nvar colon = \":\";\nvar Colon = \"∷\";\nvar Colone = \"⩴\";\nvar colone = \"≔\";\nvar coloneq = \"≔\";\nvar comma = \",\";\nvar commat = \"@\";\nvar comp = \"∁\";\nvar compfn = \"∘\";\nvar complement = \"∁\";\nvar complexes = \"ℂ\";\nvar cong = \"≅\";\nvar congdot = \"⩭\";\nvar Congruent = \"≡\";\nvar conint = \"∮\";\nvar Conint = \"∯\";\nvar ContourIntegral = \"∮\";\nvar copf = \"𝕔\";\nvar Copf = \"ℂ\";\nvar coprod = \"∐\";\nvar Coproduct = \"∐\";\nvar copy$1 = \"©\";\nvar COPY$1 = \"©\";\nvar copysr = \"℗\";\nvar CounterClockwiseContourIntegral = \"∳\";\nvar crarr = \"↵\";\nvar cross = \"✗\";\nvar Cross = \"⨯\";\nvar Cscr = \"𝒞\";\nvar cscr = \"𝒸\";\nvar csub = \"⫏\";\nvar csube = \"⫑\";\nvar csup = \"⫐\";\nvar csupe = \"⫒\";\nvar ctdot = \"⋯\";\nvar cudarrl = \"⤸\";\nvar cudarrr = \"⤵\";\nvar cuepr = \"⋞\";\nvar cuesc = \"⋟\";\nvar cularr = \"↶\";\nvar cularrp = \"⤽\";\nvar cupbrcap = \"⩈\";\nvar cupcap = \"⩆\";\nvar CupCap = \"≍\";\nvar cup = \"∪\";\nvar Cup = \"⋓\";\nvar cupcup = \"⩊\";\nvar cupdot = \"⊍\";\nvar cupor = \"⩅\";\nvar cups = \"∪︀\";\nvar curarr = \"↷\";\nvar curarrm = \"⤼\";\nvar curlyeqprec = \"⋞\";\nvar curlyeqsucc = \"⋟\";\nvar curlyvee = \"⋎\";\nvar curlywedge = \"⋏\";\nvar curren$1 = \"¤\";\nvar curvearrowleft = \"↶\";\nvar curvearrowright = \"↷\";\nvar cuvee = \"⋎\";\nvar cuwed = \"⋏\";\nvar cwconint = \"∲\";\nvar cwint = \"∱\";\nvar cylcty = \"⌭\";\nvar dagger = \"†\";\nvar Dagger = \"‡\";\nvar daleth = \"ℸ\";\nvar darr = \"↓\";\nvar Darr = \"↡\";\nvar dArr = \"⇓\";\nvar dash = \"‐\";\nvar Dashv = \"⫤\";\nvar dashv = \"⊣\";\nvar dbkarow = \"⤏\";\nvar dblac = \"˝\";\nvar Dcaron = \"Ď\";\nvar dcaron = \"ď\";\nvar Dcy = \"Д\";\nvar dcy = \"д\";\nvar ddagger = \"‡\";\nvar ddarr = \"⇊\";\nvar DD = \"ⅅ\";\nvar dd = \"ⅆ\";\nvar DDotrahd = \"⤑\";\nvar ddotseq = \"⩷\";\nvar deg$1 = \"°\";\nvar Del = \"∇\";\nvar Delta = \"Δ\";\nvar delta = \"δ\";\nvar demptyv = \"⦱\";\nvar dfisht = \"⥿\";\nvar Dfr = \"𝔇\";\nvar dfr = \"𝔡\";\nvar dHar = \"⥥\";\nvar dharl = \"⇃\";\nvar dharr = \"⇂\";\nvar DiacriticalAcute = \"´\";\nvar DiacriticalDot = \"˙\";\nvar DiacriticalDoubleAcute = \"˝\";\nvar DiacriticalGrave = \"`\";\nvar DiacriticalTilde = \"˜\";\nvar diam = \"⋄\";\nvar diamond = \"⋄\";\nvar Diamond = \"⋄\";\nvar diamondsuit = \"♦\";\nvar diams = \"♦\";\nvar die = \"¨\";\nvar DifferentialD = \"ⅆ\";\nvar digamma = \"ϝ\";\nvar disin = \"⋲\";\nvar div = \"÷\";\nvar divide$1 = \"÷\";\nvar divideontimes = \"⋇\";\nvar divonx = \"⋇\";\nvar DJcy = \"Ђ\";\nvar djcy = \"ђ\";\nvar dlcorn = \"⌞\";\nvar dlcrop = \"⌍\";\nvar dollar = \"$\";\nvar Dopf = \"𝔻\";\nvar dopf = \"𝕕\";\nvar Dot = \"¨\";\nvar dot = \"˙\";\nvar DotDot = \"⃜\";\nvar doteq = \"≐\";\nvar doteqdot = \"≑\";\nvar DotEqual = \"≐\";\nvar dotminus = \"∸\";\nvar dotplus = \"∔\";\nvar dotsquare = \"⊡\";\nvar doublebarwedge = \"⌆\";\nvar DoubleContourIntegral = \"∯\";\nvar DoubleDot = \"¨\";\nvar DoubleDownArrow = \"⇓\";\nvar DoubleLeftArrow = \"⇐\";\nvar DoubleLeftRightArrow = \"⇔\";\nvar DoubleLeftTee = \"⫤\";\nvar DoubleLongLeftArrow = \"⟸\";\nvar DoubleLongLeftRightArrow = \"⟺\";\nvar DoubleLongRightArrow = \"⟹\";\nvar DoubleRightArrow = \"⇒\";\nvar DoubleRightTee = \"⊨\";\nvar DoubleUpArrow = \"⇑\";\nvar DoubleUpDownArrow = \"⇕\";\nvar DoubleVerticalBar = \"∥\";\nvar DownArrowBar = \"⤓\";\nvar downarrow = \"↓\";\nvar DownArrow = \"↓\";\nvar Downarrow = \"⇓\";\nvar DownArrowUpArrow = \"⇵\";\nvar DownBreve = \"̑\";\nvar downdownarrows = \"⇊\";\nvar downharpoonleft = \"⇃\";\nvar downharpoonright = \"⇂\";\nvar DownLeftRightVector = \"⥐\";\nvar DownLeftTeeVector = \"⥞\";\nvar DownLeftVectorBar = \"⥖\";\nvar DownLeftVector = \"↽\";\nvar DownRightTeeVector = \"⥟\";\nvar DownRightVectorBar = \"⥗\";\nvar DownRightVector = \"⇁\";\nvar DownTeeArrow = \"↧\";\nvar DownTee = \"⊤\";\nvar drbkarow = \"⤐\";\nvar drcorn = \"⌟\";\nvar drcrop = \"⌌\";\nvar Dscr = \"𝒟\";\nvar dscr = \"𝒹\";\nvar DScy = \"Ѕ\";\nvar dscy = \"ѕ\";\nvar dsol = \"⧶\";\nvar Dstrok = \"Đ\";\nvar dstrok = \"đ\";\nvar dtdot = \"⋱\";\nvar dtri = \"▿\";\nvar dtrif = \"▾\";\nvar duarr = \"⇵\";\nvar duhar = \"⥯\";\nvar dwangle = \"⦦\";\nvar DZcy = \"Џ\";\nvar dzcy = \"џ\";\nvar dzigrarr = \"⟿\";\nvar Eacute$1 = \"É\";\nvar eacute$1 = \"é\";\nvar easter = \"⩮\";\nvar Ecaron = \"Ě\";\nvar ecaron = \"ě\";\nvar Ecirc$1 = \"Ê\";\nvar ecirc$1 = \"ê\";\nvar ecir = \"≖\";\nvar ecolon = \"≕\";\nvar Ecy = \"Э\";\nvar ecy = \"э\";\nvar eDDot = \"⩷\";\nvar Edot = \"Ė\";\nvar edot = \"ė\";\nvar eDot = \"≑\";\nvar ee = \"ⅇ\";\nvar efDot = \"≒\";\nvar Efr = \"𝔈\";\nvar efr = \"𝔢\";\nvar eg = \"⪚\";\nvar Egrave$1 = \"È\";\nvar egrave$1 = \"è\";\nvar egs = \"⪖\";\nvar egsdot = \"⪘\";\nvar el = \"⪙\";\nvar Element = \"∈\";\nvar elinters = \"⏧\";\nvar ell = \"ℓ\";\nvar els = \"⪕\";\nvar elsdot = \"⪗\";\nvar Emacr = \"Ē\";\nvar emacr = \"ē\";\nvar empty = \"∅\";\nvar emptyset = \"∅\";\nvar EmptySmallSquare = \"◻\";\nvar emptyv = \"∅\";\nvar EmptyVerySmallSquare = \"▫\";\nvar emsp13 = \" \";\nvar emsp14 = \" \";\nvar emsp = \" \";\nvar ENG = \"Ŋ\";\nvar eng = \"ŋ\";\nvar ensp = \" \";\nvar Eogon = \"Ę\";\nvar eogon = \"ę\";\nvar Eopf = \"𝔼\";\nvar eopf = \"𝕖\";\nvar epar = \"⋕\";\nvar eparsl = \"⧣\";\nvar eplus = \"⩱\";\nvar epsi = \"ε\";\nvar Epsilon = \"Ε\";\nvar epsilon = \"ε\";\nvar epsiv = \"ϵ\";\nvar eqcirc = \"≖\";\nvar eqcolon = \"≕\";\nvar eqsim = \"≂\";\nvar eqslantgtr = \"⪖\";\nvar eqslantless = \"⪕\";\nvar Equal = \"⩵\";\nvar equals = \"=\";\nvar EqualTilde = \"≂\";\nvar equest = \"≟\";\nvar Equilibrium = \"⇌\";\nvar equiv = \"≡\";\nvar equivDD = \"⩸\";\nvar eqvparsl = \"⧥\";\nvar erarr = \"⥱\";\nvar erDot = \"≓\";\nvar escr = \"ℯ\";\nvar Escr = \"ℰ\";\nvar esdot = \"≐\";\nvar Esim = \"⩳\";\nvar esim = \"≂\";\nvar Eta = \"Η\";\nvar eta = \"η\";\nvar ETH$1 = \"Ð\";\nvar eth$1 = \"ð\";\nvar Euml$1 = \"Ë\";\nvar euml$1 = \"ë\";\nvar euro = \"€\";\nvar excl = \"!\";\nvar exist = \"∃\";\nvar Exists = \"∃\";\nvar expectation = \"ℰ\";\nvar exponentiale = \"ⅇ\";\nvar ExponentialE = \"ⅇ\";\nvar fallingdotseq = \"≒\";\nvar Fcy = \"Ф\";\nvar fcy = \"ф\";\nvar female = \"♀\";\nvar ffilig = \"ﬃ\";\nvar fflig = \"ﬀ\";\nvar ffllig = \"ﬄ\";\nvar Ffr = \"𝔉\";\nvar ffr = \"𝔣\";\nvar filig = \"ﬁ\";\nvar FilledSmallSquare = \"◼\";\nvar FilledVerySmallSquare = \"▪\";\nvar fjlig = \"fj\";\nvar flat = \"♭\";\nvar fllig = \"ﬂ\";\nvar fltns = \"▱\";\nvar fnof = \"ƒ\";\nvar Fopf = \"𝔽\";\nvar fopf = \"𝕗\";\nvar forall = \"∀\";\nvar ForAll = \"∀\";\nvar fork = \"⋔\";\nvar forkv = \"⫙\";\nvar Fouriertrf = \"ℱ\";\nvar fpartint = \"⨍\";\nvar frac12$1 = \"½\";\nvar frac13 = \"⅓\";\nvar frac14$1 = \"¼\";\nvar frac15 = \"⅕\";\nvar frac16 = \"⅙\";\nvar frac18 = \"⅛\";\nvar frac23 = \"⅔\";\nvar frac25 = \"⅖\";\nvar frac34$1 = \"¾\";\nvar frac35 = \"⅗\";\nvar frac38 = \"⅜\";\nvar frac45 = \"⅘\";\nvar frac56 = \"⅚\";\nvar frac58 = \"⅝\";\nvar frac78 = \"⅞\";\nvar frasl = \"⁄\";\nvar frown = \"⌢\";\nvar fscr = \"𝒻\";\nvar Fscr = \"ℱ\";\nvar gacute = \"ǵ\";\nvar Gamma = \"Γ\";\nvar gamma = \"γ\";\nvar Gammad = \"Ϝ\";\nvar gammad = \"ϝ\";\nvar gap = \"⪆\";\nvar Gbreve = \"Ğ\";\nvar gbreve = \"ğ\";\nvar Gcedil = \"Ģ\";\nvar Gcirc = \"Ĝ\";\nvar gcirc = \"ĝ\";\nvar Gcy = \"Г\";\nvar gcy = \"г\";\nvar Gdot = \"Ġ\";\nvar gdot = \"ġ\";\nvar ge = \"≥\";\nvar gE = \"≧\";\nvar gEl = \"⪌\";\nvar gel = \"⋛\";\nvar geq = \"≥\";\nvar geqq = \"≧\";\nvar geqslant = \"⩾\";\nvar gescc = \"⪩\";\nvar ges = \"⩾\";\nvar gesdot = \"⪀\";\nvar gesdoto = \"⪂\";\nvar gesdotol = \"⪄\";\nvar gesl = \"⋛︀\";\nvar gesles = \"⪔\";\nvar Gfr = \"𝔊\";\nvar gfr = \"𝔤\";\nvar gg = \"≫\";\nvar Gg = \"⋙\";\nvar ggg = \"⋙\";\nvar gimel = \"ℷ\";\nvar GJcy = \"Ѓ\";\nvar gjcy = \"ѓ\";\nvar gla = \"⪥\";\nvar gl = \"≷\";\nvar glE = \"⪒\";\nvar glj = \"⪤\";\nvar gnap = \"⪊\";\nvar gnapprox = \"⪊\";\nvar gne = \"⪈\";\nvar gnE = \"≩\";\nvar gneq = \"⪈\";\nvar gneqq = \"≩\";\nvar gnsim = \"⋧\";\nvar Gopf = \"𝔾\";\nvar gopf = \"𝕘\";\nvar grave = \"`\";\nvar GreaterEqual = \"≥\";\nvar GreaterEqualLess = \"⋛\";\nvar GreaterFullEqual = \"≧\";\nvar GreaterGreater = \"⪢\";\nvar GreaterLess = \"≷\";\nvar GreaterSlantEqual = \"⩾\";\nvar GreaterTilde = \"≳\";\nvar Gscr = \"𝒢\";\nvar gscr = \"ℊ\";\nvar gsim = \"≳\";\nvar gsime = \"⪎\";\nvar gsiml = \"⪐\";\nvar gtcc = \"⪧\";\nvar gtcir = \"⩺\";\nvar gt$2 = \">\";\nvar GT$1 = \">\";\nvar Gt = \"≫\";\nvar gtdot = \"⋗\";\nvar gtlPar = \"⦕\";\nvar gtquest = \"⩼\";\nvar gtrapprox = \"⪆\";\nvar gtrarr = \"⥸\";\nvar gtrdot = \"⋗\";\nvar gtreqless = \"⋛\";\nvar gtreqqless = \"⪌\";\nvar gtrless = \"≷\";\nvar gtrsim = \"≳\";\nvar gvertneqq = \"≩︀\";\nvar gvnE = \"≩︀\";\nvar Hacek = \"ˇ\";\nvar hairsp = \" \";\nvar half = \"½\";\nvar hamilt = \"ℋ\";\nvar HARDcy = \"Ъ\";\nvar hardcy = \"ъ\";\nvar harrcir = \"⥈\";\nvar harr = \"↔\";\nvar hArr = \"⇔\";\nvar harrw = \"↭\";\nvar Hat = \"^\";\nvar hbar = \"ℏ\";\nvar Hcirc = \"Ĥ\";\nvar hcirc = \"ĥ\";\nvar hearts = \"♥\";\nvar heartsuit = \"♥\";\nvar hellip = \"…\";\nvar hercon = \"⊹\";\nvar hfr = \"𝔥\";\nvar Hfr = \"ℌ\";\nvar HilbertSpace = \"ℋ\";\nvar hksearow = \"⤥\";\nvar hkswarow = \"⤦\";\nvar hoarr = \"⇿\";\nvar homtht = \"∻\";\nvar hookleftarrow = \"↩\";\nvar hookrightarrow = \"↪\";\nvar hopf = \"𝕙\";\nvar Hopf = \"ℍ\";\nvar horbar = \"―\";\nvar HorizontalLine = \"─\";\nvar hscr = \"𝒽\";\nvar Hscr = \"ℋ\";\nvar hslash = \"ℏ\";\nvar Hstrok = \"Ħ\";\nvar hstrok = \"ħ\";\nvar HumpDownHump = \"≎\";\nvar HumpEqual = \"≏\";\nvar hybull = \"⁃\";\nvar hyphen = \"‐\";\nvar Iacute$1 = \"Í\";\nvar iacute$1 = \"í\";\nvar ic = \"⁣\";\nvar Icirc$1 = \"Î\";\nvar icirc$1 = \"î\";\nvar Icy = \"И\";\nvar icy = \"и\";\nvar Idot = \"İ\";\nvar IEcy = \"Е\";\nvar iecy = \"е\";\nvar iexcl$1 = \"¡\";\nvar iff = \"⇔\";\nvar ifr = \"𝔦\";\nvar Ifr = \"ℑ\";\nvar Igrave$1 = \"Ì\";\nvar igrave$1 = \"ì\";\nvar ii = \"ⅈ\";\nvar iiiint = \"⨌\";\nvar iiint = \"∭\";\nvar iinfin = \"⧜\";\nvar iiota = \"℩\";\nvar IJlig = \"Ĳ\";\nvar ijlig = \"ĳ\";\nvar Imacr = \"Ī\";\nvar imacr = \"ī\";\nvar esm_image = \"ℑ\";\nvar ImaginaryI = \"ⅈ\";\nvar imagline = \"ℐ\";\nvar imagpart = \"ℑ\";\nvar imath = \"ı\";\nvar Im = \"ℑ\";\nvar imof = \"⊷\";\nvar imped = \"Ƶ\";\nvar Implies = \"⇒\";\nvar incare = \"℅\";\nvar infin = \"∞\";\nvar infintie = \"⧝\";\nvar inodot = \"ı\";\nvar intcal = \"⊺\";\nvar esm_int = \"∫\";\nvar Int = \"∬\";\nvar integers = \"ℤ\";\nvar Integral = \"∫\";\nvar intercal = \"⊺\";\nvar Intersection = \"⋂\";\nvar intlarhk = \"⨗\";\nvar intprod = \"⨼\";\nvar InvisibleComma = \"⁣\";\nvar InvisibleTimes = \"⁢\";\nvar IOcy = \"Ё\";\nvar iocy = \"ё\";\nvar Iogon = \"Į\";\nvar iogon = \"į\";\nvar Iopf = \"𝕀\";\nvar iopf = \"𝕚\";\nvar Iota = \"Ι\";\nvar iota = \"ι\";\nvar iprod = \"⨼\";\nvar iquest$1 = \"¿\";\nvar iscr = \"𝒾\";\nvar Iscr = \"ℐ\";\nvar isin = \"∈\";\nvar isindot = \"⋵\";\nvar isinE = \"⋹\";\nvar isins = \"⋴\";\nvar isinsv = \"⋳\";\nvar isinv = \"∈\";\nvar it = \"⁢\";\nvar Itilde = \"Ĩ\";\nvar itilde = \"ĩ\";\nvar Iukcy = \"І\";\nvar iukcy = \"і\";\nvar Iuml$1 = \"Ï\";\nvar iuml$1 = \"ï\";\nvar Jcirc = \"Ĵ\";\nvar jcirc = \"ĵ\";\nvar Jcy = \"Й\";\nvar jcy = \"й\";\nvar Jfr = \"𝔍\";\nvar jfr = \"𝔧\";\nvar jmath = \"ȷ\";\nvar Jopf = \"𝕁\";\nvar jopf = \"𝕛\";\nvar Jscr = \"𝒥\";\nvar jscr = \"𝒿\";\nvar Jsercy = \"Ј\";\nvar jsercy = \"ј\";\nvar Jukcy = \"Є\";\nvar jukcy = \"є\";\nvar Kappa = \"Κ\";\nvar kappa = \"κ\";\nvar kappav = \"ϰ\";\nvar Kcedil = \"Ķ\";\nvar kcedil = \"ķ\";\nvar Kcy = \"К\";\nvar kcy = \"к\";\nvar Kfr = \"𝔎\";\nvar kfr = \"𝔨\";\nvar kgreen = \"ĸ\";\nvar KHcy = \"Х\";\nvar khcy = \"х\";\nvar KJcy = \"Ќ\";\nvar kjcy = \"ќ\";\nvar Kopf = \"𝕂\";\nvar kopf = \"𝕜\";\nvar Kscr = \"𝒦\";\nvar kscr = \"𝓀\";\nvar lAarr = \"⇚\";\nvar Lacute = \"Ĺ\";\nvar lacute = \"ĺ\";\nvar laemptyv = \"⦴\";\nvar lagran = \"ℒ\";\nvar Lambda = \"Λ\";\nvar lambda = \"λ\";\nvar lang = \"⟨\";\nvar Lang = \"⟪\";\nvar langd = \"⦑\";\nvar langle = \"⟨\";\nvar lap = \"⪅\";\nvar Laplacetrf = \"ℒ\";\nvar laquo$1 = \"«\";\nvar larrb = \"⇤\";\nvar larrbfs = \"⤟\";\nvar larr = \"←\";\nvar Larr = \"↞\";\nvar lArr = \"⇐\";\nvar larrfs = \"⤝\";\nvar larrhk = \"↩\";\nvar larrlp = \"↫\";\nvar larrpl = \"⤹\";\nvar larrsim = \"⥳\";\nvar larrtl = \"↢\";\nvar latail = \"⤙\";\nvar lAtail = \"⤛\";\nvar lat = \"⪫\";\nvar late = \"⪭\";\nvar lates = \"⪭︀\";\nvar lbarr = \"⤌\";\nvar lBarr = \"⤎\";\nvar lbbrk = \"❲\";\nvar lbrace = \"{\";\nvar lbrack = \"[\";\nvar lbrke = \"⦋\";\nvar lbrksld = \"⦏\";\nvar lbrkslu = \"⦍\";\nvar Lcaron = \"Ľ\";\nvar lcaron = \"ľ\";\nvar Lcedil = \"Ļ\";\nvar lcedil = \"ļ\";\nvar lceil = \"⌈\";\nvar lcub = \"{\";\nvar Lcy = \"Л\";\nvar lcy = \"л\";\nvar ldca = \"⤶\";\nvar ldquo = \"“\";\nvar ldquor = \"„\";\nvar ldrdhar = \"⥧\";\nvar ldrushar = \"⥋\";\nvar ldsh = \"↲\";\nvar le = \"≤\";\nvar lE = \"≦\";\nvar LeftAngleBracket = \"⟨\";\nvar LeftArrowBar = \"⇤\";\nvar leftarrow = \"←\";\nvar LeftArrow = \"←\";\nvar Leftarrow = \"⇐\";\nvar LeftArrowRightArrow = \"⇆\";\nvar leftarrowtail = \"↢\";\nvar LeftCeiling = \"⌈\";\nvar LeftDoubleBracket = \"⟦\";\nvar LeftDownTeeVector = \"⥡\";\nvar LeftDownVectorBar = \"⥙\";\nvar LeftDownVector = \"⇃\";\nvar LeftFloor = \"⌊\";\nvar leftharpoondown = \"↽\";\nvar leftharpoonup = \"↼\";\nvar leftleftarrows = \"⇇\";\nvar leftrightarrow = \"↔\";\nvar LeftRightArrow = \"↔\";\nvar Leftrightarrow = \"⇔\";\nvar leftrightarrows = \"⇆\";\nvar leftrightharpoons = \"⇋\";\nvar leftrightsquigarrow = \"↭\";\nvar LeftRightVector = \"⥎\";\nvar LeftTeeArrow = \"↤\";\nvar LeftTee = \"⊣\";\nvar LeftTeeVector = \"⥚\";\nvar leftthreetimes = \"⋋\";\nvar LeftTriangleBar = \"⧏\";\nvar LeftTriangle = \"⊲\";\nvar LeftTriangleEqual = \"⊴\";\nvar LeftUpDownVector = \"⥑\";\nvar LeftUpTeeVector = \"⥠\";\nvar LeftUpVectorBar = \"⥘\";\nvar LeftUpVector = \"↿\";\nvar LeftVectorBar = \"⥒\";\nvar LeftVector = \"↼\";\nvar lEg = \"⪋\";\nvar leg = \"⋚\";\nvar leq = \"≤\";\nvar leqq = \"≦\";\nvar leqslant = \"⩽\";\nvar lescc = \"⪨\";\nvar les = \"⩽\";\nvar lesdot = \"⩿\";\nvar lesdoto = \"⪁\";\nvar lesdotor = \"⪃\";\nvar lesg = \"⋚︀\";\nvar lesges = \"⪓\";\nvar lessapprox = \"⪅\";\nvar lessdot = \"⋖\";\nvar lesseqgtr = \"⋚\";\nvar lesseqqgtr = \"⪋\";\nvar LessEqualGreater = \"⋚\";\nvar LessFullEqual = \"≦\";\nvar LessGreater = \"≶\";\nvar lessgtr = \"≶\";\nvar LessLess = \"⪡\";\nvar lesssim = \"≲\";\nvar LessSlantEqual = \"⩽\";\nvar LessTilde = \"≲\";\nvar lfisht = \"⥼\";\nvar lfloor = \"⌊\";\nvar Lfr = \"𝔏\";\nvar lfr = \"𝔩\";\nvar lg = \"≶\";\nvar lgE = \"⪑\";\nvar lHar = \"⥢\";\nvar lhard = \"↽\";\nvar lharu = \"↼\";\nvar lharul = \"⥪\";\nvar lhblk = \"▄\";\nvar LJcy = \"Љ\";\nvar ljcy = \"љ\";\nvar llarr = \"⇇\";\nvar ll = \"≪\";\nvar Ll = \"⋘\";\nvar llcorner = \"⌞\";\nvar Lleftarrow = \"⇚\";\nvar llhard = \"⥫\";\nvar lltri = \"◺\";\nvar Lmidot = \"Ŀ\";\nvar lmidot = \"ŀ\";\nvar lmoustache = \"⎰\";\nvar lmoust = \"⎰\";\nvar lnap = \"⪉\";\nvar lnapprox = \"⪉\";\nvar lne = \"⪇\";\nvar lnE = \"≨\";\nvar lneq = \"⪇\";\nvar lneqq = \"≨\";\nvar lnsim = \"⋦\";\nvar loang = \"⟬\";\nvar loarr = \"⇽\";\nvar lobrk = \"⟦\";\nvar longleftarrow = \"⟵\";\nvar LongLeftArrow = \"⟵\";\nvar Longleftarrow = \"⟸\";\nvar longleftrightarrow = \"⟷\";\nvar LongLeftRightArrow = \"⟷\";\nvar Longleftrightarrow = \"⟺\";\nvar longmapsto = \"⟼\";\nvar longrightarrow = \"⟶\";\nvar LongRightArrow = \"⟶\";\nvar Longrightarrow = \"⟹\";\nvar looparrowleft = \"↫\";\nvar looparrowright = \"↬\";\nvar lopar = \"⦅\";\nvar Lopf = \"𝕃\";\nvar lopf = \"𝕝\";\nvar loplus = \"⨭\";\nvar lotimes = \"⨴\";\nvar lowast = \"∗\";\nvar lowbar = \"_\";\nvar LowerLeftArrow = \"↙\";\nvar LowerRightArrow = \"↘\";\nvar loz = \"◊\";\nvar lozenge = \"◊\";\nvar lozf = \"⧫\";\nvar lpar = \"(\";\nvar lparlt = \"⦓\";\nvar lrarr = \"⇆\";\nvar lrcorner = \"⌟\";\nvar lrhar = \"⇋\";\nvar lrhard = \"⥭\";\nvar lrm = \"‎\";\nvar lrtri = \"⊿\";\nvar lsaquo = \"‹\";\nvar lscr = \"𝓁\";\nvar Lscr = \"ℒ\";\nvar lsh = \"↰\";\nvar Lsh = \"↰\";\nvar lsim = \"≲\";\nvar lsime = \"⪍\";\nvar lsimg = \"⪏\";\nvar lsqb = \"[\";\nvar lsquo = \"‘\";\nvar lsquor = \"‚\";\nvar Lstrok = \"Ł\";\nvar lstrok = \"ł\";\nvar ltcc = \"⪦\";\nvar ltcir = \"⩹\";\nvar lt$2 = \"<\";\nvar LT$1 = \"<\";\nvar Lt = \"≪\";\nvar ltdot = \"⋖\";\nvar lthree = \"⋋\";\nvar ltimes = \"⋉\";\nvar ltlarr = \"⥶\";\nvar ltquest = \"⩻\";\nvar ltri = \"◃\";\nvar ltrie = \"⊴\";\nvar ltrif = \"◂\";\nvar ltrPar = \"⦖\";\nvar lurdshar = \"⥊\";\nvar luruhar = \"⥦\";\nvar lvertneqq = \"≨︀\";\nvar lvnE = \"≨︀\";\nvar macr$1 = \"¯\";\nvar male = \"♂\";\nvar malt = \"✠\";\nvar maltese = \"✠\";\nvar map = \"↦\";\nvar mapsto = \"↦\";\nvar mapstodown = \"↧\";\nvar mapstoleft = \"↤\";\nvar mapstoup = \"↥\";\nvar marker = \"▮\";\nvar mcomma = \"⨩\";\nvar Mcy = \"М\";\nvar mcy = \"м\";\nvar mdash = \"—\";\nvar mDDot = \"∺\";\nvar measuredangle = \"∡\";\nvar MediumSpace = \" \";\nvar Mellintrf = \"ℳ\";\nvar Mfr = \"𝔐\";\nvar mfr = \"𝔪\";\nvar mho = \"℧\";\nvar micro$1 = \"µ\";\nvar midast = \"*\";\nvar midcir = \"⫰\";\nvar mid = \"∣\";\nvar middot$1 = \"·\";\nvar minusb = \"⊟\";\nvar minus = \"−\";\nvar minusd = \"∸\";\nvar minusdu = \"⨪\";\nvar MinusPlus = \"∓\";\nvar mlcp = \"⫛\";\nvar mldr = \"…\";\nvar mnplus = \"∓\";\nvar models = \"⊧\";\nvar Mopf = \"𝕄\";\nvar mopf = \"𝕞\";\nvar mp = \"∓\";\nvar mscr = \"𝓂\";\nvar Mscr = \"ℳ\";\nvar mstpos = \"∾\";\nvar Mu = \"Μ\";\nvar mu = \"μ\";\nvar multimap = \"⊸\";\nvar mumap = \"⊸\";\nvar nabla = \"∇\";\nvar Nacute = \"Ń\";\nvar nacute = \"ń\";\nvar nang = \"∠⃒\";\nvar nap = \"≉\";\nvar napE = \"⩰̸\";\nvar napid = \"≋̸\";\nvar napos = \"ŉ\";\nvar napprox = \"≉\";\nvar natural = \"♮\";\nvar naturals = \"ℕ\";\nvar natur = \"♮\";\nvar nbsp$1 = \" \";\nvar nbump = \"≎̸\";\nvar nbumpe = \"≏̸\";\nvar ncap = \"⩃\";\nvar Ncaron = \"Ň\";\nvar ncaron = \"ň\";\nvar Ncedil = \"Ņ\";\nvar ncedil = \"ņ\";\nvar ncong = \"≇\";\nvar ncongdot = \"⩭̸\";\nvar ncup = \"⩂\";\nvar Ncy = \"Н\";\nvar ncy = \"н\";\nvar ndash = \"–\";\nvar nearhk = \"⤤\";\nvar nearr = \"↗\";\nvar neArr = \"⇗\";\nvar nearrow = \"↗\";\nvar ne = \"≠\";\nvar nedot = \"≐̸\";\nvar NegativeMediumSpace = \"​\";\nvar NegativeThickSpace = \"​\";\nvar NegativeThinSpace = \"​\";\nvar NegativeVeryThinSpace = \"​\";\nvar nequiv = \"≢\";\nvar nesear = \"⤨\";\nvar nesim = \"≂̸\";\nvar NestedGreaterGreater = \"≫\";\nvar NestedLessLess = \"≪\";\nvar NewLine = \"\\n\";\nvar nexist = \"∄\";\nvar nexists = \"∄\";\nvar Nfr = \"𝔑\";\nvar nfr = \"𝔫\";\nvar ngE = \"≧̸\";\nvar nge = \"≱\";\nvar ngeq = \"≱\";\nvar ngeqq = \"≧̸\";\nvar ngeqslant = \"⩾̸\";\nvar nges = \"⩾̸\";\nvar nGg = \"⋙̸\";\nvar ngsim = \"≵\";\nvar nGt = \"≫⃒\";\nvar ngt = \"≯\";\nvar ngtr = \"≯\";\nvar nGtv = \"≫̸\";\nvar nharr = \"↮\";\nvar nhArr = \"⇎\";\nvar nhpar = \"⫲\";\nvar ni = \"∋\";\nvar nis = \"⋼\";\nvar nisd = \"⋺\";\nvar niv = \"∋\";\nvar NJcy = \"Њ\";\nvar njcy = \"њ\";\nvar nlarr = \"↚\";\nvar nlArr = \"⇍\";\nvar nldr = \"‥\";\nvar nlE = \"≦̸\";\nvar nle = \"≰\";\nvar nleftarrow = \"↚\";\nvar nLeftarrow = \"⇍\";\nvar nleftrightarrow = \"↮\";\nvar nLeftrightarrow = \"⇎\";\nvar nleq = \"≰\";\nvar nleqq = \"≦̸\";\nvar nleqslant = \"⩽̸\";\nvar nles = \"⩽̸\";\nvar nless = \"≮\";\nvar nLl = \"⋘̸\";\nvar nlsim = \"≴\";\nvar nLt = \"≪⃒\";\nvar nlt = \"≮\";\nvar nltri = \"⋪\";\nvar nltrie = \"⋬\";\nvar nLtv = \"≪̸\";\nvar nmid = \"∤\";\nvar NoBreak = \"⁠\";\nvar NonBreakingSpace = \" \";\nvar nopf = \"𝕟\";\nvar Nopf = \"ℕ\";\nvar Not = \"⫬\";\nvar not$1 = \"¬\";\nvar NotCongruent = \"≢\";\nvar NotCupCap = \"≭\";\nvar NotDoubleVerticalBar = \"∦\";\nvar NotElement = \"∉\";\nvar NotEqual = \"≠\";\nvar NotEqualTilde = \"≂̸\";\nvar NotExists = \"∄\";\nvar NotGreater = \"≯\";\nvar NotGreaterEqual = \"≱\";\nvar NotGreaterFullEqual = \"≧̸\";\nvar NotGreaterGreater = \"≫̸\";\nvar NotGreaterLess = \"≹\";\nvar NotGreaterSlantEqual = \"⩾̸\";\nvar NotGreaterTilde = \"≵\";\nvar NotHumpDownHump = \"≎̸\";\nvar NotHumpEqual = \"≏̸\";\nvar notin = \"∉\";\nvar notindot = \"⋵̸\";\nvar notinE = \"⋹̸\";\nvar notinva = \"∉\";\nvar notinvb = \"⋷\";\nvar notinvc = \"⋶\";\nvar NotLeftTriangleBar = \"⧏̸\";\nvar NotLeftTriangle = \"⋪\";\nvar NotLeftTriangleEqual = \"⋬\";\nvar NotLess = \"≮\";\nvar NotLessEqual = \"≰\";\nvar NotLessGreater = \"≸\";\nvar NotLessLess = \"≪̸\";\nvar NotLessSlantEqual = \"⩽̸\";\nvar NotLessTilde = \"≴\";\nvar NotNestedGreaterGreater = \"⪢̸\";\nvar NotNestedLessLess = \"⪡̸\";\nvar notni = \"∌\";\nvar notniva = \"∌\";\nvar notnivb = \"⋾\";\nvar notnivc = \"⋽\";\nvar NotPrecedes = \"⊀\";\nvar NotPrecedesEqual = \"⪯̸\";\nvar NotPrecedesSlantEqual = \"⋠\";\nvar NotReverseElement = \"∌\";\nvar NotRightTriangleBar = \"⧐̸\";\nvar NotRightTriangle = \"⋫\";\nvar NotRightTriangleEqual = \"⋭\";\nvar NotSquareSubset = \"⊏̸\";\nvar NotSquareSubsetEqual = \"⋢\";\nvar NotSquareSuperset = \"⊐̸\";\nvar NotSquareSupersetEqual = \"⋣\";\nvar NotSubset = \"⊂⃒\";\nvar NotSubsetEqual = \"⊈\";\nvar NotSucceeds = \"⊁\";\nvar NotSucceedsEqual = \"⪰̸\";\nvar NotSucceedsSlantEqual = \"⋡\";\nvar NotSucceedsTilde = \"≿̸\";\nvar NotSuperset = \"⊃⃒\";\nvar NotSupersetEqual = \"⊉\";\nvar NotTilde = \"≁\";\nvar NotTildeEqual = \"≄\";\nvar NotTildeFullEqual = \"≇\";\nvar NotTildeTilde = \"≉\";\nvar NotVerticalBar = \"∤\";\nvar nparallel = \"∦\";\nvar npar = \"∦\";\nvar nparsl = \"⫽⃥\";\nvar npart = \"∂̸\";\nvar npolint = \"⨔\";\nvar npr = \"⊀\";\nvar nprcue = \"⋠\";\nvar nprec = \"⊀\";\nvar npreceq = \"⪯̸\";\nvar npre = \"⪯̸\";\nvar nrarrc = \"⤳̸\";\nvar nrarr = \"↛\";\nvar nrArr = \"⇏\";\nvar nrarrw = \"↝̸\";\nvar nrightarrow = \"↛\";\nvar nRightarrow = \"⇏\";\nvar nrtri = \"⋫\";\nvar nrtrie = \"⋭\";\nvar nsc = \"⊁\";\nvar nsccue = \"⋡\";\nvar nsce = \"⪰̸\";\nvar Nscr = \"𝒩\";\nvar nscr = \"𝓃\";\nvar nshortmid = \"∤\";\nvar nshortparallel = \"∦\";\nvar nsim = \"≁\";\nvar nsime = \"≄\";\nvar nsimeq = \"≄\";\nvar nsmid = \"∤\";\nvar nspar = \"∦\";\nvar nsqsube = \"⋢\";\nvar nsqsupe = \"⋣\";\nvar nsub = \"⊄\";\nvar nsubE = \"⫅̸\";\nvar nsube = \"⊈\";\nvar nsubset = \"⊂⃒\";\nvar nsubseteq = \"⊈\";\nvar nsubseteqq = \"⫅̸\";\nvar nsucc = \"⊁\";\nvar nsucceq = \"⪰̸\";\nvar nsup = \"⊅\";\nvar nsupE = \"⫆̸\";\nvar nsupe = \"⊉\";\nvar nsupset = \"⊃⃒\";\nvar nsupseteq = \"⊉\";\nvar nsupseteqq = \"⫆̸\";\nvar ntgl = \"≹\";\nvar Ntilde$1 = \"Ñ\";\nvar ntilde$1 = \"ñ\";\nvar ntlg = \"≸\";\nvar ntriangleleft = \"⋪\";\nvar ntrianglelefteq = \"⋬\";\nvar ntriangleright = \"⋫\";\nvar ntrianglerighteq = \"⋭\";\nvar Nu = \"Ν\";\nvar nu = \"ν\";\nvar num = \"#\";\nvar numero = \"№\";\nvar numsp = \" \";\nvar nvap = \"≍⃒\";\nvar nvdash = \"⊬\";\nvar nvDash = \"⊭\";\nvar nVdash = \"⊮\";\nvar nVDash = \"⊯\";\nvar nvge = \"≥⃒\";\nvar nvgt = \">⃒\";\nvar nvHarr = \"⤄\";\nvar nvinfin = \"⧞\";\nvar nvlArr = \"⤂\";\nvar nvle = \"≤⃒\";\nvar nvlt = \"<⃒\";\nvar nvltrie = \"⊴⃒\";\nvar nvrArr = \"⤃\";\nvar nvrtrie = \"⊵⃒\";\nvar nvsim = \"∼⃒\";\nvar nwarhk = \"⤣\";\nvar nwarr = \"↖\";\nvar nwArr = \"⇖\";\nvar nwarrow = \"↖\";\nvar nwnear = \"⤧\";\nvar Oacute$1 = \"Ó\";\nvar oacute$1 = \"ó\";\nvar oast = \"⊛\";\nvar Ocirc$1 = \"Ô\";\nvar ocirc$1 = \"ô\";\nvar ocir = \"⊚\";\nvar Ocy = \"О\";\nvar ocy = \"о\";\nvar odash = \"⊝\";\nvar Odblac = \"Ő\";\nvar odblac = \"ő\";\nvar odiv = \"⨸\";\nvar odot = \"⊙\";\nvar odsold = \"⦼\";\nvar OElig = \"Œ\";\nvar oelig = \"œ\";\nvar ofcir = \"⦿\";\nvar Ofr = \"𝔒\";\nvar ofr = \"𝔬\";\nvar ogon = \"˛\";\nvar Ograve$1 = \"Ò\";\nvar ograve$1 = \"ò\";\nvar ogt = \"⧁\";\nvar ohbar = \"⦵\";\nvar ohm = \"Ω\";\nvar oint = \"∮\";\nvar olarr = \"↺\";\nvar olcir = \"⦾\";\nvar olcross = \"⦻\";\nvar oline = \"‾\";\nvar olt = \"⧀\";\nvar Omacr = \"Ō\";\nvar omacr = \"ō\";\nvar Omega = \"Ω\";\nvar omega = \"ω\";\nvar Omicron = \"Ο\";\nvar omicron = \"ο\";\nvar omid = \"⦶\";\nvar ominus = \"⊖\";\nvar Oopf = \"𝕆\";\nvar oopf = \"𝕠\";\nvar opar = \"⦷\";\nvar OpenCurlyDoubleQuote = \"“\";\nvar OpenCurlyQuote = \"‘\";\nvar operp = \"⦹\";\nvar oplus = \"⊕\";\nvar orarr = \"↻\";\nvar Or = \"⩔\";\nvar or = \"∨\";\nvar ord = \"⩝\";\nvar order = \"ℴ\";\nvar orderof = \"ℴ\";\nvar ordf$1 = \"ª\";\nvar ordm$1 = \"º\";\nvar origof = \"⊶\";\nvar oror = \"⩖\";\nvar orslope = \"⩗\";\nvar orv = \"⩛\";\nvar oS = \"Ⓢ\";\nvar Oscr = \"𝒪\";\nvar oscr = \"ℴ\";\nvar Oslash$1 = \"Ø\";\nvar oslash$1 = \"ø\";\nvar osol = \"⊘\";\nvar Otilde$1 = \"Õ\";\nvar otilde$1 = \"õ\";\nvar otimesas = \"⨶\";\nvar Otimes = \"⨷\";\nvar otimes = \"⊗\";\nvar Ouml$1 = \"Ö\";\nvar ouml$1 = \"ö\";\nvar ovbar = \"⌽\";\nvar OverBar = \"‾\";\nvar OverBrace = \"⏞\";\nvar OverBracket = \"⎴\";\nvar OverParenthesis = \"⏜\";\nvar para$1 = \"¶\";\nvar parallel = \"∥\";\nvar par = \"∥\";\nvar parsim = \"⫳\";\nvar parsl = \"⫽\";\nvar part = \"∂\";\nvar PartialD = \"∂\";\nvar Pcy = \"П\";\nvar pcy = \"п\";\nvar percnt = \"%\";\nvar period = \".\";\nvar permil = \"‰\";\nvar perp = \"⊥\";\nvar pertenk = \"‱\";\nvar Pfr = \"𝔓\";\nvar pfr = \"𝔭\";\nvar Phi = \"Φ\";\nvar phi = \"φ\";\nvar phiv = \"ϕ\";\nvar phmmat = \"ℳ\";\nvar phone = \"☎\";\nvar Pi = \"Π\";\nvar pi = \"π\";\nvar pitchfork = \"⋔\";\nvar piv = \"ϖ\";\nvar planck = \"ℏ\";\nvar planckh = \"ℎ\";\nvar plankv = \"ℏ\";\nvar plusacir = \"⨣\";\nvar plusb = \"⊞\";\nvar pluscir = \"⨢\";\nvar plus = \"+\";\nvar plusdo = \"∔\";\nvar plusdu = \"⨥\";\nvar pluse = \"⩲\";\nvar PlusMinus = \"±\";\nvar plusmn$1 = \"±\";\nvar plussim = \"⨦\";\nvar plustwo = \"⨧\";\nvar pm = \"±\";\nvar Poincareplane = \"ℌ\";\nvar pointint = \"⨕\";\nvar popf = \"𝕡\";\nvar Popf = \"ℙ\";\nvar pound$1 = \"£\";\nvar prap = \"⪷\";\nvar Pr = \"⪻\";\nvar pr = \"≺\";\nvar prcue = \"≼\";\nvar precapprox = \"⪷\";\nvar prec = \"≺\";\nvar preccurlyeq = \"≼\";\nvar Precedes = \"≺\";\nvar PrecedesEqual = \"⪯\";\nvar PrecedesSlantEqual = \"≼\";\nvar PrecedesTilde = \"≾\";\nvar preceq = \"⪯\";\nvar precnapprox = \"⪹\";\nvar precneqq = \"⪵\";\nvar precnsim = \"⋨\";\nvar pre = \"⪯\";\nvar prE = \"⪳\";\nvar precsim = \"≾\";\nvar prime = \"′\";\nvar Prime = \"″\";\nvar primes = \"ℙ\";\nvar prnap = \"⪹\";\nvar prnE = \"⪵\";\nvar prnsim = \"⋨\";\nvar prod = \"∏\";\nvar Product = \"∏\";\nvar profalar = \"⌮\";\nvar profline = \"⌒\";\nvar profsurf = \"⌓\";\nvar prop = \"∝\";\nvar Proportional = \"∝\";\nvar Proportion = \"∷\";\nvar propto = \"∝\";\nvar prsim = \"≾\";\nvar prurel = \"⊰\";\nvar Pscr = \"𝒫\";\nvar pscr = \"𝓅\";\nvar Psi = \"Ψ\";\nvar psi = \"ψ\";\nvar puncsp = \" \";\nvar Qfr = \"𝔔\";\nvar qfr = \"𝔮\";\nvar qint = \"⨌\";\nvar qopf = \"𝕢\";\nvar Qopf = \"ℚ\";\nvar qprime = \"⁗\";\nvar Qscr = \"𝒬\";\nvar qscr = \"𝓆\";\nvar quaternions = \"ℍ\";\nvar quatint = \"⨖\";\nvar quest = \"?\";\nvar questeq = \"≟\";\nvar quot$2 = \"\\\"\";\nvar QUOT$1 = \"\\\"\";\nvar rAarr = \"⇛\";\nvar race = \"∽̱\";\nvar Racute = \"Ŕ\";\nvar racute = \"ŕ\";\nvar radic = \"√\";\nvar raemptyv = \"⦳\";\nvar rang = \"⟩\";\nvar Rang = \"⟫\";\nvar rangd = \"⦒\";\nvar range = \"⦥\";\nvar rangle = \"⟩\";\nvar raquo$1 = \"»\";\nvar rarrap = \"⥵\";\nvar rarrb = \"⇥\";\nvar rarrbfs = \"⤠\";\nvar rarrc = \"⤳\";\nvar rarr = \"→\";\nvar Rarr = \"↠\";\nvar rArr = \"⇒\";\nvar rarrfs = \"⤞\";\nvar rarrhk = \"↪\";\nvar rarrlp = \"↬\";\nvar rarrpl = \"⥅\";\nvar rarrsim = \"⥴\";\nvar Rarrtl = \"⤖\";\nvar rarrtl = \"↣\";\nvar rarrw = \"↝\";\nvar ratail = \"⤚\";\nvar rAtail = \"⤜\";\nvar ratio = \"∶\";\nvar rationals = \"ℚ\";\nvar rbarr = \"⤍\";\nvar rBarr = \"⤏\";\nvar RBarr = \"⤐\";\nvar rbbrk = \"❳\";\nvar rbrace = \"}\";\nvar rbrack = \"]\";\nvar rbrke = \"⦌\";\nvar rbrksld = \"⦎\";\nvar rbrkslu = \"⦐\";\nvar Rcaron = \"Ř\";\nvar rcaron = \"ř\";\nvar Rcedil = \"Ŗ\";\nvar rcedil = \"ŗ\";\nvar rceil = \"⌉\";\nvar rcub = \"}\";\nvar Rcy = \"Р\";\nvar rcy = \"р\";\nvar rdca = \"⤷\";\nvar rdldhar = \"⥩\";\nvar rdquo = \"”\";\nvar rdquor = \"”\";\nvar rdsh = \"↳\";\nvar real = \"ℜ\";\nvar realine = \"ℛ\";\nvar realpart = \"ℜ\";\nvar reals = \"ℝ\";\nvar Re = \"ℜ\";\nvar rect = \"▭\";\nvar reg$1 = \"®\";\nvar REG$1 = \"®\";\nvar ReverseElement = \"∋\";\nvar ReverseEquilibrium = \"⇋\";\nvar ReverseUpEquilibrium = \"⥯\";\nvar rfisht = \"⥽\";\nvar rfloor = \"⌋\";\nvar rfr = \"𝔯\";\nvar Rfr = \"ℜ\";\nvar rHar = \"⥤\";\nvar rhard = \"⇁\";\nvar rharu = \"⇀\";\nvar rharul = \"⥬\";\nvar Rho = \"Ρ\";\nvar rho = \"ρ\";\nvar rhov = \"ϱ\";\nvar RightAngleBracket = \"⟩\";\nvar RightArrowBar = \"⇥\";\nvar rightarrow = \"→\";\nvar RightArrow = \"→\";\nvar Rightarrow = \"⇒\";\nvar RightArrowLeftArrow = \"⇄\";\nvar rightarrowtail = \"↣\";\nvar RightCeiling = \"⌉\";\nvar RightDoubleBracket = \"⟧\";\nvar RightDownTeeVector = \"⥝\";\nvar RightDownVectorBar = \"⥕\";\nvar RightDownVector = \"⇂\";\nvar RightFloor = \"⌋\";\nvar rightharpoondown = \"⇁\";\nvar rightharpoonup = \"⇀\";\nvar rightleftarrows = \"⇄\";\nvar rightleftharpoons = \"⇌\";\nvar rightrightarrows = \"⇉\";\nvar rightsquigarrow = \"↝\";\nvar RightTeeArrow = \"↦\";\nvar RightTee = \"⊢\";\nvar RightTeeVector = \"⥛\";\nvar rightthreetimes = \"⋌\";\nvar RightTriangleBar = \"⧐\";\nvar RightTriangle = \"⊳\";\nvar RightTriangleEqual = \"⊵\";\nvar RightUpDownVector = \"⥏\";\nvar RightUpTeeVector = \"⥜\";\nvar RightUpVectorBar = \"⥔\";\nvar RightUpVector = \"↾\";\nvar RightVectorBar = \"⥓\";\nvar RightVector = \"⇀\";\nvar ring = \"˚\";\nvar risingdotseq = \"≓\";\nvar rlarr = \"⇄\";\nvar rlhar = \"⇌\";\nvar rlm = \"‏\";\nvar rmoustache = \"⎱\";\nvar rmoust = \"⎱\";\nvar rnmid = \"⫮\";\nvar roang = \"⟭\";\nvar roarr = \"⇾\";\nvar robrk = \"⟧\";\nvar ropar = \"⦆\";\nvar ropf = \"𝕣\";\nvar Ropf = \"ℝ\";\nvar roplus = \"⨮\";\nvar rotimes = \"⨵\";\nvar RoundImplies = \"⥰\";\nvar rpar = \")\";\nvar rpargt = \"⦔\";\nvar rppolint = \"⨒\";\nvar rrarr = \"⇉\";\nvar Rrightarrow = \"⇛\";\nvar rsaquo = \"›\";\nvar rscr = \"𝓇\";\nvar Rscr = \"ℛ\";\nvar rsh = \"↱\";\nvar Rsh = \"↱\";\nvar rsqb = \"]\";\nvar rsquo = \"’\";\nvar rsquor = \"’\";\nvar rthree = \"⋌\";\nvar rtimes = \"⋊\";\nvar rtri = \"▹\";\nvar rtrie = \"⊵\";\nvar rtrif = \"▸\";\nvar rtriltri = \"⧎\";\nvar RuleDelayed = \"⧴\";\nvar ruluhar = \"⥨\";\nvar rx = \"℞\";\nvar Sacute = \"Ś\";\nvar sacute = \"ś\";\nvar sbquo = \"‚\";\nvar scap = \"⪸\";\nvar Scaron = \"Š\";\nvar scaron = \"š\";\nvar Sc = \"⪼\";\nvar sc = \"≻\";\nvar sccue = \"≽\";\nvar sce = \"⪰\";\nvar scE = \"⪴\";\nvar Scedil = \"Ş\";\nvar scedil = \"ş\";\nvar Scirc = \"Ŝ\";\nvar scirc = \"ŝ\";\nvar scnap = \"⪺\";\nvar scnE = \"⪶\";\nvar scnsim = \"⋩\";\nvar scpolint = \"⨓\";\nvar scsim = \"≿\";\nvar Scy = \"С\";\nvar scy = \"с\";\nvar sdotb = \"⊡\";\nvar sdot = \"⋅\";\nvar sdote = \"⩦\";\nvar searhk = \"⤥\";\nvar searr = \"↘\";\nvar seArr = \"⇘\";\nvar searrow = \"↘\";\nvar sect$1 = \"§\";\nvar semi = \";\";\nvar seswar = \"⤩\";\nvar setminus = \"∖\";\nvar setmn = \"∖\";\nvar sext = \"✶\";\nvar Sfr = \"𝔖\";\nvar sfr = \"𝔰\";\nvar sfrown = \"⌢\";\nvar sharp = \"♯\";\nvar SHCHcy = \"Щ\";\nvar shchcy = \"щ\";\nvar SHcy = \"Ш\";\nvar shcy = \"ш\";\nvar ShortDownArrow = \"↓\";\nvar ShortLeftArrow = \"←\";\nvar shortmid = \"∣\";\nvar shortparallel = \"∥\";\nvar ShortRightArrow = \"→\";\nvar ShortUpArrow = \"↑\";\nvar shy$1 = \"­\";\nvar Sigma = \"Σ\";\nvar sigma = \"σ\";\nvar sigmaf = \"ς\";\nvar sigmav = \"ς\";\nvar sim = \"∼\";\nvar simdot = \"⩪\";\nvar sime = \"≃\";\nvar simeq = \"≃\";\nvar simg = \"⪞\";\nvar simgE = \"⪠\";\nvar siml = \"⪝\";\nvar simlE = \"⪟\";\nvar simne = \"≆\";\nvar simplus = \"⨤\";\nvar simrarr = \"⥲\";\nvar slarr = \"←\";\nvar SmallCircle = \"∘\";\nvar smallsetminus = \"∖\";\nvar smashp = \"⨳\";\nvar smeparsl = \"⧤\";\nvar smid = \"∣\";\nvar smile = \"⌣\";\nvar smt = \"⪪\";\nvar smte = \"⪬\";\nvar smtes = \"⪬︀\";\nvar SOFTcy = \"Ь\";\nvar softcy = \"ь\";\nvar solbar = \"⌿\";\nvar solb = \"⧄\";\nvar sol = \"/\";\nvar Sopf = \"𝕊\";\nvar sopf = \"𝕤\";\nvar spades = \"♠\";\nvar spadesuit = \"♠\";\nvar spar = \"∥\";\nvar sqcap = \"⊓\";\nvar sqcaps = \"⊓︀\";\nvar sqcup = \"⊔\";\nvar sqcups = \"⊔︀\";\nvar Sqrt = \"√\";\nvar sqsub = \"⊏\";\nvar sqsube = \"⊑\";\nvar sqsubset = \"⊏\";\nvar sqsubseteq = \"⊑\";\nvar sqsup = \"⊐\";\nvar sqsupe = \"⊒\";\nvar sqsupset = \"⊐\";\nvar sqsupseteq = \"⊒\";\nvar square = \"□\";\nvar Square = \"□\";\nvar SquareIntersection = \"⊓\";\nvar SquareSubset = \"⊏\";\nvar SquareSubsetEqual = \"⊑\";\nvar SquareSuperset = \"⊐\";\nvar SquareSupersetEqual = \"⊒\";\nvar SquareUnion = \"⊔\";\nvar squarf = \"▪\";\nvar squ = \"□\";\nvar squf = \"▪\";\nvar srarr = \"→\";\nvar Sscr = \"𝒮\";\nvar sscr = \"𝓈\";\nvar ssetmn = \"∖\";\nvar ssmile = \"⌣\";\nvar sstarf = \"⋆\";\nvar Star = \"⋆\";\nvar star = \"☆\";\nvar starf = \"★\";\nvar straightepsilon = \"ϵ\";\nvar straightphi = \"ϕ\";\nvar strns = \"¯\";\nvar sub = \"⊂\";\nvar Sub = \"⋐\";\nvar subdot = \"⪽\";\nvar subE = \"⫅\";\nvar sube = \"⊆\";\nvar subedot = \"⫃\";\nvar submult = \"⫁\";\nvar subnE = \"⫋\";\nvar subne = \"⊊\";\nvar subplus = \"⪿\";\nvar subrarr = \"⥹\";\nvar subset = \"⊂\";\nvar Subset = \"⋐\";\nvar subseteq = \"⊆\";\nvar subseteqq = \"⫅\";\nvar SubsetEqual = \"⊆\";\nvar subsetneq = \"⊊\";\nvar subsetneqq = \"⫋\";\nvar subsim = \"⫇\";\nvar subsub = \"⫕\";\nvar subsup = \"⫓\";\nvar succapprox = \"⪸\";\nvar succ = \"≻\";\nvar succcurlyeq = \"≽\";\nvar Succeeds = \"≻\";\nvar SucceedsEqual = \"⪰\";\nvar SucceedsSlantEqual = \"≽\";\nvar SucceedsTilde = \"≿\";\nvar succeq = \"⪰\";\nvar succnapprox = \"⪺\";\nvar succneqq = \"⪶\";\nvar succnsim = \"⋩\";\nvar succsim = \"≿\";\nvar SuchThat = \"∋\";\nvar sum = \"∑\";\nvar Sum = \"∑\";\nvar sung = \"♪\";\nvar sup1$1 = \"¹\";\nvar sup2$1 = \"²\";\nvar sup3$1 = \"³\";\nvar sup = \"⊃\";\nvar Sup = \"⋑\";\nvar supdot = \"⪾\";\nvar supdsub = \"⫘\";\nvar supE = \"⫆\";\nvar supe = \"⊇\";\nvar supedot = \"⫄\";\nvar Superset = \"⊃\";\nvar SupersetEqual = \"⊇\";\nvar suphsol = \"⟉\";\nvar suphsub = \"⫗\";\nvar suplarr = \"⥻\";\nvar supmult = \"⫂\";\nvar supnE = \"⫌\";\nvar supne = \"⊋\";\nvar supplus = \"⫀\";\nvar supset = \"⊃\";\nvar Supset = \"⋑\";\nvar supseteq = \"⊇\";\nvar supseteqq = \"⫆\";\nvar supsetneq = \"⊋\";\nvar supsetneqq = \"⫌\";\nvar supsim = \"⫈\";\nvar supsub = \"⫔\";\nvar supsup = \"⫖\";\nvar swarhk = \"⤦\";\nvar swarr = \"↙\";\nvar swArr = \"⇙\";\nvar swarrow = \"↙\";\nvar swnwar = \"⤪\";\nvar szlig$1 = \"ß\";\nvar Tab = \"\\t\";\nvar target = \"⌖\";\nvar Tau = \"Τ\";\nvar tau = \"τ\";\nvar tbrk = \"⎴\";\nvar Tcaron = \"Ť\";\nvar tcaron = \"ť\";\nvar Tcedil = \"Ţ\";\nvar tcedil = \"ţ\";\nvar Tcy = \"Т\";\nvar tcy = \"т\";\nvar tdot = \"⃛\";\nvar telrec = \"⌕\";\nvar Tfr = \"𝔗\";\nvar tfr = \"𝔱\";\nvar there4 = \"∴\";\nvar therefore = \"∴\";\nvar Therefore = \"∴\";\nvar Theta = \"Θ\";\nvar theta = \"θ\";\nvar thetasym = \"ϑ\";\nvar thetav = \"ϑ\";\nvar thickapprox = \"≈\";\nvar thicksim = \"∼\";\nvar ThickSpace = \"  \";\nvar ThinSpace = \" \";\nvar thinsp = \" \";\nvar thkap = \"≈\";\nvar thksim = \"∼\";\nvar THORN$1 = \"Þ\";\nvar thorn$1 = \"þ\";\nvar tilde = \"˜\";\nvar Tilde = \"∼\";\nvar TildeEqual = \"≃\";\nvar TildeFullEqual = \"≅\";\nvar TildeTilde = \"≈\";\nvar timesbar = \"⨱\";\nvar timesb = \"⊠\";\nvar times$1 = \"×\";\nvar timesd = \"⨰\";\nvar tint = \"∭\";\nvar toea = \"⤨\";\nvar topbot = \"⌶\";\nvar topcir = \"⫱\";\nvar esm_top = \"⊤\";\nvar Topf = \"𝕋\";\nvar topf = \"𝕥\";\nvar topfork = \"⫚\";\nvar tosa = \"⤩\";\nvar tprime = \"‴\";\nvar trade = \"™\";\nvar TRADE = \"™\";\nvar triangle = \"▵\";\nvar triangledown = \"▿\";\nvar triangleleft = \"◃\";\nvar trianglelefteq = \"⊴\";\nvar triangleq = \"≜\";\nvar triangleright = \"▹\";\nvar trianglerighteq = \"⊵\";\nvar tridot = \"◬\";\nvar trie = \"≜\";\nvar triminus = \"⨺\";\nvar TripleDot = \"⃛\";\nvar triplus = \"⨹\";\nvar trisb = \"⧍\";\nvar tritime = \"⨻\";\nvar trpezium = \"⏢\";\nvar Tscr = \"𝒯\";\nvar tscr = \"𝓉\";\nvar TScy = \"Ц\";\nvar tscy = \"ц\";\nvar TSHcy = \"Ћ\";\nvar tshcy = \"ћ\";\nvar Tstrok = \"Ŧ\";\nvar tstrok = \"ŧ\";\nvar twixt = \"≬\";\nvar twoheadleftarrow = \"↞\";\nvar twoheadrightarrow = \"↠\";\nvar Uacute$1 = \"Ú\";\nvar uacute$1 = \"ú\";\nvar uarr = \"↑\";\nvar Uarr = \"↟\";\nvar uArr = \"⇑\";\nvar Uarrocir = \"⥉\";\nvar Ubrcy = \"Ў\";\nvar ubrcy = \"ў\";\nvar Ubreve = \"Ŭ\";\nvar ubreve = \"ŭ\";\nvar Ucirc$1 = \"Û\";\nvar ucirc$1 = \"û\";\nvar Ucy = \"У\";\nvar ucy = \"у\";\nvar udarr = \"⇅\";\nvar Udblac = \"Ű\";\nvar udblac = \"ű\";\nvar udhar = \"⥮\";\nvar ufisht = \"⥾\";\nvar Ufr = \"𝔘\";\nvar ufr = \"𝔲\";\nvar Ugrave$1 = \"Ù\";\nvar ugrave$1 = \"ù\";\nvar uHar = \"⥣\";\nvar uharl = \"↿\";\nvar uharr = \"↾\";\nvar uhblk = \"▀\";\nvar ulcorn = \"⌜\";\nvar ulcorner = \"⌜\";\nvar ulcrop = \"⌏\";\nvar ultri = \"◸\";\nvar Umacr = \"Ū\";\nvar umacr = \"ū\";\nvar uml$1 = \"¨\";\nvar UnderBar = \"_\";\nvar UnderBrace = \"⏟\";\nvar UnderBracket = \"⎵\";\nvar UnderParenthesis = \"⏝\";\nvar Union = \"⋃\";\nvar UnionPlus = \"⊎\";\nvar Uogon = \"Ų\";\nvar uogon = \"ų\";\nvar Uopf = \"𝕌\";\nvar uopf = \"𝕦\";\nvar UpArrowBar = \"⤒\";\nvar uparrow = \"↑\";\nvar UpArrow = \"↑\";\nvar Uparrow = \"⇑\";\nvar UpArrowDownArrow = \"⇅\";\nvar updownarrow = \"↕\";\nvar UpDownArrow = \"↕\";\nvar Updownarrow = \"⇕\";\nvar UpEquilibrium = \"⥮\";\nvar upharpoonleft = \"↿\";\nvar upharpoonright = \"↾\";\nvar uplus = \"⊎\";\nvar UpperLeftArrow = \"↖\";\nvar UpperRightArrow = \"↗\";\nvar upsi = \"υ\";\nvar Upsi = \"ϒ\";\nvar upsih = \"ϒ\";\nvar Upsilon = \"Υ\";\nvar upsilon = \"υ\";\nvar UpTeeArrow = \"↥\";\nvar UpTee = \"⊥\";\nvar upuparrows = \"⇈\";\nvar urcorn = \"⌝\";\nvar urcorner = \"⌝\";\nvar urcrop = \"⌎\";\nvar Uring = \"Ů\";\nvar uring = \"ů\";\nvar urtri = \"◹\";\nvar Uscr = \"𝒰\";\nvar uscr = \"𝓊\";\nvar utdot = \"⋰\";\nvar Utilde = \"Ũ\";\nvar utilde = \"ũ\";\nvar utri = \"▵\";\nvar utrif = \"▴\";\nvar uuarr = \"⇈\";\nvar Uuml$1 = \"Ü\";\nvar uuml$1 = \"ü\";\nvar uwangle = \"⦧\";\nvar vangrt = \"⦜\";\nvar varepsilon = \"ϵ\";\nvar varkappa = \"ϰ\";\nvar varnothing = \"∅\";\nvar varphi = \"ϕ\";\nvar varpi = \"ϖ\";\nvar varpropto = \"∝\";\nvar varr = \"↕\";\nvar vArr = \"⇕\";\nvar varrho = \"ϱ\";\nvar varsigma = \"ς\";\nvar varsubsetneq = \"⊊︀\";\nvar varsubsetneqq = \"⫋︀\";\nvar varsupsetneq = \"⊋︀\";\nvar varsupsetneqq = \"⫌︀\";\nvar vartheta = \"ϑ\";\nvar vartriangleleft = \"⊲\";\nvar vartriangleright = \"⊳\";\nvar vBar = \"⫨\";\nvar Vbar = \"⫫\";\nvar vBarv = \"⫩\";\nvar Vcy = \"В\";\nvar vcy = \"в\";\nvar vdash = \"⊢\";\nvar vDash = \"⊨\";\nvar Vdash = \"⊩\";\nvar VDash = \"⊫\";\nvar Vdashl = \"⫦\";\nvar veebar = \"⊻\";\nvar vee = \"∨\";\nvar Vee = \"⋁\";\nvar veeeq = \"≚\";\nvar vellip = \"⋮\";\nvar verbar = \"|\";\nvar Verbar = \"‖\";\nvar vert = \"|\";\nvar Vert = \"‖\";\nvar VerticalBar = \"∣\";\nvar VerticalLine = \"|\";\nvar VerticalSeparator = \"❘\";\nvar VerticalTilde = \"≀\";\nvar VeryThinSpace = \" \";\nvar Vfr = \"𝔙\";\nvar vfr = \"𝔳\";\nvar vltri = \"⊲\";\nvar vnsub = \"⊂⃒\";\nvar vnsup = \"⊃⃒\";\nvar Vopf = \"𝕍\";\nvar vopf = \"𝕧\";\nvar vprop = \"∝\";\nvar vrtri = \"⊳\";\nvar Vscr = \"𝒱\";\nvar vscr = \"𝓋\";\nvar vsubnE = \"⫋︀\";\nvar vsubne = \"⊊︀\";\nvar vsupnE = \"⫌︀\";\nvar vsupne = \"⊋︀\";\nvar Vvdash = \"⊪\";\nvar vzigzag = \"⦚\";\nvar Wcirc = \"Ŵ\";\nvar wcirc = \"ŵ\";\nvar wedbar = \"⩟\";\nvar wedge = \"∧\";\nvar Wedge = \"⋀\";\nvar wedgeq = \"≙\";\nvar weierp = \"℘\";\nvar Wfr = \"𝔚\";\nvar wfr = \"𝔴\";\nvar Wopf = \"𝕎\";\nvar wopf = \"𝕨\";\nvar wp = \"℘\";\nvar wr = \"≀\";\nvar wreath = \"≀\";\nvar Wscr = \"𝒲\";\nvar wscr = \"𝓌\";\nvar xcap = \"⋂\";\nvar xcirc = \"◯\";\nvar xcup = \"⋃\";\nvar xdtri = \"▽\";\nvar Xfr = \"𝔛\";\nvar xfr = \"𝔵\";\nvar xharr = \"⟷\";\nvar xhArr = \"⟺\";\nvar Xi = \"Ξ\";\nvar xi = \"ξ\";\nvar xlarr = \"⟵\";\nvar xlArr = \"⟸\";\nvar xmap = \"⟼\";\nvar xnis = \"⋻\";\nvar xodot = \"⨀\";\nvar Xopf = \"𝕏\";\nvar xopf = \"𝕩\";\nvar xoplus = \"⨁\";\nvar xotime = \"⨂\";\nvar xrarr = \"⟶\";\nvar xrArr = \"⟹\";\nvar Xscr = \"𝒳\";\nvar xscr = \"𝓍\";\nvar xsqcup = \"⨆\";\nvar xuplus = \"⨄\";\nvar xutri = \"△\";\nvar xvee = \"⋁\";\nvar xwedge = \"⋀\";\nvar Yacute$1 = \"Ý\";\nvar yacute$1 = \"ý\";\nvar YAcy = \"Я\";\nvar yacy = \"я\";\nvar Ycirc = \"Ŷ\";\nvar ycirc = \"ŷ\";\nvar Ycy = \"Ы\";\nvar ycy = \"ы\";\nvar yen$1 = \"¥\";\nvar Yfr = \"𝔜\";\nvar yfr = \"𝔶\";\nvar YIcy = \"Ї\";\nvar yicy = \"ї\";\nvar Yopf = \"𝕐\";\nvar yopf = \"𝕪\";\nvar Yscr = \"𝒴\";\nvar yscr = \"𝓎\";\nvar YUcy = \"Ю\";\nvar yucy = \"ю\";\nvar yuml$1 = \"ÿ\";\nvar Yuml = \"Ÿ\";\nvar Zacute = \"Ź\";\nvar zacute = \"ź\";\nvar Zcaron = \"Ž\";\nvar zcaron = \"ž\";\nvar Zcy = \"З\";\nvar zcy = \"з\";\nvar Zdot = \"Ż\";\nvar zdot = \"ż\";\nvar zeetrf = \"ℨ\";\nvar ZeroWidthSpace = \"​\";\nvar Zeta = \"Ζ\";\nvar zeta = \"ζ\";\nvar zfr = \"𝔷\";\nvar Zfr = \"ℨ\";\nvar ZHcy = \"Ж\";\nvar zhcy = \"ж\";\nvar zigrarr = \"⇝\";\nvar zopf = \"𝕫\";\nvar Zopf = \"ℤ\";\nvar Zscr = \"𝒵\";\nvar zscr = \"𝓏\";\nvar zwj = \"‍\";\nvar zwnj = \"‌\";\nvar require$$1$1 = {\n    Aacute: Aacute$1,\n    aacute: aacute$1,\n    Abreve: Abreve,\n    abreve: abreve,\n    ac: ac,\n    acd: acd,\n    acE: acE,\n    Acirc: Acirc$1,\n    acirc: acirc$1,\n    acute: acute$1,\n    Acy: Acy,\n    acy: acy,\n    AElig: AElig$1,\n    aelig: aelig$1,\n    af: af,\n    Afr: Afr,\n    afr: afr,\n    Agrave: Agrave$1,\n    agrave: agrave$1,\n    alefsym: alefsym,\n    aleph: aleph,\n    Alpha: Alpha,\n    alpha: alpha,\n    Amacr: Amacr,\n    amacr: amacr,\n    amalg: amalg,\n    amp: amp$2,\n    AMP: AMP$1,\n    andand: andand,\n    And: And,\n    and: and,\n    andd: andd,\n    andslope: andslope,\n    andv: andv,\n    ang: ang,\n    ange: ange,\n    angle: angle,\n    angmsdaa: angmsdaa,\n    angmsdab: angmsdab,\n    angmsdac: angmsdac,\n    angmsdad: angmsdad,\n    angmsdae: angmsdae,\n    angmsdaf: angmsdaf,\n    angmsdag: angmsdag,\n    angmsdah: angmsdah,\n    angmsd: angmsd,\n    angrt: angrt,\n    angrtvb: angrtvb,\n    angrtvbd: angrtvbd,\n    angsph: angsph,\n    angst: angst,\n    angzarr: angzarr,\n    Aogon: Aogon,\n    aogon: aogon,\n    Aopf: Aopf,\n    aopf: aopf,\n    apacir: apacir,\n    ap: ap,\n    apE: apE,\n    ape: ape,\n    apid: apid,\n    apos: apos$1,\n    ApplyFunction: ApplyFunction,\n    approx: approx,\n    approxeq: approxeq,\n    Aring: Aring$1,\n    aring: aring$1,\n    Ascr: Ascr,\n    ascr: ascr,\n    Assign: Assign,\n    ast: ast,\n    asymp: asymp,\n    asympeq: asympeq,\n    Atilde: Atilde$1,\n    atilde: atilde$1,\n    Auml: Auml$1,\n    auml: auml$1,\n    awconint: awconint,\n    awint: awint,\n    backcong: backcong,\n    backepsilon: backepsilon,\n    backprime: backprime,\n    backsim: backsim,\n    backsimeq: backsimeq,\n    Backslash: Backslash,\n    Barv: Barv,\n    barvee: barvee,\n    barwed: barwed,\n    Barwed: Barwed,\n    barwedge: barwedge,\n    bbrk: bbrk,\n    bbrktbrk: bbrktbrk,\n    bcong: bcong,\n    Bcy: Bcy,\n    bcy: bcy,\n    bdquo: bdquo,\n    becaus: becaus,\n    because: because,\n    Because: Because,\n    bemptyv: bemptyv,\n    bepsi: bepsi,\n    bernou: bernou,\n    Bernoullis: Bernoullis,\n    Beta: Beta,\n    beta: beta,\n    beth: beth,\n    between: between,\n    Bfr: Bfr,\n    bfr: bfr,\n    bigcap: bigcap,\n    bigcirc: bigcirc,\n    bigcup: bigcup,\n    bigodot: bigodot,\n    bigoplus: bigoplus,\n    bigotimes: bigotimes,\n    bigsqcup: bigsqcup,\n    bigstar: bigstar,\n    bigtriangledown: bigtriangledown,\n    bigtriangleup: bigtriangleup,\n    biguplus: biguplus,\n    bigvee: bigvee,\n    bigwedge: bigwedge,\n    bkarow: bkarow,\n    blacklozenge: blacklozenge,\n    blacksquare: blacksquare,\n    blacktriangle: blacktriangle,\n    blacktriangledown: blacktriangledown,\n    blacktriangleleft: blacktriangleleft,\n    blacktriangleright: blacktriangleright,\n    blank: blank,\n    blk12: blk12,\n    blk14: blk14,\n    blk34: blk34,\n    block: block,\n    bne: bne,\n    bnequiv: bnequiv,\n    bNot: bNot,\n    bnot: bnot,\n    Bopf: Bopf,\n    bopf: bopf,\n    bot: bot,\n    bottom: bottom,\n    bowtie: bowtie,\n    boxbox: boxbox,\n    boxdl: boxdl,\n    boxdL: boxdL,\n    boxDl: boxDl,\n    boxDL: boxDL,\n    boxdr: boxdr,\n    boxdR: boxdR,\n    boxDr: boxDr,\n    boxDR: boxDR,\n    boxh: boxh,\n    boxH: boxH,\n    boxhd: boxhd,\n    boxHd: boxHd,\n    boxhD: boxhD,\n    boxHD: boxHD,\n    boxhu: boxhu,\n    boxHu: boxHu,\n    boxhU: boxhU,\n    boxHU: boxHU,\n    boxminus: boxminus,\n    boxplus: boxplus,\n    boxtimes: boxtimes,\n    boxul: boxul,\n    boxuL: boxuL,\n    boxUl: boxUl,\n    boxUL: boxUL,\n    boxur: boxur,\n    boxuR: boxuR,\n    boxUr: boxUr,\n    boxUR: boxUR,\n    boxv: boxv,\n    boxV: boxV,\n    boxvh: boxvh,\n    boxvH: boxvH,\n    boxVh: boxVh,\n    boxVH: boxVH,\n    boxvl: boxvl,\n    boxvL: boxvL,\n    boxVl: boxVl,\n    boxVL: boxVL,\n    boxvr: boxvr,\n    boxvR: boxvR,\n    boxVr: boxVr,\n    boxVR: boxVR,\n    bprime: bprime,\n    breve: breve,\n    Breve: Breve,\n    brvbar: brvbar$1,\n    bscr: bscr,\n    Bscr: Bscr,\n    bsemi: bsemi,\n    bsim: bsim,\n    bsime: bsime,\n    bsolb: bsolb,\n    bsol: bsol,\n    bsolhsub: bsolhsub,\n    bull: bull,\n    bullet: bullet,\n    bump: bump,\n    bumpE: bumpE,\n    bumpe: bumpe,\n    Bumpeq: Bumpeq,\n    bumpeq: bumpeq,\n    Cacute: Cacute,\n    cacute: cacute,\n    capand: capand,\n    capbrcup: capbrcup,\n    capcap: capcap,\n    cap: cap,\n    Cap: Cap,\n    capcup: capcup,\n    capdot: capdot,\n    CapitalDifferentialD: CapitalDifferentialD,\n    caps: caps,\n    caret: caret,\n    caron: caron,\n    Cayleys: Cayleys,\n    ccaps: ccaps,\n    Ccaron: Ccaron,\n    ccaron: ccaron,\n    Ccedil: Ccedil$1,\n    ccedil: ccedil$1,\n    Ccirc: Ccirc,\n    ccirc: ccirc,\n    Cconint: Cconint,\n    ccups: ccups,\n    ccupssm: ccupssm,\n    Cdot: Cdot,\n    cdot: cdot,\n    cedil: cedil$1,\n    Cedilla: Cedilla,\n    cemptyv: cemptyv,\n    cent: cent$1,\n    centerdot: centerdot,\n    CenterDot: CenterDot,\n    cfr: cfr,\n    Cfr: Cfr,\n    CHcy: CHcy,\n    chcy: chcy,\n    check: check,\n    checkmark: checkmark,\n    Chi: Chi,\n    chi: chi,\n    circ: circ,\n    circeq: circeq,\n    circlearrowleft: circlearrowleft,\n    circlearrowright: circlearrowright,\n    circledast: circledast,\n    circledcirc: circledcirc,\n    circleddash: circleddash,\n    CircleDot: CircleDot,\n    circledR: circledR,\n    circledS: circledS,\n    CircleMinus: CircleMinus,\n    CirclePlus: CirclePlus,\n    CircleTimes: CircleTimes,\n    cir: cir,\n    cirE: cirE,\n    cire: cire,\n    cirfnint: cirfnint,\n    cirmid: cirmid,\n    cirscir: cirscir,\n    ClockwiseContourIntegral: ClockwiseContourIntegral,\n    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,\n    CloseCurlyQuote: CloseCurlyQuote,\n    clubs: clubs,\n    clubsuit: clubsuit,\n    colon: colon,\n    Colon: Colon,\n    Colone: Colone,\n    colone: colone,\n    coloneq: coloneq,\n    comma: comma,\n    commat: commat,\n    comp: comp,\n    compfn: compfn,\n    complement: complement,\n    complexes: complexes,\n    cong: cong,\n    congdot: congdot,\n    Congruent: Congruent,\n    conint: conint,\n    Conint: Conint,\n    ContourIntegral: ContourIntegral,\n    copf: copf,\n    Copf: Copf,\n    coprod: coprod,\n    Coproduct: Coproduct,\n    copy: copy$1,\n    COPY: COPY$1,\n    copysr: copysr,\n    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,\n    crarr: crarr,\n    cross: cross,\n    Cross: Cross,\n    Cscr: Cscr,\n    cscr: cscr,\n    csub: csub,\n    csube: csube,\n    csup: csup,\n    csupe: csupe,\n    ctdot: ctdot,\n    cudarrl: cudarrl,\n    cudarrr: cudarrr,\n    cuepr: cuepr,\n    cuesc: cuesc,\n    cularr: cularr,\n    cularrp: cularrp,\n    cupbrcap: cupbrcap,\n    cupcap: cupcap,\n    CupCap: CupCap,\n    cup: cup,\n    Cup: Cup,\n    cupcup: cupcup,\n    cupdot: cupdot,\n    cupor: cupor,\n    cups: cups,\n    curarr: curarr,\n    curarrm: curarrm,\n    curlyeqprec: curlyeqprec,\n    curlyeqsucc: curlyeqsucc,\n    curlyvee: curlyvee,\n    curlywedge: curlywedge,\n    curren: curren$1,\n    curvearrowleft: curvearrowleft,\n    curvearrowright: curvearrowright,\n    cuvee: cuvee,\n    cuwed: cuwed,\n    cwconint: cwconint,\n    cwint: cwint,\n    cylcty: cylcty,\n    dagger: dagger,\n    Dagger: Dagger,\n    daleth: daleth,\n    darr: darr,\n    Darr: Darr,\n    dArr: dArr,\n    dash: dash,\n    Dashv: Dashv,\n    dashv: dashv,\n    dbkarow: dbkarow,\n    dblac: dblac,\n    Dcaron: Dcaron,\n    dcaron: dcaron,\n    Dcy: Dcy,\n    dcy: dcy,\n    ddagger: ddagger,\n    ddarr: ddarr,\n    DD: DD,\n    dd: dd,\n    DDotrahd: DDotrahd,\n    ddotseq: ddotseq,\n    deg: deg$1,\n    Del: Del,\n    Delta: Delta,\n    delta: delta,\n    demptyv: demptyv,\n    dfisht: dfisht,\n    Dfr: Dfr,\n    dfr: dfr,\n    dHar: dHar,\n    dharl: dharl,\n    dharr: dharr,\n    DiacriticalAcute: DiacriticalAcute,\n    DiacriticalDot: DiacriticalDot,\n    DiacriticalDoubleAcute: DiacriticalDoubleAcute,\n    DiacriticalGrave: DiacriticalGrave,\n    DiacriticalTilde: DiacriticalTilde,\n    diam: diam,\n    diamond: diamond,\n    Diamond: Diamond,\n    diamondsuit: diamondsuit,\n    diams: diams,\n    die: die,\n    DifferentialD: DifferentialD,\n    digamma: digamma,\n    disin: disin,\n    div: div,\n    divide: divide$1,\n    divideontimes: divideontimes,\n    divonx: divonx,\n    DJcy: DJcy,\n    djcy: djcy,\n    dlcorn: dlcorn,\n    dlcrop: dlcrop,\n    dollar: dollar,\n    Dopf: Dopf,\n    dopf: dopf,\n    Dot: Dot,\n    dot: dot,\n    DotDot: DotDot,\n    doteq: doteq,\n    doteqdot: doteqdot,\n    DotEqual: DotEqual,\n    dotminus: dotminus,\n    dotplus: dotplus,\n    dotsquare: dotsquare,\n    doublebarwedge: doublebarwedge,\n    DoubleContourIntegral: DoubleContourIntegral,\n    DoubleDot: DoubleDot,\n    DoubleDownArrow: DoubleDownArrow,\n    DoubleLeftArrow: DoubleLeftArrow,\n    DoubleLeftRightArrow: DoubleLeftRightArrow,\n    DoubleLeftTee: DoubleLeftTee,\n    DoubleLongLeftArrow: DoubleLongLeftArrow,\n    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,\n    DoubleLongRightArrow: DoubleLongRightArrow,\n    DoubleRightArrow: DoubleRightArrow,\n    DoubleRightTee: DoubleRightTee,\n    DoubleUpArrow: DoubleUpArrow,\n    DoubleUpDownArrow: DoubleUpDownArrow,\n    DoubleVerticalBar: DoubleVerticalBar,\n    DownArrowBar: DownArrowBar,\n    downarrow: downarrow,\n    DownArrow: DownArrow,\n    Downarrow: Downarrow,\n    DownArrowUpArrow: DownArrowUpArrow,\n    DownBreve: DownBreve,\n    downdownarrows: downdownarrows,\n    downharpoonleft: downharpoonleft,\n    downharpoonright: downharpoonright,\n    DownLeftRightVector: DownLeftRightVector,\n    DownLeftTeeVector: DownLeftTeeVector,\n    DownLeftVectorBar: DownLeftVectorBar,\n    DownLeftVector: DownLeftVector,\n    DownRightTeeVector: DownRightTeeVector,\n    DownRightVectorBar: DownRightVectorBar,\n    DownRightVector: DownRightVector,\n    DownTeeArrow: DownTeeArrow,\n    DownTee: DownTee,\n    drbkarow: drbkarow,\n    drcorn: drcorn,\n    drcrop: drcrop,\n    Dscr: Dscr,\n    dscr: dscr,\n    DScy: DScy,\n    dscy: dscy,\n    dsol: dsol,\n    Dstrok: Dstrok,\n    dstrok: dstrok,\n    dtdot: dtdot,\n    dtri: dtri,\n    dtrif: dtrif,\n    duarr: duarr,\n    duhar: duhar,\n    dwangle: dwangle,\n    DZcy: DZcy,\n    dzcy: dzcy,\n    dzigrarr: dzigrarr,\n    Eacute: Eacute$1,\n    eacute: eacute$1,\n    easter: easter,\n    Ecaron: Ecaron,\n    ecaron: ecaron,\n    Ecirc: Ecirc$1,\n    ecirc: ecirc$1,\n    ecir: ecir,\n    ecolon: ecolon,\n    Ecy: Ecy,\n    ecy: ecy,\n    eDDot: eDDot,\n    Edot: Edot,\n    edot: edot,\n    eDot: eDot,\n    ee: ee,\n    efDot: efDot,\n    Efr: Efr,\n    efr: efr,\n    eg: eg,\n    Egrave: Egrave$1,\n    egrave: egrave$1,\n    egs: egs,\n    egsdot: egsdot,\n    el: el,\n    Element: Element,\n    elinters: elinters,\n    ell: ell,\n    els: els,\n    elsdot: elsdot,\n    Emacr: Emacr,\n    emacr: emacr,\n    empty: empty,\n    emptyset: emptyset,\n    EmptySmallSquare: EmptySmallSquare,\n    emptyv: emptyv,\n    EmptyVerySmallSquare: EmptyVerySmallSquare,\n    emsp13: emsp13,\n    emsp14: emsp14,\n    emsp: emsp,\n    ENG: ENG,\n    eng: eng,\n    ensp: ensp,\n    Eogon: Eogon,\n    eogon: eogon,\n    Eopf: Eopf,\n    eopf: eopf,\n    epar: epar,\n    eparsl: eparsl,\n    eplus: eplus,\n    epsi: epsi,\n    Epsilon: Epsilon,\n    epsilon: epsilon,\n    epsiv: epsiv,\n    eqcirc: eqcirc,\n    eqcolon: eqcolon,\n    eqsim: eqsim,\n    eqslantgtr: eqslantgtr,\n    eqslantless: eqslantless,\n    Equal: Equal,\n    equals: equals,\n    EqualTilde: EqualTilde,\n    equest: equest,\n    Equilibrium: Equilibrium,\n    equiv: equiv,\n    equivDD: equivDD,\n    eqvparsl: eqvparsl,\n    erarr: erarr,\n    erDot: erDot,\n    escr: escr,\n    Escr: Escr,\n    esdot: esdot,\n    Esim: Esim,\n    esim: esim,\n    Eta: Eta,\n    eta: eta,\n    ETH: ETH$1,\n    eth: eth$1,\n    Euml: Euml$1,\n    euml: euml$1,\n    euro: euro,\n    excl: excl,\n    exist: exist,\n    Exists: Exists,\n    expectation: expectation,\n    exponentiale: exponentiale,\n    ExponentialE: ExponentialE,\n    fallingdotseq: fallingdotseq,\n    Fcy: Fcy,\n    fcy: fcy,\n    female: female,\n    ffilig: ffilig,\n    fflig: fflig,\n    ffllig: ffllig,\n    Ffr: Ffr,\n    ffr: ffr,\n    filig: filig,\n    FilledSmallSquare: FilledSmallSquare,\n    FilledVerySmallSquare: FilledVerySmallSquare,\n    fjlig: fjlig,\n    flat: flat,\n    fllig: fllig,\n    fltns: fltns,\n    fnof: fnof,\n    Fopf: Fopf,\n    fopf: fopf,\n    forall: forall,\n    ForAll: ForAll,\n    fork: fork,\n    forkv: forkv,\n    Fouriertrf: Fouriertrf,\n    fpartint: fpartint,\n    frac12: frac12$1,\n    frac13: frac13,\n    frac14: frac14$1,\n    frac15: frac15,\n    frac16: frac16,\n    frac18: frac18,\n    frac23: frac23,\n    frac25: frac25,\n    frac34: frac34$1,\n    frac35: frac35,\n    frac38: frac38,\n    frac45: frac45,\n    frac56: frac56,\n    frac58: frac58,\n    frac78: frac78,\n    frasl: frasl,\n    frown: frown,\n    fscr: fscr,\n    Fscr: Fscr,\n    gacute: gacute,\n    Gamma: Gamma,\n    gamma: gamma,\n    Gammad: Gammad,\n    gammad: gammad,\n    gap: gap,\n    Gbreve: Gbreve,\n    gbreve: gbreve,\n    Gcedil: Gcedil,\n    Gcirc: Gcirc,\n    gcirc: gcirc,\n    Gcy: Gcy,\n    gcy: gcy,\n    Gdot: Gdot,\n    gdot: gdot,\n    ge: ge,\n    gE: gE,\n    gEl: gEl,\n    gel: gel,\n    geq: geq,\n    geqq: geqq,\n    geqslant: geqslant,\n    gescc: gescc,\n    ges: ges,\n    gesdot: gesdot,\n    gesdoto: gesdoto,\n    gesdotol: gesdotol,\n    gesl: gesl,\n    gesles: gesles,\n    Gfr: Gfr,\n    gfr: gfr,\n    gg: gg,\n    Gg: Gg,\n    ggg: ggg,\n    gimel: gimel,\n    GJcy: GJcy,\n    gjcy: gjcy,\n    gla: gla,\n    gl: gl,\n    glE: glE,\n    glj: glj,\n    gnap: gnap,\n    gnapprox: gnapprox,\n    gne: gne,\n    gnE: gnE,\n    gneq: gneq,\n    gneqq: gneqq,\n    gnsim: gnsim,\n    Gopf: Gopf,\n    gopf: gopf,\n    grave: grave,\n    GreaterEqual: GreaterEqual,\n    GreaterEqualLess: GreaterEqualLess,\n    GreaterFullEqual: GreaterFullEqual,\n    GreaterGreater: GreaterGreater,\n    GreaterLess: GreaterLess,\n    GreaterSlantEqual: GreaterSlantEqual,\n    GreaterTilde: GreaterTilde,\n    Gscr: Gscr,\n    gscr: gscr,\n    gsim: gsim,\n    gsime: gsime,\n    gsiml: gsiml,\n    gtcc: gtcc,\n    gtcir: gtcir,\n    gt: gt$2,\n    GT: GT$1,\n    Gt: Gt,\n    gtdot: gtdot,\n    gtlPar: gtlPar,\n    gtquest: gtquest,\n    gtrapprox: gtrapprox,\n    gtrarr: gtrarr,\n    gtrdot: gtrdot,\n    gtreqless: gtreqless,\n    gtreqqless: gtreqqless,\n    gtrless: gtrless,\n    gtrsim: gtrsim,\n    gvertneqq: gvertneqq,\n    gvnE: gvnE,\n    Hacek: Hacek,\n    hairsp: hairsp,\n    half: half,\n    hamilt: hamilt,\n    HARDcy: HARDcy,\n    hardcy: hardcy,\n    harrcir: harrcir,\n    harr: harr,\n    hArr: hArr,\n    harrw: harrw,\n    Hat: Hat,\n    hbar: hbar,\n    Hcirc: Hcirc,\n    hcirc: hcirc,\n    hearts: hearts,\n    heartsuit: heartsuit,\n    hellip: hellip,\n    hercon: hercon,\n    hfr: hfr,\n    Hfr: Hfr,\n    HilbertSpace: HilbertSpace,\n    hksearow: hksearow,\n    hkswarow: hkswarow,\n    hoarr: hoarr,\n    homtht: homtht,\n    hookleftarrow: hookleftarrow,\n    hookrightarrow: hookrightarrow,\n    hopf: hopf,\n    Hopf: Hopf,\n    horbar: horbar,\n    HorizontalLine: HorizontalLine,\n    hscr: hscr,\n    Hscr: Hscr,\n    hslash: hslash,\n    Hstrok: Hstrok,\n    hstrok: hstrok,\n    HumpDownHump: HumpDownHump,\n    HumpEqual: HumpEqual,\n    hybull: hybull,\n    hyphen: hyphen,\n    Iacute: Iacute$1,\n    iacute: iacute$1,\n    ic: ic,\n    Icirc: Icirc$1,\n    icirc: icirc$1,\n    Icy: Icy,\n    icy: icy,\n    Idot: Idot,\n    IEcy: IEcy,\n    iecy: iecy,\n    iexcl: iexcl$1,\n    iff: iff,\n    ifr: ifr,\n    Ifr: Ifr,\n    Igrave: Igrave$1,\n    igrave: igrave$1,\n    ii: ii,\n    iiiint: iiiint,\n    iiint: iiint,\n    iinfin: iinfin,\n    iiota: iiota,\n    IJlig: IJlig,\n    ijlig: ijlig,\n    Imacr: Imacr,\n    imacr: imacr,\n    image: esm_image,\n    ImaginaryI: ImaginaryI,\n    imagline: imagline,\n    imagpart: imagpart,\n    imath: imath,\n    Im: Im,\n    imof: imof,\n    imped: imped,\n    Implies: Implies,\n    incare: incare,\n    \"in\": \"∈\",\n    infin: infin,\n    infintie: infintie,\n    inodot: inodot,\n    intcal: intcal,\n    int: esm_int,\n    Int: Int,\n    integers: integers,\n    Integral: Integral,\n    intercal: intercal,\n    Intersection: Intersection,\n    intlarhk: intlarhk,\n    intprod: intprod,\n    InvisibleComma: InvisibleComma,\n    InvisibleTimes: InvisibleTimes,\n    IOcy: IOcy,\n    iocy: iocy,\n    Iogon: Iogon,\n    iogon: iogon,\n    Iopf: Iopf,\n    iopf: iopf,\n    Iota: Iota,\n    iota: iota,\n    iprod: iprod,\n    iquest: iquest$1,\n    iscr: iscr,\n    Iscr: Iscr,\n    isin: isin,\n    isindot: isindot,\n    isinE: isinE,\n    isins: isins,\n    isinsv: isinsv,\n    isinv: isinv,\n    it: it,\n    Itilde: Itilde,\n    itilde: itilde,\n    Iukcy: Iukcy,\n    iukcy: iukcy,\n    Iuml: Iuml$1,\n    iuml: iuml$1,\n    Jcirc: Jcirc,\n    jcirc: jcirc,\n    Jcy: Jcy,\n    jcy: jcy,\n    Jfr: Jfr,\n    jfr: jfr,\n    jmath: jmath,\n    Jopf: Jopf,\n    jopf: jopf,\n    Jscr: Jscr,\n    jscr: jscr,\n    Jsercy: Jsercy,\n    jsercy: jsercy,\n    Jukcy: Jukcy,\n    jukcy: jukcy,\n    Kappa: Kappa,\n    kappa: kappa,\n    kappav: kappav,\n    Kcedil: Kcedil,\n    kcedil: kcedil,\n    Kcy: Kcy,\n    kcy: kcy,\n    Kfr: Kfr,\n    kfr: kfr,\n    kgreen: kgreen,\n    KHcy: KHcy,\n    khcy: khcy,\n    KJcy: KJcy,\n    kjcy: kjcy,\n    Kopf: Kopf,\n    kopf: kopf,\n    Kscr: Kscr,\n    kscr: kscr,\n    lAarr: lAarr,\n    Lacute: Lacute,\n    lacute: lacute,\n    laemptyv: laemptyv,\n    lagran: lagran,\n    Lambda: Lambda,\n    lambda: lambda,\n    lang: lang,\n    Lang: Lang,\n    langd: langd,\n    langle: langle,\n    lap: lap,\n    Laplacetrf: Laplacetrf,\n    laquo: laquo$1,\n    larrb: larrb,\n    larrbfs: larrbfs,\n    larr: larr,\n    Larr: Larr,\n    lArr: lArr,\n    larrfs: larrfs,\n    larrhk: larrhk,\n    larrlp: larrlp,\n    larrpl: larrpl,\n    larrsim: larrsim,\n    larrtl: larrtl,\n    latail: latail,\n    lAtail: lAtail,\n    lat: lat,\n    late: late,\n    lates: lates,\n    lbarr: lbarr,\n    lBarr: lBarr,\n    lbbrk: lbbrk,\n    lbrace: lbrace,\n    lbrack: lbrack,\n    lbrke: lbrke,\n    lbrksld: lbrksld,\n    lbrkslu: lbrkslu,\n    Lcaron: Lcaron,\n    lcaron: lcaron,\n    Lcedil: Lcedil,\n    lcedil: lcedil,\n    lceil: lceil,\n    lcub: lcub,\n    Lcy: Lcy,\n    lcy: lcy,\n    ldca: ldca,\n    ldquo: ldquo,\n    ldquor: ldquor,\n    ldrdhar: ldrdhar,\n    ldrushar: ldrushar,\n    ldsh: ldsh,\n    le: le,\n    lE: lE,\n    LeftAngleBracket: LeftAngleBracket,\n    LeftArrowBar: LeftArrowBar,\n    leftarrow: leftarrow,\n    LeftArrow: LeftArrow,\n    Leftarrow: Leftarrow,\n    LeftArrowRightArrow: LeftArrowRightArrow,\n    leftarrowtail: leftarrowtail,\n    LeftCeiling: LeftCeiling,\n    LeftDoubleBracket: LeftDoubleBracket,\n    LeftDownTeeVector: LeftDownTeeVector,\n    LeftDownVectorBar: LeftDownVectorBar,\n    LeftDownVector: LeftDownVector,\n    LeftFloor: LeftFloor,\n    leftharpoondown: leftharpoondown,\n    leftharpoonup: leftharpoonup,\n    leftleftarrows: leftleftarrows,\n    leftrightarrow: leftrightarrow,\n    LeftRightArrow: LeftRightArrow,\n    Leftrightarrow: Leftrightarrow,\n    leftrightarrows: leftrightarrows,\n    leftrightharpoons: leftrightharpoons,\n    leftrightsquigarrow: leftrightsquigarrow,\n    LeftRightVector: LeftRightVector,\n    LeftTeeArrow: LeftTeeArrow,\n    LeftTee: LeftTee,\n    LeftTeeVector: LeftTeeVector,\n    leftthreetimes: leftthreetimes,\n    LeftTriangleBar: LeftTriangleBar,\n    LeftTriangle: LeftTriangle,\n    LeftTriangleEqual: LeftTriangleEqual,\n    LeftUpDownVector: LeftUpDownVector,\n    LeftUpTeeVector: LeftUpTeeVector,\n    LeftUpVectorBar: LeftUpVectorBar,\n    LeftUpVector: LeftUpVector,\n    LeftVectorBar: LeftVectorBar,\n    LeftVector: LeftVector,\n    lEg: lEg,\n    leg: leg,\n    leq: leq,\n    leqq: leqq,\n    leqslant: leqslant,\n    lescc: lescc,\n    les: les,\n    lesdot: lesdot,\n    lesdoto: lesdoto,\n    lesdotor: lesdotor,\n    lesg: lesg,\n    lesges: lesges,\n    lessapprox: lessapprox,\n    lessdot: lessdot,\n    lesseqgtr: lesseqgtr,\n    lesseqqgtr: lesseqqgtr,\n    LessEqualGreater: LessEqualGreater,\n    LessFullEqual: LessFullEqual,\n    LessGreater: LessGreater,\n    lessgtr: lessgtr,\n    LessLess: LessLess,\n    lesssim: lesssim,\n    LessSlantEqual: LessSlantEqual,\n    LessTilde: LessTilde,\n    lfisht: lfisht,\n    lfloor: lfloor,\n    Lfr: Lfr,\n    lfr: lfr,\n    lg: lg,\n    lgE: lgE,\n    lHar: lHar,\n    lhard: lhard,\n    lharu: lharu,\n    lharul: lharul,\n    lhblk: lhblk,\n    LJcy: LJcy,\n    ljcy: ljcy,\n    llarr: llarr,\n    ll: ll,\n    Ll: Ll,\n    llcorner: llcorner,\n    Lleftarrow: Lleftarrow,\n    llhard: llhard,\n    lltri: lltri,\n    Lmidot: Lmidot,\n    lmidot: lmidot,\n    lmoustache: lmoustache,\n    lmoust: lmoust,\n    lnap: lnap,\n    lnapprox: lnapprox,\n    lne: lne,\n    lnE: lnE,\n    lneq: lneq,\n    lneqq: lneqq,\n    lnsim: lnsim,\n    loang: loang,\n    loarr: loarr,\n    lobrk: lobrk,\n    longleftarrow: longleftarrow,\n    LongLeftArrow: LongLeftArrow,\n    Longleftarrow: Longleftarrow,\n    longleftrightarrow: longleftrightarrow,\n    LongLeftRightArrow: LongLeftRightArrow,\n    Longleftrightarrow: Longleftrightarrow,\n    longmapsto: longmapsto,\n    longrightarrow: longrightarrow,\n    LongRightArrow: LongRightArrow,\n    Longrightarrow: Longrightarrow,\n    looparrowleft: looparrowleft,\n    looparrowright: looparrowright,\n    lopar: lopar,\n    Lopf: Lopf,\n    lopf: lopf,\n    loplus: loplus,\n    lotimes: lotimes,\n    lowast: lowast,\n    lowbar: lowbar,\n    LowerLeftArrow: LowerLeftArrow,\n    LowerRightArrow: LowerRightArrow,\n    loz: loz,\n    lozenge: lozenge,\n    lozf: lozf,\n    lpar: lpar,\n    lparlt: lparlt,\n    lrarr: lrarr,\n    lrcorner: lrcorner,\n    lrhar: lrhar,\n    lrhard: lrhard,\n    lrm: lrm,\n    lrtri: lrtri,\n    lsaquo: lsaquo,\n    lscr: lscr,\n    Lscr: Lscr,\n    lsh: lsh,\n    Lsh: Lsh,\n    lsim: lsim,\n    lsime: lsime,\n    lsimg: lsimg,\n    lsqb: lsqb,\n    lsquo: lsquo,\n    lsquor: lsquor,\n    Lstrok: Lstrok,\n    lstrok: lstrok,\n    ltcc: ltcc,\n    ltcir: ltcir,\n    lt: lt$2,\n    LT: LT$1,\n    Lt: Lt,\n    ltdot: ltdot,\n    lthree: lthree,\n    ltimes: ltimes,\n    ltlarr: ltlarr,\n    ltquest: ltquest,\n    ltri: ltri,\n    ltrie: ltrie,\n    ltrif: ltrif,\n    ltrPar: ltrPar,\n    lurdshar: lurdshar,\n    luruhar: luruhar,\n    lvertneqq: lvertneqq,\n    lvnE: lvnE,\n    macr: macr$1,\n    male: male,\n    malt: malt,\n    maltese: maltese,\n    \"Map\": \"⤅\",\n    map: map,\n    mapsto: mapsto,\n    mapstodown: mapstodown,\n    mapstoleft: mapstoleft,\n    mapstoup: mapstoup,\n    marker: marker,\n    mcomma: mcomma,\n    Mcy: Mcy,\n    mcy: mcy,\n    mdash: mdash,\n    mDDot: mDDot,\n    measuredangle: measuredangle,\n    MediumSpace: MediumSpace,\n    Mellintrf: Mellintrf,\n    Mfr: Mfr,\n    mfr: mfr,\n    mho: mho,\n    micro: micro$1,\n    midast: midast,\n    midcir: midcir,\n    mid: mid,\n    middot: middot$1,\n    minusb: minusb,\n    minus: minus,\n    minusd: minusd,\n    minusdu: minusdu,\n    MinusPlus: MinusPlus,\n    mlcp: mlcp,\n    mldr: mldr,\n    mnplus: mnplus,\n    models: models,\n    Mopf: Mopf,\n    mopf: mopf,\n    mp: mp,\n    mscr: mscr,\n    Mscr: Mscr,\n    mstpos: mstpos,\n    Mu: Mu,\n    mu: mu,\n    multimap: multimap,\n    mumap: mumap,\n    nabla: nabla,\n    Nacute: Nacute,\n    nacute: nacute,\n    nang: nang,\n    nap: nap,\n    napE: napE,\n    napid: napid,\n    napos: napos,\n    napprox: napprox,\n    natural: natural,\n    naturals: naturals,\n    natur: natur,\n    nbsp: nbsp$1,\n    nbump: nbump,\n    nbumpe: nbumpe,\n    ncap: ncap,\n    Ncaron: Ncaron,\n    ncaron: ncaron,\n    Ncedil: Ncedil,\n    ncedil: ncedil,\n    ncong: ncong,\n    ncongdot: ncongdot,\n    ncup: ncup,\n    Ncy: Ncy,\n    ncy: ncy,\n    ndash: ndash,\n    nearhk: nearhk,\n    nearr: nearr,\n    neArr: neArr,\n    nearrow: nearrow,\n    ne: ne,\n    nedot: nedot,\n    NegativeMediumSpace: NegativeMediumSpace,\n    NegativeThickSpace: NegativeThickSpace,\n    NegativeThinSpace: NegativeThinSpace,\n    NegativeVeryThinSpace: NegativeVeryThinSpace,\n    nequiv: nequiv,\n    nesear: nesear,\n    nesim: nesim,\n    NestedGreaterGreater: NestedGreaterGreater,\n    NestedLessLess: NestedLessLess,\n    NewLine: NewLine,\n    nexist: nexist,\n    nexists: nexists,\n    Nfr: Nfr,\n    nfr: nfr,\n    ngE: ngE,\n    nge: nge,\n    ngeq: ngeq,\n    ngeqq: ngeqq,\n    ngeqslant: ngeqslant,\n    nges: nges,\n    nGg: nGg,\n    ngsim: ngsim,\n    nGt: nGt,\n    ngt: ngt,\n    ngtr: ngtr,\n    nGtv: nGtv,\n    nharr: nharr,\n    nhArr: nhArr,\n    nhpar: nhpar,\n    ni: ni,\n    nis: nis,\n    nisd: nisd,\n    niv: niv,\n    NJcy: NJcy,\n    njcy: njcy,\n    nlarr: nlarr,\n    nlArr: nlArr,\n    nldr: nldr,\n    nlE: nlE,\n    nle: nle,\n    nleftarrow: nleftarrow,\n    nLeftarrow: nLeftarrow,\n    nleftrightarrow: nleftrightarrow,\n    nLeftrightarrow: nLeftrightarrow,\n    nleq: nleq,\n    nleqq: nleqq,\n    nleqslant: nleqslant,\n    nles: nles,\n    nless: nless,\n    nLl: nLl,\n    nlsim: nlsim,\n    nLt: nLt,\n    nlt: nlt,\n    nltri: nltri,\n    nltrie: nltrie,\n    nLtv: nLtv,\n    nmid: nmid,\n    NoBreak: NoBreak,\n    NonBreakingSpace: NonBreakingSpace,\n    nopf: nopf,\n    Nopf: Nopf,\n    Not: Not,\n    not: not$1,\n    NotCongruent: NotCongruent,\n    NotCupCap: NotCupCap,\n    NotDoubleVerticalBar: NotDoubleVerticalBar,\n    NotElement: NotElement,\n    NotEqual: NotEqual,\n    NotEqualTilde: NotEqualTilde,\n    NotExists: NotExists,\n    NotGreater: NotGreater,\n    NotGreaterEqual: NotGreaterEqual,\n    NotGreaterFullEqual: NotGreaterFullEqual,\n    NotGreaterGreater: NotGreaterGreater,\n    NotGreaterLess: NotGreaterLess,\n    NotGreaterSlantEqual: NotGreaterSlantEqual,\n    NotGreaterTilde: NotGreaterTilde,\n    NotHumpDownHump: NotHumpDownHump,\n    NotHumpEqual: NotHumpEqual,\n    notin: notin,\n    notindot: notindot,\n    notinE: notinE,\n    notinva: notinva,\n    notinvb: notinvb,\n    notinvc: notinvc,\n    NotLeftTriangleBar: NotLeftTriangleBar,\n    NotLeftTriangle: NotLeftTriangle,\n    NotLeftTriangleEqual: NotLeftTriangleEqual,\n    NotLess: NotLess,\n    NotLessEqual: NotLessEqual,\n    NotLessGreater: NotLessGreater,\n    NotLessLess: NotLessLess,\n    NotLessSlantEqual: NotLessSlantEqual,\n    NotLessTilde: NotLessTilde,\n    NotNestedGreaterGreater: NotNestedGreaterGreater,\n    NotNestedLessLess: NotNestedLessLess,\n    notni: notni,\n    notniva: notniva,\n    notnivb: notnivb,\n    notnivc: notnivc,\n    NotPrecedes: NotPrecedes,\n    NotPrecedesEqual: NotPrecedesEqual,\n    NotPrecedesSlantEqual: NotPrecedesSlantEqual,\n    NotReverseElement: NotReverseElement,\n    NotRightTriangleBar: NotRightTriangleBar,\n    NotRightTriangle: NotRightTriangle,\n    NotRightTriangleEqual: NotRightTriangleEqual,\n    NotSquareSubset: NotSquareSubset,\n    NotSquareSubsetEqual: NotSquareSubsetEqual,\n    NotSquareSuperset: NotSquareSuperset,\n    NotSquareSupersetEqual: NotSquareSupersetEqual,\n    NotSubset: NotSubset,\n    NotSubsetEqual: NotSubsetEqual,\n    NotSucceeds: NotSucceeds,\n    NotSucceedsEqual: NotSucceedsEqual,\n    NotSucceedsSlantEqual: NotSucceedsSlantEqual,\n    NotSucceedsTilde: NotSucceedsTilde,\n    NotSuperset: NotSuperset,\n    NotSupersetEqual: NotSupersetEqual,\n    NotTilde: NotTilde,\n    NotTildeEqual: NotTildeEqual,\n    NotTildeFullEqual: NotTildeFullEqual,\n    NotTildeTilde: NotTildeTilde,\n    NotVerticalBar: NotVerticalBar,\n    nparallel: nparallel,\n    npar: npar,\n    nparsl: nparsl,\n    npart: npart,\n    npolint: npolint,\n    npr: npr,\n    nprcue: nprcue,\n    nprec: nprec,\n    npreceq: npreceq,\n    npre: npre,\n    nrarrc: nrarrc,\n    nrarr: nrarr,\n    nrArr: nrArr,\n    nrarrw: nrarrw,\n    nrightarrow: nrightarrow,\n    nRightarrow: nRightarrow,\n    nrtri: nrtri,\n    nrtrie: nrtrie,\n    nsc: nsc,\n    nsccue: nsccue,\n    nsce: nsce,\n    Nscr: Nscr,\n    nscr: nscr,\n    nshortmid: nshortmid,\n    nshortparallel: nshortparallel,\n    nsim: nsim,\n    nsime: nsime,\n    nsimeq: nsimeq,\n    nsmid: nsmid,\n    nspar: nspar,\n    nsqsube: nsqsube,\n    nsqsupe: nsqsupe,\n    nsub: nsub,\n    nsubE: nsubE,\n    nsube: nsube,\n    nsubset: nsubset,\n    nsubseteq: nsubseteq,\n    nsubseteqq: nsubseteqq,\n    nsucc: nsucc,\n    nsucceq: nsucceq,\n    nsup: nsup,\n    nsupE: nsupE,\n    nsupe: nsupe,\n    nsupset: nsupset,\n    nsupseteq: nsupseteq,\n    nsupseteqq: nsupseteqq,\n    ntgl: ntgl,\n    Ntilde: Ntilde$1,\n    ntilde: ntilde$1,\n    ntlg: ntlg,\n    ntriangleleft: ntriangleleft,\n    ntrianglelefteq: ntrianglelefteq,\n    ntriangleright: ntriangleright,\n    ntrianglerighteq: ntrianglerighteq,\n    Nu: Nu,\n    nu: nu,\n    num: num,\n    numero: numero,\n    numsp: numsp,\n    nvap: nvap,\n    nvdash: nvdash,\n    nvDash: nvDash,\n    nVdash: nVdash,\n    nVDash: nVDash,\n    nvge: nvge,\n    nvgt: nvgt,\n    nvHarr: nvHarr,\n    nvinfin: nvinfin,\n    nvlArr: nvlArr,\n    nvle: nvle,\n    nvlt: nvlt,\n    nvltrie: nvltrie,\n    nvrArr: nvrArr,\n    nvrtrie: nvrtrie,\n    nvsim: nvsim,\n    nwarhk: nwarhk,\n    nwarr: nwarr,\n    nwArr: nwArr,\n    nwarrow: nwarrow,\n    nwnear: nwnear,\n    Oacute: Oacute$1,\n    oacute: oacute$1,\n    oast: oast,\n    Ocirc: Ocirc$1,\n    ocirc: ocirc$1,\n    ocir: ocir,\n    Ocy: Ocy,\n    ocy: ocy,\n    odash: odash,\n    Odblac: Odblac,\n    odblac: odblac,\n    odiv: odiv,\n    odot: odot,\n    odsold: odsold,\n    OElig: OElig,\n    oelig: oelig,\n    ofcir: ofcir,\n    Ofr: Ofr,\n    ofr: ofr,\n    ogon: ogon,\n    Ograve: Ograve$1,\n    ograve: ograve$1,\n    ogt: ogt,\n    ohbar: ohbar,\n    ohm: ohm,\n    oint: oint,\n    olarr: olarr,\n    olcir: olcir,\n    olcross: olcross,\n    oline: oline,\n    olt: olt,\n    Omacr: Omacr,\n    omacr: omacr,\n    Omega: Omega,\n    omega: omega,\n    Omicron: Omicron,\n    omicron: omicron,\n    omid: omid,\n    ominus: ominus,\n    Oopf: Oopf,\n    oopf: oopf,\n    opar: opar,\n    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,\n    OpenCurlyQuote: OpenCurlyQuote,\n    operp: operp,\n    oplus: oplus,\n    orarr: orarr,\n    Or: Or,\n    or: or,\n    ord: ord,\n    order: order,\n    orderof: orderof,\n    ordf: ordf$1,\n    ordm: ordm$1,\n    origof: origof,\n    oror: oror,\n    orslope: orslope,\n    orv: orv,\n    oS: oS,\n    Oscr: Oscr,\n    oscr: oscr,\n    Oslash: Oslash$1,\n    oslash: oslash$1,\n    osol: osol,\n    Otilde: Otilde$1,\n    otilde: otilde$1,\n    otimesas: otimesas,\n    Otimes: Otimes,\n    otimes: otimes,\n    Ouml: Ouml$1,\n    ouml: ouml$1,\n    ovbar: ovbar,\n    OverBar: OverBar,\n    OverBrace: OverBrace,\n    OverBracket: OverBracket,\n    OverParenthesis: OverParenthesis,\n    para: para$1,\n    parallel: parallel,\n    par: par,\n    parsim: parsim,\n    parsl: parsl,\n    part: part,\n    PartialD: PartialD,\n    Pcy: Pcy,\n    pcy: pcy,\n    percnt: percnt,\n    period: period,\n    permil: permil,\n    perp: perp,\n    pertenk: pertenk,\n    Pfr: Pfr,\n    pfr: pfr,\n    Phi: Phi,\n    phi: phi,\n    phiv: phiv,\n    phmmat: phmmat,\n    phone: phone,\n    Pi: Pi,\n    pi: pi,\n    pitchfork: pitchfork,\n    piv: piv,\n    planck: planck,\n    planckh: planckh,\n    plankv: plankv,\n    plusacir: plusacir,\n    plusb: plusb,\n    pluscir: pluscir,\n    plus: plus,\n    plusdo: plusdo,\n    plusdu: plusdu,\n    pluse: pluse,\n    PlusMinus: PlusMinus,\n    plusmn: plusmn$1,\n    plussim: plussim,\n    plustwo: plustwo,\n    pm: pm,\n    Poincareplane: Poincareplane,\n    pointint: pointint,\n    popf: popf,\n    Popf: Popf,\n    pound: pound$1,\n    prap: prap,\n    Pr: Pr,\n    pr: pr,\n    prcue: prcue,\n    precapprox: precapprox,\n    prec: prec,\n    preccurlyeq: preccurlyeq,\n    Precedes: Precedes,\n    PrecedesEqual: PrecedesEqual,\n    PrecedesSlantEqual: PrecedesSlantEqual,\n    PrecedesTilde: PrecedesTilde,\n    preceq: preceq,\n    precnapprox: precnapprox,\n    precneqq: precneqq,\n    precnsim: precnsim,\n    pre: pre,\n    prE: prE,\n    precsim: precsim,\n    prime: prime,\n    Prime: Prime,\n    primes: primes,\n    prnap: prnap,\n    prnE: prnE,\n    prnsim: prnsim,\n    prod: prod,\n    Product: Product,\n    profalar: profalar,\n    profline: profline,\n    profsurf: profsurf,\n    prop: prop,\n    Proportional: Proportional,\n    Proportion: Proportion,\n    propto: propto,\n    prsim: prsim,\n    prurel: prurel,\n    Pscr: Pscr,\n    pscr: pscr,\n    Psi: Psi,\n    psi: psi,\n    puncsp: puncsp,\n    Qfr: Qfr,\n    qfr: qfr,\n    qint: qint,\n    qopf: qopf,\n    Qopf: Qopf,\n    qprime: qprime,\n    Qscr: Qscr,\n    qscr: qscr,\n    quaternions: quaternions,\n    quatint: quatint,\n    quest: quest,\n    questeq: questeq,\n    quot: quot$2,\n    QUOT: QUOT$1,\n    rAarr: rAarr,\n    race: race,\n    Racute: Racute,\n    racute: racute,\n    radic: radic,\n    raemptyv: raemptyv,\n    rang: rang,\n    Rang: Rang,\n    rangd: rangd,\n    range: range,\n    rangle: rangle,\n    raquo: raquo$1,\n    rarrap: rarrap,\n    rarrb: rarrb,\n    rarrbfs: rarrbfs,\n    rarrc: rarrc,\n    rarr: rarr,\n    Rarr: Rarr,\n    rArr: rArr,\n    rarrfs: rarrfs,\n    rarrhk: rarrhk,\n    rarrlp: rarrlp,\n    rarrpl: rarrpl,\n    rarrsim: rarrsim,\n    Rarrtl: Rarrtl,\n    rarrtl: rarrtl,\n    rarrw: rarrw,\n    ratail: ratail,\n    rAtail: rAtail,\n    ratio: ratio,\n    rationals: rationals,\n    rbarr: rbarr,\n    rBarr: rBarr,\n    RBarr: RBarr,\n    rbbrk: rbbrk,\n    rbrace: rbrace,\n    rbrack: rbrack,\n    rbrke: rbrke,\n    rbrksld: rbrksld,\n    rbrkslu: rbrkslu,\n    Rcaron: Rcaron,\n    rcaron: rcaron,\n    Rcedil: Rcedil,\n    rcedil: rcedil,\n    rceil: rceil,\n    rcub: rcub,\n    Rcy: Rcy,\n    rcy: rcy,\n    rdca: rdca,\n    rdldhar: rdldhar,\n    rdquo: rdquo,\n    rdquor: rdquor,\n    rdsh: rdsh,\n    real: real,\n    realine: realine,\n    realpart: realpart,\n    reals: reals,\n    Re: Re,\n    rect: rect,\n    reg: reg$1,\n    REG: REG$1,\n    ReverseElement: ReverseElement,\n    ReverseEquilibrium: ReverseEquilibrium,\n    ReverseUpEquilibrium: ReverseUpEquilibrium,\n    rfisht: rfisht,\n    rfloor: rfloor,\n    rfr: rfr,\n    Rfr: Rfr,\n    rHar: rHar,\n    rhard: rhard,\n    rharu: rharu,\n    rharul: rharul,\n    Rho: Rho,\n    rho: rho,\n    rhov: rhov,\n    RightAngleBracket: RightAngleBracket,\n    RightArrowBar: RightArrowBar,\n    rightarrow: rightarrow,\n    RightArrow: RightArrow,\n    Rightarrow: Rightarrow,\n    RightArrowLeftArrow: RightArrowLeftArrow,\n    rightarrowtail: rightarrowtail,\n    RightCeiling: RightCeiling,\n    RightDoubleBracket: RightDoubleBracket,\n    RightDownTeeVector: RightDownTeeVector,\n    RightDownVectorBar: RightDownVectorBar,\n    RightDownVector: RightDownVector,\n    RightFloor: RightFloor,\n    rightharpoondown: rightharpoondown,\n    rightharpoonup: rightharpoonup,\n    rightleftarrows: rightleftarrows,\n    rightleftharpoons: rightleftharpoons,\n    rightrightarrows: rightrightarrows,\n    rightsquigarrow: rightsquigarrow,\n    RightTeeArrow: RightTeeArrow,\n    RightTee: RightTee,\n    RightTeeVector: RightTeeVector,\n    rightthreetimes: rightthreetimes,\n    RightTriangleBar: RightTriangleBar,\n    RightTriangle: RightTriangle,\n    RightTriangleEqual: RightTriangleEqual,\n    RightUpDownVector: RightUpDownVector,\n    RightUpTeeVector: RightUpTeeVector,\n    RightUpVectorBar: RightUpVectorBar,\n    RightUpVector: RightUpVector,\n    RightVectorBar: RightVectorBar,\n    RightVector: RightVector,\n    ring: ring,\n    risingdotseq: risingdotseq,\n    rlarr: rlarr,\n    rlhar: rlhar,\n    rlm: rlm,\n    rmoustache: rmoustache,\n    rmoust: rmoust,\n    rnmid: rnmid,\n    roang: roang,\n    roarr: roarr,\n    robrk: robrk,\n    ropar: ropar,\n    ropf: ropf,\n    Ropf: Ropf,\n    roplus: roplus,\n    rotimes: rotimes,\n    RoundImplies: RoundImplies,\n    rpar: rpar,\n    rpargt: rpargt,\n    rppolint: rppolint,\n    rrarr: rrarr,\n    Rrightarrow: Rrightarrow,\n    rsaquo: rsaquo,\n    rscr: rscr,\n    Rscr: Rscr,\n    rsh: rsh,\n    Rsh: Rsh,\n    rsqb: rsqb,\n    rsquo: rsquo,\n    rsquor: rsquor,\n    rthree: rthree,\n    rtimes: rtimes,\n    rtri: rtri,\n    rtrie: rtrie,\n    rtrif: rtrif,\n    rtriltri: rtriltri,\n    RuleDelayed: RuleDelayed,\n    ruluhar: ruluhar,\n    rx: rx,\n    Sacute: Sacute,\n    sacute: sacute,\n    sbquo: sbquo,\n    scap: scap,\n    Scaron: Scaron,\n    scaron: scaron,\n    Sc: Sc,\n    sc: sc,\n    sccue: sccue,\n    sce: sce,\n    scE: scE,\n    Scedil: Scedil,\n    scedil: scedil,\n    Scirc: Scirc,\n    scirc: scirc,\n    scnap: scnap,\n    scnE: scnE,\n    scnsim: scnsim,\n    scpolint: scpolint,\n    scsim: scsim,\n    Scy: Scy,\n    scy: scy,\n    sdotb: sdotb,\n    sdot: sdot,\n    sdote: sdote,\n    searhk: searhk,\n    searr: searr,\n    seArr: seArr,\n    searrow: searrow,\n    sect: sect$1,\n    semi: semi,\n    seswar: seswar,\n    setminus: setminus,\n    setmn: setmn,\n    sext: sext,\n    Sfr: Sfr,\n    sfr: sfr,\n    sfrown: sfrown,\n    sharp: sharp,\n    SHCHcy: SHCHcy,\n    shchcy: shchcy,\n    SHcy: SHcy,\n    shcy: shcy,\n    ShortDownArrow: ShortDownArrow,\n    ShortLeftArrow: ShortLeftArrow,\n    shortmid: shortmid,\n    shortparallel: shortparallel,\n    ShortRightArrow: ShortRightArrow,\n    ShortUpArrow: ShortUpArrow,\n    shy: shy$1,\n    Sigma: Sigma,\n    sigma: sigma,\n    sigmaf: sigmaf,\n    sigmav: sigmav,\n    sim: sim,\n    simdot: simdot,\n    sime: sime,\n    simeq: simeq,\n    simg: simg,\n    simgE: simgE,\n    siml: siml,\n    simlE: simlE,\n    simne: simne,\n    simplus: simplus,\n    simrarr: simrarr,\n    slarr: slarr,\n    SmallCircle: SmallCircle,\n    smallsetminus: smallsetminus,\n    smashp: smashp,\n    smeparsl: smeparsl,\n    smid: smid,\n    smile: smile,\n    smt: smt,\n    smte: smte,\n    smtes: smtes,\n    SOFTcy: SOFTcy,\n    softcy: softcy,\n    solbar: solbar,\n    solb: solb,\n    sol: sol,\n    Sopf: Sopf,\n    sopf: sopf,\n    spades: spades,\n    spadesuit: spadesuit,\n    spar: spar,\n    sqcap: sqcap,\n    sqcaps: sqcaps,\n    sqcup: sqcup,\n    sqcups: sqcups,\n    Sqrt: Sqrt,\n    sqsub: sqsub,\n    sqsube: sqsube,\n    sqsubset: sqsubset,\n    sqsubseteq: sqsubseteq,\n    sqsup: sqsup,\n    sqsupe: sqsupe,\n    sqsupset: sqsupset,\n    sqsupseteq: sqsupseteq,\n    square: square,\n    Square: Square,\n    SquareIntersection: SquareIntersection,\n    SquareSubset: SquareSubset,\n    SquareSubsetEqual: SquareSubsetEqual,\n    SquareSuperset: SquareSuperset,\n    SquareSupersetEqual: SquareSupersetEqual,\n    SquareUnion: SquareUnion,\n    squarf: squarf,\n    squ: squ,\n    squf: squf,\n    srarr: srarr,\n    Sscr: Sscr,\n    sscr: sscr,\n    ssetmn: ssetmn,\n    ssmile: ssmile,\n    sstarf: sstarf,\n    Star: Star,\n    star: star,\n    starf: starf,\n    straightepsilon: straightepsilon,\n    straightphi: straightphi,\n    strns: strns,\n    sub: sub,\n    Sub: Sub,\n    subdot: subdot,\n    subE: subE,\n    sube: sube,\n    subedot: subedot,\n    submult: submult,\n    subnE: subnE,\n    subne: subne,\n    subplus: subplus,\n    subrarr: subrarr,\n    subset: subset,\n    Subset: Subset,\n    subseteq: subseteq,\n    subseteqq: subseteqq,\n    SubsetEqual: SubsetEqual,\n    subsetneq: subsetneq,\n    subsetneqq: subsetneqq,\n    subsim: subsim,\n    subsub: subsub,\n    subsup: subsup,\n    succapprox: succapprox,\n    succ: succ,\n    succcurlyeq: succcurlyeq,\n    Succeeds: Succeeds,\n    SucceedsEqual: SucceedsEqual,\n    SucceedsSlantEqual: SucceedsSlantEqual,\n    SucceedsTilde: SucceedsTilde,\n    succeq: succeq,\n    succnapprox: succnapprox,\n    succneqq: succneqq,\n    succnsim: succnsim,\n    succsim: succsim,\n    SuchThat: SuchThat,\n    sum: sum,\n    Sum: Sum,\n    sung: sung,\n    sup1: sup1$1,\n    sup2: sup2$1,\n    sup3: sup3$1,\n    sup: sup,\n    Sup: Sup,\n    supdot: supdot,\n    supdsub: supdsub,\n    supE: supE,\n    supe: supe,\n    supedot: supedot,\n    Superset: Superset,\n    SupersetEqual: SupersetEqual,\n    suphsol: suphsol,\n    suphsub: suphsub,\n    suplarr: suplarr,\n    supmult: supmult,\n    supnE: supnE,\n    supne: supne,\n    supplus: supplus,\n    supset: supset,\n    Supset: Supset,\n    supseteq: supseteq,\n    supseteqq: supseteqq,\n    supsetneq: supsetneq,\n    supsetneqq: supsetneqq,\n    supsim: supsim,\n    supsub: supsub,\n    supsup: supsup,\n    swarhk: swarhk,\n    swarr: swarr,\n    swArr: swArr,\n    swarrow: swarrow,\n    swnwar: swnwar,\n    szlig: szlig$1,\n    Tab: Tab,\n    target: target,\n    Tau: Tau,\n    tau: tau,\n    tbrk: tbrk,\n    Tcaron: Tcaron,\n    tcaron: tcaron,\n    Tcedil: Tcedil,\n    tcedil: tcedil,\n    Tcy: Tcy,\n    tcy: tcy,\n    tdot: tdot,\n    telrec: telrec,\n    Tfr: Tfr,\n    tfr: tfr,\n    there4: there4,\n    therefore: therefore,\n    Therefore: Therefore,\n    Theta: Theta,\n    theta: theta,\n    thetasym: thetasym,\n    thetav: thetav,\n    thickapprox: thickapprox,\n    thicksim: thicksim,\n    ThickSpace: ThickSpace,\n    ThinSpace: ThinSpace,\n    thinsp: thinsp,\n    thkap: thkap,\n    thksim: thksim,\n    THORN: THORN$1,\n    thorn: thorn$1,\n    tilde: tilde,\n    Tilde: Tilde,\n    TildeEqual: TildeEqual,\n    TildeFullEqual: TildeFullEqual,\n    TildeTilde: TildeTilde,\n    timesbar: timesbar,\n    timesb: timesb,\n    times: times$1,\n    timesd: timesd,\n    tint: tint,\n    toea: toea,\n    topbot: topbot,\n    topcir: topcir,\n    top: esm_top,\n    Topf: Topf,\n    topf: topf,\n    topfork: topfork,\n    tosa: tosa,\n    tprime: tprime,\n    trade: trade,\n    TRADE: TRADE,\n    triangle: triangle,\n    triangledown: triangledown,\n    triangleleft: triangleleft,\n    trianglelefteq: trianglelefteq,\n    triangleq: triangleq,\n    triangleright: triangleright,\n    trianglerighteq: trianglerighteq,\n    tridot: tridot,\n    trie: trie,\n    triminus: triminus,\n    TripleDot: TripleDot,\n    triplus: triplus,\n    trisb: trisb,\n    tritime: tritime,\n    trpezium: trpezium,\n    Tscr: Tscr,\n    tscr: tscr,\n    TScy: TScy,\n    tscy: tscy,\n    TSHcy: TSHcy,\n    tshcy: tshcy,\n    Tstrok: Tstrok,\n    tstrok: tstrok,\n    twixt: twixt,\n    twoheadleftarrow: twoheadleftarrow,\n    twoheadrightarrow: twoheadrightarrow,\n    Uacute: Uacute$1,\n    uacute: uacute$1,\n    uarr: uarr,\n    Uarr: Uarr,\n    uArr: uArr,\n    Uarrocir: Uarrocir,\n    Ubrcy: Ubrcy,\n    ubrcy: ubrcy,\n    Ubreve: Ubreve,\n    ubreve: ubreve,\n    Ucirc: Ucirc$1,\n    ucirc: ucirc$1,\n    Ucy: Ucy,\n    ucy: ucy,\n    udarr: udarr,\n    Udblac: Udblac,\n    udblac: udblac,\n    udhar: udhar,\n    ufisht: ufisht,\n    Ufr: Ufr,\n    ufr: ufr,\n    Ugrave: Ugrave$1,\n    ugrave: ugrave$1,\n    uHar: uHar,\n    uharl: uharl,\n    uharr: uharr,\n    uhblk: uhblk,\n    ulcorn: ulcorn,\n    ulcorner: ulcorner,\n    ulcrop: ulcrop,\n    ultri: ultri,\n    Umacr: Umacr,\n    umacr: umacr,\n    uml: uml$1,\n    UnderBar: UnderBar,\n    UnderBrace: UnderBrace,\n    UnderBracket: UnderBracket,\n    UnderParenthesis: UnderParenthesis,\n    Union: Union,\n    UnionPlus: UnionPlus,\n    Uogon: Uogon,\n    uogon: uogon,\n    Uopf: Uopf,\n    uopf: uopf,\n    UpArrowBar: UpArrowBar,\n    uparrow: uparrow,\n    UpArrow: UpArrow,\n    Uparrow: Uparrow,\n    UpArrowDownArrow: UpArrowDownArrow,\n    updownarrow: updownarrow,\n    UpDownArrow: UpDownArrow,\n    Updownarrow: Updownarrow,\n    UpEquilibrium: UpEquilibrium,\n    upharpoonleft: upharpoonleft,\n    upharpoonright: upharpoonright,\n    uplus: uplus,\n    UpperLeftArrow: UpperLeftArrow,\n    UpperRightArrow: UpperRightArrow,\n    upsi: upsi,\n    Upsi: Upsi,\n    upsih: upsih,\n    Upsilon: Upsilon,\n    upsilon: upsilon,\n    UpTeeArrow: UpTeeArrow,\n    UpTee: UpTee,\n    upuparrows: upuparrows,\n    urcorn: urcorn,\n    urcorner: urcorner,\n    urcrop: urcrop,\n    Uring: Uring,\n    uring: uring,\n    urtri: urtri,\n    Uscr: Uscr,\n    uscr: uscr,\n    utdot: utdot,\n    Utilde: Utilde,\n    utilde: utilde,\n    utri: utri,\n    utrif: utrif,\n    uuarr: uuarr,\n    Uuml: Uuml$1,\n    uuml: uuml$1,\n    uwangle: uwangle,\n    vangrt: vangrt,\n    varepsilon: varepsilon,\n    varkappa: varkappa,\n    varnothing: varnothing,\n    varphi: varphi,\n    varpi: varpi,\n    varpropto: varpropto,\n    varr: varr,\n    vArr: vArr,\n    varrho: varrho,\n    varsigma: varsigma,\n    varsubsetneq: varsubsetneq,\n    varsubsetneqq: varsubsetneqq,\n    varsupsetneq: varsupsetneq,\n    varsupsetneqq: varsupsetneqq,\n    vartheta: vartheta,\n    vartriangleleft: vartriangleleft,\n    vartriangleright: vartriangleright,\n    vBar: vBar,\n    Vbar: Vbar,\n    vBarv: vBarv,\n    Vcy: Vcy,\n    vcy: vcy,\n    vdash: vdash,\n    vDash: vDash,\n    Vdash: Vdash,\n    VDash: VDash,\n    Vdashl: Vdashl,\n    veebar: veebar,\n    vee: vee,\n    Vee: Vee,\n    veeeq: veeeq,\n    vellip: vellip,\n    verbar: verbar,\n    Verbar: Verbar,\n    vert: vert,\n    Vert: Vert,\n    VerticalBar: VerticalBar,\n    VerticalLine: VerticalLine,\n    VerticalSeparator: VerticalSeparator,\n    VerticalTilde: VerticalTilde,\n    VeryThinSpace: VeryThinSpace,\n    Vfr: Vfr,\n    vfr: vfr,\n    vltri: vltri,\n    vnsub: vnsub,\n    vnsup: vnsup,\n    Vopf: Vopf,\n    vopf: vopf,\n    vprop: vprop,\n    vrtri: vrtri,\n    Vscr: Vscr,\n    vscr: vscr,\n    vsubnE: vsubnE,\n    vsubne: vsubne,\n    vsupnE: vsupnE,\n    vsupne: vsupne,\n    Vvdash: Vvdash,\n    vzigzag: vzigzag,\n    Wcirc: Wcirc,\n    wcirc: wcirc,\n    wedbar: wedbar,\n    wedge: wedge,\n    Wedge: Wedge,\n    wedgeq: wedgeq,\n    weierp: weierp,\n    Wfr: Wfr,\n    wfr: wfr,\n    Wopf: Wopf,\n    wopf: wopf,\n    wp: wp,\n    wr: wr,\n    wreath: wreath,\n    Wscr: Wscr,\n    wscr: wscr,\n    xcap: xcap,\n    xcirc: xcirc,\n    xcup: xcup,\n    xdtri: xdtri,\n    Xfr: Xfr,\n    xfr: xfr,\n    xharr: xharr,\n    xhArr: xhArr,\n    Xi: Xi,\n    xi: xi,\n    xlarr: xlarr,\n    xlArr: xlArr,\n    xmap: xmap,\n    xnis: xnis,\n    xodot: xodot,\n    Xopf: Xopf,\n    xopf: xopf,\n    xoplus: xoplus,\n    xotime: xotime,\n    xrarr: xrarr,\n    xrArr: xrArr,\n    Xscr: Xscr,\n    xscr: xscr,\n    xsqcup: xsqcup,\n    xuplus: xuplus,\n    xutri: xutri,\n    xvee: xvee,\n    xwedge: xwedge,\n    Yacute: Yacute$1,\n    yacute: yacute$1,\n    YAcy: YAcy,\n    yacy: yacy,\n    Ycirc: Ycirc,\n    ycirc: ycirc,\n    Ycy: Ycy,\n    ycy: ycy,\n    yen: yen$1,\n    Yfr: Yfr,\n    yfr: yfr,\n    YIcy: YIcy,\n    yicy: yicy,\n    Yopf: Yopf,\n    yopf: yopf,\n    Yscr: Yscr,\n    yscr: yscr,\n    YUcy: YUcy,\n    yucy: yucy,\n    yuml: yuml$1,\n    Yuml: Yuml,\n    Zacute: Zacute,\n    zacute: zacute,\n    Zcaron: Zcaron,\n    zcaron: zcaron,\n    Zcy: Zcy,\n    zcy: zcy,\n    Zdot: Zdot,\n    zdot: zdot,\n    zeetrf: zeetrf,\n    ZeroWidthSpace: ZeroWidthSpace,\n    Zeta: Zeta,\n    zeta: zeta,\n    zfr: zfr,\n    Zfr: Zfr,\n    ZHcy: ZHcy,\n    zhcy: zhcy,\n    zigrarr: zigrarr,\n    zopf: zopf,\n    Zopf: Zopf,\n    Zscr: Zscr,\n    zscr: zscr,\n    zwj: zwj,\n    zwnj: zwnj\n};\nvar Aacute = \"Á\";\nvar aacute = \"á\";\nvar Acirc = \"Â\";\nvar acirc = \"â\";\nvar acute = \"´\";\nvar AElig = \"Æ\";\nvar aelig = \"æ\";\nvar Agrave = \"À\";\nvar agrave = \"à\";\nvar amp$1 = \"&\";\nvar AMP = \"&\";\nvar Aring = \"Å\";\nvar aring = \"å\";\nvar Atilde = \"Ã\";\nvar atilde = \"ã\";\nvar Auml = \"Ä\";\nvar auml = \"ä\";\nvar brvbar = \"¦\";\nvar Ccedil = \"Ç\";\nvar ccedil = \"ç\";\nvar cedil = \"¸\";\nvar cent = \"¢\";\nvar copy = \"©\";\nvar COPY = \"©\";\nvar curren = \"¤\";\nvar deg = \"°\";\nvar divide = \"÷\";\nvar Eacute = \"É\";\nvar eacute = \"é\";\nvar Ecirc = \"Ê\";\nvar ecirc = \"ê\";\nvar Egrave = \"È\";\nvar egrave = \"è\";\nvar ETH = \"Ð\";\nvar eth = \"ð\";\nvar Euml = \"Ë\";\nvar euml = \"ë\";\nvar frac12 = \"½\";\nvar frac14 = \"¼\";\nvar frac34 = \"¾\";\nvar gt$1 = \">\";\nvar GT = \">\";\nvar Iacute = \"Í\";\nvar iacute = \"í\";\nvar Icirc = \"Î\";\nvar icirc = \"î\";\nvar iexcl = \"¡\";\nvar Igrave = \"Ì\";\nvar igrave = \"ì\";\nvar iquest = \"¿\";\nvar Iuml = \"Ï\";\nvar iuml = \"ï\";\nvar laquo = \"«\";\nvar lt$1 = \"<\";\nvar LT = \"<\";\nvar macr = \"¯\";\nvar micro = \"µ\";\nvar middot = \"·\";\nvar nbsp = \" \";\nvar not = \"¬\";\nvar Ntilde = \"Ñ\";\nvar ntilde = \"ñ\";\nvar Oacute = \"Ó\";\nvar oacute = \"ó\";\nvar Ocirc = \"Ô\";\nvar ocirc = \"ô\";\nvar Ograve = \"Ò\";\nvar ograve = \"ò\";\nvar ordf = \"ª\";\nvar ordm = \"º\";\nvar Oslash = \"Ø\";\nvar oslash = \"ø\";\nvar Otilde = \"Õ\";\nvar otilde = \"õ\";\nvar Ouml = \"Ö\";\nvar ouml = \"ö\";\nvar para = \"¶\";\nvar plusmn = \"±\";\nvar pound = \"£\";\nvar quot$1 = \"\\\"\";\nvar QUOT = \"\\\"\";\nvar raquo = \"»\";\nvar reg = \"®\";\nvar REG = \"®\";\nvar sect = \"§\";\nvar shy = \"­\";\nvar sup1 = \"¹\";\nvar sup2 = \"²\";\nvar sup3 = \"³\";\nvar szlig = \"ß\";\nvar THORN = \"Þ\";\nvar thorn = \"þ\";\nvar times = \"×\";\nvar Uacute = \"Ú\";\nvar uacute = \"ú\";\nvar Ucirc = \"Û\";\nvar ucirc = \"û\";\nvar Ugrave = \"Ù\";\nvar ugrave = \"ù\";\nvar uml = \"¨\";\nvar Uuml = \"Ü\";\nvar uuml = \"ü\";\nvar Yacute = \"Ý\";\nvar yacute = \"ý\";\nvar yen = \"¥\";\nvar yuml = \"ÿ\";\nvar require$$1 = {\n    Aacute: Aacute,\n    aacute: aacute,\n    Acirc: Acirc,\n    acirc: acirc,\n    acute: acute,\n    AElig: AElig,\n    aelig: aelig,\n    Agrave: Agrave,\n    agrave: agrave,\n    amp: amp$1,\n    AMP: AMP,\n    Aring: Aring,\n    aring: aring,\n    Atilde: Atilde,\n    atilde: atilde,\n    Auml: Auml,\n    auml: auml,\n    brvbar: brvbar,\n    Ccedil: Ccedil,\n    ccedil: ccedil,\n    cedil: cedil,\n    cent: cent,\n    copy: copy,\n    COPY: COPY,\n    curren: curren,\n    deg: deg,\n    divide: divide,\n    Eacute: Eacute,\n    eacute: eacute,\n    Ecirc: Ecirc,\n    ecirc: ecirc,\n    Egrave: Egrave,\n    egrave: egrave,\n    ETH: ETH,\n    eth: eth,\n    Euml: Euml,\n    euml: euml,\n    frac12: frac12,\n    frac14: frac14,\n    frac34: frac34,\n    gt: gt$1,\n    GT: GT,\n    Iacute: Iacute,\n    iacute: iacute,\n    Icirc: Icirc,\n    icirc: icirc,\n    iexcl: iexcl,\n    Igrave: Igrave,\n    igrave: igrave,\n    iquest: iquest,\n    Iuml: Iuml,\n    iuml: iuml,\n    laquo: laquo,\n    lt: lt$1,\n    LT: LT,\n    macr: macr,\n    micro: micro,\n    middot: middot,\n    nbsp: nbsp,\n    not: not,\n    Ntilde: Ntilde,\n    ntilde: ntilde,\n    Oacute: Oacute,\n    oacute: oacute,\n    Ocirc: Ocirc,\n    ocirc: ocirc,\n    Ograve: Ograve,\n    ograve: ograve,\n    ordf: ordf,\n    ordm: ordm,\n    Oslash: Oslash,\n    oslash: oslash,\n    Otilde: Otilde,\n    otilde: otilde,\n    Ouml: Ouml,\n    ouml: ouml,\n    para: para,\n    plusmn: plusmn,\n    pound: pound,\n    quot: quot$1,\n    QUOT: QUOT,\n    raquo: raquo,\n    reg: reg,\n    REG: REG,\n    sect: sect,\n    shy: shy,\n    sup1: sup1,\n    sup2: sup2,\n    sup3: sup3,\n    szlig: szlig,\n    THORN: THORN,\n    thorn: thorn,\n    times: times,\n    Uacute: Uacute,\n    uacute: uacute,\n    Ucirc: Ucirc,\n    ucirc: ucirc,\n    Ugrave: Ugrave,\n    ugrave: ugrave,\n    uml: uml,\n    Uuml: Uuml,\n    uuml: uuml,\n    Yacute: Yacute,\n    yacute: yacute,\n    yen: yen,\n    yuml: yuml\n};\nvar amp = \"&\";\nvar apos = \"'\";\nvar gt = \">\";\nvar lt = \"<\";\nvar quot = \"\\\"\";\nvar require$$0$1 = {\n    amp: amp,\n    apos: apos,\n    gt: gt,\n    lt: lt,\n    quot: quot\n};\nvar decode_codepoint = {};\nvar require$$0 = {\n    \"0\": 65533,\n    \"128\": 8364,\n    \"130\": 8218,\n    \"131\": 402,\n    \"132\": 8222,\n    \"133\": 8230,\n    \"134\": 8224,\n    \"135\": 8225,\n    \"136\": 710,\n    \"137\": 8240,\n    \"138\": 352,\n    \"139\": 8249,\n    \"140\": 338,\n    \"142\": 381,\n    \"145\": 8216,\n    \"146\": 8217,\n    \"147\": 8220,\n    \"148\": 8221,\n    \"149\": 8226,\n    \"150\": 8211,\n    \"151\": 8212,\n    \"152\": 732,\n    \"153\": 8482,\n    \"154\": 353,\n    \"155\": 8250,\n    \"156\": 339,\n    \"158\": 382,\n    \"159\": 376\n};\nvar __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode_codepoint, \"__esModule\", { value: true });\nvar decode_json_1 = __importDefault$2(require$$0);\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint$2 = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = \"\";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint$2(codePoint);\n}\ndecode_codepoint.default = decodeCodePoint;\nvar __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode, \"__esModule\", { value: true });\ndecode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;\nvar entities_json_1$1 = __importDefault$1(require$$1$1);\nvar legacy_json_1 = __importDefault$1(require$$1);\nvar xml_json_1$1 = __importDefault$1(require$$0$1);\nvar decode_codepoint_1 = __importDefault$1(decode_codepoint);\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\ndecode.decodeXML = getStrictDecoder(xml_json_1$1.default);\ndecode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\ndecode.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1$1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += \";?\";\n            j++;\n        }\n        else {\n            keys[i] += \";\";\n        }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1$1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== \";\")\n            str += \";\";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === \"#\") {\n            var secondChar = str.charAt(2);\n            if (secondChar === \"X\" || secondChar === \"x\") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\nvar encode = {};\nvar esm_importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(encode, \"__esModule\", { value: true });\nencode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;\nvar xml_json_1 = esm_importDefault(require$$0$1);\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = esm_importDefault(require$$1$1);\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction esm_escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nencode.escape = esm_escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nencode.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n(function (exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\n    var decode_1 = decode;\n    var encode_1 = encode;\n    /**\n     * Decodes a string with entities.\n     *\n     * @param data String to decode.\n     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `decodeXML` or `decodeHTML` directly.\n     */\n    function decode$1(data, level) {\n        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n    }\n    exports.decode = decode$1;\n    /**\n     * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n     *\n     * @param data String to decode.\n     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n     */\n    function decodeStrict(data, level) {\n        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n    }\n    exports.decodeStrict = decodeStrict;\n    /**\n     * Encodes a string with entities.\n     *\n     * @param data String to encode.\n     * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n     */\n    function encode$1(data, level) {\n        return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n    }\n    exports.encode = encode$1;\n    var encode_2 = encode;\n    Object.defineProperty(exports, \"encodeXML\", { enumerable: true, get: function () { return encode_2.encodeXML; } });\n    Object.defineProperty(exports, \"encodeHTML\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\n    Object.defineProperty(exports, \"encodeNonAsciiHTML\", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });\n    Object.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return encode_2.escape; } });\n    Object.defineProperty(exports, \"escapeUTF8\", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });\n    // Legacy aliases (deprecated)\n    Object.defineProperty(exports, \"encodeHTML4\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\n    Object.defineProperty(exports, \"encodeHTML5\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\n    var decode_2 = decode;\n    Object.defineProperty(exports, \"decodeXML\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n    Object.defineProperty(exports, \"decodeHTML\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\n    Object.defineProperty(exports, \"decodeHTMLStrict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n    // Legacy aliases (deprecated)\n    Object.defineProperty(exports, \"decodeHTML4\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\n    Object.defineProperty(exports, \"decodeHTML5\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\n    Object.defineProperty(exports, \"decodeHTML4Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n    Object.defineProperty(exports, \"decodeHTML5Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n    Object.defineProperty(exports, \"decodeXMLStrict\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n}(lib));\nvar ENTITY = '&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});';\nvar C_BACKSLASH$1 = 92;\nvar reBackslashOrAmp = /[\\\\&]/;\nvar ESCAPABLE = '[!\"#$%&\\'()*+,./:;<=>?@[\\\\\\\\\\\\]^_`{|}~-]';\nvar reEntityOrEscapedChar = new RegExp(\"\\\\\\\\\" + ESCAPABLE + \"|\" + ENTITY, 'gi');\nvar XMLSPECIAL = '[&<>\"]';\nvar reXmlSpecial = new RegExp(XMLSPECIAL, 'g');\nvar unescapeChar = function (s) {\n    if (s.charCodeAt(0) === C_BACKSLASH$1) {\n        return s.charAt(1);\n    }\n    return lib.decodeHTML(s);\n};\n// Replace entities and backslash escapes with literal characters.\nfunction unescapeString(s) {\n    if (reBackslashOrAmp.test(s)) {\n        return s.replace(reEntityOrEscapedChar, unescapeChar);\n    }\n    return s;\n}\nfunction normalizeURI(uri) {\n    try {\n        return encode_1(uri);\n    }\n    catch (err) {\n        return uri;\n    }\n}\nfunction replaceUnsafeChar(s) {\n    switch (s) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return s;\n    }\n}\nfunction escapeXml(s) {\n    if (reXmlSpecial.test(s)) {\n        return s.replace(reXmlSpecial, replaceUnsafeChar);\n    }\n    return s;\n}\nfunction repeat(str, count) {\n    var arr = [];\n    for (var i = 0; i < count; i++) {\n        arr.push(str);\n    }\n    return arr.join('');\n}\nfunction isEmpty(str) {\n    if (!str) {\n        return true;\n    }\n    return !/[^ \\t]+/.test(str);\n}\nvar NodeWalker = /** @class */ (function () {\n    function NodeWalker(root) {\n        this.current = root;\n        this.root = root;\n        this.entering = true;\n    }\n    NodeWalker.prototype.next = function () {\n        var cur = this.current;\n        var entering = this.entering;\n        if (cur === null) {\n            return null;\n        }\n        var container = isContainer(cur);\n        if (entering && container) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                // stay on node but exit\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next === null) {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        else {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        return { entering: entering, node: cur };\n    };\n    NodeWalker.prototype.resumeAt = function (node, entering) {\n        this.current = node;\n        this.entering = entering === true;\n    };\n    return NodeWalker;\n}());\nfunction isContainer(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nvar lastNodeId = 1;\nvar nodeMap = {};\nfunction getNodeById(id) {\n    return nodeMap[id];\n}\nfunction removeNodeById(id) {\n    delete nodeMap[id];\n}\nfunction removeAllNode() {\n    nodeMap = {};\n}\nvar esm_Node = /** @class */ (function () {\n    function Node(nodeType, sourcepos) {\n        this.parent = null;\n        this.prev = null;\n        this.next = null;\n        // only for container node\n        this.firstChild = null;\n        this.lastChild = null;\n        // only for leaf node\n        this.literal = null;\n        if (nodeType === 'document') {\n            this.id = -1;\n        }\n        else {\n            this.id = lastNodeId++;\n        }\n        this.type = nodeType;\n        this.sourcepos = sourcepos;\n        nodeMap[this.id] = this;\n    }\n    Node.prototype.isContainer = function () {\n        return isContainer(this);\n    };\n    Node.prototype.unlink = function () {\n        if (this.prev) {\n            this.prev.next = this.next;\n        }\n        else if (this.parent) {\n            this.parent.firstChild = this.next;\n        }\n        if (this.next) {\n            this.next.prev = this.prev;\n        }\n        else if (this.parent) {\n            this.parent.lastChild = this.prev;\n        }\n        this.parent = null;\n        this.next = null;\n        this.prev = null;\n    };\n    Node.prototype.replaceWith = function (node) {\n        this.insertBefore(node);\n        this.unlink();\n    };\n    Node.prototype.insertAfter = function (sibling) {\n        sibling.unlink();\n        sibling.next = this.next;\n        if (sibling.next) {\n            sibling.next.prev = sibling;\n        }\n        sibling.prev = this;\n        this.next = sibling;\n        if (this.parent) {\n            sibling.parent = this.parent;\n            if (!sibling.next) {\n                sibling.parent.lastChild = sibling;\n            }\n        }\n    };\n    Node.prototype.insertBefore = function (sibling) {\n        sibling.unlink();\n        sibling.prev = this.prev;\n        if (sibling.prev) {\n            sibling.prev.next = sibling;\n        }\n        sibling.next = this;\n        this.prev = sibling;\n        sibling.parent = this.parent;\n        if (!sibling.prev) {\n            sibling.parent.firstChild = sibling;\n        }\n    };\n    Node.prototype.appendChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.lastChild) {\n            this.lastChild.next = child;\n            child.prev = this.lastChild;\n            this.lastChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.prependChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.firstChild) {\n            this.firstChild.prev = child;\n            child.next = this.firstChild;\n            this.firstChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.walker = function () {\n        return new NodeWalker(this);\n    };\n    return Node;\n}());\nvar BlockNode = /** @class */ (function (_super) {\n    esm_extends(BlockNode, _super);\n    function BlockNode(nodeType, sourcepos) {\n        var _this = _super.call(this, nodeType, sourcepos) || this;\n        // temporal data (for parsing)\n        _this.open = true;\n        _this.lineOffsets = null;\n        _this.stringContent = null;\n        _this.lastLineBlank = false;\n        _this.lastLineChecked = false;\n        _this.type = nodeType;\n        return _this;\n    }\n    return BlockNode;\n}(esm_Node));\nvar ListNode = /** @class */ (function (_super) {\n    esm_extends(ListNode, _super);\n    function ListNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.listData = null;\n        return _this;\n    }\n    return ListNode;\n}(BlockNode));\nvar HeadingNode = /** @class */ (function (_super) {\n    esm_extends(HeadingNode, _super);\n    function HeadingNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.level = 0;\n        _this.headingType = 'atx';\n        return _this;\n    }\n    return HeadingNode;\n}(BlockNode));\nvar CodeBlockNode = /** @class */ (function (_super) {\n    esm_extends(CodeBlockNode, _super);\n    function CodeBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isFenced = false;\n        _this.fenceChar = null;\n        _this.fenceLength = 0;\n        _this.fenceOffset = -1;\n        _this.info = null;\n        _this.infoPadding = 0;\n        return _this;\n    }\n    return CodeBlockNode;\n}(BlockNode));\nvar TableNode = /** @class */ (function (_super) {\n    esm_extends(TableNode, _super);\n    function TableNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.columns = [];\n        return _this;\n    }\n    return TableNode;\n}(BlockNode));\nvar TableCellNode = /** @class */ (function (_super) {\n    esm_extends(TableCellNode, _super);\n    function TableCellNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.startIdx = 0;\n        _this.endIdx = 0;\n        _this.paddingLeft = 0;\n        _this.paddingRight = 0;\n        _this.ignored = false;\n        return _this;\n    }\n    return TableCellNode;\n}(BlockNode));\nvar RefDefNode = /** @class */ (function (_super) {\n    esm_extends(RefDefNode, _super);\n    function RefDefNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.title = '';\n        _this.dest = '';\n        _this.label = '';\n        return _this;\n    }\n    return RefDefNode;\n}(BlockNode));\nvar CustomBlockNode = /** @class */ (function (_super) {\n    esm_extends(CustomBlockNode, _super);\n    function CustomBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.syntaxLength = 0;\n        _this.offset = -1;\n        _this.info = '';\n        return _this;\n    }\n    return CustomBlockNode;\n}(BlockNode));\nvar HtmlBlockNode = /** @class */ (function (_super) {\n    esm_extends(HtmlBlockNode, _super);\n    function HtmlBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.htmlBlockType = -1;\n        return _this;\n    }\n    return HtmlBlockNode;\n}(BlockNode));\nvar LinkNode = /** @class */ (function (_super) {\n    esm_extends(LinkNode, _super);\n    function LinkNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destination = null;\n        _this.title = null;\n        _this.extendedAutolink = false;\n        return _this;\n    }\n    return LinkNode;\n}(esm_Node));\nvar CodeNode = /** @class */ (function (_super) {\n    esm_extends(CodeNode, _super);\n    function CodeNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.tickCount = 0;\n        return _this;\n    }\n    return CodeNode;\n}(esm_Node));\nvar CustomInlineNode = /** @class */ (function (_super) {\n    esm_extends(CustomInlineNode, _super);\n    function CustomInlineNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.info = '';\n        return _this;\n    }\n    return CustomInlineNode;\n}(esm_Node));\nfunction createNode(type, sourcepos) {\n    switch (type) {\n        case 'heading':\n            return new HeadingNode(type, sourcepos);\n        case 'list':\n        case 'item':\n            return new ListNode(type, sourcepos);\n        case 'link':\n        case 'image':\n            return new LinkNode(type, sourcepos);\n        case 'codeBlock':\n            return new CodeBlockNode(type, sourcepos);\n        case 'htmlBlock':\n            return new HtmlBlockNode(type, sourcepos);\n        case 'table':\n            return new TableNode(type, sourcepos);\n        case 'tableCell':\n            return new TableCellNode(type, sourcepos);\n        case 'document':\n        case 'paragraph':\n        case 'blockQuote':\n        case 'thematicBreak':\n        case 'tableRow':\n        case 'tableBody':\n        case 'tableHead':\n        case 'frontMatter':\n            return new BlockNode(type, sourcepos);\n        case 'code':\n            return new CodeNode(type, sourcepos);\n        case 'refDef':\n            return new RefDefNode(type, sourcepos);\n        case 'customBlock':\n            return new CustomBlockNode(type, sourcepos);\n        case 'customInline':\n            return new CustomInlineNode(type, sourcepos);\n        default:\n            return new esm_Node(type, sourcepos);\n    }\n}\nfunction isCodeBlock(node) {\n    return node.type === 'codeBlock';\n}\nfunction isHtmlBlock(node) {\n    return node.type === 'htmlBlock';\n}\nfunction isHeading(node) {\n    return node.type === 'heading';\n}\nfunction isList(node) {\n    return node.type === 'list';\n}\nfunction isTable(node) {\n    return node.type === 'table';\n}\nfunction isRefDef(node) {\n    return node.type === 'refDef';\n}\nfunction isCustomBlock(node) {\n    return node.type === 'customBlock';\n}\nfunction isCustomInline(node) {\n    return node.type === 'customInline';\n}\nfunction esm_text(s, sourcepos) {\n    var node = createNode('text', sourcepos);\n    node.literal = s;\n    return node;\n}\nvar TAGNAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTEDVALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLEQUOTEDVALUE = \"'[^']*'\";\nvar DOUBLEQUOTEDVALUE = '\"[^\"]*\"';\nvar ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE + \"|\" + DOUBLEQUOTEDVALUE + \")\";\nvar ATTRIBUTEVALUESPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTEVALUE + \")\";\nvar ATTRIBUTE = \"\" + '(?:\\\\s+' + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + \"?)\";\nvar OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\\\\s*/?>\";\nvar CLOSETAG = \"</\" + TAGNAME + \"\\\\s*[>]\";\nvar HTMLCOMMENT = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar PROCESSINGINSTRUCTION = '[<][?].*?[?][>]';\nvar DECLARATION = '<![A-Z]+\\\\s+[^>]*>';\nvar CDATA = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\nvar HTMLTAG = \"(?:\" + OPENTAG + \"|\" + CLOSETAG + \"|\" + HTMLCOMMENT + \"|\" + PROCESSINGINSTRUCTION + \"|\" + DECLARATION + \"|\" + CDATA + \")\";\nvar reHtmlTag = new RegExp(\"^\" + HTMLTAG, 'i');\n// derived from https://github.com/mathiasbynens/String.fromCodePoint\n/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nvar fromCodePoint;\nif (String.fromCodePoint) {\n    fromCodePoint = function (_) {\n        try {\n            return String.fromCodePoint(_);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                return String.fromCharCode(0xfffd);\n            }\n            throw e;\n        }\n    };\n}\nelse {\n    var stringFromCharCode_1 = String.fromCharCode;\n    var floor_1 = Math.floor;\n    fromCodePoint = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = args.length;\n        if (!length) {\n            return '';\n        }\n        var result = '';\n        while (++index < length) {\n            var codePoint = Number(args[index]);\n            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                codePoint < 0 || // not a valid Unicode code point\n                codePoint > 0x10ffff || // not a valid Unicode code point\n                floor_1(codePoint) !== codePoint // not an integer\n            ) {\n                return String.fromCharCode(0xfffd);\n            }\n            if (codePoint <= 0xffff) {\n                // BMP code point\n                codeUnits.push(codePoint);\n            }\n            else {\n                // Astral code point; split in surrogate halves\n                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint -= 0x10000;\n                highSurrogate = (codePoint >> 10) + 0xd800;\n                lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                codeUnits.push(highSurrogate, lowSurrogate);\n            }\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += stringFromCharCode_1.apply(void 0, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    };\n}\nvar fromCodePoint$1 = fromCodePoint;\nvar DOMAIN = '(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+';\nvar PATH = '[^<\\\\s]*[^<?!.,:*_?~\\\\s]';\nvar EMAIL = '[\\\\w.+-]+@(?:[\\\\w-]+\\\\.)+[\\\\w-]+';\nfunction trimUnmatchedTrailingParens(source) {\n    var trailingParen = /\\)+$/.exec(source);\n    if (trailingParen) {\n        var count = 0;\n        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {\n            var ch = source_1[_i];\n            if (ch === '(') {\n                if (count < 0) {\n                    count = 1;\n                }\n                else {\n                    count += 1;\n                }\n            }\n            else if (ch === ')') {\n                count -= 1;\n            }\n        }\n        if (count < 0) {\n            var trimCount = Math.min(-count, trailingParen[0].length);\n            return source.substring(0, source.length - trimCount);\n        }\n    }\n    return source;\n}\nfunction trimTrailingEntity(source) {\n    return source.replace(/&[A-Za-z0-9]+;$/, '');\n}\nfunction parseEmailLink(source) {\n    var reEmailLink = new RegExp(EMAIL, 'g');\n    var result = [];\n    var m;\n    while ((m = reEmailLink.exec(source))) {\n        var text_1 = m[0];\n        if (!/[_-]+$/.test(text_1)) {\n            result.push({\n                text: text_1,\n                range: [m.index, m.index + text_1.length - 1],\n                url: \"mailto:\" + text_1,\n            });\n        }\n    }\n    return result;\n}\nfunction parseUrlLink(source) {\n    var reWwwAutolink = new RegExp(\"(www|https?://).\" + DOMAIN + PATH, 'g');\n    var result = [];\n    var m;\n    while ((m = reWwwAutolink.exec(source))) {\n        var text_2 = trimTrailingEntity(trimUnmatchedTrailingParens(m[0]));\n        var scheme = m[1] === 'www' ? 'http://' : '';\n        result.push({\n            text: text_2,\n            range: [m.index, m.index + text_2.length - 1],\n            url: \"\" + scheme + text_2,\n        });\n    }\n    return result;\n}\nfunction baseAutolinkParser(source) {\n    return esm_spreadArray(esm_spreadArray([], parseUrlLink(source)), parseEmailLink(source)).sort(function (a, b) { return a.range[0] - b.range[0]; });\n}\nfunction convertExtAutoLinks(walker, autolinkParser) {\n    if (typeof autolinkParser === 'boolean') {\n        autolinkParser = baseAutolinkParser;\n    }\n    var event;\n    var _loop_1 = function () {\n        var entering = event.entering, node = event.node;\n        if (entering && node.type === 'text' && node.parent.type !== 'link') {\n            var literal = node.literal;\n            var linkInfos = autolinkParser(literal);\n            if (!linkInfos || !linkInfos.length) {\n                return \"continue\";\n            }\n            var lastIdx = 0;\n            var _a = node.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];\n            var sourcepos = function (startIdx, endIdx) {\n                return [\n                    [lineNum_1, chPos_1 + startIdx],\n                    [lineNum_1, chPos_1 + endIdx],\n                ];\n            };\n            var newNodes = [];\n            for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {\n                var _b = linkInfos_1[_i], range = _b.range, url = _b.url, linkText = _b.text;\n                if (range[0] > lastIdx) {\n                    newNodes.push(esm_text(literal.substring(lastIdx, range[0]), sourcepos(lastIdx, range[0] - 1)));\n                }\n                var linkNode = createNode('link', sourcepos.apply(void 0, range));\n                linkNode.appendChild(esm_text(linkText, sourcepos.apply(void 0, range)));\n                linkNode.destination = url;\n                linkNode.extendedAutolink = true;\n                newNodes.push(linkNode);\n                lastIdx = range[1] + 1;\n            }\n            if (lastIdx < literal.length) {\n                newNodes.push(esm_text(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));\n            }\n            for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {\n                var newNode = newNodes_1[_c];\n                node.insertBefore(newNode);\n            }\n            node.unlink();\n        }\n    };\n    while ((event = walker.next())) {\n        _loop_1();\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n// normalize a reference in reference link (remove []s, trim,\n// collapse internal space, unicode case fold.\n// See commonmark/commonmark.js#168.\nfunction normalizeReference(str) {\n    return str\n        .slice(1, str.length - 1)\n        .trim()\n        .replace(/[ \\t\\r\\n]+/, ' ')\n        .toLowerCase()\n        .toUpperCase();\n}\nfunction iterateObject(obj, iteratee) {\n    Object.keys(obj).forEach(function (key) {\n        iteratee(key, obj[key]);\n    });\n}\nfunction omit(obj) {\n    var propNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        propNames[_i - 1] = arguments[_i];\n    }\n    var resultMap = esm_assign({}, obj);\n    propNames.forEach(function (key) {\n        delete resultMap[key];\n    });\n    return resultMap;\n}\nfunction isEmptyObj(obj) {\n    return !Object.keys(obj).length;\n}\nfunction clearObj(obj) {\n    Object.keys(obj).forEach(function (key) {\n        delete obj[key];\n    });\n}\nvar C_NEWLINE = 10;\nvar C_ASTERISK = 42;\nvar C_UNDERSCORE = 95;\nvar C_BACKTICK = 96;\nvar C_OPEN_BRACKET$1 = 91;\nvar C_CLOSE_BRACKET = 93;\nvar C_TILDE = 126;\nvar C_LESSTHAN$1 = 60;\nvar C_BANG = 33;\nvar C_BACKSLASH = 92;\nvar C_AMPERSAND = 38;\nvar C_OPEN_PAREN = 40;\nvar C_CLOSE_PAREN = 41;\nvar C_COLON = 58;\nvar C_SINGLEQUOTE = 39;\nvar C_DOUBLEQUOTE = 34;\nvar C_DOLLAR = 36;\n// Some regexps used in inline parser:\nvar ESCAPED_CHAR = \"\\\\\\\\\" + ESCAPABLE;\nvar rePunctuation = new RegExp(/[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/);\nvar reLinkTitle = new RegExp(\"^(?:\\\"(\" + ESCAPED_CHAR + \"|[^\\\"\\\\x00])*\\\"\" +\n    \"|\" +\n    (\"'(\" + ESCAPED_CHAR + \"|[^'\\\\x00])*'\") +\n    \"|\" +\n    (\"\\\\((\" + ESCAPED_CHAR + \"|[^()\\\\x00])*\\\\))\"));\nvar reLinkDestinationBraces = /^(?:<(?:[^<>\\n\\\\\\x00]|\\\\.)*>)/;\nvar reEscapable = new RegExp(\"^\" + ESCAPABLE);\nvar reEntityHere = new RegExp(\"^\" + ENTITY, 'i');\nvar reTicks = /`+/;\nvar reTicksHere = /^`+/;\nvar reEllipses = /\\.\\.\\./g;\nvar reDash = /--+/g;\nvar reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\\x00-\\x20]*>/i;\nvar reSpnl = /^ *(?:\\n *)?/;\nvar reWhitespaceChar = /^[ \\t\\n\\x0b\\x0c\\x0d]/;\nvar reUnicodeWhitespaceChar = /^\\s/;\nvar reFinalSpace = / *$/;\nvar reInitialSpace = /^ */;\nvar reSpaceAtEndOfLine = /^ *(?:\\n|$)/;\nvar reLinkLabel = /^\\[(?:[^\\\\\\[\\]]|\\\\.){0,1000}\\]/;\n// Matches a string of non-special characters.\nvar reMain = /^[^\\n`\\[\\]\\\\!<&*_'\"~$]+/m;\nvar InlineParser = /** @class */ (function () {\n    function InlineParser(options) {\n        // An InlineParser keeps track of a subject (a string to be parsed)\n        // and a position in that subject.\n        this.subject = '';\n        this.delimiters = null; // used by handleDelim method\n        this.brackets = null;\n        this.pos = 0;\n        this.lineStartNum = 0;\n        this.lineIdx = 0;\n        this.lineOffsets = [0];\n        this.linePosOffset = 0;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.options = options;\n    }\n    InlineParser.prototype.sourcepos = function (start, end) {\n        var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];\n        var lineNum = this.lineStartNum + this.lineIdx;\n        var startpos = [lineNum, start + linePosOffset];\n        if (typeof end === 'number') {\n            return [startpos, [lineNum, end + linePosOffset]];\n        }\n        return startpos;\n    };\n    InlineParser.prototype.nextLine = function () {\n        this.lineIdx += 1;\n        this.linePosOffset = -this.pos;\n    };\n    // If re matches at current position in the subject, advance\n    // position in subject and return the match; otherwise return null.\n    InlineParser.prototype.match = function (re) {\n        var m = re.exec(this.subject.slice(this.pos));\n        if (m === null) {\n            return null;\n        }\n        this.pos += m.index + m[0].length;\n        return m[0];\n    };\n    // Returns the code for the character at the current subject position, or -1\n    // there are no more characters.\n    InlineParser.prototype.peek = function () {\n        if (this.pos < this.subject.length) {\n            return this.subject.charCodeAt(this.pos);\n        }\n        return -1;\n    };\n    // Parse zero or more space characters, including at most one newline\n    InlineParser.prototype.spnl = function () {\n        this.match(reSpnl);\n        return true;\n    };\n    // All of the parsers below try to match something at the current position\n    // in the subject.  If they succeed in matching anything, they\n    // return the inline matched, advancing the subject.\n    // Attempt to parse backticks, adding either a backtick code span or a\n    // literal sequence of backticks.\n    InlineParser.prototype.parseBackticks = function (block) {\n        var startpos = this.pos + 1;\n        var ticks = this.match(reTicksHere);\n        if (ticks === null) {\n            return false;\n        }\n        var afterOpenTicks = this.pos;\n        var matched;\n        while ((matched = this.match(reTicks)) !== null) {\n            if (matched === ticks) {\n                var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);\n                var sourcepos = this.sourcepos(startpos, this.pos);\n                var lines = contents.split('\\n');\n                if (lines.length > 1) {\n                    var lastLine = last(lines);\n                    this.lineIdx += lines.length - 1;\n                    this.linePosOffset = -(this.pos - lastLine.length - ticks.length);\n                    sourcepos[1] = this.sourcepos(this.pos);\n                    contents = lines.join(' ');\n                }\n                var node = createNode('code', sourcepos);\n                if (contents.length > 0 &&\n                    contents.match(/[^ ]/) !== null &&\n                    contents[0] == ' ' &&\n                    contents[contents.length - 1] == ' ') {\n                    node.literal = contents.slice(1, contents.length - 1);\n                }\n                else {\n                    node.literal = contents;\n                }\n                node.tickCount = ticks.length;\n                block.appendChild(node);\n                return true;\n            }\n        }\n        // If we got here, we didn't match a closing backtick sequence.\n        this.pos = afterOpenTicks;\n        block.appendChild(esm_text(ticks, this.sourcepos(startpos, this.pos - 1)));\n        return true;\n    };\n    // Parse a backslash-escaped special character, adding either the escaped\n    // character, a hard line break (if the backslash is followed by a newline),\n    // or a literal backslash to the block's children.  Assumes current character\n    // is a backslash.\n    InlineParser.prototype.parseBackslash = function (block) {\n        var subj = this.subject;\n        var node;\n        this.pos += 1;\n        var startpos = this.pos;\n        if (this.peek() === C_NEWLINE) {\n            this.pos += 1;\n            node = createNode('linebreak', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            this.nextLine();\n        }\n        else if (reEscapable.test(subj.charAt(this.pos))) {\n            block.appendChild(esm_text(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));\n            this.pos += 1;\n        }\n        else {\n            block.appendChild(esm_text('\\\\', this.sourcepos(startpos, startpos)));\n        }\n        return true;\n    };\n    // Attempt to parse an autolink (URL or email in pointy brackets).\n    InlineParser.prototype.parseAutolink = function (block) {\n        var m;\n        var dest;\n        var node;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEmailAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(\"mailto:\" + dest);\n            node.title = '';\n            node.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        if ((m = this.match(reAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(dest);\n            node.title = '';\n            node.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        return false;\n    };\n    // Attempt to parse a raw HTML tag.\n    InlineParser.prototype.parseHtmlTag = function (block) {\n        var startpos = this.pos + 1;\n        var m = this.match(reHtmlTag);\n        if (m === null) {\n            return false;\n        }\n        var node = createNode('htmlInline', this.sourcepos(startpos, this.pos));\n        node.literal = m;\n        block.appendChild(node);\n        return true;\n    };\n    // Scan a sequence of characters with code cc, and return information about\n    // the number of delimiters and whether they are positioned such that\n    // they can open and/or close emphasis or strong emphasis.  A utility\n    // function for strong/emph parsing.\n    InlineParser.prototype.scanDelims = function (cc) {\n        var numdelims = 0;\n        var startpos = this.pos;\n        if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            numdelims++;\n            this.pos++;\n        }\n        else {\n            while (this.peek() === cc) {\n                numdelims++;\n                this.pos++;\n            }\n        }\n        if (numdelims === 0 || (numdelims < 2 && (cc === C_TILDE || cc === C_DOLLAR))) {\n            this.pos = startpos;\n            return null;\n        }\n        var charBefore = startpos === 0 ? '\\n' : this.subject.charAt(startpos - 1);\n        var ccAfter = this.peek();\n        var charAfter;\n        if (ccAfter === -1) {\n            charAfter = '\\n';\n        }\n        else {\n            charAfter = fromCodePoint$1(ccAfter);\n        }\n        var afterIsWhitespace = reUnicodeWhitespaceChar.test(charAfter);\n        var afterIsPunctuation = rePunctuation.test(charAfter);\n        var beforeIsWhitespace = reUnicodeWhitespaceChar.test(charBefore);\n        var beforeIsPunctuation = rePunctuation.test(charBefore);\n        var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);\n        var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);\n        var canOpen;\n        var canClose;\n        if (cc === C_UNDERSCORE) {\n            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);\n            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);\n        }\n        else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            canOpen = leftFlanking && !rightFlanking;\n            canClose = rightFlanking;\n        }\n        else if (cc === C_DOLLAR) {\n            canOpen = !afterIsWhitespace;\n            canClose = !beforeIsWhitespace;\n        }\n        else {\n            canOpen = leftFlanking;\n            canClose = rightFlanking;\n        }\n        this.pos = startpos;\n        return { numdelims: numdelims, canOpen: canOpen, canClose: canClose };\n    };\n    // Handle a delimiter marker for emphasis or a quote.\n    InlineParser.prototype.handleDelim = function (cc, block) {\n        var res = this.scanDelims(cc);\n        if (!res) {\n            return false;\n        }\n        var numdelims = res.numdelims;\n        var startpos = this.pos + 1;\n        var contents;\n        this.pos += numdelims;\n        if (cc === C_SINGLEQUOTE) {\n            contents = '\\u2019';\n        }\n        else if (cc === C_DOUBLEQUOTE) {\n            contents = '\\u201C';\n        }\n        else {\n            contents = this.subject.slice(startpos - 1, this.pos);\n        }\n        var node = esm_text(contents, this.sourcepos(startpos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        if ((res.canOpen || res.canClose) &&\n            (this.options.smart || (cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE))) {\n            this.delimiters = {\n                cc: cc,\n                numdelims: numdelims,\n                origdelims: numdelims,\n                node: node,\n                previous: this.delimiters,\n                next: null,\n                canOpen: res.canOpen,\n                canClose: res.canClose,\n            };\n            if (this.delimiters.previous) {\n                this.delimiters.previous.next = this.delimiters;\n            }\n        }\n        return true;\n    };\n    InlineParser.prototype.removeDelimiter = function (delim) {\n        if (delim.previous !== null) {\n            delim.previous.next = delim.next;\n        }\n        if (delim.next === null) {\n            // top of stack\n            this.delimiters = delim.previous;\n        }\n        else {\n            delim.next.previous = delim.previous;\n        }\n    };\n    InlineParser.prototype.removeDelimitersBetween = function (bottom, top) {\n        if (bottom.next !== top) {\n            bottom.next = top;\n            top.previous = bottom;\n        }\n    };\n    /**\n     * Process all delimiters - emphasis, strong emphasis, strikethrough(gfm)\n     * If the smart punctuation options is true,\n     * convert single/double quotes to corresponding unicode characters.\n     **/\n    InlineParser.prototype.processEmphasis = function (stackBottom) {\n        var _a;\n        var opener;\n        var closer;\n        var oldCloser;\n        var openerInl, closerInl;\n        var openerFound;\n        var oddMatch = false;\n        var openersBottom = (_a = {},\n            _a[C_UNDERSCORE] = [stackBottom, stackBottom, stackBottom],\n            _a[C_ASTERISK] = [stackBottom, stackBottom, stackBottom],\n            _a[C_SINGLEQUOTE] = [stackBottom],\n            _a[C_DOUBLEQUOTE] = [stackBottom],\n            _a[C_TILDE] = [stackBottom],\n            _a[C_DOLLAR] = [stackBottom],\n            _a);\n        // find first closer above stackBottom:\n        closer = this.delimiters;\n        while (closer !== null && closer.previous !== stackBottom) {\n            closer = closer.previous;\n        }\n        // move forward, looking for closers, and handling each\n        while (closer !== null) {\n            var closercc = closer.cc;\n            var closerEmph = closercc === C_UNDERSCORE || closercc === C_ASTERISK;\n            if (!closer.canClose) {\n                closer = closer.next;\n            }\n            else {\n                // found emphasis closer. now look back for first matching opener:\n                opener = closer.previous;\n                openerFound = false;\n                while (opener !== null &&\n                    opener !== stackBottom &&\n                    opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {\n                    oddMatch =\n                        closerEmph &&\n                            (closer.canOpen || opener.canClose) &&\n                            closer.origdelims % 3 !== 0 &&\n                            (opener.origdelims + closer.origdelims) % 3 === 0;\n                    if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {\n                        openerFound = true;\n                        break;\n                    }\n                    opener = opener.previous;\n                }\n                oldCloser = closer;\n                if (closerEmph || closercc === C_TILDE || closercc === C_DOLLAR) {\n                    if (!openerFound) {\n                        closer = closer.next;\n                    }\n                    else if (opener) {\n                        // (null opener check for type narrowing)\n                        // calculate actual number of delimiters used from closer\n                        var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;\n                        var emptyDelims = closerEmph ? 0 : 1;\n                        openerInl = opener.node;\n                        closerInl = closer.node;\n                        // build contents for new emph element\n                        var nodeType = closerEmph\n                            ? useDelims === 1\n                                ? 'emph'\n                                : 'strong'\n                            : 'strike';\n                        if (closercc === C_DOLLAR) {\n                            nodeType = 'customInline';\n                        }\n                        var newNode = createNode(nodeType);\n                        var openerEndPos = openerInl.sourcepos[1];\n                        var closerStartPos = closerInl.sourcepos[0];\n                        newNode.sourcepos = [\n                            [openerEndPos[0], openerEndPos[1] - useDelims + 1],\n                            [closerStartPos[0], closerStartPos[1] + useDelims - 1],\n                        ];\n                        openerInl.sourcepos[1][1] -= useDelims;\n                        closerInl.sourcepos[0][1] += useDelims;\n                        openerInl.literal = openerInl.literal.slice(useDelims);\n                        closerInl.literal = closerInl.literal.slice(useDelims);\n                        opener.numdelims -= useDelims;\n                        closer.numdelims -= useDelims;\n                        // remove used delimiters from stack elts and inlines\n                        var tmp = openerInl.next;\n                        var next = void 0;\n                        while (tmp && tmp !== closerInl) {\n                            next = tmp.next;\n                            tmp.unlink();\n                            newNode.appendChild(tmp);\n                            tmp = next;\n                        }\n                        // build custom inline node\n                        if (closercc === C_DOLLAR) {\n                            var textNode = newNode.firstChild;\n                            var literal = textNode.literal || '';\n                            var info = literal.split(/\\s/)[0];\n                            newNode.info = info;\n                            if (literal.length <= info.length) {\n                                textNode.unlink();\n                            }\n                            else {\n                                textNode.sourcepos[0][1] += info.length;\n                                textNode.literal = literal.replace(info + \" \", '');\n                            }\n                        }\n                        openerInl.insertAfter(newNode);\n                        // remove elts between opener and closer in delimiters stack\n                        this.removeDelimitersBetween(opener, closer);\n                        // if opener has 0 delims, remove it and the inline\n                        // if opener has 1 delims and character is tilde, remove delimiter only\n                        if (opener.numdelims <= emptyDelims) {\n                            if (opener.numdelims === 0) {\n                                openerInl.unlink();\n                            }\n                            this.removeDelimiter(opener);\n                        }\n                        // if closer has 0 delims, remove it and the inline\n                        // if closer has 1 delims and character is tilde, remove delimiter only\n                        if (closer.numdelims <= emptyDelims) {\n                            if (closer.numdelims === 0) {\n                                closerInl.unlink();\n                            }\n                            var tempstack = closer.next;\n                            this.removeDelimiter(closer);\n                            closer = tempstack;\n                        }\n                    }\n                }\n                else if (closercc === C_SINGLEQUOTE) {\n                    closer.node.literal = '\\u2019';\n                    if (openerFound) {\n                        opener.node.literal = '\\u2018';\n                    }\n                    closer = closer.next;\n                }\n                else if (closercc === C_DOUBLEQUOTE) {\n                    closer.node.literal = '\\u201D';\n                    if (openerFound) {\n                        opener.node.literal = '\\u201C';\n                    }\n                    closer = closer.next;\n                }\n                if (!openerFound) {\n                    // Set lower bound for future searches for openers:\n                    openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;\n                    if (!oldCloser.canOpen) {\n                        // We can remove a closer that can't be an opener,\n                        // once we've seen there's no matching opener:\n                        this.removeDelimiter(oldCloser);\n                    }\n                }\n            }\n        }\n        // remove all delimiters\n        while (this.delimiters !== null && this.delimiters !== stackBottom) {\n            this.removeDelimiter(this.delimiters);\n        }\n    };\n    // Attempt to parse link title (sans quotes), returning the string\n    // or null if no match.\n    InlineParser.prototype.parseLinkTitle = function () {\n        var title = this.match(reLinkTitle);\n        if (title === null) {\n            return null;\n        }\n        // chop off quotes from title and unescape:\n        return unescapeString(title.substr(1, title.length - 2));\n    };\n    // Attempt to parse link destination, returning the string or null if no match.\n    InlineParser.prototype.parseLinkDestination = function () {\n        var res = this.match(reLinkDestinationBraces);\n        if (res === null) {\n            if (this.peek() === C_LESSTHAN$1) {\n                return null;\n            }\n            // @TODO handrolled parser; res should be null or the string\n            var savepos = this.pos;\n            var openparens = 0;\n            var c = void 0;\n            while ((c = this.peek()) !== -1) {\n                if (c === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1))) {\n                    this.pos += 1;\n                    if (this.peek() !== -1) {\n                        this.pos += 1;\n                    }\n                }\n                else if (c === C_OPEN_PAREN) {\n                    this.pos += 1;\n                    openparens += 1;\n                }\n                else if (c === C_CLOSE_PAREN) {\n                    if (openparens < 1) {\n                        break;\n                    }\n                    else {\n                        this.pos += 1;\n                        openparens -= 1;\n                    }\n                }\n                else if (reWhitespaceChar.exec(fromCodePoint$1(c)) !== null) {\n                    break;\n                }\n                else {\n                    this.pos += 1;\n                }\n            }\n            if (this.pos === savepos && c !== C_CLOSE_PAREN) {\n                return null;\n            }\n            if (openparens !== 0) {\n                return null;\n            }\n            res = this.subject.substr(savepos, this.pos - savepos);\n            return normalizeURI(unescapeString(res));\n        } // chop off surrounding <..>:\n        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));\n    };\n    // Attempt to parse a link label, returning number of characters parsed.\n    InlineParser.prototype.parseLinkLabel = function () {\n        var m = this.match(reLinkLabel);\n        if (m === null || m.length > 1001) {\n            return 0;\n        }\n        return m.length;\n    };\n    // Add open bracket to delimiter stack and add a text node to block's children.\n    InlineParser.prototype.parseOpenBracket = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        var node = esm_text('[', this.sourcepos(this.pos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        this.addBracket(node, startpos, false);\n        return true;\n    };\n    // IF next character is [, and ! delimiter to delimiter stack and\n    // add a text node to block's children.  Otherwise just add a text node.\n    InlineParser.prototype.parseBang = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        if (this.peek() === C_OPEN_BRACKET$1) {\n            this.pos += 1;\n            var node = esm_text('![', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            // Add entry to stack for this opener\n            this.addBracket(node, startpos + 1, true);\n        }\n        else {\n            var node = esm_text('!', this.sourcepos(this.pos, this.pos));\n            block.appendChild(node);\n        }\n        return true;\n    };\n    // Try to match close bracket against an opening in the delimiter\n    // stack.  Add either a link or image, or a plain [ character,\n    // to block's children.  If there is a matching delimiter,\n    // remove it from the delimiter stack.\n    InlineParser.prototype.parseCloseBracket = function (block) {\n        var dest = null;\n        var title = null;\n        var matched = false;\n        this.pos += 1;\n        var startpos = this.pos;\n        // get last [ or ![\n        var opener = this.brackets;\n        if (opener === null) {\n            // no matched opener, just return a literal\n            block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));\n            return true;\n        }\n        if (!opener.active) {\n            // no matched opener, just return a literal\n            block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));\n            // take opener off brackets stack\n            this.removeBracket();\n            return true;\n        }\n        // If we got here, open is a potential opener\n        var isImage = opener.image;\n        // Check to see if we have a link/image\n        var savepos = this.pos;\n        // Inline link?\n        if (this.peek() === C_OPEN_PAREN) {\n            this.pos++;\n            if (this.spnl() &&\n                (dest = this.parseLinkDestination()) !== null &&\n                this.spnl() &&\n                // make sure there's a space before the title:\n                ((reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&\n                    (title = this.parseLinkTitle())) ||\n                    true) &&\n                this.spnl() &&\n                this.peek() === C_CLOSE_PAREN) {\n                this.pos += 1;\n                matched = true;\n            }\n            else {\n                this.pos = savepos;\n            }\n        }\n        var refLabel = '';\n        if (!matched) {\n            // Next, see if there's a link label\n            var beforelabel = this.pos;\n            var n = this.parseLinkLabel();\n            if (n > 2) {\n                refLabel = this.subject.slice(beforelabel, beforelabel + n);\n            }\n            else if (!opener.bracketAfter) {\n                // Empty or missing second label means to use the first label as the reference.\n                // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.\n                refLabel = this.subject.slice(opener.index, startpos);\n            }\n            if (n === 0) {\n                // If shortcut reference link, rewind before spaces we skipped.\n                this.pos = savepos;\n            }\n            if (refLabel) {\n                refLabel = normalizeReference(refLabel);\n                // lookup rawlabel in refMap\n                var link = this.refMap[refLabel];\n                if (link) {\n                    dest = link.destination;\n                    title = link.title;\n                    matched = true;\n                }\n            }\n        }\n        if (matched) {\n            var node = createNode(isImage ? 'image' : 'link');\n            node.destination = dest;\n            node.title = title || '';\n            node.sourcepos = [opener.startpos, this.sourcepos(this.pos)];\n            var tmp = opener.node.next;\n            var next = void 0;\n            while (tmp) {\n                next = tmp.next;\n                tmp.unlink();\n                node.appendChild(tmp);\n                tmp = next;\n            }\n            block.appendChild(node);\n            this.processEmphasis(opener.previousDelimiter);\n            this.removeBracket();\n            opener.node.unlink();\n            // We remove this bracket and processEmphasis will remove later delimiters.\n            // Now, for a link, we also deactivate earlier link openers.\n            // (no links in links)\n            if (!isImage) {\n                opener = this.brackets;\n                while (opener !== null) {\n                    if (!opener.image) {\n                        opener.active = false; // deactivate this opener\n                    }\n                    opener = opener.previous;\n                }\n            }\n            if (this.options.referenceDefinition) {\n                this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n            }\n            return true;\n        } // no match\n        this.removeBracket(); // remove this opener from stack\n        this.pos = startpos;\n        block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));\n        if (this.options.referenceDefinition) {\n            this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n        }\n        return true;\n    };\n    InlineParser.prototype.addBracket = function (node, index, image) {\n        if (this.brackets !== null) {\n            this.brackets.bracketAfter = true;\n        }\n        this.brackets = {\n            node: node,\n            startpos: this.sourcepos(index + (image ? 0 : 1)),\n            previous: this.brackets,\n            previousDelimiter: this.delimiters,\n            index: index,\n            image: image,\n            active: true,\n        };\n    };\n    InlineParser.prototype.removeBracket = function () {\n        if (this.brackets) {\n            this.brackets = this.brackets.previous;\n        }\n    };\n    // Attempt to parse an entity.\n    InlineParser.prototype.parseEntity = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEntityHere))) {\n            block.appendChild(esm_text(lib.decodeHTML(m), this.sourcepos(startpos, this.pos)));\n            return true;\n        }\n        return false;\n    };\n    // Parse a run of ordinary characters, or a single character with\n    // a special meaning in markdown, as a plain string.\n    InlineParser.prototype.parseString = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reMain))) {\n            if (this.options.smart) {\n                var lit = m.replace(reEllipses, '\\u2026').replace(reDash, function (chars) {\n                    var enCount = 0;\n                    var emCount = 0;\n                    if (chars.length % 3 === 0) {\n                        // If divisible by 3, use all em dashes\n                        emCount = chars.length / 3;\n                    }\n                    else if (chars.length % 2 === 0) {\n                        // If divisible by 2, use all en dashes\n                        enCount = chars.length / 2;\n                    }\n                    else if (chars.length % 3 === 2) {\n                        // If 2 extra dashes, use en dash for last 2; em dashes for rest\n                        enCount = 1;\n                        emCount = (chars.length - 2) / 3;\n                    }\n                    else {\n                        // Use en dashes for last 4 hyphens; em dashes for rest\n                        enCount = 2;\n                        emCount = (chars.length - 4) / 3;\n                    }\n                    return repeat('\\u2014', emCount) + repeat('\\u2013', enCount);\n                });\n                block.appendChild(esm_text(lit, this.sourcepos(startpos, this.pos)));\n            }\n            else {\n                var node = esm_text(m, this.sourcepos(startpos, this.pos));\n                block.appendChild(node);\n            }\n            return true;\n        }\n        return false;\n    };\n    // Parse a newline.  If it was preceded by two spaces, return a hard\n    // line break; otherwise a soft line break.\n    InlineParser.prototype.parseNewline = function (block) {\n        this.pos += 1; // assume we're at a \\n\n        // check previous node for trailing spaces\n        var lastc = block.lastChild;\n        if (lastc && lastc.type === 'text' && lastc.literal[lastc.literal.length - 1] === ' ') {\n            var hardbreak = lastc.literal[lastc.literal.length - 2] === ' ';\n            var litLen = lastc.literal.length;\n            lastc.literal = lastc.literal.replace(reFinalSpace, '');\n            var finalSpaceLen = litLen - lastc.literal.length;\n            lastc.sourcepos[1][1] -= finalSpaceLen;\n            block.appendChild(createNode(hardbreak ? 'linebreak' : 'softbreak', this.sourcepos(this.pos - finalSpaceLen, this.pos)));\n        }\n        else {\n            block.appendChild(createNode('softbreak', this.sourcepos(this.pos, this.pos)));\n        }\n        this.nextLine();\n        this.match(reInitialSpace); // gobble leading spaces in next line\n        return true;\n    };\n    // Attempt to parse a link reference, modifying refmap.\n    InlineParser.prototype.parseReference = function (block, refMap) {\n        if (!this.options.referenceDefinition) {\n            return 0;\n        }\n        this.subject = block.stringContent;\n        this.pos = 0;\n        var title = null;\n        var startpos = this.pos;\n        // label:\n        var matchChars = this.parseLinkLabel();\n        if (matchChars === 0) {\n            return 0;\n        }\n        var rawlabel = this.subject.substr(0, matchChars);\n        // colon:\n        if (this.peek() === C_COLON) {\n            this.pos++;\n        }\n        else {\n            this.pos = startpos;\n            return 0;\n        }\n        //  link url\n        this.spnl();\n        var dest = this.parseLinkDestination();\n        if (dest === null) {\n            this.pos = startpos;\n            return 0;\n        }\n        var beforetitle = this.pos;\n        this.spnl();\n        if (this.pos !== beforetitle) {\n            title = this.parseLinkTitle();\n        }\n        if (title === null) {\n            title = '';\n            // rewind before spaces\n            this.pos = beforetitle;\n        }\n        // make sure we're at line end:\n        var atLineEnd = true;\n        if (this.match(reSpaceAtEndOfLine) === null) {\n            if (title === '') {\n                atLineEnd = false;\n            }\n            else {\n                // the potential title we found is not at the line end,\n                // but it could still be a legal link reference if we\n                // discard the title\n                title = '';\n                // rewind before spaces\n                this.pos = beforetitle;\n                // and instead check if the link URL is at the line end\n                atLineEnd = this.match(reSpaceAtEndOfLine) !== null;\n            }\n        }\n        if (!atLineEnd) {\n            this.pos = startpos;\n            return 0;\n        }\n        var normalLabel = normalizeReference(rawlabel);\n        if (normalLabel === '') {\n            // label must contain non-whitespace characters\n            this.pos = startpos;\n            return 0;\n        }\n        var sourcepos = this.getReferenceDefSourcepos(block);\n        block.sourcepos[0][0] = sourcepos[1][0] + 1;\n        var node = createNode('refDef', sourcepos);\n        node.title = title;\n        node.dest = dest;\n        node.label = normalLabel;\n        block.insertBefore(node);\n        if (!refMap[normalLabel]) {\n            refMap[normalLabel] = createRefDefState(node);\n        }\n        else {\n            this.refDefCandidateMap[node.id] = node;\n        }\n        return this.pos - startpos;\n    };\n    InlineParser.prototype.mergeTextNodes = function (walker) {\n        var event;\n        var textNodes = [];\n        while ((event = walker.next())) {\n            var entering = event.entering, node = event.node;\n            if (entering && node.type === 'text') {\n                textNodes.push(node);\n            }\n            else if (textNodes.length === 1) {\n                textNodes = [];\n            }\n            else if (textNodes.length > 1) {\n                var firstNode = textNodes[0];\n                var lastNode = textNodes[textNodes.length - 1];\n                if (firstNode.sourcepos && lastNode.sourcepos) {\n                    firstNode.sourcepos[1] = lastNode.sourcepos[1];\n                }\n                firstNode.next = lastNode.next;\n                if (firstNode.next) {\n                    firstNode.next.prev = firstNode;\n                }\n                for (var i = 1; i < textNodes.length; i += 1) {\n                    firstNode.literal += textNodes[i].literal;\n                    textNodes[i].unlink();\n                }\n                textNodes = [];\n            }\n        }\n    };\n    InlineParser.prototype.getReferenceDefSourcepos = function (block) {\n        var lines = block.stringContent.split(/\\n|\\r\\n/);\n        var passedUrlLine = false;\n        var quotationCount = 0;\n        var lastLineOffset = { line: 0, ch: 0 };\n        for (var i = 0; i < lines.length; i += 1) {\n            var line = lines[i];\n            if (reWhitespaceChar.test(line)) {\n                break;\n            }\n            if (/\\:/.test(line) && quotationCount === 0) {\n                if (passedUrlLine) {\n                    break;\n                }\n                var lineOffset = line.indexOf(':') === line.length - 1 ? i + 1 : i;\n                lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };\n                passedUrlLine = true;\n            }\n            // should consider extendable title\n            var matched = line.match(/'|\"/g);\n            if (matched) {\n                quotationCount += matched.length;\n            }\n            if (quotationCount === 2) {\n                lastLineOffset = { line: i, ch: line.length };\n                break;\n            }\n        }\n        return [\n            [block.sourcepos[0][0], block.sourcepos[0][1]],\n            [block.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch],\n        ];\n    };\n    // Parse the next inline element in subject, advancing subject position.\n    // On success, add the result to block's children and return true.\n    // On failure, return false.\n    InlineParser.prototype.parseInline = function (block) {\n        var _a;\n        var res = false;\n        var c = this.peek();\n        if (c === -1) {\n            return false;\n        }\n        switch (c) {\n            case C_NEWLINE:\n                res = this.parseNewline(block);\n                break;\n            case C_BACKSLASH:\n                res = this.parseBackslash(block);\n                break;\n            case C_BACKTICK:\n                res = this.parseBackticks(block);\n                break;\n            case C_ASTERISK:\n            case C_UNDERSCORE:\n            case C_TILDE:\n            case C_DOLLAR:\n                res = this.handleDelim(c, block);\n                break;\n            case C_SINGLEQUOTE:\n            case C_DOUBLEQUOTE:\n                res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block);\n                break;\n            case C_OPEN_BRACKET$1:\n                res = this.parseOpenBracket(block);\n                break;\n            case C_BANG:\n                res = this.parseBang(block);\n                break;\n            case C_CLOSE_BRACKET:\n                res = this.parseCloseBracket(block);\n                break;\n            case C_LESSTHAN$1:\n                res = this.parseAutolink(block) || this.parseHtmlTag(block);\n                break;\n            case C_AMPERSAND:\n                if (!block.disabledEntityParse) {\n                    res = this.parseEntity(block);\n                }\n                break;\n            default:\n                res = this.parseString(block);\n                break;\n        }\n        if (!res) {\n            this.pos += 1;\n            block.appendChild(esm_text(fromCodePoint$1(c), this.sourcepos(this.pos, this.pos + 1)));\n        }\n        return true;\n    };\n    // Parse string content in block into inline children,\n    // using refmap to resolve references.\n    InlineParser.prototype.parse = function (block) {\n        this.subject = block.stringContent.trim();\n        this.pos = 0;\n        this.delimiters = null;\n        this.brackets = null;\n        this.lineOffsets = block.lineOffsets || [0];\n        this.lineIdx = 0;\n        this.linePosOffset = 0;\n        this.lineStartNum = block.sourcepos[0][0];\n        if (isHeading(block)) {\n            this.lineOffsets[0] += block.level + 1;\n        }\n        while (this.parseInline(block)) { }\n        block.stringContent = null; // allow raw string to be garbage collected\n        this.processEmphasis(null);\n        this.mergeTextNodes(block.walker());\n        var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;\n        if (extendedAutolinks) {\n            convertExtAutoLinks(block.walker(), extendedAutolinks);\n        }\n        if (customParser && block.firstChild) {\n            var event_1;\n            var walker = block.firstChild.walker();\n            while ((event_1 = walker.next())) {\n                var node = event_1.node, entering = event_1.entering;\n                if (customParser[node.type]) {\n                    customParser[node.type](node, { entering: entering, options: this.options });\n                }\n            }\n        }\n    };\n    return InlineParser;\n}());\nvar reTaskListItemMarker = /^\\[([ \\txX])\\][ \\t]+/;\n// finalize for block handler\nfunction taskListItemFinalize(_, block) {\n    if (block.firstChild && block.firstChild.type === 'paragraph') {\n        var p = block.firstChild;\n        var m = p.stringContent.match(reTaskListItemMarker);\n        if (m) {\n            var mLen = m[0].length;\n            p.stringContent = p.stringContent.substring(mLen - 1);\n            p.sourcepos[0][1] += mLen;\n            p.lineOffsets[0] += mLen;\n            block.listData.task = true;\n            block.listData.checked = /[xX]/.test(m[1]);\n        }\n    }\n}\nvar table = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableHead' || t === 'tableBody';\n    },\n    acceptsLines: false,\n};\nvar tableBody$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow';\n    },\n    acceptsLines: false,\n};\nvar tableHead$1 = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow' || t === 'tableDelimRow';\n    },\n    acceptsLines: false,\n};\nvar tableDelimRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableDelimCell';\n    },\n    acceptsLines: false,\n};\nvar tableDelimCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar tableRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableCell';\n    },\n    acceptsLines: false,\n};\nvar tableCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar CODE_INDENT = 4;\nvar C_TAB = 9;\nvar C_GREATERTHAN = 62;\nvar C_LESSTHAN = 60;\nvar C_SPACE = 32;\nvar C_OPEN_BRACKET = 91;\nvar reNonSpace = /[^ \\t\\f\\v\\r\\n]/;\nvar reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;\n// Returns true if block ends with a blank line, descending if needed\n// into lists and sublists.\nfunction endsWithBlankLine(block) {\n    var curBlock = block;\n    while (curBlock) {\n        if (curBlock.lastLineBlank) {\n            return true;\n        }\n        var t = curBlock.type;\n        if (!curBlock.lastLineChecked && (t === 'list' || t === 'item')) {\n            curBlock.lastLineChecked = true;\n            curBlock = curBlock.lastChild;\n        }\n        else {\n            curBlock.lastLineChecked = true;\n            break;\n        }\n    }\n    return false;\n}\nfunction peek(ln, pos) {\n    if (pos < ln.length) {\n        return ln.charCodeAt(pos);\n    }\n    return -1;\n}\n// Returns true if string contains only space characters.\nfunction isBlank(s) {\n    return !reNonSpace.test(s);\n}\nfunction isSpaceOrTab(c) {\n    return c === C_SPACE || c === C_TAB;\n}\nvar reClosingCustomBlock = /^\\$\\$$/;\nvar customBlock$1 = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reClosingCustomBlock);\n        if (match) {\n            // closing custom block\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        // skip optional spaces of custom block offset\n        var i = container.offset;\n        while (i > 0 && isSpaceOrTab(peek(line, parser.offset))) {\n            parser.advanceOffset(1, true);\n            i--;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        // first line becomes info string\n        var content = block.stringContent;\n        var newlinePos = content.indexOf('\\n');\n        var firstLine = content.slice(0, newlinePos);\n        var rest = content.slice(newlinePos + 1);\n        var infoString = firstLine.match(/^(\\s*)(.*)/);\n        block.info = unescapeString(infoString[2].trim());\n        block.literal = rest;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar noop = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar document$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar list = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var item = block.firstChild;\n        while (item) {\n            // check for non-final list item ending with blank line:\n            if (endsWithBlankLine(item) && item.next) {\n                block.listData.tight = false;\n                break;\n            }\n            // recurse into children of list item, to see if there are\n            // spaces between any of them:\n            var subitem = item.firstChild;\n            while (subitem) {\n                if (endsWithBlankLine(subitem) && (item.next || subitem.next)) {\n                    block.listData.tight = false;\n                    break;\n                }\n                subitem = subitem.next;\n            }\n            item = item.next;\n        }\n    },\n    canContain: function (t) {\n        return t === 'item';\n    },\n    acceptsLines: false,\n};\nvar blockQuote$1 = {\n    continue: function (parser) {\n        var ln = parser.currentLine;\n        if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {\n            parser.advanceNextNonspace();\n            parser.advanceOffset(1, false);\n            if (isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n            }\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar item = {\n    continue: function (parser, container) {\n        if (parser.blank) {\n            if (container.firstChild === null) {\n                // Blank line after empty list item\n                return 1 /* Stop */;\n            }\n            parser.advanceNextNonspace();\n        }\n        else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {\n            parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: taskListItemFinalize,\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar heading = {\n    continue: function () {\n        // a heading can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar thematicBreak$1 = {\n    continue: function () {\n        // a thematic break can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar codeBlock = {\n    continue: function (parser, container) {\n        var ln = parser.currentLine;\n        var indent = parser.indent;\n        if (container.isFenced) {\n            // fenced\n            var match = indent <= 3 &&\n                ln.charAt(parser.nextNonspace) === container.fenceChar &&\n                ln.slice(parser.nextNonspace).match(reClosingCodeFence);\n            if (match && match[0].length >= container.fenceLength) {\n                // closing fence - we're at end of line, so we can return\n                parser.lastLineLength = parser.offset + indent + match[0].length;\n                parser.finalize(container, parser.lineNumber);\n                return 2 /* Finished */;\n            }\n            // skip optional spaces of fence offset\n            var i = container.fenceOffset;\n            while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n                i--;\n            }\n        }\n        else {\n            // indented\n            if (indent >= CODE_INDENT) {\n                parser.advanceOffset(CODE_INDENT, true);\n            }\n            else if (parser.blank) {\n                parser.advanceNextNonspace();\n            }\n            else {\n                return 1 /* Stop */;\n            }\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        if (block.stringContent === null) {\n            return;\n        }\n        if (block.isFenced) {\n            // fenced\n            // first line becomes info string\n            var content = block.stringContent;\n            var newlinePos = content.indexOf('\\n');\n            var firstLine = content.slice(0, newlinePos);\n            var rest = content.slice(newlinePos + 1);\n            var infoString = firstLine.match(/^(\\s*)(.*)/);\n            block.infoPadding = infoString[1].length;\n            block.info = unescapeString(infoString[2].trim());\n            block.literal = rest;\n        }\n        else {\n            // indented\n            block.literal = (_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '\\n');\n        }\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar htmlBlock$1 = {\n    continue: function (parser, container) {\n        return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7)\n            ? 1 /* Stop */\n            : 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        block.literal = ((_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '')) || null;\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar paragraph = {\n    continue: function (parser) {\n        return parser.blank ? 1 /* Stop */ : 0 /* Go */;\n    },\n    finalize: function (parser, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        var pos;\n        var hasReferenceDefs = false;\n        // try parsing the beginning as link reference definitions:\n        while (peek(block.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(block, parser.refMap))) {\n            block.stringContent = block.stringContent.slice(pos);\n            hasReferenceDefs = true;\n        }\n        if (hasReferenceDefs && isBlank(block.stringContent)) {\n            block.unlink();\n        }\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar refDef = noop;\nvar frontMatter$2 = noop;\nvar blockHandlers = {\n    document: document$1,\n    list: list,\n    blockQuote: blockQuote$1,\n    item: item,\n    heading: heading,\n    thematicBreak: thematicBreak$1,\n    codeBlock: codeBlock,\n    htmlBlock: htmlBlock$1,\n    paragraph: paragraph,\n    table: table,\n    tableBody: tableBody$1,\n    tableHead: tableHead$1,\n    tableRow: tableRow,\n    tableCell: tableCell,\n    tableDelimRow: tableDelimRow,\n    tableDelimCell: tableDelimCell,\n    refDef: refDef,\n    customBlock: customBlock$1,\n    frontMatter: frontMatter$2,\n};\nfunction parseRowContent(content) {\n    var startIdx = 0;\n    var offset = 0;\n    var cells = [];\n    for (var i = 0; i < content.length; i += 1) {\n        if (content[i] === '|' && content[i - 1] !== '\\\\') {\n            var cell = content.substring(startIdx, i);\n            if (startIdx === 0 && isEmpty(cell)) {\n                offset = i + 1;\n            }\n            else {\n                cells.push(cell);\n            }\n            startIdx = i + 1;\n        }\n    }\n    if (startIdx < content.length) {\n        var cell = content.substring(startIdx, content.length);\n        if (!isEmpty(cell)) {\n            cells.push(cell);\n        }\n    }\n    return [offset, cells];\n}\nfunction generateTableCells(cellType, contents, lineNum, chPos) {\n    var cells = [];\n    for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {\n        var content = contents_1[_i];\n        var preSpaces = content.match(/^[ \\t]+/);\n        var paddingLeft = preSpaces ? preSpaces[0].length : 0;\n        var paddingRight = void 0, trimmed = void 0;\n        if (paddingLeft === content.length) {\n            paddingLeft = 0;\n            paddingRight = 0;\n            trimmed = '';\n        }\n        else {\n            var postSpaces = content.match(/[ \\t]+$/);\n            paddingRight = postSpaces ? postSpaces[0].length : 0;\n            trimmed = content.slice(paddingLeft, content.length - paddingRight);\n        }\n        var chPosStart = chPos + paddingLeft;\n        var tableCell = createNode(cellType, [\n            [lineNum, chPos],\n            [lineNum, chPos + content.length - 1],\n        ]);\n        tableCell.stringContent = trimmed.replace(/\\\\\\|/g, '|'); // replace esacped pipe(\\|)\n        tableCell.startIdx = cells.length;\n        tableCell.endIdx = cells.length;\n        tableCell.lineOffsets = [chPosStart - 1];\n        tableCell.paddingLeft = paddingLeft;\n        tableCell.paddingRight = paddingRight;\n        cells.push(tableCell);\n        chPos += content.length + 1;\n    }\n    return cells;\n}\nfunction getColumnFromDelimCell(cellNode) {\n    var align = null;\n    var content = cellNode.stringContent;\n    var firstCh = content[0];\n    var lastCh = content[content.length - 1];\n    if (lastCh === ':') {\n        align = firstCh === ':' ? 'center' : 'right';\n    }\n    else if (firstCh === ':') {\n        align = 'left';\n    }\n    return { align: align };\n}\nvar tableHead = function (parser, container) {\n    var stringContent = container.stringContent;\n    if (container.type === 'paragraph' && !parser.indented && !parser.blank) {\n        var lastNewLineIdx = stringContent.length - 1;\n        var lastLineStartIdx = stringContent.lastIndexOf('\\n', lastNewLineIdx - 1) + 1;\n        var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);\n        var delimContent = parser.currentLine.slice(parser.nextNonspace);\n        var _a = parseRowContent(headerContent), headerOffset = _a[0], headerCells = _a[1];\n        var _b = parseRowContent(delimContent), delimOffset = _b[0], delimCells = _b[1];\n        var reValidDelimCell_1 = /^[ \\t]*:?-+:?[ \\t]*$/;\n        if (\n        // not checking if the number of header cells and delimiter cells are the same\n        // to consider the case of merged-column (via plugin)\n        !headerCells.length ||\n            !delimCells.length ||\n            delimCells.some(function (cell) { return !reValidDelimCell_1.test(cell); }) ||\n            // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option\n            (delimCells.length === 1 && delimContent.indexOf('|') !== 0)) {\n            return 0 /* None */;\n        }\n        var lineOffsets = container.lineOffsets;\n        var firstLineNum = parser.lineNumber - 1;\n        var firstLineStart = last(lineOffsets) + 1;\n        var table = createNode('table', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        // eslint-disable-next-line arrow-body-style\n        table.columns = delimCells.map(function () { return ({ align: null }); });\n        container.insertAfter(table);\n        if (lineOffsets.length === 1) {\n            container.unlink();\n        }\n        else {\n            container.stringContent = stringContent.slice(0, lastLineStartIdx);\n            var paraLastLineStartIdx = stringContent.lastIndexOf('\\n', lastLineStartIdx - 2) + 1;\n            var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;\n            parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;\n            parser.finalize(container, firstLineNum - 1);\n        }\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        var tableHead_1 = createNode('tableHead', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        table.appendChild(tableHead_1);\n        var tableHeadRow_1 = createNode('tableRow', [\n            [firstLineNum, firstLineStart],\n            [firstLineNum, firstLineStart + headerContent.length - 1],\n        ]);\n        var tableDelimRow_1 = createNode('tableDelimRow', [\n            [parser.lineNumber, parser.nextNonspace + 1],\n            [parser.lineNumber, parser.offset],\n        ]);\n        tableHead_1.appendChild(tableHeadRow_1);\n        tableHead_1.appendChild(tableDelimRow_1);\n        generateTableCells('tableCell', headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function (cellNode) {\n            tableHeadRow_1.appendChild(cellNode);\n        });\n        var delimCellNodes = generateTableCells('tableDelimCell', delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);\n        delimCellNodes.forEach(function (cellNode) {\n            tableDelimRow_1.appendChild(cellNode);\n        });\n        table.columns = delimCellNodes.map(getColumnFromDelimCell);\n        parser.tip = table;\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar tableBody = function (parser, container) {\n    if ((container.type !== 'table' && container.type !== 'tableBody') ||\n        (!parser.blank && parser.currentLine.indexOf('|') === -1)) {\n        return 0 /* None */;\n    }\n    parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n    if (parser.blank) {\n        var table_1 = container;\n        if (container.type === 'tableBody') {\n            table_1 = container.parent;\n            parser.finalize(container, parser.lineNumber - 1);\n        }\n        parser.finalize(table_1, parser.lineNumber - 1);\n        return 0 /* None */;\n    }\n    var tableBody = container;\n    if (container.type === 'table') {\n        tableBody = parser.addChild('tableBody', parser.nextNonspace);\n        tableBody.stringContent = null;\n    }\n    var tableRow = createNode('tableRow', [\n        [parser.lineNumber, parser.nextNonspace + 1],\n        [parser.lineNumber, parser.currentLine.length],\n    ]);\n    tableBody.appendChild(tableRow);\n    var table = tableBody.parent;\n    var content = parser.currentLine.slice(parser.nextNonspace);\n    var _a = parseRowContent(content), offset = _a[0], cellContents = _a[1];\n    generateTableCells('tableCell', cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset).forEach(function (cellNode, idx) {\n        if (idx >= table.columns.length) {\n            cellNode.ignored = true;\n        }\n        tableRow.appendChild(cellNode);\n    });\n    return 2 /* Leaf */;\n};\nvar reCustomBlock = /^(\\$\\$)(\\s*[a-zA-Z])+/;\nvar reCanBeCustomInline = /^(\\$\\$)(\\s*[a-zA-Z])+.*(\\$\\$)/;\nvar customBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        !reCanBeCustomInline.test(parser.currentLine) &&\n        (match = parser.currentLine.match(reCustomBlock))) {\n        var syntaxLength = match[1].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('customBlock', parser.nextNonspace);\n        container.syntaxLength = syntaxLength;\n        container.offset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(syntaxLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;\nvar reHtmlBlockOpen = [\n    /./,\n    /^<(?:script|pre|style)(?:\\s|>|$)/i,\n    /^<!--/,\n    /^<[?]/,\n    /^<![A-Z]/,\n    /^<!\\[CDATA\\[/,\n    /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|[/]?[>]|$)/i,\n    new RegExp(\"^(?:\" + OPENTAG + \"|\" + CLOSETAG + \")\\\\s*$\", 'i'),\n];\nvar reSetextHeadingLine = /^(?:=+|-+)[ \\t]*$/;\nvar reATXHeadingMarker = /^#{1,6}(?:[ \\t]+|$)/;\nvar reThematicBreak = /^(?:(?:\\*[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:-[ \\t]*){3,})[ \\t]*$/;\nvar reBulletListMarker = /^[*+-]/;\nvar reOrderedListMarker = /^(\\d{1,9})([.)])/;\n// Parse a list marker and return data on the marker (type,\n// start, delimiter, bullet character, padding) or null.\nfunction parseListMarker(parser, container) {\n    var rest = parser.currentLine.slice(parser.nextNonspace);\n    var match;\n    var nextc;\n    var data = {\n        type: 'bullet',\n        tight: true,\n        bulletChar: '',\n        start: 0,\n        delimiter: '',\n        padding: 0,\n        markerOffset: parser.indent,\n        // GFM: Task List Item\n        task: false,\n        checked: false,\n    };\n    if (parser.indent >= 4) {\n        return null;\n    }\n    if ((match = rest.match(reBulletListMarker))) {\n        data.type = 'bullet';\n        data.bulletChar = match[0][0];\n    }\n    else if ((match = rest.match(reOrderedListMarker)) &&\n        (container.type !== 'paragraph' || match[1] === '1')) {\n        data.type = 'ordered';\n        data.start = parseInt(match[1], 10);\n        data.delimiter = match[2];\n    }\n    else {\n        return null;\n    }\n    // make sure we have spaces after\n    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);\n    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {\n        return null;\n    }\n    // if it interrupts paragraph, make sure first line isn't blank\n    if (container.type === 'paragraph' &&\n        !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {\n        return null;\n    }\n    // we've got a match! advance offset and calculate padding\n    parser.advanceNextNonspace(); // to start of marker\n    parser.advanceOffset(match[0].length, true); // to end of marker\n    var spacesStartCol = parser.column;\n    var spacesStartOffset = parser.offset;\n    do {\n        parser.advanceOffset(1, true);\n        nextc = peek(parser.currentLine, parser.offset);\n    } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));\n    var blankItem = peek(parser.currentLine, parser.offset) === -1;\n    var spacesAfterMarker = parser.column - spacesStartCol;\n    if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {\n        data.padding = match[0].length + 1;\n        parser.column = spacesStartCol;\n        parser.offset = spacesStartOffset;\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n    }\n    else {\n        data.padding = match[0].length + spacesAfterMarker;\n    }\n    return data;\n}\n// Returns true if the two list items are of the same type,\n// with the same delimiter and bullet character.  This is used\n// in agglomerating list items into lists.\nfunction listsMatch(listData, itemData) {\n    return (listData.type === itemData.type &&\n        listData.delimiter === itemData.delimiter &&\n        listData.bulletChar === itemData.bulletChar);\n}\nfunction isDisallowedDeepHeading(parser, node) {\n    return parser.options.disallowDeepHeading && (node.type === 'blockQuote' || node.type === 'item');\n}\nvar blockQuote = function (parser) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(1, false);\n        // optional following space\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n        parser.closeUnmatchedBlocks();\n        parser.addChild('blockQuote', parser.nextNonspace);\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\nvar atxHeading = function (parser, container) {\n    var match;\n    if (!parser.indented &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(match[0].length, false);\n        parser.closeUnmatchedBlocks();\n        var heading = parser.addChild('heading', parser.nextNonspace);\n        heading.level = match[0].trim().length; // number of #s\n        heading.headingType = 'atx';\n        // remove trailing ###s:\n        heading.stringContent = parser.currentLine\n            .slice(parser.offset)\n            .replace(/^[ \\t]*#+[ \\t]*$/, '')\n            .replace(/[ \\t]+#+[ \\t]*$/, '');\n        parser.advanceOffset(parser.currentLine.length - parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar fencedCodeBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {\n        var fenceLength = match[0].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('codeBlock', parser.nextNonspace);\n        container.isFenced = true;\n        container.fenceLength = fenceLength;\n        container.fenceChar = match[0][0];\n        container.fenceOffset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(fenceLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar htmlBlock = function (parser, container) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {\n        var s = parser.currentLine.slice(parser.nextNonspace);\n        var disallowedTags = parser.options.disallowedHtmlBlockTags;\n        var blockType = void 0;\n        for (blockType = 1; blockType <= 7; blockType++) {\n            var matched = s.match(reHtmlBlockOpen[blockType]);\n            if (matched) {\n                if (blockType === 7) {\n                    if (container.type === 'paragraph') {\n                        return 0 /* None */;\n                    }\n                    if (disallowedTags.length > 0) {\n                        var reDisallowedTags = new RegExp(\"</?(?:\" + disallowedTags.join('|') + \")\", 'i');\n                        if (reDisallowedTags.test(matched[0])) {\n                            return 0 /* None */;\n                        }\n                    }\n                }\n                parser.closeUnmatchedBlocks();\n                // We don't adjust parser.offset;\n                // spaces are part of the HTML block:\n                var b = parser.addChild('htmlBlock', parser.offset);\n                b.htmlBlockType = blockType;\n                return 2 /* Leaf */;\n            }\n        }\n    }\n    return 0 /* None */;\n};\nvar seTextHeading = function (parser, container) {\n    var match;\n    if (container.stringContent !== null &&\n        !parser.indented &&\n        container.type === 'paragraph' &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container.parent) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {\n        parser.closeUnmatchedBlocks();\n        // resolve reference link definitions\n        var pos = void 0;\n        while (peek(container.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(container, parser.refMap))) {\n            container.stringContent = container.stringContent.slice(pos);\n        }\n        if (container.stringContent.length > 0) {\n            var heading = createNode('heading', container.sourcepos);\n            heading.level = match[0][0] === '=' ? 1 : 2;\n            heading.headingType = 'setext';\n            heading.stringContent = container.stringContent;\n            container.insertAfter(heading);\n            container.unlink();\n            parser.tip = heading;\n            parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n            return 2 /* Leaf */;\n        }\n        return 0 /* None */;\n    }\n    return 0 /* None */;\n};\nvar thematicBreak = function (parser) {\n    if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {\n        parser.closeUnmatchedBlocks();\n        parser.addChild('thematicBreak', parser.nextNonspace);\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar listItem = function (parser, container) {\n    var data;\n    var currNode = container;\n    if ((!parser.indented || container.type === 'list') &&\n        (data = parseListMarker(parser, currNode))) {\n        parser.closeUnmatchedBlocks();\n        // add the list if needed\n        if (parser.tip.type !== 'list' || !listsMatch(currNode.listData, data)) {\n            currNode = parser.addChild('list', parser.nextNonspace);\n            currNode.listData = data;\n        }\n        // add the list item\n        currNode = parser.addChild('item', parser.nextNonspace);\n        currNode.listData = data;\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\n// indented code block\nvar indentedCodeBlock = function (parser) {\n    if (parser.indented && parser.tip.type !== 'paragraph' && !parser.blank) {\n        // indented code\n        parser.advanceOffset(CODE_INDENT, true);\n        parser.closeUnmatchedBlocks();\n        parser.addChild('codeBlock', parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar blockStarts = [\n    blockQuote,\n    atxHeading,\n    fencedCodeBlock,\n    htmlBlock,\n    seTextHeading,\n    thematicBreak,\n    listItem,\n    indentedCodeBlock,\n    tableHead,\n    tableBody,\n    customBlock,\n];\n// `---` for YAML, `+++` for TOML, `;;;` for JSON\nvar reFrontMatter = /^(-{3}|\\+{3}|;{3})$/;\nvar frontMatter$1 = function (parser, container) {\n    var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;\n    if (lineNumber === 1 &&\n        !indented &&\n        container.type === 'document' &&\n        reFrontMatter.test(currentLine)) {\n        parser.closeUnmatchedBlocks();\n        var frontMatter_1 = parser.addChild('frontMatter', parser.nextNonspace);\n        frontMatter_1.stringContent = currentLine;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(currentLine.length, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar frontMatter = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reFrontMatter);\n        if (container.type === 'frontMatter' && match) {\n            container.stringContent += line;\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        block.literal = block.stringContent;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar reHtmlBlockClose = [\n    /./,\n    /<\\/(?:script|pre|style)>/i,\n    /-->/,\n    /\\?>/,\n    />/,\n    /\\]\\]>/,\n];\nvar reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/;\nvar reLineEnding$1 = /\\r\\n|\\n|\\r/;\nfunction esm_document() {\n    return createNode('document', [\n        [1, 1],\n        [0, 0],\n    ]);\n}\nvar defaultOptions$1 = {\n    smart: false,\n    tagFilter: false,\n    extendedAutolinks: false,\n    disallowedHtmlBlockTags: [],\n    referenceDefinition: false,\n    disallowDeepHeading: false,\n    customParser: null,\n    frontMatter: false,\n};\nvar Parser = /** @class */ (function () {\n    function Parser(options) {\n        this.options = esm_assign(esm_assign({}, defaultOptions$1), options);\n        this.doc = esm_document();\n        this.tip = this.doc;\n        this.oldtip = this.doc;\n        this.lineNumber = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.nextNonspace = 0;\n        this.nextNonspaceColumn = 0;\n        this.indent = 0;\n        this.currentLine = '';\n        this.indented = false;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.allClosed = true;\n        this.lastMatchedContainer = this.doc;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.lastLineLength = 0;\n        this.lines = [];\n        if (this.options.frontMatter) {\n            blockHandlers.frontMatter = frontMatter;\n            blockStarts.unshift(frontMatter$1);\n        }\n        this.inlineParser = new InlineParser(this.options);\n    }\n    Parser.prototype.advanceOffset = function (count, columns) {\n        if (columns === void 0) {\n            columns = false;\n        }\n        var currentLine = this.currentLine;\n        var charsToTab, charsToAdvance;\n        var c;\n        while (count > 0 && (c = currentLine[this.offset])) {\n            if (c === '\\t') {\n                charsToTab = 4 - (this.column % 4);\n                if (columns) {\n                    this.partiallyConsumedTab = charsToTab > count;\n                    charsToAdvance = charsToTab > count ? count : charsToTab;\n                    this.column += charsToAdvance;\n                    this.offset += this.partiallyConsumedTab ? 0 : 1;\n                    count -= charsToAdvance;\n                }\n                else {\n                    this.partiallyConsumedTab = false;\n                    this.column += charsToTab;\n                    this.offset += 1;\n                    count -= 1;\n                }\n            }\n            else {\n                this.partiallyConsumedTab = false;\n                this.offset += 1;\n                this.column += 1; // assume ascii; block starts are ascii\n                count -= 1;\n            }\n        }\n    };\n    Parser.prototype.advanceNextNonspace = function () {\n        this.offset = this.nextNonspace;\n        this.column = this.nextNonspaceColumn;\n        this.partiallyConsumedTab = false;\n    };\n    Parser.prototype.findNextNonspace = function () {\n        var currentLine = this.currentLine;\n        var i = this.offset;\n        var cols = this.column;\n        var c;\n        while ((c = currentLine.charAt(i)) !== '') {\n            if (c === ' ') {\n                i++;\n                cols++;\n            }\n            else if (c === '\\t') {\n                i++;\n                cols += 4 - (cols % 4);\n            }\n            else {\n                break;\n            }\n        }\n        this.blank = c === '\\n' || c === '\\r' || c === '';\n        this.nextNonspace = i;\n        this.nextNonspaceColumn = cols;\n        this.indent = this.nextNonspaceColumn - this.column;\n        this.indented = this.indent >= CODE_INDENT;\n    };\n    // Add a line to the block at the tip.  We assume the tip\n    // can accept lines -- that check should be done before calling this.\n    Parser.prototype.addLine = function () {\n        if (this.partiallyConsumedTab) {\n            this.offset += 1; // skip over tab\n            // add space characters:\n            var charsToTab = 4 - (this.column % 4);\n            this.tip.stringContent += repeat(' ', charsToTab);\n        }\n        if (this.tip.lineOffsets) {\n            this.tip.lineOffsets.push(this.offset);\n        }\n        else {\n            this.tip.lineOffsets = [this.offset];\n        }\n        this.tip.stringContent += this.currentLine.slice(this.offset) + \"\\n\";\n    };\n    // Add block of type tag as a child of the tip.  If the tip can't\n    // accept children, close and finalize it and try its parent,\n    // and so on til we find a block that can accept children.\n    Parser.prototype.addChild = function (tag, offset) {\n        while (!blockHandlers[this.tip.type].canContain(tag)) {\n            this.finalize(this.tip, this.lineNumber - 1);\n        }\n        var columnNumber = offset + 1; // offset 0 = column 1\n        var newBlock = createNode(tag, [\n            [this.lineNumber, columnNumber],\n            [0, 0],\n        ]);\n        newBlock.stringContent = '';\n        this.tip.appendChild(newBlock);\n        this.tip = newBlock;\n        return newBlock;\n    };\n    // Finalize and close any unmatched blocks.\n    Parser.prototype.closeUnmatchedBlocks = function () {\n        if (!this.allClosed) {\n            // finalize any blocks not matched\n            while (this.oldtip !== this.lastMatchedContainer) {\n                var parent_1 = this.oldtip.parent;\n                this.finalize(this.oldtip, this.lineNumber - 1);\n                this.oldtip = parent_1;\n            }\n            this.allClosed = true;\n        }\n    };\n    // Finalize a block.  Close it and do any necessary postprocessing,\n    // e.g. creating stringContent from strings, setting the 'tight'\n    // or 'loose' status of a list, and parsing the beginnings\n    // of paragraphs for reference definitions.  Reset the tip to the\n    // parent of the closed block.\n    Parser.prototype.finalize = function (block, lineNumber) {\n        var above = block.parent;\n        block.open = false;\n        block.sourcepos[1] = [lineNumber, this.lastLineLength];\n        blockHandlers[block.type].finalize(this, block);\n        this.tip = above;\n    };\n    // Walk through a block & children recursively, parsing string content\n    // into inline content where appropriate.\n    Parser.prototype.processInlines = function (block) {\n        var event;\n        var customParser = this.options.customParser;\n        var walker = block.walker();\n        this.inlineParser.refMap = this.refMap;\n        this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;\n        this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;\n        this.inlineParser.options = this.options;\n        while ((event = walker.next())) {\n            var node = event.node, entering = event.entering;\n            var t = node.type;\n            if (customParser && customParser[t]) {\n                customParser[t](node, { entering: entering, options: this.options });\n            }\n            if (!entering &&\n                (t === 'paragraph' ||\n                    t === 'heading' ||\n                    (t === 'tableCell' && !node.ignored))) {\n                this.inlineParser.parse(node);\n            }\n        }\n    };\n    // Analyze a line of text and update the document appropriately.\n    // We parse markdown text by calling this on each line of input,\n    // then finalizing the document.\n    Parser.prototype.incorporateLine = function (ln) {\n        var container = this.doc;\n        this.oldtip = this.tip;\n        this.offset = 0;\n        this.column = 0;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.lineNumber += 1;\n        // replace NUL characters for security\n        if (ln.indexOf('\\u0000') !== -1) {\n            ln = ln.replace(/\\0/g, '\\uFFFD');\n        }\n        this.currentLine = ln;\n        // For each containing block, try to parse the associated line start.\n        // Bail out on failure: container will point to the last matching block.\n        // Set allMatched to false if not all containers match.\n        var allMatched = true;\n        var lastChild;\n        while ((lastChild = container.lastChild) && lastChild.open) {\n            container = lastChild;\n            this.findNextNonspace();\n            switch (blockHandlers[container.type]['continue'](this, container)) {\n                case 0 /* Go */: // we've matched, keep going\n                    break;\n                case 1 /* Stop */: // we've failed to match a block\n                    allMatched = false;\n                    break;\n                case 2 /* Finished */: // we've hit end of line for fenced code close and can return\n                    this.lastLineLength = ln.length;\n                    return;\n                default:\n                    throw new Error('continue returned illegal value, must be 0, 1, or 2');\n            }\n            if (!allMatched) {\n                container = container.parent; // back up to last matching block\n                break;\n            }\n        }\n        this.allClosed = container === this.oldtip;\n        this.lastMatchedContainer = container;\n        var matchedLeaf = container.type !== 'paragraph' && blockHandlers[container.type].acceptsLines;\n        var blockStartsLen = blockStarts.length;\n        // Unless last matched container is a code block, try new container starts,\n        // adding children to the last matched container:\n        while (!matchedLeaf) {\n            this.findNextNonspace();\n            // this is a little performance optimization:\n            if (container.type !== 'table' &&\n                container.type !== 'tableBody' &&\n                container.type !== 'paragraph' &&\n                !this.indented &&\n                !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {\n                this.advanceNextNonspace();\n                break;\n            }\n            var i = 0;\n            while (i < blockStartsLen) {\n                var res = blockStarts[i](this, container);\n                if (res === 1 /* Container */) {\n                    container = this.tip;\n                    break;\n                }\n                else if (res === 2 /* Leaf */) {\n                    container = this.tip;\n                    matchedLeaf = true;\n                    break;\n                }\n                else {\n                    i++;\n                }\n            }\n            if (i === blockStartsLen) {\n                // nothing matched\n                this.advanceNextNonspace();\n                break;\n            }\n        }\n        // What remains at the offset is a text line.  Add the text to the\n        // appropriate container.\n        // First check for a lazy paragraph continuation:\n        if (!this.allClosed && !this.blank && this.tip.type === 'paragraph') {\n            // lazy paragraph continuation\n            this.addLine();\n        }\n        else {\n            // not a lazy continuation\n            // finalize any blocks not matched\n            this.closeUnmatchedBlocks();\n            if (this.blank && container.lastChild) {\n                container.lastChild.lastLineBlank = true;\n            }\n            var t = container.type;\n            // Block quote lines are never blank as they start with >\n            // and we don't count blanks in fenced code for purposes of tight/loose\n            // lists or breaking out of lists. We also don't set _lastLineBlank\n            // on an empty list item, or if we just closed a fenced block.\n            var lastLineBlank = this.blank &&\n                !(t === 'blockQuote' ||\n                    (isCodeBlock(container) && container.isFenced) ||\n                    (t === 'item' && !container.firstChild && container.sourcepos[0][0] === this.lineNumber));\n            // propagate lastLineBlank up through parents:\n            var cont = container;\n            while (cont) {\n                cont.lastLineBlank = lastLineBlank;\n                cont = cont.parent;\n            }\n            if (blockHandlers[t].acceptsLines) {\n                this.addLine();\n                // if HtmlBlock, check for end condition\n                if (isHtmlBlock(container) &&\n                    container.htmlBlockType >= 1 &&\n                    container.htmlBlockType <= 5 &&\n                    reHtmlBlockClose[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {\n                    this.lastLineLength = ln.length;\n                    this.finalize(container, this.lineNumber);\n                }\n            }\n            else if (this.offset < ln.length && !this.blank) {\n                // create paragraph container for line\n                container = this.addChild('paragraph', this.offset);\n                this.advanceNextNonspace();\n                this.addLine();\n            }\n        }\n        this.lastLineLength = ln.length;\n    };\n    // The main parsing function.  Returns a parsed document AST.\n    Parser.prototype.parse = function (input, lineTexts) {\n        this.doc = esm_document();\n        this.tip = this.doc;\n        this.lineNumber = 0;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var lines = input.split(reLineEnding$1);\n        var len = lines.length;\n        this.lines = lineTexts ? lineTexts : lines;\n        if (this.options.referenceDefinition) {\n            this.clearRefMaps();\n        }\n        if (input.charCodeAt(input.length - 1) === C_NEWLINE) {\n            // ignore last blank line created by final newline\n            len -= 1;\n        }\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        while (this.tip) {\n            this.finalize(this.tip, len);\n        }\n        this.processInlines(this.doc);\n        return this.doc;\n    };\n    Parser.prototype.partialParseStart = function (lineNumber, lines) {\n        this.doc = esm_document();\n        this.tip = this.doc;\n        this.lineNumber = lineNumber - 1;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var len = lines.length;\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        return this.doc;\n    };\n    Parser.prototype.partialParseExtends = function (lines) {\n        for (var i = 0; i < lines.length; i++) {\n            this.incorporateLine(lines[i]);\n        }\n    };\n    Parser.prototype.partialParseFinish = function () {\n        while (this.tip) {\n            this.finalize(this.tip, this.lineNumber);\n        }\n        this.processInlines(this.doc);\n    };\n    Parser.prototype.setRefMaps = function (refMap, refLinkCandidateMap, refDefCandidateMap) {\n        this.refMap = refMap;\n        this.refLinkCandidateMap = refLinkCandidateMap;\n        this.refDefCandidateMap = refDefCandidateMap;\n    };\n    Parser.prototype.clearRefMaps = function () {\n        [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (map) {\n            clearObj(map);\n        });\n    };\n    return Parser;\n}());\nfunction comparePos(p1, p2) {\n    if (p1[0] < p2[0]) {\n        return 1 /* LT */;\n    }\n    if (p1[0] > p2[0]) {\n        return -1 /* GT */;\n    }\n    if (p1[1] < p2[1]) {\n        return 1 /* LT */;\n    }\n    if (p1[1] > p2[1]) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction compareRangeAndPos(_a, pos) {\n    var startPos = _a[0], endPos = _a[1];\n    if (comparePos(endPos, pos) === 1 /* LT */) {\n        return 1 /* LT */;\n    }\n    if (comparePos(startPos, pos) === -1 /* GT */) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction removeNextUntil(node, last) {\n    if (node.parent !== last.parent || node === last) {\n        return;\n    }\n    var next = node.next;\n    while (next && next !== last) {\n        var temp = next.next;\n        for (var _i = 0, _a = ['parent', 'prev', 'next']; _i < _a.length; _i++) {\n            var type = _a[_i];\n            if (next[type]) {\n                removeNodeById(next[type].id);\n                next[type] = null;\n            }\n        }\n        next = temp;\n    }\n    node.next = last.next;\n    if (last.next) {\n        last.next.prev = node;\n    }\n    else {\n        node.parent.lastChild = node;\n    }\n}\nfunction getChildNodes(parent) {\n    var nodes = [];\n    var curr = parent.firstChild;\n    while (curr) {\n        nodes.push(curr);\n        curr = curr.next;\n    }\n    return nodes;\n}\nfunction insertNodesBefore(target, nodes) {\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n        target.insertBefore(node);\n    }\n}\nfunction prependChildNodes(parent, nodes) {\n    for (var i = nodes.length - 1; i >= 0; i -= 1) {\n        parent.prependChild(nodes[i]);\n    }\n}\nfunction updateNextLineNumbers(base, diff) {\n    if (!base || !base.parent || diff === 0) {\n        return;\n    }\n    var walker = base.parent.walker();\n    walker.resumeAt(base, true);\n    var event;\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            node.sourcepos[0][0] += diff;\n            node.sourcepos[1][0] += diff;\n        }\n    }\n}\nfunction compareRangeAndLine(_a, line) {\n    var startPos = _a[0], endPos = _a[1];\n    if (endPos[0] < line) {\n        return 1 /* LT */;\n    }\n    if (startPos[0] > line) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction findChildNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            return node;\n        }\n        if (comp === -1 /* GT */) {\n            // To consider that top line is blank line\n            return node.prev || node;\n        }\n        node = node.next;\n    }\n    return parent.lastChild;\n}\nfunction lastLeafNode(node) {\n    while (node.lastChild) {\n        node = node.lastChild;\n    }\n    return node;\n}\nfunction sameLineTopAncestor(node) {\n    while (node.parent &&\n        node.parent.type !== 'document' &&\n        node.parent.sourcepos[0][0] === node.sourcepos[0][0]) {\n        node = node.parent;\n    }\n    return node;\n}\nfunction findFirstNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            if (node.sourcepos[0][0] === line || !node.firstChild) {\n                return node;\n            }\n            prev = node;\n            node = node.firstChild;\n        }\n        else if (comp === -1 /* GT */) {\n            break;\n        }\n        else {\n            prev = node;\n            node = node.next;\n        }\n    }\n    if (prev) {\n        return sameLineTopAncestor(lastLeafNode(prev));\n    }\n    return null;\n}\nfunction findNodeAtPosition(parent, pos) {\n    var node = parent;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndPos(node.sourcepos, pos);\n        if (comp === 0 /* EQ */) {\n            if (node.firstChild) {\n                prev = node;\n                node = node.firstChild;\n            }\n            else {\n                return node;\n            }\n        }\n        else if (comp === -1 /* GT */) {\n            return prev;\n        }\n        else if (node.next) {\n            node = node.next;\n        }\n        else {\n            return prev;\n        }\n    }\n    return node;\n}\nfunction findNodeById(id) {\n    return getNodeById(id) || null;\n}\nfunction invokeNextUntil(callback, start, end) {\n    if (end === void 0) {\n        end = null;\n    }\n    if (start) {\n        var walker = start.walker();\n        while (start && start !== end) {\n            callback(start);\n            var next = walker.next();\n            if (next) {\n                start = next.node;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\nfunction isUnlinked(id) {\n    var node = findNodeById(id);\n    if (!node) {\n        return true;\n    }\n    while (node && node.type !== 'document') {\n        // eslint-disable-next-line no-loop-func\n        if (!node.parent && !node.prev && !node.next) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\nvar reLineEnding = /\\r\\n|\\n|\\r/;\nfunction canBeContinuedListItem(lineText) {\n    var spaceMatch = lineText.match(/^[ \\t]+/);\n    if (spaceMatch && (spaceMatch[0].length >= 2 || /\\t/.test(spaceMatch[0]))) {\n        return true;\n    }\n    var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;\n    return reBulletListMarker.test(leftTrimmed) || reOrderedListMarker.test(leftTrimmed);\n}\nfunction canBeContinuedTableBody(lineText) {\n    return !isBlank(lineText) && lineText.indexOf('|') !== -1;\n}\nfunction createRefDefState(node) {\n    var id = node.id, title = node.title, sourcepos = node.sourcepos, dest = node.dest;\n    return {\n        id: id,\n        title: title,\n        sourcepos: sourcepos,\n        unlinked: false,\n        destination: dest,\n    };\n}\nvar ToastMark = /** @class */ (function () {\n    function ToastMark(contents, options) {\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);\n        this.parser = new Parser(options);\n        this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);\n        this.eventHandlerMap = { change: [] };\n        contents = contents || '';\n        this.lineTexts = contents.split(reLineEnding);\n        this.root = this.parser.parse(contents, this.lineTexts);\n    }\n    ToastMark.prototype.updateLineTexts = function (startPos, endPos, newText) {\n        var _a;\n        var startLine = startPos[0], startCol = startPos[1];\n        var endLine = endPos[0], endCol = endPos[1];\n        var newLines = newText.split(reLineEnding);\n        var newLineLen = newLines.length;\n        var startLineText = this.lineTexts[startLine - 1];\n        var endLineText = this.lineTexts[endLine - 1];\n        newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];\n        newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);\n        var removedLineLen = endLine - startLine + 1;\n        (_a = this.lineTexts).splice.apply(_a, esm_spreadArray([startLine - 1, removedLineLen], newLines));\n        return newLineLen - removedLineLen;\n    };\n    ToastMark.prototype.updateRootNodeState = function () {\n        if (this.lineTexts.length === 1 && this.lineTexts[0] === '') {\n            this.root.lastLineBlank = true;\n            this.root.sourcepos = [\n                [1, 1],\n                [1, 0],\n            ];\n            return;\n        }\n        if (this.root.lastChild) {\n            this.root.lastLineBlank = this.root.lastChild.lastLineBlank;\n        }\n        var lineTexts = this.lineTexts;\n        var idx = lineTexts.length - 1;\n        while (lineTexts[idx] === '') {\n            idx -= 1;\n        }\n        if (lineTexts.length - 2 > idx) {\n            idx += 1;\n        }\n        this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];\n    };\n    ToastMark.prototype.replaceRangeNodes = function (startNode, endNode, newNodes) {\n        if (!startNode) {\n            if (endNode) {\n                insertNodesBefore(endNode, newNodes);\n                removeNodeById(endNode.id);\n                endNode.unlink();\n            }\n            else {\n                prependChildNodes(this.root, newNodes);\n            }\n        }\n        else {\n            insertNodesBefore(startNode, newNodes);\n            removeNextUntil(startNode, endNode);\n            [startNode.id, endNode.id].forEach(function (id) { return removeNodeById(id); });\n            startNode.unlink();\n        }\n    };\n    ToastMark.prototype.getNodeRange = function (startPos, endPos) {\n        var startNode = findChildNodeAtLine(this.root, startPos[0]);\n        var endNode = findChildNodeAtLine(this.root, endPos[0]);\n        // extend node range to include a following block which doesn't have preceding blank line\n        if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {\n            endNode = endNode.next;\n        }\n        return [startNode, endNode];\n    };\n    ToastMark.prototype.trigger = function (eventName, param) {\n        this.eventHandlerMap[eventName].forEach(function (handler) {\n            handler(param);\n        });\n    };\n    ToastMark.prototype.extendEndLine = function (line) {\n        while (this.lineTexts[line] === '') {\n            line += 1;\n        }\n        return line;\n    };\n    ToastMark.prototype.parseRange = function (startNode, endNode, startLine, endLine) {\n        // extends starting range if the first node can be a continued list item\n        if (startNode &&\n            startNode.prev &&\n            ((isList(startNode.prev) && canBeContinuedListItem(this.lineTexts[startLine - 1])) ||\n                (isTable(startNode.prev) && canBeContinuedTableBody(this.lineTexts[startLine - 1])))) {\n            startNode = startNode.prev;\n            startLine = startNode.sourcepos[0][0];\n        }\n        var editedLines = this.lineTexts.slice(startLine - 1, endLine);\n        var root = this.parser.partialParseStart(startLine, editedLines);\n        // extends ending range if the following node can be a fenced code block or a continued list item\n        var nextNode = endNode ? endNode.next : this.root.firstChild;\n        var lastChild = root.lastChild;\n        var isOpenedLastChildCodeBlock = lastChild && isCodeBlock(lastChild) && lastChild.open;\n        var isOpenedLastChildCustomBlock = lastChild && isCustomBlock(lastChild) && lastChild.open;\n        var isLastChildList = lastChild && isList(lastChild);\n        while (((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode) ||\n            (isLastChildList && nextNode && (nextNode.type === 'list' || nextNode.sourcepos[0][1] >= 2))) {\n            var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);\n            this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));\n            if (!startNode) {\n                startNode = endNode;\n            }\n            endNode = nextNode;\n            endLine = newEndLine;\n            nextNode = nextNode.next;\n        }\n        this.parser.partialParseFinish();\n        var newNodes = getChildNodes(root);\n        return { newNodes: newNodes, extStartNode: startNode, extEndNode: endNode };\n    };\n    ToastMark.prototype.getRemovedNodeRange = function (extStartNode, extEndNode) {\n        if (!extStartNode ||\n            (extStartNode && isRefDef(extStartNode)) ||\n            (extEndNode && isRefDef(extEndNode))) {\n            return null;\n        }\n        return {\n            id: [extStartNode.id, extEndNode.id],\n            line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1],\n        };\n    };\n    ToastMark.prototype.markDeletedRefMap = function (extStartNode, extEndNode) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var markDeleted = function (node) {\n                if (isRefDef(node)) {\n                    var refDefState = _this.refMap[node.label];\n                    if (refDefState && node.id === refDefState.id) {\n                        refDefState.unlinked = true;\n                    }\n                }\n            };\n            if (extStartNode) {\n                invokeNextUntil(markDeleted, extStartNode.parent, extEndNode);\n            }\n            if (extEndNode) {\n                invokeNextUntil(markDeleted, extEndNode);\n            }\n        }\n    };\n    ToastMark.prototype.replaceWithNewRefDefState = function (nodes) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var replaceWith_1 = function (node) {\n                if (isRefDef(node)) {\n                    var label = node.label;\n                    var refDefState = _this.refMap[label];\n                    if (!refDefState || refDefState.unlinked) {\n                        _this.refMap[label] = createRefDefState(node);\n                    }\n                }\n            };\n            nodes.forEach(function (node) {\n                invokeNextUntil(replaceWith_1, node);\n            });\n        }\n    };\n    ToastMark.prototype.replaceWithRefDefCandidate = function () {\n        var _this = this;\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            iterateObject(this.refDefCandidateMap, function (_, candidate) {\n                var label = candidate.label, sourcepos = candidate.sourcepos;\n                var refDefState = _this.refMap[label];\n                if (!refDefState ||\n                    refDefState.unlinked ||\n                    refDefState.sourcepos[0][0] > sourcepos[0][0]) {\n                    _this.refMap[label] = createRefDefState(candidate);\n                }\n            });\n        }\n    };\n    ToastMark.prototype.getRangeWithRefDef = function (startLine, endLine, startNode, endNode, lineDiff) {\n        if (this.referenceDefinition && !isEmptyObj(this.refMap)) {\n            var prevNode = findChildNodeAtLine(this.root, startLine - 1);\n            var nextNode = findChildNodeAtLine(this.root, endLine + 1);\n            if (prevNode && isRefDef(prevNode) && prevNode !== startNode && prevNode !== endNode) {\n                startNode = prevNode;\n                startLine = startNode.sourcepos[0][0];\n            }\n            if (nextNode && isRefDef(nextNode) && nextNode !== startNode && nextNode !== endNode) {\n                endNode = nextNode;\n                endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);\n            }\n        }\n        return [startNode, endNode, startLine, endLine];\n    };\n    ToastMark.prototype.parse = function (startPos, endPos, lineDiff) {\n        if (lineDiff === void 0) {\n            lineDiff = 0;\n        }\n        var range = this.getNodeRange(startPos, endPos);\n        var startNode = range[0], endNode = range[1];\n        var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];\n        var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);\n        var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));\n        var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;\n        var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);\n        var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;\n        if (this.referenceDefinition) {\n            this.markDeletedRefMap(extStartNode, extEndNode);\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n            this.replaceWithNewRefDefState(newNodes);\n        }\n        else {\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n        }\n        return { nodes: newNodes, removedNodeRange: removedNodeRange, nextNode: nextNode };\n    };\n    ToastMark.prototype.parseRefLink = function () {\n        var _this = this;\n        var result = [];\n        if (!isEmptyObj(this.refMap)) {\n            iterateObject(this.refMap, function (label, value) {\n                if (value.unlinked) {\n                    delete _this.refMap[label];\n                }\n                iterateObject(_this.refLinkCandidateMap, function (_, candidate) {\n                    var node = candidate.node, refLabel = candidate.refLabel;\n                    if (refLabel === label) {\n                        result.push(_this.parse(node.sourcepos[0], node.sourcepos[1]));\n                    }\n                });\n            });\n        }\n        return result;\n    };\n    ToastMark.prototype.removeUnlinkedCandidate = function () {\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (candidateMap) {\n                iterateObject(candidateMap, function (id) {\n                    if (isUnlinked(id)) {\n                        delete candidateMap[id];\n                    }\n                });\n            });\n        }\n    };\n    ToastMark.prototype.editMarkdown = function (startPos, endPos, newText) {\n        var lineDiff = this.updateLineTexts(startPos, endPos, newText);\n        var parseResult = this.parse(startPos, endPos, lineDiff);\n        var editResult = omit(parseResult, 'nextNode');\n        updateNextLineNumbers(parseResult.nextNode, lineDiff);\n        this.updateRootNodeState();\n        var result = [editResult];\n        if (this.referenceDefinition) {\n            this.removeUnlinkedCandidate();\n            this.replaceWithRefDefCandidate();\n            result = result.concat(this.parseRefLink());\n        }\n        this.trigger('change', result);\n        return result;\n    };\n    ToastMark.prototype.getLineTexts = function () {\n        return this.lineTexts;\n    };\n    ToastMark.prototype.getRootNode = function () {\n        return this.root;\n    };\n    ToastMark.prototype.findNodeAtPosition = function (pos) {\n        var node = findNodeAtPosition(this.root, pos);\n        if (!node || node === this.root) {\n            return null;\n        }\n        return node;\n    };\n    ToastMark.prototype.findFirstNodeAtLine = function (line) {\n        return findFirstNodeAtLine(this.root, line);\n    };\n    ToastMark.prototype.on = function (eventName, callback) {\n        this.eventHandlerMap[eventName].push(callback);\n    };\n    ToastMark.prototype.off = function (eventName, callback) {\n        var handlers = this.eventHandlerMap[eventName];\n        var idx = handlers.indexOf(callback);\n        handlers.splice(idx, 1);\n    };\n    ToastMark.prototype.findNodeById = function (id) {\n        return findNodeById(id);\n    };\n    ToastMark.prototype.removeAllNode = function () {\n        removeAllNode();\n    };\n    return ToastMark;\n}());\nvar disallowedTags = [\n    'title',\n    'textarea',\n    'style',\n    'xmp',\n    'iframe',\n    'noembed',\n    'noframes',\n    'script',\n    'plaintext',\n];\nvar reDisallowedTag = new RegExp(\"<(/?(?:\" + disallowedTags.join('|') + \")[^>]*>)\", 'ig');\nfunction filterDisallowedTags(str) {\n    if (reDisallowedTag.test(str)) {\n        return str.replace(reDisallowedTag, function (_, group) { return \"&lt;\" + group; });\n    }\n    return str;\n}\nvar baseConvertors = {\n    heading: function (node, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: \"h\" + node.level,\n            outerNewLine: true,\n        };\n    },\n    text: function (node) {\n        return {\n            type: 'text',\n            content: node.literal,\n        };\n    },\n    softbreak: function (_, _a) {\n        var options = _a.options;\n        return {\n            type: 'html',\n            content: options.softbreak,\n        };\n    },\n    linebreak: function () {\n        return {\n            type: 'html',\n            content: '<br />\\n',\n        };\n    },\n    emph: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'em',\n        };\n    },\n    strong: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'strong',\n        };\n    },\n    paragraph: function (node, _a) {\n        var _b;\n        var entering = _a.entering;\n        var grandparent = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent;\n        if (grandparent && grandparent.type === 'list') {\n            if (grandparent.listData.tight) {\n                return null;\n            }\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'p',\n            outerNewLine: true,\n        };\n    },\n    thematicBreak: function () {\n        return {\n            type: 'openTag',\n            tagName: 'hr',\n            outerNewLine: true,\n            selfClose: true,\n        };\n    },\n    blockQuote: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'blockquote',\n            outerNewLine: true,\n            innerNewLine: true,\n        };\n    },\n    list: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, type = _b.type, start = _b.start;\n        var tagName = type === 'bullet' ? 'ul' : 'ol';\n        var attributes = {};\n        if (tagName === 'ol' && start !== null && start !== 1) {\n            attributes.start = start.toString();\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: tagName,\n            attributes: attributes,\n            outerNewLine: true,\n        };\n    },\n    item: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    htmlInline: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        return { type: 'html', content: content };\n    },\n    htmlBlock: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        if (options.nodeId) {\n            return [\n                { type: 'openTag', tagName: 'div', outerNewLine: true },\n                { type: 'html', content: content },\n                { type: 'closeTag', tagName: 'div', outerNewLine: true },\n            ];\n        }\n        return { type: 'html', content: content, outerNewLine: true };\n    },\n    code: function (node) {\n        return [\n            { type: 'openTag', tagName: 'code' },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var infoStr = node.info;\n        var infoWords = infoStr ? infoStr.split(/\\s+/) : [];\n        var codeClassNames = [];\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            codeClassNames.push(\"language-\" + escapeXml(infoWords[0]));\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', outerNewLine: true },\n            { type: 'openTag', tagName: 'code', classNames: codeClassNames },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre', outerNewLine: true },\n        ];\n    },\n    link: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, title = _b.title, destination = _b.destination;\n            return {\n                type: 'openTag',\n                tagName: 'a',\n                attributes: esm_assign({ href: escapeXml(destination) }, (title && { title: escapeXml(title) })),\n            };\n        }\n        return { type: 'closeTag', tagName: 'a' };\n    },\n    image: function (node, _a) {\n        var getChildrenText = _a.getChildrenText, skipChildren = _a.skipChildren;\n        var _b = node, title = _b.title, destination = _b.destination;\n        skipChildren();\n        return {\n            type: 'openTag',\n            tagName: 'img',\n            selfClose: true,\n            attributes: esm_assign({ src: escapeXml(destination), alt: getChildrenText(node) }, (title && { title: escapeXml(title) })),\n        };\n    },\n    customBlock: function (node, context, convertors) {\n        var info = node.info.trim().toLowerCase();\n        var customConvertor = convertors[info];\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + info + \" block node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return [\n            { type: 'openTag', tagName: 'div', outerNewLine: true },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    frontMatter: function (node) {\n        return [\n            {\n                type: 'openTag',\n                tagName: 'div',\n                outerNewLine: true,\n                // Because front matter is metadata, it should not be render.\n                attributes: { style: 'white-space: pre; display: none;' },\n            },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    customInline: function (node, context, convertors) {\n        var _a = node, info = _a.info, firstChild = _a.firstChild;\n        var nomalizedInfo = info.trim().toLowerCase();\n        var customConvertor = convertors[nomalizedInfo];\n        var entering = context.entering;\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + nomalizedInfo + \" inline node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return entering\n            ? [\n                { type: 'openTag', tagName: 'span' },\n                { type: 'text', content: \"$$\" + info + (firstChild ? ' ' : '') },\n            ]\n            : [\n                { type: 'text', content: '$$' },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n    },\n};\nvar gfmConvertors = {\n    strike: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'del',\n        };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, checked = _b.checked, task = _b.task;\n        if (entering) {\n            var itemTag = {\n                type: 'openTag',\n                tagName: 'li',\n                outerNewLine: true,\n            };\n            if (task) {\n                return [\n                    itemTag,\n                    {\n                        type: 'openTag',\n                        tagName: 'input',\n                        selfClose: true,\n                        attributes: esm_assign(esm_assign({}, (checked && { checked: '' })), { disabled: '', type: 'checkbox' }),\n                    },\n                    {\n                        type: 'text',\n                        content: ' ',\n                    },\n                ];\n            }\n            return itemTag;\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    table: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'table',\n            outerNewLine: true,\n        };\n    },\n    tableHead: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'thead',\n            outerNewLine: true,\n        };\n    },\n    tableBody: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'tbody',\n            outerNewLine: true,\n        };\n    },\n    tableRow: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            return {\n                type: 'openTag',\n                tagName: 'tr',\n                outerNewLine: true,\n            };\n        }\n        var result = [];\n        if (node.lastChild) {\n            var columnLen = node.parent.parent.columns.length;\n            var lastColIdx = node.lastChild.endIdx;\n            for (var i = lastColIdx + 1; i < columnLen; i += 1) {\n                result.push({\n                    type: 'openTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                }, {\n                    type: 'closeTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                });\n            }\n        }\n        result.push({\n            type: 'closeTag',\n            tagName: 'tr',\n            outerNewLine: true,\n        });\n        return result;\n    },\n    tableCell: function (node, _a) {\n        var entering = _a.entering;\n        if (node.ignored) {\n            return {\n                type: 'text',\n                content: '',\n            };\n        }\n        var tablePart = node.parent.parent;\n        var tagName = tablePart.type === 'tableHead' ? 'th' : 'td';\n        var table = tablePart.parent;\n        var columnInfo = table.columns[node.startIdx];\n        var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;\n        if (entering) {\n            return esm_assign({ type: 'openTag', tagName: tagName, outerNewLine: true }, (attributes && { attributes: attributes }));\n        }\n        return {\n            type: 'closeTag',\n            tagName: tagName,\n            outerNewLine: true,\n        };\n    },\n};\nvar defaultOptions = {\n    softbreak: '\\n',\n    gfm: false,\n    tagFilter: false,\n    nodeId: false,\n};\nfunction getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var node_1 = event.node;\n        if (node_1.type === 'text') {\n            buffer.push(node_1.literal);\n        }\n    }\n    return buffer.join('');\n}\nvar Renderer = /** @class */ (function () {\n    function Renderer(customOptions) {\n        this.buffer = [];\n        this.options = esm_assign(esm_assign({}, defaultOptions), customOptions);\n        this.convertors = this.createConvertors();\n        delete this.options.convertors;\n    }\n    Renderer.prototype.createConvertors = function () {\n        var convertors = esm_assign({}, baseConvertors);\n        if (this.options.gfm) {\n            convertors = esm_assign(esm_assign({}, convertors), gfmConvertors);\n        }\n        if (this.options.convertors) {\n            var customConvertors_1 = this.options.convertors;\n            var nodeTypes = Object.keys(customConvertors_1);\n            var defaultConvertors_1 = esm_assign(esm_assign({}, baseConvertors), gfmConvertors);\n            nodeTypes.forEach(function (nodeType) {\n                var orgConvertor = convertors[nodeType];\n                var convertor = customConvertors_1[nodeType];\n                var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType) === -1\n                    ? nodeType.toLowerCase()\n                    : nodeType;\n                if (orgConvertor) {\n                    convertors[convertorType] = function (node, context, convertors) {\n                        context.origin = function () { return orgConvertor(node, context, convertors); };\n                        return convertor(node, context);\n                    };\n                }\n                else {\n                    convertors[convertorType] = convertor;\n                }\n            });\n        }\n        return convertors;\n    };\n    Renderer.prototype.getConvertors = function () {\n        return this.convertors;\n    };\n    Renderer.prototype.getOptions = function () {\n        return this.options;\n    };\n    Renderer.prototype.render = function (rootNode) {\n        var _this = this;\n        this.buffer = [];\n        var walker = rootNode.walker();\n        var event = null;\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            if (!convertor) {\n                return \"continue\";\n            }\n            var skipped = false;\n            var context = {\n                entering: entering,\n                leaf: !isContainer(node),\n                options: this_1.options,\n                getChildrenText: getChildrenText,\n                skipChildren: function () {\n                    skipped = true;\n                },\n            };\n            var converted = isCustomBlock(node) || isCustomInline(node)\n                ? convertor(node, context, this_1.convertors)\n                : convertor(node, context);\n            if (converted) {\n                var htmlNodes = Array.isArray(converted) ? converted : [converted];\n                htmlNodes.forEach(function (htmlNode, index) {\n                    if (htmlNode.type === 'openTag' && _this.options.nodeId && index === 0) {\n                        if (!htmlNode.attributes) {\n                            htmlNode.attributes = {};\n                        }\n                        htmlNode.attributes['data-nodeid'] = String(node.id);\n                    }\n                    _this.renderHTMLNode(htmlNode);\n                });\n                if (skipped) {\n                    walker.resumeAt(node, false);\n                    walker.next();\n                }\n            }\n        };\n        var this_1 = this;\n        while ((event = walker.next())) {\n            _loop_1();\n        }\n        this.addNewLine();\n        return this.buffer.join('');\n    };\n    Renderer.prototype.renderHTMLNode = function (node) {\n        switch (node.type) {\n            case 'openTag':\n            case 'closeTag':\n                this.renderElementNode(node);\n                break;\n            case 'text':\n                this.renderTextNode(node);\n                break;\n            case 'html':\n                this.renderRawHtmlNode(node);\n                break;\n            // no-default-case\n        }\n    };\n    Renderer.prototype.generateOpenTagString = function (node) {\n        var _this = this;\n        var tagName = node.tagName, classNames = node.classNames, attributes = node.attributes;\n        this.buffer.push(\"<\" + tagName);\n        if (classNames && classNames.length > 0) {\n            this.buffer.push(\" class=\\\"\" + classNames.join(' ') + \"\\\"\");\n        }\n        if (attributes) {\n            Object.keys(attributes).forEach(function (attrName) {\n                var attrValue = attributes[attrName];\n                _this.buffer.push(\" \" + attrName + \"=\\\"\" + attrValue + \"\\\"\");\n            });\n        }\n        if (node.selfClose) {\n            this.buffer.push(' /');\n        }\n        this.buffer.push('>');\n    };\n    Renderer.prototype.generateCloseTagString = function (_a) {\n        var tagName = _a.tagName;\n        this.buffer.push(\"</\" + tagName + \">\");\n    };\n    Renderer.prototype.addNewLine = function () {\n        if (this.buffer.length && last(last(this.buffer)) !== '\\n') {\n            this.buffer.push('\\n');\n        }\n    };\n    Renderer.prototype.addOuterNewLine = function (node) {\n        if (node.outerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.addInnerNewLine = function (node) {\n        if (node.innerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.renderTextNode = function (node) {\n        this.buffer.push(escapeXml(node.content));\n    };\n    Renderer.prototype.renderRawHtmlNode = function (node) {\n        this.addOuterNewLine(node);\n        this.buffer.push(node.content);\n        this.addOuterNewLine(node);\n    };\n    Renderer.prototype.renderElementNode = function (node) {\n        if (node.type === 'openTag') {\n            this.addOuterNewLine(node);\n            this.generateOpenTagString(node);\n            if (node.selfClose) {\n                this.addOuterNewLine(node);\n            }\n            else {\n                this.addInnerNewLine(node);\n            }\n        }\n        else {\n            this.addInnerNewLine(node);\n            this.generateCloseTagString(node);\n            this.addOuterNewLine(node);\n        }\n    };\n    return Renderer;\n}());\n\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/forEachOwnProperties.js\nvar collection_forEachOwnProperties = __nested_webpack_require_87464__(956);\nvar forEachOwnProperties_default = /*#__PURE__*/__nested_webpack_require_87464__.n(collection_forEachOwnProperties);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/object/extend.js\nvar extend = __nested_webpack_require_87464__(969);\nvar extend_default = /*#__PURE__*/__nested_webpack_require_87464__.n(extend);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domEvent/on.js\nvar on = __nested_webpack_require_87464__(348);\nvar on_default = /*#__PURE__*/__nested_webpack_require_87464__.n(on);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domEvent/off.js\nvar off = __nested_webpack_require_87464__(349);\nvar off_default = /*#__PURE__*/__nested_webpack_require_87464__.n(off);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/addClass.js\nvar addClass = __nested_webpack_require_87464__(204);\nvar addClass_default = /*#__PURE__*/__nested_webpack_require_87464__.n(addClass);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/removeClass.js\nvar removeClass = __nested_webpack_require_87464__(462);\nvar removeClass_default = /*#__PURE__*/__nested_webpack_require_87464__.n(removeClass);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/css.js\nvar css = __nested_webpack_require_87464__(522);\nvar css_default = /*#__PURE__*/__nested_webpack_require_87464__.n(css);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/toArray.js\nvar collection_toArray = __nested_webpack_require_87464__(990);\nvar toArray_default = /*#__PURE__*/__nested_webpack_require_87464__.n(collection_toArray);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isArray.js\nvar type_isArray = __nested_webpack_require_87464__(322);\nvar isArray_default = /*#__PURE__*/__nested_webpack_require_87464__.n(type_isArray);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isString.js\nvar type_isString = __nested_webpack_require_87464__(758);\nvar isString_default = /*#__PURE__*/__nested_webpack_require_87464__.n(type_isString);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isUndefined.js\nvar type_isUndefined = __nested_webpack_require_87464__(929);\nvar isUndefined_default = /*#__PURE__*/__nested_webpack_require_87464__.n(type_isUndefined);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/hasClass.js\nvar hasClass = __nested_webpack_require_87464__(714);\nvar hasClass_default = /*#__PURE__*/__nested_webpack_require_87464__.n(hasClass);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/matches.js\nvar domUtil_matches = __nested_webpack_require_87464__(471);\n;// CONCATENATED MODULE: ./src/utils/constants.ts\nvar TAG_NAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTE_NAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTED_VALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLE_QUOTED_VALUE = \"'[^']*'\";\nvar DOUBLE_QUOTED_VALUE = '\"[^\"]*\"';\nvar ATTRIBUTE_VALUE = \"(?:\" + UNQUOTED_VALUE + \"|\" + SINGLE_QUOTED_VALUE + \"|\" + DOUBLE_QUOTED_VALUE + \")\";\nvar ATTRIBUTE_VALUE_SPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTE_VALUE + \")\";\nvar constants_ATTRIBUTE = \"\" + '(?:\\\\s+' + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + \"?)\";\nvar constants_OPEN_TAG = \"<(\" + TAG_NAME + \")(\" + constants_ATTRIBUTE + \")*\\\\s*/?>\";\nvar CLOSE_TAG = \"</(\" + TAG_NAME + \")\\\\s*[>]\";\nvar constants_HTML_TAG = \"(?:\" + constants_OPEN_TAG + \"|\" + CLOSE_TAG + \")\";\nvar reHTMLTag = new RegExp(\"^\" + constants_HTML_TAG, 'i');\nvar constants_reBR = /<br\\s*\\/*>/i;\nvar reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar constants_ALTERNATIVE_TAG_FOR_BR = '</p><p>';\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isNull.js\nvar type_isNull = __nested_webpack_require_87464__(934);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/request/sendHostname.js\nvar request_sendHostname = __nested_webpack_require_87464__(391);\n;// CONCATENATED MODULE: ./src/utils/common.ts\n\n\n\n\n\nvar isMac = /Mac/.test(navigator.platform);\nvar reSpaceMoreThanOne = /[\\u0020]+/g;\nvar common_reEscapeChars = /[>(){}[\\]+-.!#|]/g;\nvar reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\\-._]*)(\\s|[^\\\\>])*\\/?>|<(\\/)([a-zA-Z_][a-zA-Z0-9\\-._]*)\\s*\\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\\-.:/]*)>/g;\nvar reEscapeBackSlash = /\\\\[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]/g;\nvar reEscapePairedChars = /[*_~`]/g;\nvar reMdImageSyntax = /!\\[.*\\]\\(.*\\)/g;\nvar reEscapedCharInLinkSyntax = /[[\\]]/g;\nvar reEscapeBackSlashInSentence = /(?:^|[^\\\\])\\\\(?!\\\\)/g;\nvar common_XMLSPECIAL = '[&<>\"]';\nvar common_reXmlSpecial = new RegExp(common_XMLSPECIAL, 'g');\nfunction common_replaceUnsafeChar(char) {\n    switch (char) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return char;\n    }\n}\nfunction common_escapeXml(text) {\n    if (common_reXmlSpecial.test(text)) {\n        return text.replace(common_reXmlSpecial, common_replaceUnsafeChar);\n    }\n    return text;\n}\nfunction sendHostName() {\n    sendHostname('editor', 'UA-129966929-1');\n}\nfunction common_includes(arr, targetItem) {\n    return arr.indexOf(targetItem) !== -1;\n}\nvar availableLinkAttributes = ['rel', 'target', 'hreflang', 'type'];\nvar reMarkdownTextToEscapeMap = {\n    codeblock: /(^ {4}[^\\n]+\\n*)+/,\n    thematicBreak: /^ *((\\* *){3,}|(- *){3,} *|(_ *){3,}) */,\n    atxHeading: /^(#{1,6}) +[\\s\\S]+/,\n    seTextheading: /^([^\\n]+)\\n *(=|-){2,} */,\n    blockquote: /^( *>[^\\n]+.*)+/,\n    list: /^ *(\\*+|-+|\\d+\\.) [\\s\\S]+/,\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? */,\n    link: /!?\\[.*\\]\\(.*\\)/,\n    reflink: /!?\\[.*\\]\\s*\\[([^\\]]*)\\]/,\n    verticalBar: /\\u007C/,\n    fencedCodeblock: /^((`|~){3,})/,\n};\nfunction sanitizeLinkAttribute(attribute) {\n    if (!attribute) {\n        return null;\n    }\n    var linkAttributes = {};\n    availableLinkAttributes.forEach(function (key) {\n        if (!isUndefined_default()(attribute[key])) {\n            linkAttributes[key] = attribute[key];\n        }\n    });\n    return linkAttributes;\n}\nfunction common_repeat(text, count) {\n    var result = '';\n    for (var i = 0; i < count; i += 1) {\n        result += text;\n    }\n    return result;\n}\nfunction isNeedEscapeText(text) {\n    var needEscape = false;\n    forEachOwnProperties(reMarkdownTextToEscapeMap, function (reMarkdownTextToEscape) {\n        if (reMarkdownTextToEscape.test(text)) {\n            needEscape = true;\n        }\n        return !needEscape;\n    });\n    return needEscape;\n}\nfunction escapeTextForLink(text) {\n    var imageSyntaxRanges = [];\n    var result = reMdImageSyntax.exec(text);\n    while (result) {\n        imageSyntaxRanges.push([result.index, result.index + result[0].length]);\n        result = reMdImageSyntax.exec(text);\n    }\n    return text.replace(reEscapedCharInLinkSyntax, function (matched, offset) {\n        var isDelimiter = imageSyntaxRanges.some(function (range) { return offset > range[0] && offset < range[1]; });\n        return isDelimiter ? matched : \"\\\\\" + matched;\n    });\n}\nfunction common_escape(text) {\n    var aheadReplacer = function (matched) { return \"\\\\\" + matched; };\n    var behindReplacer = function (matched) { return matched + \"\\\\\"; };\n    var escapedText = text.replace(reSpaceMoreThanOne, ' ');\n    if (reEscapeBackSlash.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlash, aheadReplacer);\n    }\n    if (reEscapeBackSlashInSentence.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlashInSentence, behindReplacer);\n    }\n    escapedText = escapedText.replace(reEscapePairedChars, aheadReplacer);\n    if (reEscapeHTML.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeHTML, aheadReplacer);\n    }\n    if (isNeedEscapeText(escapedText)) {\n        escapedText = escapedText.replace(common_reEscapeChars, aheadReplacer);\n    }\n    return escapedText;\n}\nfunction quote(text) {\n    var result;\n    if (text.indexOf('\"') === -1) {\n        result = '\"\"';\n    }\n    else {\n        result = text.indexOf(\"'\") === -1 ? \"''\" : '()';\n    }\n    return result[0] + text + result[1];\n}\nfunction common_isNil(value) {\n    return isNull(value) || isUndefined(value);\n}\nfunction shallowEqual(o1, o2) {\n    if (o1 === null && o1 === o2) {\n        return true;\n    }\n    if (typeof o1 !== 'object' || typeof o2 !== 'object' || common_isNil(o1) || common_isNil(o2)) {\n        return o1 === o2;\n    }\n    for (var key in o1) {\n        if (o1[key] !== o2[key]) {\n            return false;\n        }\n    }\n    for (var key in o2) {\n        if (!(key in o1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction common_last(arr) {\n    return arr[arr.length - 1];\n}\nfunction common_between(value, min, max) {\n    return value >= min && value <= max;\n}\nfunction isObject(obj) {\n    return typeof obj === 'object' && obj !== null;\n}\nfunction deepMergedCopy(targetObj, obj) {\n    var resultObj = tslib_es6_assign({}, targetObj);\n    if (targetObj && obj) {\n        Object.keys(obj).forEach(function (prop) {\n            if (isObject(resultObj[prop])) {\n                if (Array.isArray(obj[prop])) {\n                    resultObj[prop] = deepCopyArray(obj[prop]);\n                }\n                else if (resultObj.hasOwnProperty(prop)) {\n                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);\n                }\n                else {\n                    resultObj[prop] = deepCopy(obj[prop]);\n                }\n            }\n            else {\n                resultObj[prop] = obj[prop];\n            }\n        });\n    }\n    return resultObj;\n}\nfunction deepCopyArray(items) {\n    return items.map(function (item) {\n        if (isObject(item)) {\n            return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);\n        }\n        return item;\n    });\n}\nfunction deepCopy(obj) {\n    var keys = Object.keys(obj);\n    if (!keys.length) {\n        return obj;\n    }\n    return keys.reduce(function (acc, prop) {\n        if (isObject(obj[prop])) {\n            acc[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);\n        }\n        else {\n            acc[prop] = obj[prop];\n        }\n        return acc;\n    }, {});\n}\nfunction common_assign(targetObj, obj) {\n    if (obj === void 0) { obj = {}; }\n    Object.keys(obj).forEach(function (prop) {\n        if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === 'object') {\n            if (Array.isArray(obj[prop])) {\n                targetObj[prop] = obj[prop];\n            }\n            else {\n                common_assign(targetObj[prop], obj[prop]);\n            }\n        }\n        else {\n            targetObj[prop] = obj[prop];\n        }\n    });\n    return targetObj;\n}\nfunction getSortedNumPair(valueA, valueB) {\n    return valueA > valueB ? [valueB, valueA] : [valueA, valueB];\n}\n\n;// CONCATENATED MODULE: ./src/utils/dom.ts\n\n\n\n\n\n\n\n\n\n\nfunction isPositionInBox(style, offsetX, offsetY) {\n    var left = parseInt(style.left, 10);\n    var top = parseInt(style.top, 10);\n    var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);\n    var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);\n    return offsetX >= left && offsetX <= left + width && offsetY >= top && offsetY <= top + height;\n}\nvar CLS_PREFIX = 'toastui-editor-';\nfunction cls() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    var result = [];\n    for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {\n        var name = names_1[_a];\n        var className = void 0;\n        if (Array.isArray(name)) {\n            className = name[0] ? name[1] : null;\n        }\n        else {\n            className = name;\n        }\n        if (className) {\n            result.push(\"\" + CLS_PREFIX + className);\n        }\n    }\n    return result.join(' ');\n}\nfunction clsWithMdPrefix() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    return names.map(function (className) { return CLS_PREFIX + \"md-\" + className; }).join(' ');\n}\nfunction isTextNode(node) {\n    return (node === null || node === void 0 ? void 0 : node.nodeType) === Node.TEXT_NODE;\n}\nfunction isElemNode(node) {\n    return node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction findNodes(element, selector) {\n    var nodeList = toArray(element.querySelectorAll(selector));\n    if (nodeList.length) {\n        return nodeList;\n    }\n    return [];\n}\nfunction appendNodes(node, nodesToAppend) {\n    nodesToAppend = isArray(nodesToAppend) ? toArray(nodesToAppend) : [nodesToAppend];\n    nodesToAppend.forEach(function (nodeToAppend) {\n        node.appendChild(nodeToAppend);\n    });\n}\nfunction insertBeforeNode(insertedNode, node) {\n    if (node.parentNode) {\n        node.parentNode.insertBefore(insertedNode, node);\n    }\n}\nfunction removeNode(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction unwrapNode(node) {\n    var result = [];\n    while (node.firstChild) {\n        result.push(node.firstChild);\n        if (node.parentNode) {\n            node.parentNode.insertBefore(node.firstChild, node);\n        }\n    }\n    removeNode(node);\n    return result;\n}\nfunction toggleClass(element, className, state) {\n    if (isUndefined_default()(state)) {\n        state = !hasClass_default()(element, className);\n    }\n    var toggleFn = state ? (addClass_default()) : (removeClass_default());\n    toggleFn(element, className);\n}\nfunction createElementWith(contents, target) {\n    var container = document.createElement('div');\n    if (isString_default()(contents)) {\n        container.innerHTML = contents;\n    }\n    else {\n        container.appendChild(contents);\n    }\n    var firstChild = container.firstChild;\n    if (target) {\n        target.appendChild(firstChild);\n    }\n    return firstChild;\n}\nfunction getOuterWidth(el) {\n    var computed = window.getComputedStyle(el);\n    return (['margin-left', 'margin-right'].reduce(function (acc, type) { return acc + parseInt(computed.getPropertyValue(type), 10); }, 0) + el.offsetWidth);\n}\nfunction closest(node, found) {\n    var condition;\n    if (isString(found)) {\n        condition = function (target) { return matches(target, found); };\n    }\n    else {\n        condition = function (target) { return target === found; };\n    }\n    while (node && node !== document) {\n        if (isElemNode(node) && condition(node)) {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction getTotalOffset(el, root) {\n    var offsetTop = 0;\n    var offsetLeft = 0;\n    while (el && el !== root) {\n        var top = el.offsetTop, left = el.offsetLeft, offsetParent = el.offsetParent;\n        offsetTop += top;\n        offsetLeft += left;\n        if (offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.offsetParent;\n    }\n    return { offsetTop: offsetTop, offsetLeft: offsetLeft };\n}\nfunction finalizeHtml(html, needHtmlText) {\n    var result;\n    if (needHtmlText) {\n        result = html.innerHTML;\n    }\n    else {\n        var frag = document.createDocumentFragment();\n        var childNodes = toArray(html.childNodes);\n        var length = childNodes.length;\n        for (var i = 0; i < length; i += 1) {\n            frag.appendChild(childNodes[i]);\n        }\n        result = frag;\n    }\n    return result;\n}\nfunction dom_empty(node) {\n    while (node.firstChild) {\n        node.removeChild(node.firstChild);\n    }\n}\nfunction appendNode(node, appended) {\n    if (isString(appended)) {\n        node.insertAdjacentHTML('beforeend', appended);\n    }\n    else {\n        var nodes = appended.length\n            ? toArray(appended)\n            : [appended];\n        for (var i = 0, len = nodes.length; i < len; i += 1) {\n            node.appendChild(nodes[i]);\n        }\n    }\n}\nfunction prependNode(node, appended) {\n    if (isString(appended)) {\n        node.insertAdjacentHTML('afterbegin', appended);\n    }\n    else {\n        var nodes = appended.length\n            ? toArray(appended)\n            : [appended];\n        for (var i = nodes.length - 1, len = 0; i >= len; i -= 1) {\n            node.insertBefore(nodes[i], node.firstChild);\n        }\n    }\n}\nfunction setAttributes(attributes, element) {\n    Object.keys(attributes).forEach(function (attrName) {\n        if (isNil(attributes[attrName])) {\n            element.removeAttribute(attrName);\n        }\n        else {\n            element.setAttribute(attrName, attributes[attrName]);\n        }\n    });\n}\nfunction replaceBRWithEmptyBlock(html) {\n    // remove br in paragraph to compatible with markdown\n    var replacedHTML = html.replace(/<p><br\\s*\\/*><\\/p>/gi, '<p></p>');\n    var reHTMLTag = new RegExp(HTML_TAG, 'ig');\n    var htmlTagMatched = replacedHTML.match(reHTMLTag);\n    htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function (htmlTag, index) {\n        if (reBR.test(htmlTag)) {\n            var alternativeTag = ALTERNATIVE_TAG_FOR_BR;\n            if (index) {\n                var prevTag = htmlTagMatched[index - 1];\n                var openTagMatched = prevTag.match(OPEN_TAG);\n                if (openTagMatched && !/br/i.test(openTagMatched[1])) {\n                    var tagName = openTagMatched[1];\n                    alternativeTag = \"</\" + tagName + \"><\" + tagName + \">\";\n                }\n            }\n            replacedHTML = replacedHTML.replace(reBR, alternativeTag);\n        }\n    });\n    return replacedHTML;\n}\nfunction removeProseMirrorHackNodes(html) {\n    var reProseMirrorImage = /<img class=\"ProseMirror-separator\" alt=\"\">/g;\n    var reProseMirrorTrailingBreak = / class=\"ProseMirror-trailingBreak\"/g;\n    var resultHTML = html;\n    resultHTML = resultHTML.replace(reProseMirrorImage, '');\n    resultHTML = resultHTML.replace(reProseMirrorTrailingBreak, '');\n    return resultHTML;\n}\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isFunction.js\nvar isFunction = __nested_webpack_require_87464__(294);\nvar isFunction_default = /*#__PURE__*/__nested_webpack_require_87464__.n(isFunction);\n;// CONCATENATED MODULE: ./src/utils/markdown.ts\n\nfunction hasSpecificTypeAncestor(mdNode) {\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        types[_i - 1] = arguments[_i];\n    }\n    while (mdNode && mdNode.parent && mdNode.parent.type !== 'document') {\n        if (includes(types, mdNode.parent.type)) {\n            return true;\n        }\n        mdNode = mdNode.parent;\n    }\n    return false;\n}\nfunction markdown_getMdStartLine(mdNode) {\n    return mdNode.sourcepos[0][0];\n}\nfunction markdown_getMdEndLine(mdNode) {\n    return mdNode.sourcepos[1][0];\n}\nfunction getMdStartCh(mdNode) {\n    return mdNode.sourcepos[0][1];\n}\nfunction getMdEndCh(mdNode) {\n    return mdNode.sourcepos[1][1];\n}\nfunction isMultiLineNode(mdNode) {\n    var type = mdNode.type;\n    return type === 'codeBlock' || type === 'paragraph';\n}\nfunction isHTMLNode(mdNode) {\n    var type = mdNode.type;\n    return type === 'htmlBlock' || type === 'htmlInline';\n}\nfunction markdown_isStyledInlineNode(mdNode) {\n    var type = mdNode.type;\n    return (type === 'strike' ||\n        type === 'strong' ||\n        type === 'emph' ||\n        type === 'code' ||\n        type === 'link' ||\n        type === 'image');\n}\nfunction isCodeBlockNode(mdNode) {\n    return mdNode && mdNode.type === 'codeBlock';\n}\nfunction isCustomBlockNode(mdNode) {\n    return mdNode && mdNode.type === 'customBlock';\n}\nfunction isListNode(mdNode) {\n    return mdNode && (mdNode.type === 'item' || mdNode.type === 'list');\n}\nfunction isOrderedListNode(mdNode) {\n    return isListNode(mdNode) && mdNode.listData.type === 'ordered';\n}\nfunction isBulletListNode(mdNode) {\n    return isListNode(mdNode) && mdNode.listData.type !== 'ordered';\n}\nfunction isTableCellNode(mdNode) {\n    return mdNode && (mdNode.type === 'tableCell' || mdNode.type === 'tableDelimCell');\n}\nfunction isInlineNode(mdNode) {\n    switch (mdNode.type) {\n        case 'code':\n        case 'text':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'htmlInline':\n        case 'linebreak':\n        case 'softbreak':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction findClosestNode(mdNode, condition, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        if (condition(mdNode)) {\n            return mdNode;\n        }\n        mdNode = mdNode.parent;\n    }\n    return null;\n}\nfunction traverseParentNodes(mdNode, iteratee, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        iteratee(mdNode);\n        mdNode = mdNode.parent;\n    }\n}\nfunction addOffsetPos(originPos, offset) {\n    return [originPos[0], originPos[1] + offset];\n}\nfunction setOffsetPos(originPos, newOffset) {\n    return [originPos[0], newOffset];\n}\nfunction getInlineMarkdownText(mdNode) {\n    var text = mdNode.firstChild.literal;\n    switch (mdNode.type) {\n        case 'emph':\n            return \"*\" + text + \"*\";\n        case 'strong':\n            return \"**\" + text + \"**\";\n        case 'strike':\n            return \"~~\" + text + \"~~\";\n        case 'code':\n            return \"`\" + text + \"`\";\n        case 'link':\n        case 'image':\n            /* eslint-disable no-case-declarations */\n            var _a = mdNode, destination = _a.destination, title = _a.title;\n            var delim = mdNode.type === 'link' ? '' : '!';\n            return delim + \"[\" + text + \"](\" + destination + (title ? \" \\\"\" + title + \"\\\"\" : '') + \")\";\n        default:\n            return null;\n    }\n}\nfunction markdown_isContainer(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction markdown_getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var childNode = event.node;\n        if (childNode.type === 'text') {\n            buffer.push(childNode.literal);\n        }\n    }\n    return buffer.join('');\n}\n\n;// CONCATENATED MODULE: ./src/widget/rules.ts\n\nvar widgetRules = (/* unused pure expression or super */ null && (0));\nvar widgetRuleMap = {};\nvar reWidgetPrefix = /\\$\\$widget\\d+\\s/;\nfunction unwrapWidgetSyntax(text) {\n    var index = text.search(reWidgetPrefix);\n    if (index !== -1) {\n        var rest = text.substring(index);\n        var replaced = rest.replace(reWidgetPrefix, '').replace('$$', '');\n        text = text.substring(0, index);\n        text += unwrapWidgetSyntax(replaced);\n    }\n    return text;\n}\nfunction createWidgetContent(info, text) {\n    return \"$$\" + info + \" \" + text + \"$$\";\n}\nfunction widgetToDOM(info, text) {\n    var _a = widgetRuleMap[info], rule = _a.rule, toDOM = _a.toDOM;\n    var matches = unwrapWidgetSyntax(text).match(rule);\n    if (matches) {\n        text = matches[0];\n    }\n    return toDOM(text);\n}\nfunction getWidgetRules() {\n    return widgetRules;\n}\nfunction setWidgetRules(rules) {\n    widgetRules = rules;\n    widgetRules.forEach(function (rule, index) {\n        widgetRuleMap[\"widget\" + index] = rule;\n    });\n}\nfunction mergeNodes(nodes, text, schema, ruleIndex) {\n    return nodes.concat(createNodesWithWidget(text, schema, ruleIndex));\n}\n/**\n * create nodes with plain text and replace text matched to the widget rules with the widget node\n * For example, in case the text and widget rules as below\n *\n * text: $test plain text #test\n * widget rules: [{ rule: /$.+/ }, { rule: /#.+/ }]\n *\n * The creating node process is recursive and is as follows.\n *\n * in first widget rule(/$.+/)\n *  $test -> widget node\n *  plain text -> match with next widget rule\n *  #test -> match with next widget rule\n *\n * in second widget rule(/#.+/)\n *  plain text -> text node(no rule for matching)\n *  #test -> widget node\n */\nfunction createNodesWithWidget(text, schema, ruleIndex) {\n    if (ruleIndex === void 0) { ruleIndex = 0; }\n    var nodes = [];\n    var rule = (widgetRules[ruleIndex] || {}).rule;\n    var nextRuleIndex = ruleIndex + 1;\n    text = unwrapWidgetSyntax(text);\n    if (rule && rule.test(text)) {\n        var index = void 0;\n        while ((index = text.search(rule)) !== -1) {\n            var prev = text.substring(0, index);\n            // get widget node on first splitted text using next widget rule\n            if (prev) {\n                nodes = mergeNodes(nodes, prev, schema, nextRuleIndex);\n            }\n            // build widget node using current widget rule\n            text = text.substring(index);\n            var literal = text.match(rule)[0];\n            var info = \"widget\" + ruleIndex;\n            nodes.push(schema.nodes.widget.create({ info: info }, schema.text(createWidgetContent(info, literal))));\n            text = text.substring(literal.length);\n        }\n        // get widget node on last splitted text using next widget rule\n        if (text) {\n            nodes = mergeNodes(nodes, text, schema, nextRuleIndex);\n        }\n    }\n    else if (text) {\n        nodes =\n            ruleIndex < widgetRules.length - 1\n                ? mergeNodes(nodes, text, schema, nextRuleIndex)\n                : [schema.text(text)];\n    }\n    return nodes;\n}\nfunction getWidgetContent(widgetNode) {\n    var event;\n    var text = '';\n    var walker = widgetNode.walker();\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            if (node !== widgetNode && node.type !== 'text') {\n                text += getInlineMarkdownText(node);\n                // skip the children\n                walker.resumeAt(widgetNode, false);\n                walker.next();\n            }\n            else if (node.type === 'text') {\n                text += node.literal;\n            }\n        }\n    }\n    return text;\n}\n\n// EXTERNAL MODULE: ../../node_modules/dompurify/dist/purify.js\nvar purify = __nested_webpack_require_87464__(368);\nvar purify_default = /*#__PURE__*/__nested_webpack_require_87464__.n(purify);\n;// CONCATENATED MODULE: ./src/sanitizer/htmlSanitizer.ts\n\n\n\nvar CAN_BE_WHITE_TAG_LIST = ['iframe', 'embed'];\nvar whiteTagList = [];\nfunction htmlSanitizer_registerTagWhitelistIfPossible(tagName) {\n    if (common_includes(CAN_BE_WHITE_TAG_LIST, tagName)) {\n        whiteTagList.push(tagName.toLowerCase());\n    }\n}\nfunction sanitizeHTML(html, options) {\n    return purify_default().sanitize(html, tslib_es6_assign({ ADD_TAGS: whiteTagList, ADD_ATTR: ['rel', 'target', 'hreflang', 'type'], FORBID_TAGS: [\n            'input',\n            'script',\n            'textarea',\n            'form',\n            'button',\n            'select',\n            'meta',\n            'style',\n            'link',\n            'title',\n            'object',\n            'base',\n        ] }, options));\n}\n\n;// CONCATENATED MODULE: ./src/wysiwyg/nodes/html.ts\n\n\n\n\nfunction getChildrenHTML(node, typeName) {\n    return node\n        .literal.replace(new RegExp(\"(<\\\\s*\" + typeName + \"[^>]*>)|(</\" + typeName + \"\\\\s*[>])\", 'ig'), '')\n        .trim();\n}\nfunction getHTMLAttrsByHTMLString(html) {\n    html = html.match(reHTMLTag)[0];\n    var attrs = html.match(new RegExp(constants_ATTRIBUTE, 'g'));\n    return attrs\n        ? attrs.reduce(function (acc, attr) {\n            var _a = attr.trim().split('='), name = _a[0], values = _a.slice(1);\n            if (values.length) {\n                acc[name] = values.join('=').replace(/'|\"/g, '').trim();\n            }\n            return acc;\n        }, {})\n        : {};\n}\nfunction getHTMLAttrs(dom) {\n    return toArray_default()(dom.attributes).reduce(function (acc, attr) {\n        acc[attr.nodeName] = attr.nodeValue;\n        return acc;\n    }, {});\n}\nfunction sanitizeDOM(node, typeName, sanitizer, wwToDOMAdaptor) {\n    var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node);\n    var html = sanitizer(dom.outerHTML);\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    dom = container.firstChild;\n    var htmlAttrs = getHTMLAttrs(dom);\n    return { dom: dom, htmlAttrs: htmlAttrs };\n}\nvar schemaFactory = {\n    htmlBlock: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            atom: true,\n            content: 'block+',\n            group: 'block',\n            attrs: {\n                htmlAttrs: { default: {} },\n                childrenHTML: { default: '' },\n                htmlBlock: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                            childrenHTML: dom.innerHTML,\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var _a = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;\n                htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + \" html-block\" : 'html-block';\n                return __spreadArray([typeName, htmlAttrs], toArray_default()(dom.childNodes));\n            },\n        };\n    },\n    htmlInline: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            attrs: {\n                htmlAttrs: { default: {} },\n                htmlInline: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var htmlAttrs = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor).htmlAttrs;\n                return [typeName, htmlAttrs, 0];\n            },\n        };\n    },\n};\nfunction createHTMLSchemaMap(convertorMap, sanitizeHTML, wwToDOMAdaptor) {\n    var htmlSchemaMap = { nodes: {}, marks: {} };\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            Object.keys(convertorMap[htmlType]).forEach(function (type) {\n                var targetType = htmlType === 'htmlBlock' ? 'nodes' : 'marks';\n                // register tag white list for preventing to remove the html in sanitizer\n                registerTagWhitelistIfPossible(type);\n                htmlSchemaMap[targetType][type] = schemaFactory[htmlType](type, sanitizeHTML, wwToDOMAdaptor);\n            });\n        }\n    });\n    return htmlSchemaMap;\n}\n\n;// CONCATENATED MODULE: ./src/markdown/htmlRenderConvertors.ts\n\n\n\n\n\n\nvar reCloseTag = /^\\s*<\\s*\\//;\nvar htmlRenderConvertors_baseConvertors = {\n    paragraph: function (_, _a) {\n        var entering = _a.entering, origin = _a.origin, options = _a.options;\n        if (options.nodeId) {\n            return {\n                type: entering ? 'openTag' : 'closeTag',\n                outerNewLine: true,\n                tagName: 'p',\n            };\n        }\n        return origin();\n    },\n    softbreak: function (node) {\n        var isPrevNodeHTML = node.prev && node.prev.type === 'htmlInline';\n        var isPrevBR = isPrevNodeHTML && /<br ?\\/?>/.test(node.prev.literal);\n        var content = isPrevBR ? '\\n' : '<br>\\n';\n        return { type: 'html', content: content };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var attributes = {};\n            var classNames = [];\n            if (node.listData.task) {\n                attributes['data-task'] = '';\n                classNames.push('task-list-item');\n                if (node.listData.checked) {\n                    classNames.push('checked');\n                    attributes['data-task-checked'] = '';\n                }\n            }\n            return {\n                type: 'openTag',\n                tagName: 'li',\n                classNames: classNames,\n                attributes: attributes,\n                outerNewLine: true,\n            };\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    code: function (node) {\n        var attributes = { 'data-backticks': String(node.tickCount) };\n        return [\n            { type: 'openTag', tagName: 'code', attributes: attributes },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var _a = node, fenceLength = _a.fenceLength, info = _a.info;\n        var infoWords = info ? info.split(/\\s+/) : [];\n        var preClasses = [];\n        var codeAttrs = {};\n        if (fenceLength > 3) {\n            codeAttrs['data-backticks'] = fenceLength;\n        }\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            var lang = infoWords[0];\n            preClasses.push(\"lang-\" + lang);\n            codeAttrs['data-language'] = lang;\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', classNames: preClasses },\n            { type: 'openTag', tagName: 'code', attributes: codeAttrs },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre' },\n        ];\n    },\n    customInline: function (node, _a) {\n        var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;\n        var info = node.info;\n        if (info.indexOf('widget') !== -1 && entering) {\n            skipChildren();\n            var content = getWidgetContent(node);\n            var htmlInline = widgetToDOM(info, content).outerHTML;\n            return [\n                { type: 'openTag', tagName: 'span', classNames: ['tui-widget'] },\n                { type: 'html', content: htmlInline },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n        }\n        return origin();\n    },\n};\nfunction getHTMLRenderConvertors(linkAttributes, customConvertors) {\n    var convertors = tslib_es6_assign({}, htmlRenderConvertors_baseConvertors);\n    if (linkAttributes) {\n        convertors.link = function (_, _a) {\n            var entering = _a.entering, origin = _a.origin;\n            var result = origin();\n            if (entering) {\n                result.attributes = tslib_es6_assign(tslib_es6_assign({}, result.attributes), linkAttributes);\n            }\n            return result;\n        };\n    }\n    if (customConvertors) {\n        Object.keys(customConvertors).forEach(function (nodeType) {\n            var orgConvertor = convertors[nodeType];\n            var customConvertor = customConvertors[nodeType];\n            if (orgConvertor && isFunction_default()(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var newContext = tslib_es6_assign({}, context);\n                    newContext.origin = function () { return orgConvertor(node, context); };\n                    return customConvertor(node, newContext);\n                };\n            }\n            else if (common_includes(['htmlBlock', 'htmlInline'], nodeType) && !isFunction_default()(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var matched = node.literal.match(reHTMLTag);\n                    if (matched) {\n                        var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];\n                        var typeName = (openTagName || closeTagName).toLowerCase();\n                        var htmlConvertor = customConvertor[typeName];\n                        var childrenHTML = getChildrenHTML(node, typeName);\n                        if (htmlConvertor) {\n                            // copy for preventing to overwrite the originial property\n                            var newNode = tslib_es6_assign({}, node);\n                            newNode.attrs = getHTMLAttrsByHTMLString(rootHTML);\n                            newNode.childrenHTML = childrenHTML;\n                            newNode.type = typeName;\n                            context.entering = !reCloseTag.test(node.literal);\n                            return htmlConvertor(newNode, context);\n                        }\n                    }\n                    return context.origin();\n                };\n            }\n            else {\n                convertors[nodeType] = customConvertor;\n            }\n        });\n    }\n    return convertors;\n}\n\n;// CONCATENATED MODULE: ./src/markdown/scroll/dom.ts\n\n\nvar nestableTypes = (/* unused pure expression or super */ null && (0));\nvar nestableTagNames = ['UL', 'OL', 'BLOCKQUOTE'];\nfunction isBlankLine(doc, index) {\n    var _a;\n    var pmNode = doc.child(index);\n    return !pmNode.childCount || (pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim()));\n}\nfunction getEditorRangeHeightInfo(doc, mdNode, children) {\n    var start = getMdStartLine(mdNode) - 1;\n    var end = getMdEndLine(mdNode) - 1;\n    var rect = children[start].getBoundingClientRect();\n    var height = children[end].offsetTop -\n        children[start].offsetTop +\n        children[end].clientHeight;\n    return {\n        height: height <= 0\n            ? children[start].clientHeight\n            : height + getBlankLinesHeight(doc, children, Math.min(end + 1, doc.childCount - 1)),\n        rect: rect,\n    };\n}\nfunction getBlankLinesHeight(doc, children, start) {\n    var end = doc.childCount - 1;\n    var height = 0;\n    while (start <= end && isBlankLine(doc, start)) {\n        height += children[start].clientHeight;\n        start += 1;\n    }\n    return height;\n}\nfunction findAncestorHavingId(el, root) {\n    while (!el.getAttribute('data-nodeid') && el.parentElement !== root) {\n        el = el.parentElement;\n    }\n    return el;\n}\nfunction dom_getTotalOffsetTop(el, root) {\n    var offsetTop = 0;\n    while (el && el !== root) {\n        if (!common_includes(nestableTagNames, el.tagName)) {\n            offsetTop += el.offsetTop;\n        }\n        if (el.offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.parentElement;\n    }\n    return offsetTop;\n}\nfunction findAdjacentElementToScrollTop(scrollTop, root) {\n    var el = root;\n    var prev = null;\n    while (el) {\n        var firstElementChild = el.firstElementChild;\n        if (!firstElementChild) {\n            break;\n        }\n        var lastSibling = findLastSiblingElementToScrollTop(firstElementChild, scrollTop, dom_getTotalOffsetTop(el, root));\n        prev = el;\n        el = lastSibling;\n    }\n    var adjacentEl = el || prev;\n    return adjacentEl === root ? null : adjacentEl;\n}\nfunction findLastSiblingElementToScrollTop(el, scrollTop, offsetTop) {\n    if (el && scrollTop > offsetTop + el.offsetTop) {\n        return (findLastSiblingElementToScrollTop(el.nextElementSibling, scrollTop, offsetTop) || el);\n    }\n    return null;\n}\nfunction getAdditionalPos(scrollTop, offsetTop, height, targetNodeHeight) {\n    var ratio = Math.min((scrollTop - offsetTop) / height, 1);\n    return ratio * targetNodeHeight;\n}\nfunction getParentNodeObj(previewContent, mdNode) {\n    var el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    while (!el || isStyledInlineNode(mdNode)) {\n        mdNode = mdNode.parent;\n        el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    }\n    return getNonNestableNodeObj({ mdNode: mdNode, el: el });\n}\nfunction getNonNestableNodeObj(_a) {\n    var mdNode = _a.mdNode, el = _a.el;\n    while ((includes(nestableTypes, mdNode.type) || mdNode.type === 'table') && mdNode.firstChild) {\n        mdNode = mdNode.firstChild;\n        el = el.firstElementChild;\n    }\n    return { mdNode: mdNode, el: el };\n}\n\n;// CONCATENATED MODULE: ./src/markdown/scroll/offset.ts\n\n\nvar offsetInfoMap = {};\nfunction setHeight(id, height) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].height = height;\n}\nfunction setOffsetTop(id, offsetTop) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].offsetTop = offsetTop;\n}\nfunction getHeight(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].height;\n}\nfunction getOffsetTop(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].offsetTop;\n}\nfunction removeOffsetInfoByNode(node) {\n    if (node) {\n        delete offsetInfoMap[Number(node.getAttribute('data-nodeid'))];\n        toArray_default()(node.children).forEach(function (child) {\n            removeOffsetInfoByNode(child);\n        });\n    }\n}\nfunction getAndSaveOffsetInfo(node, root, mdNodeId) {\n    var cachedHeight = getHeight(mdNodeId);\n    var cachedTop = getOffsetTop(mdNodeId);\n    var nodeHeight = cachedHeight || node.clientHeight;\n    var offsetTop = cachedTop || getTotalOffsetTop(node, root) || node.offsetTop;\n    if (!cachedHeight) {\n        setHeight(mdNodeId, nodeHeight);\n    }\n    if (!cachedTop) {\n        setOffsetTop(mdNodeId, offsetTop);\n    }\n    return { nodeHeight: nodeHeight, offsetTop: offsetTop };\n}\n\n;// CONCATENATED MODULE: ./src/markdown/mdPreview.ts\n\n\n\n\n\n\n\n\n\n\n\nvar CLASS_HIGHLIGHT = cls('md-preview-highlight');\nfunction findTableCell(tableRow, chOffset) {\n    var cell = tableRow.firstChild;\n    while (cell && cell.next) {\n        if (getMdStartCh(cell.next) > chOffset + 1) {\n            break;\n        }\n        cell = cell.next;\n    }\n    return cell;\n}\n/**\n * Class Markdown Preview\n * @param {HTMLElement} el - base element\n * @param {eventEmitter} eventEmitter - event manager\n * @param {object} options\n * @param {boolean} options.isViewer - true for view-only mode\n * @param {boolean} options.highlight - true for using live-highlight feature\n * @param {object} opitons.linkAttributes - attributes for link element\n * @param {object} opitons.customHTMLRenderer - map of custom HTML render functions\n *\n * @ignore\n */\nvar MarkdownPreview = /** @class */ (function () {\n    function MarkdownPreview(eventEmitter, options) {\n        var el = document.createElement('div');\n        this.el = el;\n        this.eventEmitter = eventEmitter;\n        this.isViewer = !!options.isViewer;\n        this.el.className = cls('md-preview');\n        var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;\n        this.renderer = new Renderer({\n            gfm: true,\n            nodeId: true,\n            convertors: getHTMLRenderConvertors(linkAttributes, customHTMLRenderer),\n        });\n        this.cursorNodeId = null;\n        this.sanitizer = sanitizer;\n        this.initEvent(highlight);\n        this.initContentSection();\n        // To prevent overflowing contents in the viewer\n        if (this.isViewer) {\n            this.previewContent.style.overflowWrap = 'break-word';\n        }\n    }\n    MarkdownPreview.prototype.initContentSection = function () {\n        this.previewContent = createElementWith(\"<div class=\\\"\" + cls('contents') + \"\\\"></div>\");\n        if (!this.isViewer) {\n            this.el.appendChild(this.previewContent);\n        }\n    };\n    MarkdownPreview.prototype.toggleActive = function (active) {\n        toggleClass(this.el, 'active', active);\n    };\n    MarkdownPreview.prototype.initEvent = function (highlight) {\n        var _this = this;\n        this.eventEmitter.listen('updatePreview', this.update.bind(this));\n        if (this.isViewer) {\n            return;\n        }\n        if (highlight) {\n            this.eventEmitter.listen('changeToolbarState', function (_a) {\n                var mdNode = _a.mdNode, cursorPos = _a.cursorPos;\n                _this.updateCursorNode(mdNode, cursorPos);\n            });\n            this.eventEmitter.listen('blur', function () {\n                _this.removeHighlight();\n            });\n        }\n        on_default()(this.el, 'scroll', function (event) {\n            _this.eventEmitter.emit('scroll', 'preview', findAdjacentElementToScrollTop(event.target.scrollTop, _this.previewContent));\n        });\n        this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(true); });\n        this.eventEmitter.listen('changePreviewTabWrite', function () { return _this.toggleActive(false); });\n    };\n    MarkdownPreview.prototype.removeHighlight = function () {\n        if (this.cursorNodeId) {\n            var currentEl = this.getElementByNodeId(this.cursorNodeId);\n            if (currentEl) {\n                removeClass_default()(currentEl, CLASS_HIGHLIGHT);\n            }\n        }\n    };\n    MarkdownPreview.prototype.updateCursorNode = function (cursorNode, cursorPos) {\n        if (cursorNode) {\n            cursorNode = findClosestNode(cursorNode, function (mdNode) { return !isInlineNode(mdNode); });\n            if (cursorNode.type === 'tableRow') {\n                cursorNode = findTableCell(cursorNode, cursorPos[1]);\n            }\n            else if (cursorNode.type === 'tableBody') {\n                // empty line next to table\n                cursorNode = null;\n            }\n        }\n        var cursorNodeId = cursorNode ? cursorNode.id : null;\n        if (this.cursorNodeId === cursorNodeId) {\n            return;\n        }\n        var oldEL = this.getElementByNodeId(this.cursorNodeId);\n        var newEL = this.getElementByNodeId(cursorNodeId);\n        if (oldEL) {\n            removeClass_default()(oldEL, CLASS_HIGHLIGHT);\n        }\n        if (newEL) {\n            addClass_default()(newEL, CLASS_HIGHLIGHT);\n        }\n        this.cursorNodeId = cursorNodeId;\n    };\n    MarkdownPreview.prototype.getElementByNodeId = function (nodeId) {\n        return nodeId\n            ? this.previewContent.querySelector(\"[data-nodeid=\\\"\" + nodeId + \"\\\"]\")\n            : null;\n    };\n    MarkdownPreview.prototype.update = function (changed) {\n        var _this = this;\n        changed.forEach(function (editResult) { return _this.replaceRangeNodes(editResult); });\n        this.eventEmitter.emit('afterPreviewRender', this);\n    };\n    MarkdownPreview.prototype.replaceRangeNodes = function (editResult) {\n        var _this = this;\n        var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;\n        var contentEl = this.previewContent;\n        var newHtml = this.eventEmitter.emitReduce('beforePreviewRender', this.sanitizer(nodes.map(function (node) { return _this.renderer.render(node); }).join('')));\n        if (!removedNodeRange) {\n            contentEl.insertAdjacentHTML('afterbegin', newHtml);\n        }\n        else {\n            var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];\n            var startEl = this.getElementByNodeId(startNodeId);\n            var endEl = this.getElementByNodeId(endNodeId);\n            if (startEl) {\n                startEl.insertAdjacentHTML('beforebegin', newHtml);\n                var el = startEl;\n                while (el && el !== endEl) {\n                    var nextEl = el.nextElementSibling;\n                    removeNode(el);\n                    removeOffsetInfoByNode(el);\n                    el = nextEl;\n                }\n                if (el === null || el === void 0 ? void 0 : el.parentNode) {\n                    removeNode(el);\n                    removeOffsetInfoByNode(el);\n                }\n            }\n        }\n    };\n    MarkdownPreview.prototype.getRenderer = function () {\n        return this.renderer;\n    };\n    MarkdownPreview.prototype.destroy = function () {\n        off_default()(this.el, 'scroll');\n        this.el = null;\n    };\n    MarkdownPreview.prototype.getElement = function () {\n        return this.el;\n    };\n    MarkdownPreview.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.previewContent.innerHTML);\n    };\n    MarkdownPreview.prototype.setHTML = function (html) {\n        this.previewContent.innerHTML = html;\n    };\n    MarkdownPreview.prototype.setHeight = function (height) {\n        css_default()(this.el, { height: height + \"px\" });\n    };\n    MarkdownPreview.prototype.setMinHeight = function (minHeight) {\n        css_default()(this.el, { minHeight: minHeight + \"px\" });\n    };\n    return MarkdownPreview;\n}());\n/* harmony default export */ var mdPreview = (MarkdownPreview);\n\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-state\",\"commonjs2\":\"prosemirror-state\",\"amd\":\"prosemirror-state\"}\nvar external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_ = __nested_webpack_require_87464__(814);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-inputrules\",\"commonjs2\":\"prosemirror-inputrules\",\"amd\":\"prosemirror-inputrules\"}\nvar external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_ = __nested_webpack_require_87464__(479);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-view\",\"commonjs2\":\"prosemirror-view\",\"amd\":\"prosemirror-view\"}\nvar external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_ = __nested_webpack_require_87464__(311);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-keymap\",\"commonjs2\":\"prosemirror-keymap\",\"amd\":\"prosemirror-keymap\"}\nvar external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_ = __nested_webpack_require_87464__(481);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-model\",\"commonjs2\":\"prosemirror-model\",\"amd\":\"prosemirror-model\"}\nvar external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_ = __nested_webpack_require_87464__(43);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/array/inArray.js\nvar inArray = __nested_webpack_require_87464__(928);\nvar inArray_default = /*#__PURE__*/__nested_webpack_require_87464__.n(inArray);\n;// CONCATENATED MODULE: ./src/utils/map.ts\n\n/**\n * @class\n * @ignore\n * @classdesc ES6 Map\n */\nvar map_Map = /** @class */ (function () {\n    function Map() {\n        this.keys = [];\n        this.values = [];\n    }\n    Map.prototype.getKeyIndex = function (key) {\n        return inArray_default()(key, this.keys);\n    };\n    Map.prototype.get = function (key) {\n        return this.values[this.getKeyIndex(key)];\n    };\n    Map.prototype.set = function (key, value) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.values[keyIndex] = value;\n        }\n        else {\n            this.keys.push(key);\n            this.values.push(value);\n        }\n        return this;\n    };\n    Map.prototype.has = function (key) {\n        return this.getKeyIndex(key) > -1;\n    };\n    Map.prototype.delete = function (key) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.keys.splice(keyIndex, 1);\n            this.values.splice(keyIndex, 1);\n            return true;\n        }\n        return false;\n    };\n    Map.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        if (thisArg === void 0) { thisArg = this; }\n        this.values.forEach(function (value, index) {\n            if (value && _this.keys[index]) {\n                callback.call(thisArg, value, _this.keys[index], _this);\n            }\n        });\n    };\n    Map.prototype.clear = function () {\n        this.keys = [];\n        this.values = [];\n    };\n    return Map;\n}());\n/* harmony default export */ var utils_map = (map_Map);\n\n;// CONCATENATED MODULE: ./src/i18n/i18n.ts\n/**\n * @fileoverview Implements i18n\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\n\n\nvar DEFAULT_CODE = 'en-US';\n/**\n * Class I18n\n * @ignore\n */\nvar I18n = /** @class */ (function () {\n    function I18n() {\n        this.code = DEFAULT_CODE;\n        this.langs = new utils_map();\n    }\n    I18n.prototype.setCode = function (code) {\n        this.code = code || DEFAULT_CODE;\n    };\n    /**\n     * Set language set\n     * @param {string|string[]} codes locale code\n     * @param {object} data language set\n     */\n    I18n.prototype.setLanguage = function (codes, data) {\n        var _this = this;\n        codes = [].concat(codes);\n        codes.forEach(function (code) {\n            if (!_this.langs.has(code)) {\n                _this.langs.set(code, data);\n            }\n            else {\n                var langData = _this.langs.get(code);\n                _this.langs.set(code, extend_default()(langData, data));\n            }\n        });\n    };\n    I18n.prototype.get = function (key, code) {\n        if (!code) {\n            code = this.code;\n        }\n        var langSet = this.langs.get(code);\n        if (!langSet) {\n            langSet = this.langs.get(DEFAULT_CODE);\n        }\n        var text = langSet[key];\n        if (!text) {\n            throw new Error(\"There is no text key \\\"\" + key + \"\\\" in \" + code);\n        }\n        return text;\n    };\n    return I18n;\n}());\n\n/* harmony default export */ var i18n = (new I18n());\n\n;// CONCATENATED MODULE: ./src/wysiwyg/helper/node.ts\n\n\nfunction findNodeBy(pos, condition) {\n    var depth = pos.depth;\n    while (depth) {\n        var node = pos.node(depth);\n        if (condition(node, depth)) {\n            return {\n                node: node,\n                depth: depth,\n                offset: depth > 0 ? pos.before(depth) : 0,\n            };\n        }\n        depth -= 1;\n    }\n    return null;\n}\nfunction node_isListNode(_a) {\n    var type = _a.type;\n    return type.name === 'bulletList' || type.name === 'orderedList';\n}\nfunction isInListNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem' || type.name === 'bulletList' || type.name === 'orderedList';\n    });\n}\nfunction isInTableNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n    });\n}\nfunction findListItem(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem';\n    });\n}\nfunction createDOMInfoParsedRawHTML(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            var rawHTML = dom.getAttribute('data-raw-html');\n            return __assign({}, (rawHTML && { rawHTML: rawHTML }));\n        },\n    };\n}\nfunction createCellAttrs(attrs) {\n    return Object.keys(attrs).reduce(function (acc, attrName) {\n        if (attrName !== 'rawHTML' && attrs[attrName]) {\n            attrName = attrName === 'className' ? 'class' : attrName;\n            acc[attrName] = attrs[attrName];\n        }\n        return acc;\n    }, {});\n}\nfunction createParsedCellDOM(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            return ['rawHTML', 'colspan', 'rowspan', 'extended'].reduce(function (acc, attrName) {\n                var attrNameInDOM = attrName === 'rawHTML' ? 'data-raw-html' : attrName;\n                var attrValue = dom.getAttribute(attrNameInDOM);\n                if (attrValue) {\n                    acc[attrName] = includes(['rawHTML', 'extended'], attrName)\n                        ? attrValue\n                        : Number(attrValue);\n                }\n                return acc;\n            }, {});\n        },\n    };\n}\nfunction getDefaultCustomAttrs() {\n    return {\n        htmlAttrs: { default: null },\n        classNames: { default: null },\n    };\n}\nfunction getCustomAttrs(attrs) {\n    var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;\n    return __assign(__assign({}, htmlAttrs), { class: classNames ? classNames.join(' ') : null });\n}\n\n;// CONCATENATED MODULE: ./src/wysiwyg/helper/tableOffsetMap.ts\n\n\nvar cache = new Map();\n/* eslint-disable @typescript-eslint/no-unused-vars */\nvar TableOffsetMap = /** @class */ (function () {\n    function TableOffsetMap(table, tableRows, tableStartPos, rowInfo) {\n        this.table = table;\n        this.tableRows = tableRows;\n        this.tableStartPos = tableStartPos;\n        this.rowInfo = rowInfo;\n    }\n    TableOffsetMap.create = function (cellPos) {\n        var table = findNodeBy(cellPos, function (_a) {\n            var type = _a.type;\n            return type.name === 'table';\n        });\n        if (table) {\n            var node = table.node, depth = table.depth, offset = table.offset;\n            var cached = cache.get(node);\n            if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset + 1) {\n                return cached;\n            }\n            var rows_1 = [];\n            var tablePos = cellPos.start(depth);\n            var thead = node.child(0);\n            var tbody = node.child(1);\n            var theadCellInfo = createOffsetMap(thead, tablePos);\n            var tbodyCellInfo = createOffsetMap(tbody, tablePos + thead.nodeSize);\n            thead.forEach(function (row) { return rows_1.push(row); });\n            tbody.forEach(function (row) { return rows_1.push(row); });\n            var map = new TableOffsetMap(node, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));\n            cache.set(node, map);\n            return map;\n        }\n        return null;\n    };\n    Object.defineProperty(TableOffsetMap.prototype, \"totalRowCount\", {\n        get: function () {\n            return this.rowInfo.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"totalColumnCount\", {\n        get: function () {\n            return this.rowInfo[0].length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableStartOffset\", {\n        get: function () {\n            return this.tableStartPos;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableEndOffset\", {\n        get: function () {\n            return this.tableStartPos + this.table.nodeSize - 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TableOffsetMap.prototype.getCellInfo = function (rowIdx, colIdx) {\n        return this.rowInfo[rowIdx][colIdx];\n    };\n    TableOffsetMap.prototype.posAt = function (rowIdx, colIdx) {\n        for (var i = 0, rowStart = this.tableStartPos;; i += 1) {\n            var rowEnd = rowStart + this.tableRows[i].nodeSize;\n            if (i === rowIdx) {\n                var index = colIdx;\n                // Skip the cells from previous row(via rowspan)\n                while (index < this.totalColumnCount && this.rowInfo[i][index].offset < rowStart) {\n                    index += 1;\n                }\n                return index === this.totalColumnCount ? rowEnd : this.rowInfo[i][index].offset;\n            }\n            rowStart = rowEnd;\n        }\n    };\n    TableOffsetMap.prototype.getNodeAndPos = function (rowIdx, colIdx) {\n        var cellInfo = this.rowInfo[rowIdx][colIdx];\n        return {\n            node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),\n            pos: cellInfo.offset,\n        };\n    };\n    TableOffsetMap.prototype.extendedRowspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.extendedColspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.getRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getRowspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getCellStartOffset = function (rowIdx, colIdx) {\n        var offset = this.rowInfo[rowIdx][colIdx].offset;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset;\n    };\n    TableOffsetMap.prototype.getCellEndOffset = function (rowIdx, colIdx) {\n        var _a = this.rowInfo[rowIdx][colIdx], offset = _a.offset, nodeSize = _a.nodeSize;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset + nodeSize;\n    };\n    TableOffsetMap.prototype.getCellIndex = function (cellPos) {\n        for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {\n            var rowInfo = this.rowInfo[rowIdx];\n            for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {\n                if (rowInfo[colIdx].offset + 1 > cellPos.pos) {\n                    return [rowIdx, colIdx];\n                }\n            }\n        }\n        return [0, 0];\n    };\n    TableOffsetMap.prototype.getRectOffsets = function (startCellPos, endCellPos) {\n        var _a, _b, _c;\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        if (startCellPos.pos > endCellPos.pos) {\n            _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];\n        }\n        var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];\n        var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];\n        _b = getSortedNumPair(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];\n        _c = getSortedNumPair(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];\n        return this.getSpannedOffsets({ startRowIdx: startRowIdx, startColIdx: startColIdx, endRowIdx: endRowIdx, endColIdx: endColIdx });\n    };\n    TableOffsetMap.prototype.getSpannedOffsets = function (selectionInfo) {\n        return selectionInfo;\n    };\n    return TableOffsetMap;\n}());\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\nvar createOffsetMap = function (headOrBody, startOffset) {\n    var cellInfoMatrix = [];\n    headOrBody.forEach(function (row, rowOffset) {\n        // get row index based on table(not table head or table body)\n        var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };\n        row.forEach(function (_a, cellOffset) {\n            var nodeSize = _a.nodeSize;\n            var colIdx = 0;\n            while (rowInfo[colIdx]) {\n                colIdx += 1;\n            }\n            rowInfo[colIdx] = {\n                // 2 is the sum of the front and back positions of the tag\n                offset: startOffset + rowOffset + cellOffset + 2,\n                nodeSize: nodeSize,\n            };\n            rowInfo.length += 1;\n        });\n        cellInfoMatrix.push(rowInfo);\n    });\n    return cellInfoMatrix;\n};\nfunction mixinTableOffsetMapPrototype(offsetMapMixin, createOffsetMapMixin) {\n    common_assign(TableOffsetMap.prototype, offsetMapMixin);\n    createOffsetMap = createOffsetMapMixin;\n    return TableOffsetMap;\n}\n\n;// CONCATENATED MODULE: ./src/helper/plugin.ts\n\n\n\n\n\n\n\n\n\n\nfunction execPlugin(pluginInfo) {\n    var plugin = pluginInfo.plugin, eventEmitter = pluginInfo.eventEmitter, usageStatistics = pluginInfo.usageStatistics, instance = pluginInfo.instance;\n    var pmState = { Plugin: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin, PluginKey: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.PluginKey, Selection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection, TextSelection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection };\n    var pmView = { Decoration: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.Decoration, DecorationSet: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.DecorationSet };\n    var pmModel = { Fragment: external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment };\n    var pmRules = { InputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.InputRule, inputRules: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.inputRules, undoInputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.undoInputRule };\n    var pmKeymap = { keymap: external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_.keymap };\n    var context = {\n        eventEmitter: eventEmitter,\n        usageStatistics: usageStatistics,\n        instance: instance,\n        pmState: pmState,\n        pmView: pmView,\n        pmModel: pmModel,\n        pmRules: pmRules,\n        pmKeymap: pmKeymap,\n        i18n: i18n,\n    };\n    if (isArray_default()(plugin)) {\n        var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;\n        return pluginFn(context, options);\n    }\n    return plugin(context);\n}\nfunction getPluginInfo(pluginsInfo) {\n    var plugins = pluginsInfo.plugins, eventEmitter = pluginsInfo.eventEmitter, usageStatistics = pluginsInfo.usageStatistics, instance = pluginsInfo.instance;\n    eventEmitter.listen('mixinTableOffsetMapPrototype', mixinTableOffsetMapPrototype);\n    return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function (acc, plugin) {\n        var pluginInfoResult = execPlugin({\n            plugin: plugin,\n            eventEmitter: eventEmitter,\n            usageStatistics: usageStatistics,\n            instance: instance,\n        });\n        if (!pluginInfoResult) {\n            throw new Error('The return value of the executed plugin is empty.');\n        }\n        var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;\n        if (toHTMLRenderers) {\n            acc.toHTMLRenderers = deepMergedCopy(acc.toHTMLRenderers, toHTMLRenderers);\n        }\n        if (toMarkdownRenderers) {\n            acc.toMarkdownRenderers = deepMergedCopy(acc.toMarkdownRenderers, toMarkdownRenderers);\n        }\n        if (markdownPlugins) {\n            acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);\n        }\n        if (wysiwygPlugins) {\n            acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);\n        }\n        if (wysiwygNodeViews) {\n            acc.wwNodeViews = tslib_es6_assign(tslib_es6_assign({}, acc.wwNodeViews), wysiwygNodeViews);\n        }\n        if (markdownCommands) {\n            acc.mdCommands = tslib_es6_assign(tslib_es6_assign({}, acc.mdCommands), markdownCommands);\n        }\n        if (wysiwygCommands) {\n            acc.wwCommands = tslib_es6_assign(tslib_es6_assign({}, acc.wwCommands), wysiwygCommands);\n        }\n        if (toolbarItems) {\n            acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);\n        }\n        if (markdownParsers) {\n            acc.markdownParsers = tslib_es6_assign(tslib_es6_assign({}, acc.markdownParsers), markdownParsers);\n        }\n        return acc;\n    }, {\n        toHTMLRenderers: {},\n        toMarkdownRenderers: {},\n        mdPlugins: [],\n        wwPlugins: [],\n        wwNodeViews: {},\n        mdCommands: {},\n        wwCommands: {},\n        toolbarItems: [],\n        markdownParsers: {},\n    });\n}\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isFalsy.js\nvar isFalsy = __nested_webpack_require_87464__(404);\nvar isFalsy_default = /*#__PURE__*/__nested_webpack_require_87464__.n(isFalsy);\n;// CONCATENATED MODULE: ./src/event/eventEmitter.ts\n\n\n\n\nvar eventTypeList = [\n    'afterPreviewRender',\n    'updatePreview',\n    'changeMode',\n    'needChangeMode',\n    'command',\n    'changePreviewStyle',\n    'changePreviewTabPreview',\n    'changePreviewTabWrite',\n    'scroll',\n    'contextmenu',\n    'show',\n    'hide',\n    'changeLanguage',\n    'changeToolbarState',\n    'toggleScrollSync',\n    'mixinTableOffsetMapPrototype',\n    'setFocusedNode',\n    'removePopupWidget',\n    'query',\n    // provide event for user\n    'openPopup',\n    'closePopup',\n    'addImageBlobHook',\n    'beforePreviewRender',\n    'beforeConvertWysiwygToMarkdown',\n    'load',\n    'loadUI',\n    'change',\n    'caretChange',\n    'destroy',\n    'focus',\n    'blur',\n    'keydown',\n    'keyup',\n];\n/**\n * Class EventEmitter\n * @ignore\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        var _this = this;\n        this.events = new utils_map();\n        this.eventTypes = eventTypeList.reduce(function (types, type) {\n            return tslib_es6_assign(tslib_es6_assign({}, types), { type: type });\n        }, {});\n        this.hold = false;\n        eventTypeList.forEach(function (eventType) {\n            _this.addEventType(eventType);\n        });\n    }\n    /**\n     * Listen event and bind event handler\n     * @param {string} type Event type string\n     * @param {function} handler Event handler\n     */\n    EventEmitter.prototype.listen = function (type, handler) {\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type) || [];\n        if (!this.hasEventType(typeInfo.type)) {\n            throw new Error(\"There is no event type \" + typeInfo.type);\n        }\n        if (typeInfo.namespace) {\n            handler.namespace = typeInfo.namespace;\n        }\n        eventHandlers.push(handler);\n        this.events.set(typeInfo.type, eventHandlers);\n    };\n    /**\n     * Emit event\n     * @param {string} eventName Event name to emit\n     * @returns {Array}\n     */\n    EventEmitter.prototype.emit = function (type) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type);\n        var results = [];\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, args);\n                if (!isUndefined_default()(result)) {\n                    results.push(result);\n                }\n            });\n        }\n        return results;\n    };\n    /**\n     * Emit given event and return result\n     * @param {string} eventName Event name to emit\n     * @param {any} source Source to change\n     * @returns {string}\n     */\n    EventEmitter.prototype.emitReduce = function (type, source) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var eventHandlers = this.events.get(type);\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, __spreadArray([source], args));\n                if (!isFalsy_default()(result)) {\n                    source = result;\n                }\n            });\n        }\n        return source;\n    };\n    /**\n     * Get event type and namespace\n     * @param {string} type Event type name\n     * @returns {{type: string, namespace: string}}\n     * @private\n     */\n    EventEmitter.prototype.getTypeInfo = function (type) {\n        var splited = type.split('.');\n        return {\n            type: splited[0],\n            namespace: splited[1],\n        };\n    };\n    /**\n     * Check whether event type exists or not\n     * @param {string} type Event type name\n     * @returns {boolean}\n     * @private\n     */\n    EventEmitter.prototype.hasEventType = function (type) {\n        return !isUndefined_default()(this.eventTypes[this.getTypeInfo(type).type]);\n    };\n    /**\n     * Add event type when given event not exists\n     * @param {string} type Event type name\n     */\n    EventEmitter.prototype.addEventType = function (type) {\n        if (this.hasEventType(type)) {\n            throw new Error(\"There is already have event type \" + type);\n        }\n        this.eventTypes[type] = type;\n    };\n    /**\n     * Remove event handler from given event type\n     * @param {string} eventType Event type name\n     * @param {function} [handler] - registered event handler\n     */\n    EventEmitter.prototype.removeEventHandler = function (eventType, handler) {\n        var _this = this;\n        var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;\n        if (type && handler) {\n            this.removeEventHandlerWithHandler(type, handler);\n        }\n        else if (type && !namespace) {\n            this.events.delete(type);\n        }\n        else if (!type && namespace) {\n            this.events.forEach(function (_, evtType) {\n                _this.removeEventHandlerWithTypeInfo(evtType, namespace);\n            });\n        }\n        else if (type && namespace) {\n            this.removeEventHandlerWithTypeInfo(type, namespace);\n        }\n    };\n    /**\n     * Remove event handler with event handler\n     * @param {string} type - event type name\n     * @param {function} handler - event handler\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithHandler = function (type, handler) {\n        var eventHandlers = this.events.get(type);\n        if (eventHandlers) {\n            var handlerIndex = eventHandlers.indexOf(handler);\n            if (eventHandlers.indexOf(handler) >= 0) {\n                eventHandlers.splice(handlerIndex, 1);\n            }\n        }\n    };\n    /**\n     * Remove event handler with event type information\n     * @param {string} type Event type name\n     * @param {string} namespace Event namespace\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithTypeInfo = function (type, namespace) {\n        var handlersToSurvive = [];\n        var eventHandlers = this.events.get(type);\n        if (!eventHandlers) {\n            return;\n        }\n        eventHandlers.map(function (handler) {\n            if (handler.namespace !== namespace) {\n                handlersToSurvive.push(handler);\n            }\n            return null;\n        });\n        this.events.set(type, handlersToSurvive);\n    };\n    EventEmitter.prototype.getEvents = function () {\n        return this.events;\n    };\n    EventEmitter.prototype.holdEventInvoke = function (fn) {\n        this.hold = true;\n        fn();\n        this.hold = false;\n    };\n    return EventEmitter;\n}());\n/* harmony default export */ var eventEmitter = (EventEmitter);\n\n;// CONCATENATED MODULE: ./src/viewer.ts\n\n\n\n\n\n\n\n\n\n\n\n\nvar TASK_ATTR_NAME = 'data-task';\nvar DISABLED_TASK_ATTR_NAME = 'data-task-disabled';\nvar TASK_CHECKED_CLASS_NAME = 'checked';\nfunction registerHTMLTagToWhitelist(convertorMap) {\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            // register tag white list for preventing to remove the html in sanitizer\n            Object.keys(convertorMap[htmlType]).forEach(function (type) { return htmlSanitizer_registerTagWhitelistIfPossible(type); });\n        }\n    });\n}\n/**\n * Class ToastUIEditorViewer\n * @param {object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.initialValue] Editor's initial value\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {string} [options.theme] - The theme to style the viewer with. The default is included in toastui-editor.css.\n */\nvar ToastUIEditorViewer = /** @class */ (function () {\n    function ToastUIEditorViewer(options) {\n        var _this = this;\n        this.options = extend_default()({\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            usageStatistics: true,\n            theme: 'light',\n        }, options);\n        this.eventEmitter = new eventEmitter();\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        var _a = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        }) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;\n        var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: tslib_es6_assign(tslib_es6_assign({}, toHTMLRenderers), customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        registerHTMLTagToWhitelist(rendererOptions.customHTMLRenderer);\n        if (this.options.events) {\n            forEachOwnProperties_default()(this.options.events, function (fn, key) {\n                _this.on(key, fn);\n            });\n        }\n        var _c = this.options, el = _c.el, initialValue = _c.initialValue, theme = _c.theme;\n        var existingHTML = el.innerHTML;\n        if (theme !== 'light') {\n            el.classList.add(cls(theme));\n        }\n        el.innerHTML = '';\n        this.toastMark = new ToastMark('', {\n            disallowedHtmlBlockTags: ['br', 'img'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.preview = new mdPreview(this.eventEmitter, tslib_es6_assign(tslib_es6_assign({}, rendererOptions), { isViewer: true }));\n        on_default()(this.preview.previewContent, 'mousedown', this.toggleTask.bind(this));\n        if (initialValue) {\n            this.setMarkdown(initialValue);\n        }\n        else if (existingHTML) {\n            this.preview.setHTML(existingHTML);\n        }\n        el.appendChild(this.preview.previewContent);\n        this.eventEmitter.emit('load', this);\n    }\n    /**\n     * Toggle task by detecting mousedown event.\n     * @param {MouseEvent} ev - event\n     * @private\n     */\n    ToastUIEditorViewer.prototype.toggleTask = function (ev) {\n        var element = ev.target;\n        var style = getComputedStyle(element, ':before');\n        if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME) &&\n            element.hasAttribute(TASK_ATTR_NAME) &&\n            isPositionInBox(style, ev.offsetX, ev.offsetY)) {\n            toggleClass(element, TASK_CHECKED_CLASS_NAME);\n            this.eventEmitter.emit('change', {\n                source: 'viewer',\n                date: ev,\n            });\n        }\n    };\n    /**\n     * Set content for preview\n     * @param {string} markdown Markdown text\n     */\n    ToastUIEditorViewer.prototype.setMarkdown = function (markdown) {\n        var lineTexts = this.toastMark.getLineTexts();\n        var length = lineTexts.length;\n        var lastLine = common_last(lineTexts);\n        var endSourcepos = [length, lastLine.length + 1];\n        var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || '');\n        this.eventEmitter.emit('updatePreview', editResult);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorViewer.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove Viewer preview from document\n     */\n    ToastUIEditorViewer.prototype.destroy = function () {\n        off_default()(this.preview.el, 'mousedown', this.toggleTask.bind(this));\n        this.preview.destroy();\n        this.eventEmitter.emit('destroy');\n    };\n    /**\n     * Return true\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isViewer = function () {\n        return true;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isMarkdownMode = function () {\n        return false;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isWysiwygMode = function () {\n        return false;\n    };\n    return ToastUIEditorViewer;\n}());\n/* harmony default export */ var viewer = (ToastUIEditorViewer);\n\n;// CONCATENATED MODULE: ./src/indexViewer.ts\n\n\n/* harmony default export */ var indexViewer = (viewer);\n\n}();\n__nested_webpack_exports__ = __nested_webpack_exports__[\"default\"];\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L3RvYXN0dWktZWRpdG9yLXZpZXdlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsMEZBQXdCLEdBQUcsbUJBQU8sQ0FBQyxrRkFBb0IsR0FBRyxtQkFBTyxDQUFDLGdGQUFtQixHQUFHLG1CQUFPLENBQUMsZ0ZBQW1CLEdBQUcsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDbkwsTUFBTSxFQUs4SjtBQUNwSyxDQUFDO0FBQ0QsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHLEtBQUk7QUFDUCxFQUFFLENBQUM7QUFDSCxDQUFDLHFCQUFxQjs7QUFFdEIscUNBQXFDLDBCQUEwQiwwQ0FBMEMsZ0JBQWdCLE9BQU8sb0JBQW9CLGVBQWUsT0FBTzs7QUFFMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLEVBQUUsaUJBQWlCLEVBQUUsTUFBTTtBQUN6RDtBQUNBLHNEQUFzRDtBQUN0RCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1R0FBdUcscUJBQXFCLG1CQUFtQjs7QUFFL0ksdUNBQXVDLDBCQUEwQiwwQ0FBMEMsZ0JBQWdCLE9BQU8sb0JBQW9CLGVBQWUsT0FBTzs7QUFFNUs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsVUFBVTtBQUN2QixjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RDtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxpQ0FBaUM7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxlQUFlLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUUsZ0NBQWdDLEtBQUssNkNBQTZDLEtBQUs7QUFDOUksMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDJDQUEyQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHLEdBQUcsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMseUJBQXlCLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkNBQTJDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsNEJBQTRCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVksWUFBWTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7O0FBV0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw0Q0FBNEMsd0NBQXdDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsNkRBQTZEO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0NBQW1CO0FBQ3BDLHNDQUFzQyxnQ0FBbUI7QUFDekQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELGtFQUFrRSxDQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxJQUFJLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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c0IsZ0JBQWdCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxDQUFDOzs7QUFHRDs7QUFFQSxDQUFDO0FBQ0QsMEJBQW1CLEdBQUcsMEJBQW1CO0FBQ3pDLGlCQUFpQiwwQkFBbUI7QUFDcEMsVUFBVTtBQUNWO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmb3JnZS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvZWRpdG9yL2Rpc3QvdG9hc3R1aS1lZGl0b3Itdmlld2VyLmpzPzNjNWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAdG9hc3QtdWkvZWRpdG9yXG4gKiBAdmVyc2lvbiAzLjIuMiB8IEZyaSBGZWIgMTcgMjAyM1xuICogQGF1dGhvciBOSE4gQ2xvdWQgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicHJvc2VtaXJyb3ItaW5wdXRydWxlc1wiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLWtleW1hcFwiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLW1vZGVsXCIpLCByZXF1aXJlKFwicHJvc2VtaXJyb3Itc3RhdGVcIiksIHJlcXVpcmUoXCJwcm9zZW1pcnJvci12aWV3XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInByb3NlbWlycm9yLWlucHV0cnVsZXNcIiwgXCJwcm9zZW1pcnJvci1rZXltYXBcIiwgXCJwcm9zZW1pcnJvci1tb2RlbFwiLCBcInByb3NlbWlycm9yLXN0YXRlXCIsIFwicHJvc2VtaXJyb3Itdmlld1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJ0b2FzdHVpXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicHJvc2VtaXJyb3ItaW5wdXRydWxlc1wiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLWtleW1hcFwiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLW1vZGVsXCIpLCByZXF1aXJlKFwicHJvc2VtaXJyb3Itc3RhdGVcIiksIHJlcXVpcmUoXCJwcm9zZW1pcnJvci12aWV3XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJ0b2FzdHVpXCJdID0gcm9vdFtcInRvYXN0dWlcIl0gfHwge30sIHJvb3RbXCJ0b2FzdHVpXCJdW1wiRWRpdG9yXCJdID0gZmFjdG9yeShyb290W3VuZGVmaW5lZF0sIHJvb3RbdW5kZWZpbmVkXSwgcm9vdFt1bmRlZmluZWRdLCByb290W3VuZGVmaW5lZF0sIHJvb3RbdW5kZWZpbmVkXSk7XG59KShzZWxmLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NzlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDgxX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQzX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzgxNF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zMTFfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDM2ODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyohIEBsaWNlbnNlIERPTVB1cmlmeSAyLjMuMyB8IChjKSBDdXJlNTMgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgbGljZW5zZSAyLjAgYW5kIE1vemlsbGEgUHVibGljIExpY2Vuc2UgMi4wIHwgZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvMi4zLjMvTElDRU5TRSAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHJ1ZSA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgMDtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0Lmhhc093blByb3BlcnR5LFxuICAgICAgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsXG4gICAgICBpc0Zyb3plbiA9IE9iamVjdC5pc0Zyb3plbixcbiAgICAgIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgdmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemUsXG4gICAgICBzZWFsID0gT2JqZWN0LnNlYWwsXG4gICAgICBjcmVhdGUgPSBPYmplY3QuY3JlYXRlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LFxuICAgICAgYXBwbHkgPSBfcmVmLmFwcGx5LFxuICAgICAgY29uc3RydWN0ID0gX3JlZi5jb25zdHJ1Y3Q7XG5cbiAgaWYgKCFhcHBseSkge1xuICAgIGFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZnVuLCB0aGlzVmFsdWUsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW4uYXBwbHkodGhpc1ZhbHVlLCBhcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFmcmVlemUpIHtcbiAgICBmcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghc2VhbCkge1xuICAgIHNlYWwgPSBmdW5jdGlvbiBzZWFsKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gIH1cblxuICBpZiAoIWNvbnN0cnVjdCkge1xuICAgIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIGNvbnN0cnVjdChGdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShGdW5jLCBbbnVsbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzKSkpKSgpO1xuICAgIH07XG4gIH1cblxuICB2YXIgYXJyYXlGb3JFYWNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuZm9yRWFjaCk7XG4gIHZhciBhcnJheVBvcCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnBvcCk7XG4gIHZhciBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcblxuICB2YXIgc3RyaW5nVG9Mb3dlckNhc2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UpO1xuICB2YXIgc3RyaW5nTWF0Y2ggPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUubWF0Y2gpO1xuICB2YXIgc3RyaW5nUmVwbGFjZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbiAgdmFyIHN0cmluZ0luZGV4T2YgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZik7XG4gIHZhciBzdHJpbmdUcmltID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuXG4gIHZhciByZWdFeHBUZXN0ID0gdW5hcHBseShSZWdFeHAucHJvdG90eXBlLnRlc3QpO1xuXG4gIHZhciB0eXBlRXJyb3JDcmVhdGUgPSB1bmNvbnN0cnVjdChUeXBlRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIHVuYXBwbHkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuY29uc3RydWN0KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uc3RydWN0KGZ1bmMsIGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICAvKiBBZGQgcHJvcGVydGllcyB0byBhIGxvb2t1cCB0YWJsZSAqL1xuICBmdW5jdGlvbiBhZGRUb1NldChzZXQsIGFycmF5KSB7XG4gICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAvLyBNYWtlICdpbicgYW5kIHRydXRoeSBjaGVja3MgbGlrZSBCb29sZWFuKHNldC5jb25zdHJ1Y3RvcilcbiAgICAgIC8vIGluZGVwZW5kZW50IG9mIGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gT2JqZWN0LnByb3RvdHlwZS5cbiAgICAgIC8vIFByZXZlbnQgcHJvdG90eXBlIHNldHRlcnMgZnJvbSBpbnRlcmNlcHRpbmcgc2V0IGFzIGEgdGhpcyB2YWx1ZS5cbiAgICAgIHNldFByb3RvdHlwZU9mKHNldCwgbnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGwtLSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBhcnJheVtsXTtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGxjRWxlbWVudCA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQpO1xuICAgICAgICBpZiAobGNFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgLy8gQ29uZmlnIHByZXNldHMgKGUuZy4gdGFncy5qcywgYXR0cnMuanMpIGFyZSBpbW11dGFibGUuXG4gICAgICAgICAgaWYgKCFpc0Zyb3plbihhcnJheSkpIHtcbiAgICAgICAgICAgIGFycmF5W2xdID0gbGNFbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQgPSBsY0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0W2VsZW1lbnRdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0O1xuICB9XG5cbiAgLyogU2hhbGxvdyBjbG9uZSBhbiBvYmplY3QgKi9cbiAgZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XG4gICAgdmFyIG5ld09iamVjdCA9IGNyZWF0ZShudWxsKTtcblxuICAgIHZhciBwcm9wZXJ0eSA9IHZvaWQgMDtcbiAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgaWYgKGFwcGx5KGhhc093blByb3BlcnR5LCBvYmplY3QsIFtwcm9wZXJ0eV0pKSB7XG4gICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmplY3Q7XG4gIH1cblxuICAvKiBJRTEwIGRvZXNuJ3Qgc3VwcG9ydCBfX2xvb2t1cEdldHRlcl9fIHNvIGxldHMnXG4gICAqIHNpbXVsYXRlIGl0LiBJdCBhbHNvIGF1dG9tYXRpY2FsbHkgY2hlY2tzXG4gICAqIGlmIHRoZSBwcm9wIGlzIGZ1bmN0aW9uIG9yIGdldHRlciBhbmQgYmVoYXZlc1xuICAgKiBhY2NvcmRpbmdseS4gKi9cbiAgZnVuY3Rpb24gbG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcCkge1xuICAgIHdoaWxlIChvYmplY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XG4gICAgICBpZiAoZGVzYykge1xuICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhbGxiYWNrVmFsdWUoZWxlbWVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdmYWxsYmFjayB2YWx1ZSBmb3InLCBlbGVtZW50KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxsYmFja1ZhbHVlO1xuICB9XG5cbiAgdmFyIGh0bWwgPSBmcmVlemUoWydhJywgJ2FiYnInLCAnYWNyb255bScsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2JsaW5rJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnY29udGVudCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlY29yYXRvcicsICdkZWwnLCAnZGV0YWlscycsICdkZm4nLCAnZGlhbG9nJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZWxlbWVudCcsICdlbScsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb250JywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAnbGFiZWwnLCAnbGVnZW5kJywgJ2xpJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGVyJywgJ25hdicsICdub2JyJywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdvdXRwdXQnLCAncCcsICdwaWN0dXJlJywgJ3ByZScsICdwcm9ncmVzcycsICdxJywgJ3JwJywgJ3J0JywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NoYWRvdycsICdzbWFsbCcsICdzb3VyY2UnLCAnc3BhY2VyJywgJ3NwYW4nLCAnc3RyaWtlJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0cicsICd0cmFjaycsICd0dCcsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInXSk7XG5cbiAgLy8gU1ZHXG4gIHZhciBzdmcgPSBmcmVlemUoWydzdmcnLCAnYScsICdhbHRnbHlwaCcsICdhbHRnbHlwaGRlZicsICdhbHRnbHlwaGl0ZW0nLCAnYW5pbWF0ZWNvbG9yJywgJ2FuaW1hdGVtb3Rpb24nLCAnYW5pbWF0ZXRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcHBhdGgnLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZycsICdnbHlwaCcsICdnbHlwaHJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhcmdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21wYXRoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbGdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICdzdHlsZScsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dHBhdGgnLCAndGl0bGUnLCAndHJlZicsICd0c3BhbicsICd2aWV3JywgJ3ZrZXJuJ10pO1xuXG4gIHZhciBzdmdGaWx0ZXJzID0gZnJlZXplKFsnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JywgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJ10pO1xuXG4gIC8vIExpc3Qgb2YgU1ZHIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FsbG93ZWQgYnkgZGVmYXVsdC5cbiAgLy8gV2Ugc3RpbGwgbmVlZCB0byBrbm93IHRoZW0gc28gdGhhdCB3ZSBjYW4gZG8gbmFtZXNwYWNlXG4gIC8vIGNoZWNrcyBwcm9wZXJseSBpbiBjYXNlIG9uZSB3YW50cyB0byBhZGQgdGhlbSB0b1xuICAvLyBhbGxvdy1saXN0LlxuICB2YXIgc3ZnRGlzYWxsb3dlZCA9IGZyZWV6ZShbJ2FuaW1hdGUnLCAnY29sb3ItcHJvZmlsZScsICdjdXJzb3InLCAnZGlzY2FyZCcsICdmZWRyb3BzaGFkb3cnLCAnZmVpbWFnZScsICdmb250LWZhY2UnLCAnZm9udC1mYWNlLWZvcm1hdCcsICdmb250LWZhY2UtbmFtZScsICdmb250LWZhY2Utc3JjJywgJ2ZvbnQtZmFjZS11cmknLCAnZm9yZWlnbm9iamVjdCcsICdoYXRjaCcsICdoYXRjaHBhdGgnLCAnbWVzaCcsICdtZXNoZ3JhZGllbnQnLCAnbWVzaHBhdGNoJywgJ21lc2hyb3cnLCAnbWlzc2luZy1nbHlwaCcsICdzY3JpcHQnLCAnc2V0JywgJ3NvbGlkY29sb3InLCAndW5rbm93bicsICd1c2UnXSk7XG5cbiAgdmFyIG1hdGhNbCA9IGZyZWV6ZShbJ21hdGgnLCAnbWVuY2xvc2UnLCAnbWVycm9yJywgJ21mZW5jZWQnLCAnbWZyYWMnLCAnbWdseXBoJywgJ21pJywgJ21sYWJlbGVkdHInLCAnbW11bHRpc2NyaXB0cycsICdtbicsICdtbycsICdtb3ZlcicsICdtcGFkZGVkJywgJ21waGFudG9tJywgJ21yb290JywgJ21yb3cnLCAnbXMnLCAnbXNwYWNlJywgJ21zcXJ0JywgJ21zdHlsZScsICdtc3ViJywgJ21zdXAnLCAnbXN1YnN1cCcsICdtdGFibGUnLCAnbXRkJywgJ210ZXh0JywgJ210cicsICdtdW5kZXInLCAnbXVuZGVyb3ZlciddKTtcblxuICAvLyBTaW1pbGFybHkgdG8gU1ZHLCB3ZSB3YW50IHRvIGtub3cgYWxsIE1hdGhNTCBlbGVtZW50cyxcbiAgLy8gZXZlbiB0aG9zZSB0aGF0IHdlIGRpc2FsbG93IGJ5IGRlZmF1bHQuXG4gIHZhciBtYXRoTWxEaXNhbGxvd2VkID0gZnJlZXplKFsnbWFjdGlvbicsICdtYWxpZ25ncm91cCcsICdtYWxpZ25tYXJrJywgJ21sb25nZGl2JywgJ21zY2FycmllcycsICdtc2NhcnJ5JywgJ21zZ3JvdXAnLCAnbXN0YWNrJywgJ21zbGluZScsICdtc3JvdycsICdzZW1hbnRpY3MnLCAnYW5ub3RhdGlvbicsICdhbm5vdGF0aW9uLXhtbCcsICdtcHJlc2NyaXB0cycsICdub25lJ10pO1xuXG4gIHZhciB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG5cbiAgdmFyIGh0bWwkMSA9IGZyZWV6ZShbJ2FjY2VwdCcsICdhY3Rpb24nLCAnYWxpZ24nLCAnYWx0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsICdhdXRvcGljdHVyZWlucGljdHVyZScsICdhdXRvcGxheScsICdiYWNrZ3JvdW5kJywgJ2JnY29sb3InLCAnYm9yZGVyJywgJ2NhcHR1cmUnLCAnY2VsbHBhZGRpbmcnLCAnY2VsbHNwYWNpbmcnLCAnY2hlY2tlZCcsICdjaXRlJywgJ2NsYXNzJywgJ2NsZWFyJywgJ2NvbG9yJywgJ2NvbHMnLCAnY29sc3BhbicsICdjb250cm9scycsICdjb250cm9sc2xpc3QnLCAnY29vcmRzJywgJ2Nyb3Nzb3JpZ2luJywgJ2RhdGV0aW1lJywgJ2RlY29kaW5nJywgJ2RlZmF1bHQnLCAnZGlyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVwaWN0dXJlaW5waWN0dXJlJywgJ2Rpc2FibGVyZW1vdGVwbGF5YmFjaycsICdkb3dubG9hZCcsICdkcmFnZ2FibGUnLCAnZW5jdHlwZScsICdlbnRlcmtleWhpbnQnLCAnZmFjZScsICdmb3InLCAnaGVhZGVycycsICdoZWlnaHQnLCAnaGlkZGVuJywgJ2hpZ2gnLCAnaHJlZicsICdocmVmbGFuZycsICdpZCcsICdpbnB1dG1vZGUnLCAnaW50ZWdyaXR5JywgJ2lzbWFwJywgJ2tpbmQnLCAnbGFiZWwnLCAnbGFuZycsICdsaXN0JywgJ2xvYWRpbmcnLCAnbG9vcCcsICdsb3cnLCAnbWF4JywgJ21heGxlbmd0aCcsICdtZWRpYScsICdtZXRob2QnLCAnbWluJywgJ21pbmxlbmd0aCcsICdtdWx0aXBsZScsICdtdXRlZCcsICduYW1lJywgJ25vc2hhZGUnLCAnbm92YWxpZGF0ZScsICdub3dyYXAnLCAnb3BlbicsICdvcHRpbXVtJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncGxheXNpbmxpbmUnLCAncG9zdGVyJywgJ3ByZWxvYWQnLCAncHViZGF0ZScsICdyYWRpb2dyb3VwJywgJ3JlYWRvbmx5JywgJ3JlbCcsICdyZXF1aXJlZCcsICdyZXYnLCAncmV2ZXJzZWQnLCAncm9sZScsICdyb3dzJywgJ3Jvd3NwYW4nLCAnc3BlbGxjaGVjaycsICdzY29wZScsICdzZWxlY3RlZCcsICdzaGFwZScsICdzaXplJywgJ3NpemVzJywgJ3NwYW4nLCAnc3JjbGFuZycsICdzdGFydCcsICdzcmMnLCAnc3Jjc2V0JywgJ3N0ZXAnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJpbmRleCcsICd0aXRsZScsICd0cmFuc2xhdGUnLCAndHlwZScsICd1c2VtYXAnLCAndmFsaWduJywgJ3ZhbHVlJywgJ3dpZHRoJywgJ3htbG5zJywgJ3Nsb3QnXSk7XG5cbiAgdmFyIHN2ZyQxID0gZnJlZXplKFsnYWNjZW50LWhlaWdodCcsICdhY2N1bXVsYXRlJywgJ2FkZGl0aXZlJywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhc2NlbnQnLCAnYXR0cmlidXRlbmFtZScsICdhdHRyaWJ1dGV0eXBlJywgJ2F6aW11dGgnLCAnYmFzZWZyZXF1ZW5jeScsICdiYXNlbGluZS1zaGlmdCcsICdiZWdpbicsICdiaWFzJywgJ2J5JywgJ2NsYXNzJywgJ2NsaXAnLCAnY2xpcHBhdGh1bml0cycsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2N4JywgJ2N5JywgJ2QnLCAnZHgnLCAnZHknLCAnZGlmZnVzZWNvbnN0YW50JywgJ2RpcmVjdGlvbicsICdkaXNwbGF5JywgJ2Rpdmlzb3InLCAnZHVyJywgJ2VkZ2Vtb2RlJywgJ2VsZXZhdGlvbicsICdlbmQnLCAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2ZpbHRlcicsICdmaWx0ZXJ1bml0cycsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdmeCcsICdmeScsICdnMScsICdnMicsICdnbHlwaC1uYW1lJywgJ2dseXBocmVmJywgJ2dyYWRpZW50dW5pdHMnLCAnZ3JhZGllbnR0cmFuc2Zvcm0nLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2luJywgJ2luMicsICdrJywgJ2sxJywgJ2syJywgJ2szJywgJ2s0JywgJ2tlcm5pbmcnLCAna2V5cG9pbnRzJywgJ2tleXNwbGluZXMnLCAna2V5dGltZXMnLCAnbGFuZycsICdsZW5ndGhhZGp1c3QnLCAnbGV0dGVyLXNwYWNpbmcnLCAna2VybmVsbWF0cml4JywgJ2tlcm5lbHVuaXRsZW5ndGgnLCAnbGlnaHRpbmctY29sb3InLCAnbG9jYWwnLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdtYXJrZXJoZWlnaHQnLCAnbWFya2VydW5pdHMnLCAnbWFya2Vyd2lkdGgnLCAnbWFza2NvbnRlbnR1bml0cycsICdtYXNrdW5pdHMnLCAnbWF4JywgJ21hc2snLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21vZGUnLCAnbWluJywgJ25hbWUnLCAnbnVtb2N0YXZlcycsICdvZmZzZXQnLCAnb3BlcmF0b3InLCAnb3BhY2l0eScsICdvcmRlcicsICdvcmllbnQnLCAnb3JpZW50YXRpb24nLCAnb3JpZ2luJywgJ292ZXJmbG93JywgJ3BhaW50LW9yZGVyJywgJ3BhdGgnLCAncGF0aGxlbmd0aCcsICdwYXR0ZXJuY29udGVudHVuaXRzJywgJ3BhdHRlcm50cmFuc2Zvcm0nLCAncGF0dGVybnVuaXRzJywgJ3BvaW50cycsICdwcmVzZXJ2ZWFscGhhJywgJ3ByZXNlcnZlYXNwZWN0cmF0aW8nLCAncHJpbWl0aXZldW5pdHMnLCAncicsICdyeCcsICdyeScsICdyYWRpdXMnLCAncmVmeCcsICdyZWZ5JywgJ3JlcGVhdGNvdW50JywgJ3JlcGVhdGR1cicsICdyZXN0YXJ0JywgJ3Jlc3VsdCcsICdyb3RhdGUnLCAnc2NhbGUnLCAnc2VlZCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3BlY3VsYXJjb25zdGFudCcsICdzcGVjdWxhcmV4cG9uZW50JywgJ3NwcmVhZG1ldGhvZCcsICdzdGFydG9mZnNldCcsICdzdGRkZXZpYXRpb24nLCAnc3RpdGNodGlsZXMnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlJywgJ3N0cm9rZS13aWR0aCcsICdzdHlsZScsICdzdXJmYWNlc2NhbGUnLCAnc3lzdGVtbGFuZ3VhZ2UnLCAndGFiaW5kZXgnLCAndGFyZ2V0eCcsICd0YXJnZXR5JywgJ3RyYW5zZm9ybScsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndGV4dGxlbmd0aCcsICd0eXBlJywgJ3UxJywgJ3UyJywgJ3VuaWNvZGUnLCAndmFsdWVzJywgJ3ZpZXdib3gnLCAndmlzaWJpbGl0eScsICd2ZXJzaW9uJywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dpZHRoJywgJ3dvcmQtc3BhY2luZycsICd3cmFwJywgJ3dyaXRpbmctbW9kZScsICd4Y2hhbm5lbHNlbGVjdG9yJywgJ3ljaGFubmVsc2VsZWN0b3InLCAneCcsICd4MScsICd4MicsICd4bWxucycsICd5JywgJ3kxJywgJ3kyJywgJ3onLCAnem9vbWFuZHBhbiddKTtcblxuICB2YXIgbWF0aE1sJDEgPSBmcmVlemUoWydhY2NlbnQnLCAnYWNjZW50dW5kZXInLCAnYWxpZ24nLCAnYmV2ZWxsZWQnLCAnY2xvc2UnLCAnY29sdW1uc2FsaWduJywgJ2NvbHVtbmxpbmVzJywgJ2NvbHVtbnNwYW4nLCAnZGVub21hbGlnbicsICdkZXB0aCcsICdkaXInLCAnZGlzcGxheScsICdkaXNwbGF5c3R5bGUnLCAnZW5jb2RpbmcnLCAnZmVuY2UnLCAnZnJhbWUnLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnbGFyZ2VvcCcsICdsZW5ndGgnLCAnbGluZXRoaWNrbmVzcycsICdsc3BhY2UnLCAnbHF1b3RlJywgJ21hdGhiYWNrZ3JvdW5kJywgJ21hdGhjb2xvcicsICdtYXRoc2l6ZScsICdtYXRodmFyaWFudCcsICdtYXhzaXplJywgJ21pbnNpemUnLCAnbW92YWJsZWxpbWl0cycsICdub3RhdGlvbicsICdudW1hbGlnbicsICdvcGVuJywgJ3Jvd2FsaWduJywgJ3Jvd2xpbmVzJywgJ3Jvd3NwYWNpbmcnLCAncm93c3BhbicsICdyc3BhY2UnLCAncnF1b3RlJywgJ3NjcmlwdGxldmVsJywgJ3NjcmlwdG1pbnNpemUnLCAnc2NyaXB0c2l6ZW11bHRpcGxpZXInLCAnc2VsZWN0aW9uJywgJ3NlcGFyYXRvcicsICdzZXBhcmF0b3JzJywgJ3N0cmV0Y2h5JywgJ3N1YnNjcmlwdHNoaWZ0JywgJ3N1cHNjcmlwdHNoaWZ0JywgJ3N5bW1ldHJpYycsICd2b2Zmc2V0JywgJ3dpZHRoJywgJ3htbG5zJ10pO1xuXG4gIHZhciB4bWwgPSBmcmVlemUoWyd4bGluazpocmVmJywgJ3htbDppZCcsICd4bGluazp0aXRsZScsICd4bWw6c3BhY2UnLCAneG1sbnM6eGxpbmsnXSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XG4gIHZhciBNVVNUQUNIRV9FWFBSID0gc2VhbCgvXFx7XFx7W1xcc1xcU10qfFtcXHNcXFNdKlxcfVxcfS9nbSk7IC8vIFNwZWNpZnkgdGVtcGxhdGUgZGV0ZWN0aW9uIHJlZ2V4IGZvciBTQUZFX0ZPUl9URU1QTEFURVMgbW9kZVxuICB2YXIgRVJCX0VYUFIgPSBzZWFsKC88JVtcXHNcXFNdKnxbXFxzXFxTXSolPi9nbSk7XG4gIHZhciBEQVRBX0FUVFIgPSBzZWFsKC9eZGF0YS1bXFwtXFx3LlxcdTAwQjctXFx1RkZGRl0vKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICB2YXIgQVJJQV9BVFRSID0gc2VhbCgvXmFyaWEtW1xcLVxcd10rJC8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gIHZhciBJU19BTExPV0VEX1VSSSA9IHNlYWwoL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98Y2lkfHhtcHApOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2kgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICApO1xuICB2YXIgSVNfU0NSSVBUX09SX0RBVEEgPSBzZWFsKC9eKD86XFx3K3NjcmlwdHxkYXRhKTovaSk7XG4gIHZhciBBVFRSX1dISVRFU1BBQ0UgPSBzZWFsKC9bXFx1MDAwMC1cXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDI5XFx1MjA1RlxcdTMwMDBdL2cgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICk7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheSQxKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbiAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm8tb3AgcG9saWN5IGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICogRG9uJ3QgZXhwb3J0IHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSFcbiAgICogQHBhcmFtIHs/VHJ1c3RlZFR5cGVQb2xpY3lGYWN0b3J5fSB0cnVzdGVkVHlwZXMgVGhlIHBvbGljeSBmYWN0b3J5LlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgb2JqZWN0ICh0byBkZXRlcm1pbmUgcG9saWN5IG5hbWUgc3VmZml4KVxuICAgKiBAcmV0dXJuIHs/VHJ1c3RlZFR5cGVQb2xpY3l9IFRoZSBwb2xpY3kgY3JlYXRlZCAob3IgbnVsbCwgaWYgVHJ1c3RlZCBUeXBlc1xuICAgKiBhcmUgbm90IHN1cHBvcnRlZCkuXG4gICAqL1xuICB2YXIgX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSA9IGZ1bmN0aW9uIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBkb2N1bWVudCkge1xuICAgIGlmICgodHlwZW9mIHRydXN0ZWRUeXBlcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHJ1c3RlZFR5cGVzKSkgIT09ICdvYmplY3QnIHx8IHR5cGVvZiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyB0aGUgY2FsbGVycyB0byBjb250cm9sIHRoZSB1bmlxdWUgcG9saWN5IG5hbWVcbiAgICAvLyBieSBhZGRpbmcgYSBkYXRhLXR0LXBvbGljeS1zdWZmaXggdG8gdGhlIHNjcmlwdCBlbGVtZW50IHdpdGggdGhlIERPTVB1cmlmeS5cbiAgICAvLyBQb2xpY3kgY3JlYXRpb24gd2l0aCBkdXBsaWNhdGUgbmFtZXMgdGhyb3dzIGluIFRydXN0ZWQgVHlwZXMuXG4gICAgdmFyIHN1ZmZpeCA9IG51bGw7XG4gICAgdmFyIEFUVFJfTkFNRSA9ICdkYXRhLXR0LXBvbGljeS1zdWZmaXgnO1xuICAgIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpIHtcbiAgICAgIHN1ZmZpeCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSk7XG4gICAgfVxuXG4gICAgdmFyIHBvbGljeU5hbWUgPSAnZG9tcHVyaWZ5JyArIChzdWZmaXggPyAnIycgKyBzdWZmaXggOiAnJyk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kocG9saWN5TmFtZSwge1xuICAgICAgICBjcmVhdGVIVE1MOiBmdW5jdGlvbiBjcmVhdGVIVE1MKGh0bWwkJDEpIHtcbiAgICAgICAgICByZXR1cm4gaHRtbCQkMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgLy8gUG9saWN5IGNyZWF0aW9uIGZhaWxlZCAobW9zdCBsaWtlbHkgYW5vdGhlciBET01QdXJpZnkgc2NyaXB0IGhhc1xuICAgICAgLy8gYWxyZWFkeSBydW4pLiBTa2lwIGNyZWF0aW5nIHRoZSBwb2xpY3ksIGFzIHRoaXMgd2lsbCBvbmx5IGNhdXNlIGVycm9yc1xuICAgICAgLy8gaWYgVFQgYXJlIGVuZm9yY2VkLlxuICAgICAgY29uc29sZS53YXJuKCdUcnVzdGVkVHlwZXMgcG9saWN5ICcgKyBwb2xpY3lOYW1lICsgJyBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVET01QdXJpZnkoKSB7XG4gICAgdmFyIHdpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZ2V0R2xvYmFsKCk7XG5cbiAgICB2YXIgRE9NUHVyaWZ5ID0gZnVuY3Rpb24gRE9NUHVyaWZ5KHJvb3QpIHtcbiAgICAgIHJldHVybiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFZlcnNpb24gbGFiZWwsIGV4cG9zZWQgZm9yIGVhc2llciBjaGVja3NcbiAgICAgKiBpZiBET01QdXJpZnkgaXMgdXAgdG8gZGF0ZSBvciBub3RcbiAgICAgKi9cbiAgICBET01QdXJpZnkudmVyc2lvbiA9ICcyLjMuMyc7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBlbGVtZW50cyB0aGF0IERPTVB1cmlmeSByZW1vdmVkIGR1cmluZyBzYW5pdGF0aW9uLlxuICAgICAqIEVtcHR5IGlmIG5vdGhpbmcgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcblxuICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50Lm5vZGVUeXBlICE9PSA5KSB7XG4gICAgICAvLyBOb3QgcnVubmluZyBpbiBhIGJyb3dzZXIsIHByb3ZpZGUgYSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgICAvLyBzbyB0aGF0IHlvdSBjYW4gcGFzcyB5b3VyIG93biBXaW5kb3dcbiAgICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbERvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgIHZhciBEb2N1bWVudEZyYWdtZW50ID0gd2luZG93LkRvY3VtZW50RnJhZ21lbnQsXG4gICAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPSB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAgICAgICAgTm9kZSA9IHdpbmRvdy5Ob2RlLFxuICAgICAgICBFbGVtZW50ID0gd2luZG93LkVsZW1lbnQsXG4gICAgICAgIE5vZGVGaWx0ZXIgPSB3aW5kb3cuTm9kZUZpbHRlcixcbiAgICAgICAgX3dpbmRvdyROYW1lZE5vZGVNYXAgPSB3aW5kb3cuTmFtZWROb2RlTWFwLFxuICAgICAgICBOYW1lZE5vZGVNYXAgPSBfd2luZG93JE5hbWVkTm9kZU1hcCA9PT0gdW5kZWZpbmVkID8gd2luZG93Lk5hbWVkTm9kZU1hcCB8fCB3aW5kb3cuTW96TmFtZWRBdHRyTWFwIDogX3dpbmRvdyROYW1lZE5vZGVNYXAsXG4gICAgICAgIFRleHQgPSB3aW5kb3cuVGV4dCxcbiAgICAgICAgQ29tbWVudCA9IHdpbmRvdy5Db21tZW50LFxuICAgICAgICBET01QYXJzZXIgPSB3aW5kb3cuRE9NUGFyc2VyLFxuICAgICAgICB0cnVzdGVkVHlwZXMgPSB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuXG5cbiAgICB2YXIgRWxlbWVudFByb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgdmFyIGNsb25lTm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2xvbmVOb2RlJyk7XG4gICAgdmFyIGdldE5leHRTaWJsaW5nID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICduZXh0U2libGluZycpO1xuICAgIHZhciBnZXRDaGlsZE5vZGVzID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjaGlsZE5vZGVzJyk7XG4gICAgdmFyIGdldFBhcmVudE5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ3BhcmVudE5vZGUnKTtcblxuICAgIC8vIEFzIHBlciBpc3N1ZSAjNDcsIHRoZSB3ZWItY29tcG9uZW50cyByZWdpc3RyeSBpcyBpbmhlcml0ZWQgYnkgYVxuICAgIC8vIG5ldyBkb2N1bWVudCBjcmVhdGVkIHZpYSBjcmVhdGVIVE1MRG9jdW1lbnQuIEFzIHBlciB0aGUgc3BlY1xuICAgIC8vIChodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjcmVhdGluZy1hbmQtcGFzc2luZy1yZWdpc3RyaWVzKVxuICAgIC8vIGEgbmV3IGVtcHR5IHJlZ2lzdHJ5IGlzIHVzZWQgd2hlbiBjcmVhdGluZyBhIHRlbXBsYXRlIGNvbnRlbnRzIG93bmVyXG4gICAgLy8gZG9jdW1lbnQsIHNvIHdlIHVzZSB0aGF0IGFzIG91ciBwYXJlbnQgZG9jdW1lbnQgdG8gZW5zdXJlIG5vdGhpbmdcbiAgICAvLyBpcyBpbmhlcml0ZWQuXG4gICAgaWYgKHR5cGVvZiBIVE1MVGVtcGxhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cnVzdGVkVHlwZXNQb2xpY3kgPSBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgb3JpZ2luYWxEb2N1bWVudCk7XG4gICAgdmFyIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoJycpIDogJyc7XG5cbiAgICB2YXIgX2RvY3VtZW50ID0gZG9jdW1lbnQsXG4gICAgICAgIGltcGxlbWVudGF0aW9uID0gX2RvY3VtZW50LmltcGxlbWVudGF0aW9uLFxuICAgICAgICBjcmVhdGVOb2RlSXRlcmF0b3IgPSBfZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yLFxuICAgICAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQsXG4gICAgICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lID0gX2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lO1xuICAgIHZhciBpbXBvcnROb2RlID0gb3JpZ2luYWxEb2N1bWVudC5pbXBvcnROb2RlO1xuXG5cbiAgICB2YXIgZG9jdW1lbnRNb2RlID0ge307XG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50TW9kZSA9IGNsb25lKGRvY3VtZW50KS5kb2N1bWVudE1vZGUgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiB7fTtcbiAgICB9IGNhdGNoIChfKSB7fVxuXG4gICAgdmFyIGhvb2tzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2Ugd2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgcnVubmluZyB0aGUgZnVsbCBET01QdXJpZnkuXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gdHlwZW9mIGdldFBhcmVudE5vZGUgPT09ICdmdW5jdGlvbicgJiYgaW1wbGVtZW50YXRpb24gJiYgdHlwZW9mIGltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRNb2RlICE9PSA5O1xuXG4gICAgdmFyIE1VU1RBQ0hFX0VYUFIkJDEgPSBNVVNUQUNIRV9FWFBSLFxuICAgICAgICBFUkJfRVhQUiQkMSA9IEVSQl9FWFBSLFxuICAgICAgICBEQVRBX0FUVFIkJDEgPSBEQVRBX0FUVFIsXG4gICAgICAgIEFSSUFfQVRUUiQkMSA9IEFSSUFfQVRUUixcbiAgICAgICAgSVNfU0NSSVBUX09SX0RBVEEkJDEgPSBJU19TQ1JJUFRfT1JfREFUQSxcbiAgICAgICAgQVRUUl9XSElURVNQQUNFJCQxID0gQVRUUl9XSElURVNQQUNFO1xuICAgIHZhciBJU19BTExPV0VEX1VSSSQkMSA9IElTX0FMTE9XRURfVVJJO1xuXG4gICAgLyoqXG4gICAgICogV2UgY29uc2lkZXIgdGhlIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzIGJlbG93IHRvIGJlIHNhZmUuIElkZWFsbHlcbiAgICAgKiBkb24ndCBhZGQgYW55IG5ldyBvbmVzIGJ1dCBmZWVsIGZyZWUgdG8gcmVtb3ZlIHVud2FudGVkIG9uZXMuXG4gICAgICovXG5cbiAgICAvKiBhbGxvd2VkIGVsZW1lbnQgbmFtZXMgKi9cblxuICAgIHZhciBBTExPV0VEX1RBR1MgPSBudWxsO1xuICAgIHZhciBERUZBVUxUX0FMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEoaHRtbCksIF90b0NvbnN1bWFibGVBcnJheSQxKHN2ZyksIF90b0NvbnN1bWFibGVBcnJheSQxKHN2Z0ZpbHRlcnMpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShtYXRoTWwpLCBfdG9Db25zdW1hYmxlQXJyYXkkMSh0ZXh0KSkpO1xuXG4gICAgLyogQWxsb3dlZCBhdHRyaWJ1dGUgbmFtZXMgKi9cbiAgICB2YXIgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9BTExPV0VEX0FUVFIgPSBhZGRUb1NldCh7fSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSQxKGh0bWwkMSksIF90b0NvbnN1bWFibGVBcnJheSQxKHN2ZyQxKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEobWF0aE1sJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkkMSh4bWwpKSk7XG5cbiAgICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiB0YWdzIChvdmVycmlkZXMgQUxMT1dFRF9UQUdTL0FERF9UQUdTKSAqL1xuICAgIHZhciBGT1JCSURfVEFHUyA9IG51bGw7XG5cbiAgICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiBhdHRyaWJ1dGVzIChvdmVycmlkZXMgQUxMT1dFRF9BVFRSL0FERF9BVFRSKSAqL1xuICAgIHZhciBGT1JCSURfQVRUUiA9IG51bGw7XG5cbiAgICAvKiBEZWNpZGUgaWYgQVJJQSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gICAgdmFyIEFMTE9XX0FSSUFfQVRUUiA9IHRydWU7XG5cbiAgICAvKiBEZWNpZGUgaWYgY3VzdG9tIGRhdGEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuICAgIHZhciBBTExPV19EQVRBX0FUVFIgPSB0cnVlO1xuXG4gICAgLyogRGVjaWRlIGlmIHVua25vd24gcHJvdG9jb2xzIGFyZSBva2F5ICovXG4gICAgdmFyIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gZmFsc2U7XG5cbiAgICAvKiBPdXRwdXQgc2hvdWxkIGJlIHNhZmUgZm9yIGNvbW1vbiB0ZW1wbGF0ZSBlbmdpbmVzLlxuICAgICAqIFRoaXMgbWVhbnMsIERPTVB1cmlmeSByZW1vdmVzIGRhdGEgYXR0cmlidXRlcywgbXVzdGFjaGVzIGFuZCBFUkJcbiAgICAgKi9cbiAgICB2YXIgU0FGRV9GT1JfVEVNUExBVEVTID0gZmFsc2U7XG5cbiAgICAvKiBEZWNpZGUgaWYgZG9jdW1lbnQgd2l0aCA8aHRtbD4uLi4gc2hvdWxkIGJlIHJldHVybmVkICovXG4gICAgdmFyIFdIT0xFX0RPQ1VNRU5UID0gZmFsc2U7XG5cbiAgICAvKiBUcmFjayB3aGV0aGVyIGNvbmZpZyBpcyBhbHJlYWR5IHNldCBvbiB0aGlzIGluc3RhbmNlIG9mIERPTVB1cmlmeS4gKi9cbiAgICB2YXIgU0VUX0NPTkZJRyA9IGZhbHNlO1xuXG4gICAgLyogRGVjaWRlIGlmIGFsbCBlbGVtZW50cyAoZS5nLiBzdHlsZSwgc2NyaXB0KSBtdXN0IGJlIGNoaWxkcmVuIG9mXG4gICAgICogZG9jdW1lbnQuYm9keS4gQnkgZGVmYXVsdCwgYnJvd3NlcnMgbWlnaHQgbW92ZSB0aGVtIHRvIGRvY3VtZW50LmhlYWQgKi9cbiAgICB2YXIgRk9SQ0VfQk9EWSA9IGZhbHNlO1xuXG4gICAgLyogRGVjaWRlIGlmIGEgRE9NIGBIVE1MQm9keUVsZW1lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICAgKiBzdHJpbmcgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkuXG4gICAgICogSWYgYFdIT0xFX0RPQ1VNRU5UYCBpcyBlbmFibGVkIGEgYEhUTUxIdG1sRWxlbWVudGAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkXG4gICAgICovXG4gICAgdmFyIFJFVFVSTl9ET00gPSBmYWxzZTtcblxuICAgIC8qIERlY2lkZSBpZiBhIERPTSBgRG9jdW1lbnRGcmFnbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgICAqIHN0cmluZyAgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkgKi9cbiAgICB2YXIgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGZhbHNlO1xuXG4gICAgLyogSWYgYFJFVFVSTl9ET01gIG9yIGBSRVRVUk5fRE9NX0ZSQUdNRU5UYCBpcyBlbmFibGVkLCBkZWNpZGUgaWYgdGhlIHJldHVybmVkIERPTVxuICAgICAqIGBOb2RlYCBpcyBpbXBvcnRlZCBpbnRvIHRoZSBjdXJyZW50IGBEb2N1bWVudGAuIElmIHRoaXMgZmxhZyBpcyBub3QgZW5hYmxlZCB0aGVcbiAgICAgKiBgTm9kZWAgd2lsbCBiZWxvbmcgKGl0cyBvd25lckRvY3VtZW50KSB0byBhIGZyZXNoIGBIVE1MRG9jdW1lbnRgLCBjcmVhdGVkIGJ5XG4gICAgICogRE9NUHVyaWZ5LlxuICAgICAqXG4gICAgICogVGhpcyBkZWZhdWx0cyB0byBgdHJ1ZWAgc3RhcnRpbmcgRE9NUHVyaWZ5IDIuMi4wLiBOb3RlIHRoYXQgc2V0dGluZyBpdCB0byBgZmFsc2VgXG4gICAgICogbWlnaHQgY2F1c2UgWFNTIGZyb20gYXR0YWNrcyBoaWRkZW4gaW4gY2xvc2VkIHNoYWRvd3Jvb3RzIGluIGNhc2UgdGhlIGJyb3dzZXJcbiAgICAgKiBzdXBwb3J0cyBEZWNsYXJhdGl2ZSBTaGFkb3c6IERPTSBodHRwczovL3dlYi5kZXYvZGVjbGFyYXRpdmUtc2hhZG93LWRvbS9cbiAgICAgKi9cbiAgICB2YXIgUkVUVVJOX0RPTV9JTVBPUlQgPSB0cnVlO1xuXG4gICAgLyogVHJ5IHRvIHJldHVybiBhIFRydXN0ZWQgVHlwZSBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmluZywgcmV0dXJuIGEgc3RyaW5nIGluXG4gICAgICogY2FzZSBUcnVzdGVkIFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkICAqL1xuICAgIHZhciBSRVRVUk5fVFJVU1RFRF9UWVBFID0gZmFsc2U7XG5cbiAgICAvKiBPdXRwdXQgc2hvdWxkIGJlIGZyZWUgZnJvbSBET00gY2xvYmJlcmluZyBhdHRhY2tzPyAqL1xuICAgIHZhciBTQU5JVElaRV9ET00gPSB0cnVlO1xuXG4gICAgLyogS2VlcCBlbGVtZW50IGNvbnRlbnQgd2hlbiByZW1vdmluZyBlbGVtZW50PyAqL1xuICAgIHZhciBLRUVQX0NPTlRFTlQgPSB0cnVlO1xuXG4gICAgLyogSWYgYSBgTm9kZWAgaXMgcGFzc2VkIHRvIHNhbml0aXplKCksIHRoZW4gcGVyZm9ybXMgc2FuaXRpemF0aW9uIGluLXBsYWNlIGluc3RlYWRcbiAgICAgKiBvZiBpbXBvcnRpbmcgaXQgaW50byBhIG5ldyBEb2N1bWVudCBhbmQgcmV0dXJuaW5nIGEgc2FuaXRpemVkIGNvcHkgKi9cbiAgICB2YXIgSU5fUExBQ0UgPSBmYWxzZTtcblxuICAgIC8qIEFsbG93IHVzYWdlIG9mIHByb2ZpbGVzIGxpa2UgaHRtbCwgc3ZnIGFuZCBtYXRoTWwgKi9cbiAgICB2YXIgVVNFX1BST0ZJTEVTID0ge307XG5cbiAgICAvKiBUYWdzIHRvIGlnbm9yZSBjb250ZW50IG9mIHdoZW4gS0VFUF9DT05URU5UIGlzIHRydWUgKi9cbiAgICB2YXIgRk9SQklEX0NPTlRFTlRTID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9GT1JCSURfQ09OVEVOVFMgPSBhZGRUb1NldCh7fSwgWydhbm5vdGF0aW9uLXhtbCcsICdhdWRpbycsICdjb2xncm91cCcsICdkZXNjJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGVhZCcsICdpZnJhbWUnLCAnbWF0aCcsICdtaScsICdtbicsICdtbycsICdtcycsICdtdGV4dCcsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ3BsYWludGV4dCcsICdzY3JpcHQnLCAnc3R5bGUnLCAnc3ZnJywgJ3RlbXBsYXRlJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3ZpZGVvJywgJ3htcCddKTtcblxuICAgIC8qIFRhZ3MgdGhhdCBhcmUgc2FmZSBmb3IgZGF0YTogVVJJcyAqL1xuICAgIHZhciBEQVRBX1VSSV9UQUdTID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9EQVRBX1VSSV9UQUdTID0gYWRkVG9TZXQoe30sIFsnYXVkaW8nLCAndmlkZW8nLCAnaW1nJywgJ3NvdXJjZScsICdpbWFnZScsICd0cmFjayddKTtcblxuICAgIC8qIEF0dHJpYnV0ZXMgc2FmZSBmb3IgdmFsdWVzIGxpa2UgXCJqYXZhc2NyaXB0OlwiICovXG4gICAgdmFyIFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsO1xuICAgIHZhciBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMgPSBhZGRUb1NldCh7fSwgWydhbHQnLCAnY2xhc3MnLCAnZm9yJywgJ2lkJywgJ2xhYmVsJywgJ25hbWUnLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdyb2xlJywgJ3N1bW1hcnknLCAndGl0bGUnLCAndmFsdWUnLCAnc3R5bGUnLCAneG1sbnMnXSk7XG5cbiAgICB2YXIgTUFUSE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbiAgICB2YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgdmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuICAgIC8qIERvY3VtZW50IG5hbWVzcGFjZSAqL1xuICAgIHZhciBOQU1FU1BBQ0UgPSBIVE1MX05BTUVTUEFDRTtcbiAgICB2YXIgSVNfRU1QVFlfSU5QVVQgPSBmYWxzZTtcblxuICAgIC8qIFBhcnNpbmcgb2Ygc3RyaWN0IFhIVE1MIGRvY3VtZW50cyAqL1xuICAgIHZhciBQQVJTRVJfTUVESUFfVFlQRSA9IHZvaWQgMDtcbiAgICB2YXIgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyA9IFsnYXBwbGljYXRpb24veGh0bWwreG1sJywgJ3RleHQvaHRtbCddO1xuICAgIHZhciBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFID0gJ3RleHQvaHRtbCc7XG4gICAgdmFyIHRyYW5zZm9ybUNhc2VGdW5jID0gdm9pZCAwO1xuXG4gICAgLyogS2VlcCBhIHJlZmVyZW5jZSB0byBjb25maWcgdG8gcGFzcyB0byBob29rcyAqL1xuICAgIHZhciBDT05GSUcgPSBudWxsO1xuXG4gICAgLyogSWRlYWxseSwgZG8gbm90IHRvdWNoIGFueXRoaW5nIGJlbG93IHRoaXMgbGluZSAqL1xuICAgIC8qIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18gKi9cblxuICAgIHZhciBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcblxuICAgIC8qKlxuICAgICAqIF9wYXJzZUNvbmZpZ1xuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjZmcgb3B0aW9uYWwgY29uZmlnIGxpdGVyYWxcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIHZhciBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcoY2ZnKSB7XG4gICAgICBpZiAoQ09ORklHICYmIENPTkZJRyA9PT0gY2ZnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLyogU2hpZWxkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gdGFtcGVyaW5nICovXG4gICAgICBpZiAoIWNmZyB8fCAodHlwZW9mIGNmZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2ZnKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNmZyA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSBwcm90b3R5cGUgcG9sbHV0aW9uICovXG4gICAgICBjZmcgPSBjbG9uZShjZmcpO1xuXG4gICAgICAvKiBTZXQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgICBBTExPV0VEX1RBR1MgPSAnQUxMT1dFRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfVEFHUykgOiBERUZBVUxUX0FMTE9XRURfVEFHUztcbiAgICAgIEFMTE9XRURfQVRUUiA9ICdBTExPV0VEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9BVFRSKSA6IERFRkFVTFRfQUxMT1dFRF9BVFRSO1xuICAgICAgVVJJX1NBRkVfQVRUUklCVVRFUyA9ICdBRERfVVJJX1NBRkVfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTKSwgY2ZnLkFERF9VUklfU0FGRV9BVFRSKSA6IERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUztcbiAgICAgIERBVEFfVVJJX1RBR1MgPSAnQUREX0RBVEFfVVJJX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KGNsb25lKERFRkFVTFRfREFUQV9VUklfVEFHUyksIGNmZy5BRERfREFUQV9VUklfVEFHUykgOiBERUZBVUxUX0RBVEFfVVJJX1RBR1M7XG4gICAgICBGT1JCSURfQ09OVEVOVFMgPSAnRk9SQklEX0NPTlRFTlRTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9DT05URU5UUykgOiBERUZBVUxUX0ZPUkJJRF9DT05URU5UUztcbiAgICAgIEZPUkJJRF9UQUdTID0gJ0ZPUkJJRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTKSA6IHt9O1xuICAgICAgRk9SQklEX0FUVFIgPSAnRk9SQklEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0FUVFIpIDoge307XG4gICAgICBVU0VfUFJPRklMRVMgPSAnVVNFX1BST0ZJTEVTJyBpbiBjZmcgPyBjZmcuVVNFX1BST0ZJTEVTIDogZmFsc2U7XG4gICAgICBBTExPV19BUklBX0FUVFIgPSBjZmcuQUxMT1dfQVJJQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgICBBTExPV19EQVRBX0FUVFIgPSBjZmcuQUxMT1dfREFUQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGNmZy5BTExPV19VTktOT1dOX1BST1RPQ09MUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgU0FGRV9GT1JfVEVNUExBVEVTID0gY2ZnLlNBRkVfRk9SX1RFTVBMQVRFUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgV0hPTEVfRE9DVU1FTlQgPSBjZmcuV0hPTEVfRE9DVU1FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICAgIFJFVFVSTl9ET00gPSBjZmcuUkVUVVJOX0RPTSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGNmZy5SRVRVUk5fRE9NX0ZSQUdNRU5UIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBSRVRVUk5fRE9NX0lNUE9SVCA9IGNmZy5SRVRVUk5fRE9NX0lNUE9SVCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgICAgUkVUVVJOX1RSVVNURURfVFlQRSA9IGNmZy5SRVRVUk5fVFJVU1RFRF9UWVBFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBGT1JDRV9CT0RZID0gY2ZnLkZPUkNFX0JPRFkgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICAgIEtFRVBfQ09OVEVOVCA9IGNmZy5LRUVQX0NPTlRFTlQgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICAgIElOX1BMQUNFID0gY2ZnLklOX1BMQUNFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBJU19BTExPV0VEX1VSSSQkMSA9IGNmZy5BTExPV0VEX1VSSV9SRUdFWFAgfHwgSVNfQUxMT1dFRF9VUkkkJDE7XG4gICAgICBOQU1FU1BBQ0UgPSBjZmcuTkFNRVNQQUNFIHx8IEhUTUxfTkFNRVNQQUNFO1xuXG4gICAgICBQQVJTRVJfTUVESUFfVFlQRSA9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItaW5jbHVkZXNcbiAgICAgIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMuaW5kZXhPZihjZmcuUEFSU0VSX01FRElBX1RZUEUpID09PSAtMSA/IFBBUlNFUl9NRURJQV9UWVBFID0gREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA6IFBBUlNFUl9NRURJQV9UWVBFID0gY2ZnLlBBUlNFUl9NRURJQV9UWVBFO1xuXG4gICAgICAvLyBIVE1MIHRhZ3MgYW5kIGF0dHJpYnV0ZXMgYXJlIG5vdCBjYXNlLXNlbnNpdGl2ZSwgY29udmVydGluZyB0byBsb3dlcmNhc2UuIEtlZXBpbmcgWEhUTUwgYXMgaXMuXG4gICAgICB0cmFuc2Zvcm1DYXNlRnVuYyA9IFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSA6IHN0cmluZ1RvTG93ZXJDYXNlO1xuXG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgIEFMTE9XX0RBVEFfQVRUUiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICBSRVRVUk5fRE9NID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogUGFyc2UgcHJvZmlsZSBpbmZvICovXG4gICAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICAgIEFMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEodGV4dCkpKTtcbiAgICAgICAgQUxMT1dFRF9BVFRSID0gW107XG4gICAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgaHRtbCk7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBodG1sJDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmcgPT09IHRydWUpIHtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Zyk7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmckMSk7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmdGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2ZyQxKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgbWF0aE1sKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIG1hdGhNbCQxKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogTWVyZ2UgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgICBpZiAoY2ZnLkFERF9UQUdTKSB7XG4gICAgICAgIGlmIChBTExPV0VEX1RBR1MgPT09IERFRkFVTFRfQUxMT1dFRF9UQUdTKSB7XG4gICAgICAgICAgQUxMT1dFRF9UQUdTID0gY2xvbmUoQUxMT1dFRF9UQUdTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgY2ZnLkFERF9UQUdTKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNmZy5BRERfQVRUUikge1xuICAgICAgICBpZiAoQUxMT1dFRF9BVFRSID09PSBERUZBVUxUX0FMTE9XRURfQVRUUikge1xuICAgICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGNmZy5BRERfQVRUUik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjZmcuQUREX1VSSV9TQUZFX0FUVFIpIHtcbiAgICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNmZy5GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgICAgaWYgKEZPUkJJRF9DT05URU5UUyA9PT0gREVGQVVMVF9GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSBjbG9uZShGT1JCSURfQ09OVEVOVFMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkVG9TZXQoRk9SQklEX0NPTlRFTlRTLCBjZmcuRk9SQklEX0NPTlRFTlRTKTtcbiAgICAgIH1cblxuICAgICAgLyogQWRkICN0ZXh0IGluIGNhc2UgS0VFUF9DT05URU5UIGlzIHNldCB0byB0cnVlICovXG4gICAgICBpZiAoS0VFUF9DT05URU5UKSB7XG4gICAgICAgIEFMTE9XRURfVEFHU1snI3RleHQnXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIEFkZCBodG1sLCBoZWFkIGFuZCBib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIFdIT0xFX0RPQ1VNRU5UIGlzIHRydWUgKi9cbiAgICAgIGlmIChXSE9MRV9ET0NVTUVOVCkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsnaHRtbCcsICdoZWFkJywgJ2JvZHknXSk7XG4gICAgICB9XG5cbiAgICAgIC8qIEFkZCB0Ym9keSB0byBBTExPV0VEX1RBR1MgaW4gY2FzZSB0YWJsZXMgYXJlIHBlcm1pdHRlZCwgc2VlICMyODYsICMzNjUgKi9cbiAgICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ3Rib2R5J10pO1xuICAgICAgICBkZWxldGUgRk9SQklEX1RBR1MudGJvZHk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgZnVydGhlciBtYW5pcHVsYXRpb24gb2YgY29uZmlndXJhdGlvbi5cbiAgICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSUU4LCBTYWZhcmkgNSwgZXRjLlxuICAgICAgaWYgKGZyZWV6ZSkge1xuICAgICAgICBmcmVlemUoY2ZnKTtcbiAgICAgIH1cblxuICAgICAgQ09ORklHID0gY2ZnO1xuICAgIH07XG5cbiAgICB2YXIgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnbWknLCAnbW8nLCAnbW4nLCAnbXMnLCAnbXRleHQnXSk7XG5cbiAgICB2YXIgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydmb3JlaWdub2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnLCAnYW5ub3RhdGlvbi14bWwnXSk7XG5cbiAgICAvKiBLZWVwIHRyYWNrIG9mIGFsbCBwb3NzaWJsZSBTVkcgYW5kIE1hdGhNTCB0YWdzXG4gICAgICogc28gdGhhdCB3ZSBjYW4gcGVyZm9ybSB0aGUgbmFtZXNwYWNlIGNoZWNrc1xuICAgICAqIGNvcnJlY3RseS4gKi9cbiAgICB2YXIgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIHN2Zyk7XG4gICAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICBhZGRUb1NldChBTExfU1ZHX1RBR1MsIHN2Z0Rpc2FsbG93ZWQpO1xuXG4gICAgdmFyIEFMTF9NQVRITUxfVEFHUyA9IGFkZFRvU2V0KHt9LCBtYXRoTWwpO1xuICAgIGFkZFRvU2V0KEFMTF9NQVRITUxfVEFHUywgbWF0aE1sRGlzYWxsb3dlZCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCBhIERPTSBlbGVtZW50IHdob3NlIG5hbWVzcGFjZSBpcyBiZWluZyBjaGVja2VkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBmYWxzZSBpZiB0aGUgZWxlbWVudCBoYXMgYVxuICAgICAqICBuYW1lc3BhY2UgdGhhdCBhIHNwZWMtY29tcGxpYW50IHBhcnNlciB3b3VsZCBuZXZlclxuICAgICAqICByZXR1cm4uIFJldHVybiB0cnVlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB2YXIgX2NoZWNrVmFsaWROYW1lc3BhY2UgPSBmdW5jdGlvbiBfY2hlY2tWYWxpZE5hbWVzcGFjZShlbGVtZW50KSB7XG4gICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICAgICAgLy8gSW4gSlNET00sIGlmIHdlJ3JlIGluc2lkZSBzaGFkb3cgRE9NLCB0aGVuIHBhcmVudE5vZGVcbiAgICAgIC8vIGNhbiBiZSBudWxsLiBXZSBqdXN0IHNpbXVsYXRlIHBhcmVudCBpbiB0aGlzIGNhc2UuXG4gICAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50LnRhZ05hbWUpIHtcbiAgICAgICAgcGFyZW50ID0ge1xuICAgICAgICAgIG5hbWVzcGFjZVVSSTogSFRNTF9OQU1FU1BBQ0UsXG4gICAgICAgICAgdGFnTmFtZTogJ3RlbXBsYXRlJ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gICAgICB2YXIgcGFyZW50VGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKHBhcmVudC50YWdOYW1lKTtcblxuICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBIVE1MIG5hbWVzcGFjZSB0byBTVkdcbiAgICAgICAgLy8gaXMgdmlhIDxzdmc+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBNYXRoTUwgdG8gU1ZHIGlzIHZpYVxuICAgICAgICAvLyBzdmcgaWYgcGFyZW50IGlzIGVpdGhlciA8YW5ub3RhdGlvbi14bWw+IG9yIE1hdGhNTFxuICAgICAgICAvLyB0ZXh0IGludGVncmF0aW9uIHBvaW50cy5cbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ3N2ZycgJiYgKHBhcmVudFRhZ05hbWUgPT09ICdhbm5vdGF0aW9uLXhtbCcgfHwgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgZWxlbWVudHMgdGhhdCBhcmUgZGVmaW5lZCBpbiBTVkdcbiAgICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBTVkcgbmFtZXNwYWNlLlxuICAgICAgICByZXR1cm4gQm9vbGVhbihBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIE1hdGhNTFxuICAgICAgICAvLyBpcyB2aWEgPG1hdGg+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIE1hdGhNTCBpcyB2aWFcbiAgICAgICAgLy8gPG1hdGg+IGFuZCBIVE1MIGludGVncmF0aW9uIHBvaW50c1xuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCcgJiYgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gTWF0aE1MXG4gICAgICAgIC8vIHNwZWMuIEFsbCBvdGhlcnMgYXJlIGRpc2FsbG93ZWQgaW4gTWF0aE1MIG5hbWVzcGFjZS5cbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIEhUTUwgaXMgdmlhXG4gICAgICAgIC8vIEhUTUwgaW50ZWdyYXRpb24gcG9pbnRzLCBhbmQgZnJvbSBNYXRoTUwgdG8gSFRNTFxuICAgICAgICAvLyBpcyB2aWEgTWF0aE1MIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFICYmICFIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFICYmICFNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDZXJ0YWluIGVsZW1lbnRzIGFyZSBhbGxvd2VkIGluIGJvdGggU1ZHIGFuZCBIVE1MXG4gICAgICAgIC8vIG5hbWVzcGFjZS4gV2UgbmVlZCB0byBzcGVjaWZ5IHRoZW0gZXhwbGljaXRseVxuICAgICAgICAvLyBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IGVycm9ub3VzbHkgZGVsZXRlZCBmcm9tXG4gICAgICAgIC8vIEhUTUwgbmFtZXNwYWNlLlxuICAgICAgICB2YXIgY29tbW9uU3ZnQW5kSFRNTEVsZW1lbnRzID0gYWRkVG9TZXQoe30sIFsndGl0bGUnLCAnc3R5bGUnLCAnZm9udCcsICdhJywgJ3NjcmlwdCddKTtcblxuICAgICAgICAvLyBXZSBkaXNhbGxvdyB0YWdzIHRoYXQgYXJlIHNwZWNpZmljIGZvciBNYXRoTUxcbiAgICAgICAgLy8gb3IgU1ZHIGFuZCBzaG91bGQgbmV2ZXIgYXBwZWFyIGluIEhUTUwgbmFtZXNwYWNlXG4gICAgICAgIHJldHVybiAhQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdICYmIChjb21tb25TdmdBbmRIVE1MRWxlbWVudHNbdGFnTmFtZV0gfHwgIUFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb2RlIHNob3VsZCBuZXZlciByZWFjaCB0aGlzIHBsYWNlICh0aGlzIG1lYW5zXG4gICAgICAvLyB0aGF0IHRoZSBlbGVtZW50IHNvbWVob3cgZ290IG5hbWVzcGFjZSB0aGF0IGlzIG5vdFxuICAgICAgLy8gSFRNTCwgU1ZHIG9yIE1hdGhNTCkuIFJldHVybiBmYWxzZSBqdXN0IGluIGNhc2UuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9mb3JjZVJlbW92ZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBhIERPTSBub2RlXG4gICAgICovXG4gICAgdmFyIF9mb3JjZVJlbW92ZSA9IGZ1bmN0aW9uIF9mb3JjZVJlbW92ZShub2RlKSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogbm9kZSB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1yZW1vdmVcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vZGUub3V0ZXJIVE1MID0gZW1wdHlIVE1MO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfcmVtb3ZlQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgYW4gQXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIGEgRE9NIG5vZGVcbiAgICAgKi9cbiAgICB2YXIgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgbm9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgICAgYXR0cmlidXRlOiBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgICAgZnJvbTogbm9kZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICAgIGZyb206IG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXG4gICAgICAvLyBXZSB2b2lkIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIHVucmVtb3ZhYmxlIFwiaXNcIlwiIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChuYW1lID09PSAnaXMnICYmICFBTExPV0VEX0FUVFJbbmFtZV0pIHtcbiAgICAgICAgaWYgKFJFVFVSTl9ET00gfHwgUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfZm9yY2VSZW1vdmUobm9kZSk7XG4gICAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2luaXREb2N1bWVudFxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJ0eSBhIHN0cmluZyBvZiBkaXJ0eSBtYXJrdXBcbiAgICAgKiBAcmV0dXJuIHtEb2N1bWVudH0gYSBET00sIGZpbGxlZCB3aXRoIHRoZSBkaXJ0eSBtYXJrdXBcbiAgICAgKi9cbiAgICB2YXIgX2luaXREb2N1bWVudCA9IGZ1bmN0aW9uIF9pbml0RG9jdW1lbnQoZGlydHkpIHtcbiAgICAgIC8qIENyZWF0ZSBhIEhUTUwgZG9jdW1lbnQgKi9cbiAgICAgIHZhciBkb2MgPSB2b2lkIDA7XG4gICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICAgIGRpcnR5ID0gJzxyZW1vdmU+PC9yZW1vdmU+JyArIGRpcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSWYgRk9SQ0VfQk9EWSBpc24ndCB1c2VkLCBsZWFkaW5nIHdoaXRlc3BhY2UgbmVlZHMgdG8gYmUgcHJlc2VydmVkIG1hbnVhbGx5ICovXG4gICAgICAgIHZhciBtYXRjaGVzID0gc3RyaW5nTWF0Y2goZGlydHksIC9eW1xcclxcblxcdCBdKy8pO1xuICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1swXTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykge1xuICAgICAgICAvLyBSb290IG9mIFhIVE1MIGRvYyBtdXN0IGNvbnRhaW4geG1sbnMgZGVjbGFyYXRpb24gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIveGh0bWwxL25vcm1hdGl2ZS5odG1sI3N0cmljdClcbiAgICAgICAgZGlydHkgPSAnPGh0bWwgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI+PGhlYWQ+PC9oZWFkPjxib2R5PicgKyBkaXJ0eSArICc8L2JvZHk+PC9odG1sPic7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJ0eVBheWxvYWQgPSB0cnVzdGVkVHlwZXNQb2xpY3kgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgIC8qXG4gICAgICAgKiBVc2UgdGhlIERPTVBhcnNlciBBUEkgYnkgZGVmYXVsdCwgZmFsbGJhY2sgbGF0ZXIgaWYgbmVlZHMgYmVcbiAgICAgICAqIERPTVBhcnNlciBub3Qgd29yayBmb3Igc3ZnIHdoZW4gaGFzIG11bHRpcGxlIHJvb3QgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGRpcnR5UGF5bG9hZCwgUEFSU0VSX01FRElBX1RZUEUpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuXG4gICAgICAvKiBVc2UgY3JlYXRlSFRNTERvY3VtZW50IGluIGNhc2UgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAgICAgIGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgIGRvYyA9IGltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KE5BTUVTUEFDRSwgJ3RlbXBsYXRlJywgbnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBJU19FTVBUWV9JTlBVVCA/ICcnIDogZGlydHlQYXlsb2FkO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgLy8gU3ludGF4IGVycm9yIGlmIGRpcnR5UGF5bG9hZCBpcyBpbnZhbGlkIHhtbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBib2R5ID0gZG9jLmJvZHkgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgaWYgKGRpcnR5ICYmIGxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxlYWRpbmdXaGl0ZXNwYWNlKSwgYm9keS5jaGlsZE5vZGVzWzBdIHx8IG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvKiBXb3JrIG9uIHdob2xlIGRvY3VtZW50IG9yIGp1c3QgaXRzIGJvZHkgKi9cbiAgICAgIGlmIChOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gV0hPTEVfRE9DVU1FTlQgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogYm9keTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2NyZWF0ZUl0ZXJhdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtEb2N1bWVudH0gcm9vdCBkb2N1bWVudC9mcmFnbWVudCB0byBjcmVhdGUgaXRlcmF0b3IgZm9yXG4gICAgICogQHJldHVybiB7SXRlcmF0b3J9IGl0ZXJhdG9yIGluc3RhbmNlXG4gICAgICovXG4gICAgdmFyIF9jcmVhdGVJdGVyYXRvciA9IGZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvcihyb290KSB7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsIHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfaXNDbG9iYmVyZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge05vZGV9IGVsbSBlbGVtZW50IHRvIGNoZWNrIGZvciBjbG9iYmVyaW5nIGF0dGFja3NcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGNsb2JiZXJlZCwgZmFsc2UgaWYgc2FmZVxuICAgICAqL1xuICAgIHZhciBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiBfaXNDbG9iYmVyZWQoZWxtKSB7XG4gICAgICBpZiAoZWxtIGluc3RhbmNlb2YgVGV4dCB8fCBlbG0gaW5zdGFuY2VvZiBDb21tZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBlbG0ubm9kZU5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0udGV4dENvbnRlbnQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQ2hpbGQgIT09ICdmdW5jdGlvbicgfHwgIShlbG0uYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkgfHwgdHlwZW9mIGVsbS5yZW1vdmVBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5zZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5uYW1lc3BhY2VVUkkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0uaW5zZXJ0QmVmb3JlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9pc05vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge05vZGV9IG9iaiBvYmplY3QgdG8gY2hlY2sgd2hldGhlciBpdCdzIGEgRE9NIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlzIG9iamVjdCBpcyBhIERPTSBub2RlXG4gICAgICovXG4gICAgdmFyIF9pc05vZGUgPSBmdW5jdGlvbiBfaXNOb2RlKG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2YgTm9kZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoTm9kZSkpID09PSAnb2JqZWN0JyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiBvYmplY3QgJiYgKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2V4ZWN1dGVIb29rXG4gICAgICogRXhlY3V0ZSB1c2VyIGNvbmZpZ3VyYWJsZSBob29rc1xuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBlbnRyeVBvaW50ICBOYW1lIG9mIHRoZSBob29rJ3MgZW50cnkgcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBjdXJyZW50Tm9kZSBub2RlIHRvIHdvcmsgb24gd2l0aCB0aGUgaG9va1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBhZGRpdGlvbmFsIGhvb2sgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIHZhciBfZXhlY3V0ZUhvb2sgPSBmdW5jdGlvbiBfZXhlY3V0ZUhvb2soZW50cnlQb2ludCwgY3VycmVudE5vZGUsIGRhdGEpIHtcbiAgICAgIGlmICghaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcnJheUZvckVhY2goaG9va3NbZW50cnlQb2ludF0sIGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9zYW5pdGl6ZUVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgICAqIEBwcm90ZWN0IHRleHRDb250ZW50XG4gICAgICogQHByb3RlY3QgcmVtb3ZlQ2hpbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHtOb2RlfSBjdXJyZW50Tm9kZSB0byBjaGVjayBmb3IgcGVybWlzc2lvbiB0byBleGlzdFxuICAgICAqIEByZXR1cm4gIHtCb29sZWFufSB0cnVlIGlmIG5vZGUgd2FzIGtpbGxlZCwgZmFsc2UgaWYgbGVmdCBhbGl2ZVxuICAgICAqL1xuICAgIHZhciBfc2FuaXRpemVFbGVtZW50cyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKSB7XG4gICAgICB2YXIgY29udGVudCA9IHZvaWQgMDtcblxuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuXG4gICAgICAvKiBDaGVjayBpZiBlbGVtZW50IGlzIGNsb2JiZXJlZCBvciBjYW4gY2xvYmJlciAqL1xuICAgICAgaWYgKF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIENoZWNrIGlmIHRhZ25hbWUgY29udGFpbnMgVW5pY29kZSAqL1xuICAgICAgaWYgKHN0cmluZ01hdGNoKGN1cnJlbnROb2RlLm5vZGVOYW1lLCAvW1xcdTAwODAtXFx1RkZGRl0vKSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogTm93IGxldCdzIGNoZWNrIHRoZSBlbGVtZW50J3MgdHlwZSBhbmQgbmFtZSAqL1xuICAgICAgdmFyIHRhZ05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplRWxlbWVudCcsIGN1cnJlbnROb2RlLCB7XG4gICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1NcbiAgICAgIH0pO1xuXG4gICAgICAvKiBEZXRlY3QgbVhTUyBhdHRlbXB0cyBhYnVzaW5nIG5hbWVzcGFjZSBjb25mdXNpb24gKi9cbiAgICAgIGlmICghX2lzTm9kZShjdXJyZW50Tm9kZS5maXJzdEVsZW1lbnRDaGlsZCkgJiYgKCFfaXNOb2RlKGN1cnJlbnROb2RlLmNvbnRlbnQpIHx8ICFfaXNOb2RlKGN1cnJlbnROb2RlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQpKSAmJiByZWdFeHBUZXN0KC88Wy9cXHddL2csIGN1cnJlbnROb2RlLmlubmVySFRNTCkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIE1pdGlnYXRlIGEgcHJvYmxlbSB3aXRoIHRlbXBsYXRlcyBpbnNpZGUgc2VsZWN0ICovXG4gICAgICBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcgJiYgcmVnRXhwVGVzdCgvPHRlbXBsYXRlL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFJlbW92ZSBlbGVtZW50IGlmIGFueXRoaW5nIGZvcmJpZHMgaXRzIHByZXNlbmNlICovXG4gICAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgICAvKiBLZWVwIGNvbnRlbnQgZXhjZXB0IGZvciBiYWQtbGlzdGVkIGVsZW1lbnRzICovXG4gICAgICAgIGlmIChLRUVQX0NPTlRFTlQgJiYgIUZPUkJJRF9DT05URU5UU1t0YWdOYW1lXSkge1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlcyAmJiBwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lTm9kZShjaGlsZE5vZGVzW2ldLCB0cnVlKSwgZ2V0TmV4dFNpYmxpbmcoY3VycmVudE5vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogQ2hlY2sgd2hldGhlciBlbGVtZW50IGhhcyBhIHZhbGlkIG5hbWVzcGFjZSAqL1xuICAgICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhX2NoZWNrVmFsaWROYW1lc3BhY2UoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHRhZ05hbWUgPT09ICdub3NjcmlwdCcgfHwgdGFnTmFtZSA9PT0gJ25vZW1iZWQnKSAmJiByZWdFeHBUZXN0KC88XFwvbm8oc2NyaXB0fGVtYmVkKS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBTYW5pdGl6ZSBlbGVtZW50IGNvbnRlbnQgdG8gYmUgdGVtcGxhdGUtc2FmZSAqL1xuICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUyAmJiBjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAvKiBHZXQgdGhlIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnQgKi9cbiAgICAgICAgY29udGVudCA9IGN1cnJlbnROb2RlLnRleHRDb250ZW50O1xuICAgICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBNVVNUQUNIRV9FWFBSJCQxLCAnICcpO1xuICAgICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBFUkJfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnRleHRDb250ZW50ICE9PSBjb250ZW50KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7IGVsZW1lbnQ6IGN1cnJlbnROb2RlLmNsb25lTm9kZSgpIH0pO1xuICAgICAgICAgIGN1cnJlbnROb2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVFbGVtZW50cycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfaXNWYWxpZEF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBsY1RhZyBMb3dlcmNhc2UgdGFnIG5hbWUgb2YgY29udGFpbmluZyBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbGNOYW1lIExvd2VyY2FzZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgdmFyIF9pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpIHtcbiAgICAgIC8qIE1ha2Ugc3VyZSBhdHRyaWJ1dGUgY2Fubm90IGNsb2JiZXIgKi9cbiAgICAgIGlmIChTQU5JVElaRV9ET00gJiYgKGxjTmFtZSA9PT0gJ2lkJyB8fCBsY05hbWUgPT09ICduYW1lJykgJiYgKHZhbHVlIGluIGRvY3VtZW50IHx8IHZhbHVlIGluIGZvcm1FbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qIEFsbG93IHZhbGlkIGRhdGEtKiBhdHRyaWJ1dGVzOiBBdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGFmdGVyIFwiLVwiXG4gICAgICAgICAgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI2VtYmVkZGluZy1jdXN0b20tbm9uLXZpc2libGUtZGF0YS13aXRoLXRoZS1kYXRhLSotYXR0cmlidXRlcylcbiAgICAgICAgICBYTUwtY29tcGF0aWJsZSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN4bWwtY29tcGF0aWJsZSBhbmQgaHR0cDovL3d3dy53My5vcmcvVFIveG1sLyNkMGU4MDQpXG4gICAgICAgICAgV2UgZG9uJ3QgbmVlZCB0byBjaGVjayB0aGUgdmFsdWU7IGl0J3MgYWx3YXlzIFVSSSBzYWZlLiAqL1xuICAgICAgaWYgKEFMTE9XX0RBVEFfQVRUUiAmJiAhRk9SQklEX0FUVFJbbGNOYW1lXSAmJiByZWdFeHBUZXN0KERBVEFfQVRUUiQkMSwgbGNOYW1lKSkgOyBlbHNlIGlmIChBTExPV19BUklBX0FUVFIgJiYgcmVnRXhwVGVzdChBUklBX0FUVFIkJDEsIGxjTmFtZSkpIDsgZWxzZSBpZiAoIUFMTE9XRURfQVRUUltsY05hbWVdIHx8IEZPUkJJRF9BVFRSW2xjTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8qIENoZWNrIHZhbHVlIGlzIHNhZmUuIEZpcnN0LCBpcyBhdHRyIGluZXJ0PyBJZiBzbywgaXMgc2FmZSAqL1xuICAgICAgfSBlbHNlIGlmIChVUklfU0FGRV9BVFRSSUJVVEVTW2xjTmFtZV0pIDsgZWxzZSBpZiAocmVnRXhwVGVzdChJU19BTExPV0VEX1VSSSQkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJCQxLCAnJykpKSA7IGVsc2UgaWYgKChsY05hbWUgPT09ICdzcmMnIHx8IGxjTmFtZSA9PT0gJ3hsaW5rOmhyZWYnIHx8IGxjTmFtZSA9PT0gJ2hyZWYnKSAmJiBsY1RhZyAhPT0gJ3NjcmlwdCcgJiYgc3RyaW5nSW5kZXhPZih2YWx1ZSwgJ2RhdGE6JykgPT09IDAgJiYgREFUQV9VUklfVEFHU1tsY1RhZ10pIDsgZWxzZSBpZiAoQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgJiYgIXJlZ0V4cFRlc3QoSVNfU0NSSVBUX09SX0RBVEEkJDEsIHN0cmluZ1JlcGxhY2UodmFsdWUsIEFUVFJfV0hJVEVTUEFDRSQkMSwgJycpKSkgOyBlbHNlIGlmICghdmFsdWUpIDsgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9zYW5pdGl6ZUF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0IGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgICAqIEBwcm90ZWN0IHJlbW92ZUF0dHJpYnV0ZVxuICAgICAqIEBwcm90ZWN0IHNldEF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gY3VycmVudE5vZGUgdG8gc2FuaXRpemVcbiAgICAgKi9cbiAgICB2YXIgX3Nhbml0aXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpIHtcbiAgICAgIHZhciBhdHRyID0gdm9pZCAwO1xuICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgdmFyIGxjTmFtZSA9IHZvaWQgMDtcbiAgICAgIHZhciBsID0gdm9pZCAwO1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gY3VycmVudE5vZGUuYXR0cmlidXRlcztcblxuICAgICAgLyogQ2hlY2sgaWYgd2UgaGF2ZSBhdHRyaWJ1dGVzOyBpZiBub3Qgd2UgbWlnaHQgaGF2ZSBhIHRleHQgbm9kZSAqL1xuXG4gICAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG9va0V2ZW50ID0ge1xuICAgICAgICBhdHRyTmFtZTogJycsXG4gICAgICAgIGF0dHJWYWx1ZTogJycsXG4gICAgICAgIGtlZXBBdHRyOiB0cnVlLFxuICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogQUxMT1dFRF9BVFRSXG4gICAgICB9O1xuICAgICAgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuXG4gICAgICAvKiBHbyBiYWNrd2FyZHMgb3ZlciBhbGwgYXR0cmlidXRlczsgc2FmZWx5IHJlbW92ZSBiYWQgb25lcyAqL1xuICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tsXTtcbiAgICAgICAgdmFyIF9hdHRyID0gYXR0cixcbiAgICAgICAgICAgIG5hbWUgPSBfYXR0ci5uYW1lLFxuICAgICAgICAgICAgbmFtZXNwYWNlVVJJID0gX2F0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgIHZhbHVlID0gc3RyaW5nVHJpbShhdHRyLnZhbHVlKTtcbiAgICAgICAgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMobmFtZSk7XG5cbiAgICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgICBob29rRXZlbnQuYXR0ck5hbWUgPSBsY05hbWU7XG4gICAgICAgIGhvb2tFdmVudC5hdHRyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaG9va0V2ZW50LmtlZXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIgPSB1bmRlZmluZWQ7IC8vIEFsbG93cyBkZXZlbG9wZXJzIHRvIHNlZSB0aGlzIGlzIGEgcHJvcGVydHkgdGhleSBjYW4gc2V0XG4gICAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplQXR0cmlidXRlJywgY3VycmVudE5vZGUsIGhvb2tFdmVudCk7XG4gICAgICAgIHZhbHVlID0gaG9va0V2ZW50LmF0dHJWYWx1ZTtcbiAgICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG4gICAgICAgIGlmIChob29rRXZlbnQuZm9yY2VLZWVwQXR0cikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogUmVtb3ZlIGF0dHJpYnV0ZSAqL1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgICAgaWYgKCFob29rRXZlbnQua2VlcEF0dHIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFdvcmsgYXJvdW5kIGEgc2VjdXJpdHkgaXNzdWUgaW4galF1ZXJ5IDMuMCAqL1xuICAgICAgICBpZiAocmVnRXhwVGVzdCgvXFwvPi9pLCB2YWx1ZSkpIHtcbiAgICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNhbml0aXplIGF0dHJpYnV0ZSBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgTVVTVEFDSEVfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIEVSQl9FWFBSJCQxLCAnICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogSXMgYHZhbHVlYCB2YWxpZCBmb3IgdGhpcyBhdHRyaWJ1dGU/ICovXG4gICAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgICAgaWYgKCFfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIEhhbmRsZSBpbnZhbGlkIGRhdGEtKiBhdHRyaWJ1dGUgc2V0IGJ5IHRyeS1jYXRjaGluZyBpdCAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBzZXRBdHRyaWJ1dGUoKSBmb3IgYnJvd3Nlci11bnJlY29nbml6ZWQgbmFtZXNwYWNlcyBlLmcuIFwieC1zY2hlbWFcIi4gKi9cbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlQb3AoRE9NUHVyaWZ5LnJlbW92ZWQpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVBdHRyaWJ1dGVzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfc2FuaXRpemVTaGFkb3dET01cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdtZW50IHRvIGl0ZXJhdGUgb3ZlciByZWN1cnNpdmVseVxuICAgICAqL1xuICAgIHZhciBfc2FuaXRpemVTaGFkb3dET00gPSBmdW5jdGlvbiBfc2FuaXRpemVTaGFkb3dET00oZnJhZ21lbnQpIHtcbiAgICAgIHZhciBzaGFkb3dOb2RlID0gdm9pZCAwO1xuICAgICAgdmFyIHNoYWRvd0l0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKGZyYWdtZW50KTtcblxuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZVNoYWRvd0RPTScsIGZyYWdtZW50LCBudWxsKTtcblxuICAgICAgd2hpbGUgKHNoYWRvd05vZGUgPSBzaGFkb3dJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVTaGFkb3dOb2RlJywgc2hhZG93Tm9kZSwgbnVsbCk7XG5cbiAgICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgICAgaWYgKF9zYW5pdGl6ZUVsZW1lbnRzKHNoYWRvd05vZGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBEZWVwIHNoYWRvdyBET00gZGV0ZWN0ZWQgKi9cbiAgICAgICAgaWYgKHNoYWRvd05vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oc2hhZG93Tm9kZS5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKHNoYWRvd05vZGUpO1xuICAgICAgfVxuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNhbml0aXplXG4gICAgICogUHVibGljIG1ldGhvZCBwcm92aWRpbmcgY29yZSBzYW5pdGF0aW9uIGZ1bmN0aW9uYWxpdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE5vZGV9IGRpcnR5IHN0cmluZyBvciBET00gbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgRE9NUHVyaWZ5LnNhbml0aXplID0gZnVuY3Rpb24gKGRpcnR5LCBjZmcpIHtcbiAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xuICAgICAgdmFyIGltcG9ydGVkTm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBvbGROb2RlID0gdm9pZCAwO1xuICAgICAgdmFyIHJldHVybk5vZGUgPSB2b2lkIDA7XG4gICAgICAvKiBNYWtlIHN1cmUgd2UgaGF2ZSBhIHN0cmluZyB0byBzYW5pdGl6ZS5cbiAgICAgICAgRE8gTk9UIHJldHVybiBlYXJseSwgYXMgdGhpcyB3aWxsIHJldHVybiB0aGUgd3JvbmcgdHlwZSBpZlxuICAgICAgICB0aGUgdXNlciBoYXMgcmVxdWVzdGVkIGEgRE9NIG9iamVjdCByYXRoZXIgdGhhbiBhIHN0cmluZyAqL1xuICAgICAgSVNfRU1QVFlfSU5QVVQgPSAhZGlydHk7XG4gICAgICBpZiAoSVNfRU1QVFlfSU5QVVQpIHtcbiAgICAgICAgZGlydHkgPSAnPCEtLT4nO1xuICAgICAgfVxuXG4gICAgICAvKiBTdHJpbmdpZnksIGluIGNhc2UgZGlydHkgaXMgYW4gb2JqZWN0ICovXG4gICAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAnc3RyaW5nJyAmJiAhX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ3RvU3RyaW5nIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlydHkgPSBkaXJ0eS50b1N0cmluZygpO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ2RpcnR5IGlzIG5vdCBhIHN0cmluZywgYWJvcnRpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogQ2hlY2sgd2UgY2FuIHJ1bi4gT3RoZXJ3aXNlIGZhbGwgYmFjayBvciBpZ25vcmUgKi9cbiAgICAgIGlmICghRE9NUHVyaWZ5LmlzU3VwcG9ydGVkKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKHdpbmRvdy50b1N0YXRpY0hUTUwpID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygd2luZG93LnRvU3RhdGljSFRNTCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9pc05vZGUoZGlydHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eS5vdXRlckhUTUwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICAgIH1cblxuICAgICAgLyogQXNzaWduIGNvbmZpZyB2YXJzICovXG4gICAgICBpZiAoIVNFVF9DT05GSUcpIHtcbiAgICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgICB9XG5cbiAgICAgIC8qIENsZWFuIHVwIHJlbW92ZWQgZWxlbWVudHMgKi9cbiAgICAgIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG5cbiAgICAgIC8qIENoZWNrIGlmIGRpcnR5IGlzIGNvcnJlY3RseSB0eXBlZCBmb3IgSU5fUExBQ0UgKi9cbiAgICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIElOX1BMQUNFID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChJTl9QTEFDRSkgOyBlbHNlIGlmIChkaXJ0eSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgLyogSWYgZGlydHkgaXMgYSBET00gZWxlbWVudCwgYXBwZW5kIHRvIGFuIGVtcHR5IGRvY3VtZW50IHRvIGF2b2lkXG4gICAgICAgICAgIGVsZW1lbnRzIGJlaW5nIHN0cmlwcGVkIGJ5IHRoZSBwYXJzZXIgKi9cbiAgICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoJzwhLS0tLT4nKTtcbiAgICAgICAgaW1wb3J0ZWROb2RlID0gYm9keS5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZGlydHksIHRydWUpO1xuICAgICAgICBpZiAoaW1wb3J0ZWROb2RlLm5vZGVUeXBlID09PSAxICYmIGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgLyogTm9kZSBpcyBhbHJlYWR5IGEgYm9keSwgdXNlIGFzIGlzICovXG4gICAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoaW1wb3J0ZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogRXhpdCBkaXJlY3RseSBpZiB3ZSBoYXZlIG5vdGhpbmcgdG8gZG8gKi9cbiAgICAgICAgaWYgKCFSRVRVUk5fRE9NICYmICFTQUZFX0ZPUl9URU1QTEFURVMgJiYgIVdIT0xFX0RPQ1VNRU5UICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgICBkaXJ0eS5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJbml0aWFsaXplIHRoZSBkb2N1bWVudCB0byB3b3JrIG9uICovXG4gICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KGRpcnR5KTtcblxuICAgICAgICAvKiBDaGVjayB3ZSBoYXZlIGEgRE9NIG5vZGUgZnJvbSB0aGUgZGF0YSAqL1xuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gUkVUVVJOX0RPTSA/IG51bGwgOiBlbXB0eUhUTUw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogUmVtb3ZlIGZpcnN0IGVsZW1lbnQgbm9kZSAob3VycykgaWYgRk9SQ0VfQk9EWSBpcyBzZXQgKi9cbiAgICAgIGlmIChib2R5ICYmIEZPUkNFX0JPRFkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIC8qIEdldCBub2RlIGl0ZXJhdG9yICovXG4gICAgICB2YXIgbm9kZUl0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKElOX1BMQUNFID8gZGlydHkgOiBib2R5KTtcblxuICAgICAgLyogTm93IHN0YXJ0IGl0ZXJhdGluZyBvdmVyIHRoZSBjcmVhdGVkIGRvY3VtZW50ICovXG4gICAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAvKiBGaXggSUUncyBzdHJhbmdlIGJlaGF2aW9yIHdpdGggbWFuaXB1bGF0ZWQgdGV4dE5vZGVzICM4OSAqL1xuICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMgJiYgY3VycmVudE5vZGUgPT09IG9sZE5vZGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNoYWRvdyBET00gZGV0ZWN0ZWQsIHNhbml0aXplIGl0ICovXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShjdXJyZW50Tm9kZS5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKTtcblxuICAgICAgICBvbGROb2RlID0gY3VycmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIG9sZE5vZGUgPSBudWxsO1xuXG4gICAgICAvKiBJZiB3ZSBzYW5pdGl6ZWQgYGRpcnR5YCBpbi1wbGFjZSwgcmV0dXJuIGl0LiAqL1xuICAgICAgaWYgKElOX1BMQUNFKSB7XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICAgIH1cblxuICAgICAgLyogUmV0dXJuIHNhbml0aXplZCBzdHJpbmcgb3IgRE9NICovXG4gICAgICBpZiAoUkVUVVJOX0RPTSkge1xuICAgICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgIHJldHVybk5vZGUgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50LmNhbGwoYm9keS5vd25lckRvY3VtZW50KTtcblxuICAgICAgICAgIHdoaWxlIChib2R5LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgICAgIHJldHVybk5vZGUuYXBwZW5kQ2hpbGQoYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuTm9kZSA9IGJvZHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUkVUVVJOX0RPTV9JTVBPUlQpIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgQWRvcHROb2RlKCkgaXMgbm90IHVzZWQgYmVjYXVzZSBpbnRlcm5hbCBzdGF0ZSBpcyBub3QgcmVzZXRcbiAgICAgICAgICAgIChlLmcuIHRoZSBwYXN0IG5hbWVzIG1hcCBvZiBhIEhUTUxGb3JtRWxlbWVudCksIHRoaXMgaXMgc2FmZVxuICAgICAgICAgICAgaW4gdGhlb3J5IGJ1dCB3ZSB3b3VsZCByYXRoZXIgbm90IHJpc2sgYW5vdGhlciBhdHRhY2sgdmVjdG9yLlxuICAgICAgICAgICAgVGhlIHN0YXRlIHRoYXQgaXMgY2xvbmVkIGJ5IGltcG9ydE5vZGUoKSBpcyBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgICAgICAgIGJ5IHRoZSBzcGVjcy5cbiAgICAgICAgICAqL1xuICAgICAgICAgIHJldHVybk5vZGUgPSBpbXBvcnROb2RlLmNhbGwob3JpZ2luYWxEb2N1bWVudCwgcmV0dXJuTm9kZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuTm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmlhbGl6ZWRIVE1MID0gV0hPTEVfRE9DVU1FTlQgPyBib2R5Lm91dGVySFRNTCA6IGJvZHkuaW5uZXJIVE1MO1xuXG4gICAgICAvKiBTYW5pdGl6ZSBmaW5hbCBzdHJpbmcgdGVtcGxhdGUtc2FmZSAqL1xuICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIE1VU1RBQ0hFX0VYUFIkJDEsICcgJyk7XG4gICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKSA6IHNlcmlhbGl6ZWRIVE1MO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHRvIHNldCB0aGUgY29uZmlndXJhdGlvbiBvbmNlXG4gICAgICogc2V0Q29uZmlnXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgRE9NUHVyaWZ5LnNldENvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgICAgU0VUX0NPTkZJRyA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIHRoZSBjb25maWd1cmF0aW9uXG4gICAgICogY2xlYXJDb25maWdcbiAgICAgKlxuICAgICAqL1xuICAgIERPTVB1cmlmeS5jbGVhckNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIENPTkZJRyA9IG51bGw7XG4gICAgICBTRVRfQ09ORklHID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gY2hlY2sgaWYgYW4gYXR0cmlidXRlIHZhbHVlIGlzIHZhbGlkLlxuICAgICAqIFVzZXMgbGFzdCBzZXQgY29uZmlnLCBpZiBhbnkuIE90aGVyd2lzZSwgdXNlcyBjb25maWcgZGVmYXVsdHMuXG4gICAgICogaXNWYWxpZEF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgb2YgY29udGFpbmluZyBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYXR0ciBBdHRyaWJ1dGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC4gT3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLlxuICAgICAqL1xuICAgIERPTVB1cmlmeS5pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gKHRhZywgYXR0ciwgdmFsdWUpIHtcbiAgICAgIC8qIEluaXRpYWxpemUgc2hhcmVkIGNvbmZpZyB2YXJzIGlmIG5lY2Vzc2FyeS4gKi9cbiAgICAgIGlmICghQ09ORklHKSB7XG4gICAgICAgIF9wYXJzZUNvbmZpZyh7fSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKHRhZyk7XG4gICAgICB2YXIgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoYXR0cik7XG4gICAgICByZXR1cm4gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRIb29rXG4gICAgICogUHVibGljIG1ldGhvZCB0byBhZGQgRE9NUHVyaWZ5IGhvb2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2sgdG8gYWRkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va0Z1bmN0aW9uIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgKi9cbiAgICBET01QdXJpZnkuYWRkSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHtcbiAgICAgIGlmICh0eXBlb2YgaG9va0Z1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaG9va3NbZW50cnlQb2ludF0gPSBob29rc1tlbnRyeVBvaW50XSB8fCBbXTtcbiAgICAgIGFycmF5UHVzaChob29rc1tlbnRyeVBvaW50XSwgaG9va0Z1bmN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlSG9va1xuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIGEgRE9NUHVyaWZ5IGhvb2sgYXQgYSBnaXZlbiBlbnRyeVBvaW50XG4gICAgICogKHBvcHMgaXQgZnJvbSB0aGUgc3RhY2sgb2YgaG9va3MgaWYgbW9yZSBhcmUgcHJlc2VudClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9vayB0byByZW1vdmVcbiAgICAgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgYXJyYXlQb3AoaG9va3NbZW50cnlQb2ludF0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVIb29rc1xuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIGFsbCBET01QdXJpZnkgaG9va3MgYXQgYSBnaXZlbiBlbnRyeVBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rcyB0byByZW1vdmVcbiAgICAgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlSG9va3MgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gW107XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZUFsbEhvb2tzXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rc1xuICAgICAqXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LnJlbW92ZUFsbEhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaG9va3MgPSB7fTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgfVxuXG4gIHZhciBwdXJpZnkgPSBjcmVhdGVET01QdXJpZnkoKTtcblxuICByZXR1cm4gcHVyaWZ5O1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXJpZnkuanMubWFwXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBhcnJheS5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIyKTtcblxuLyoqXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBhcnJheVxuICogZnJvbSBzdGFydCBpbmRleChkZWZhdWx0IDApLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqIEl0IGNvbXBhcmVzIHNlYXJjaEVsZW1lbnQgdG8gZWxlbWVudHMgb2YgdGhlIEFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICogKHRoZSBzYW1lIG1ldGhvZCB1c2VkIGJ5IHRoZSA9PT0sIG9yIHRyaXBsZS1lcXVhbHMsIG9wZXJhdG9yKS5cbiAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCBTdGFydCBpbmRleCBpbiBhcnJheSBmb3Igc2VhcmNoaW5nIChkZWZhdWx0IDApXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgRmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudFxuICogQG1lbWJlcm9mIG1vZHVsZTphcnJheVxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGluQXJyYXkgZnJvbSAndHVpLWNvZGUtc25pcHBldC9hcnJheS9pbkFycmF5JztcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGluQXJyYXkgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2FycmF5L2luQXJyYXknKTtcbiAqXG4gKiBjb25zdCBhcnIgPSBbJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91ciddO1xuICogY29uc3QgaWR4MSA9IGluQXJyYXkoJ29uZScsIGFyciwgMyk7IC8vIC0xXG4gKiBjb25zdCBpZHgyID0gaW5BcnJheSgnb25lJywgYXJyKTsgLy8gMFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNlYXJjaEVsZW1lbnQsIGFycmF5LCBzdGFydEluZGV4KSB7XG4gIHZhciBpO1xuICB2YXIgbGVuZ3RoO1xuICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuXG4gIGlmICghaXNBcnJheShhcnJheSkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgc2VhcmNoRWxlbWVudCwgc3RhcnRJbmRleCk7XG4gIH1cblxuICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGZvciAoaSA9IHN0YXJ0SW5kZXg7IHN0YXJ0SW5kZXggPj0gMCAmJiBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbkFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2OTA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qob3IgZWxlbWVudCBvZiBhcnJheSkgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyMik7XG52YXIgZm9yRWFjaEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OTMpO1xudmFyIGZvckVhY2hPd25Qcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTYpO1xuXG4vKipcbiAqIEBtb2R1bGUgY29sbGVjdGlvblxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qob3IgZWxlbWVudCBvZiBhcnJheSkgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBJZiB0aGUgb2JqZWN0IGlzIEFycmF5LWxpa2Ugb2JqZWN0KGV4LWFyZ3VtZW50cyBvYmplY3QpLCBJdCBuZWVkcyB0byB0cmFuc2Zvcm0gdG8gQXJyYXkuKHNlZSAnZXgyJyBvZiBleGFtcGxlKS5cbiAqIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGUgbG9vcCB3aWxsIGJlIHN0b3BwZWQuXG4gKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICAxKSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5KG9yIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudClcbiAqICAyKSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50KVxuICogIDMpIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgZm9yRWFjaCBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaCc7IFxuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaCA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoJyk7IFxuICpcbiAqIGxldCBzdW0gPSAwO1xuICpcbiAqIGZvckVhY2goWzEsMiwzXSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqXG4gKiAvLyBJbiBjYXNlIG9mIEFycmF5LWxpa2Ugb2JqZWN0XG4gKiBjb25zdCBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7IC8vIGNoYW5nZSB0byBhcnJheVxuICogZm9yRWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3JFYWNoQXJyYXkob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaE93blByb3BlcnRpZXMob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4OTM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnRcbiAqIGluIHRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudFxuICogIDIpIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudFxuICogIDMpIFRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c3xOb2RlTGlzdH0gYXJyIFRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgZm9yRWFjaEFycmF5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoQXJyYXknO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaEFycmF5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2hBcnJheScpOyBcbiAqXG4gKiBsZXQgc3VtID0gMDtcbiAqXG4gKiBmb3JFYWNoQXJyYXkoWzEsMiwzXSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFyciwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgY29udGV4dCA9IGNvbnRleHQgfHwgbnVsbDtcblxuICBmb3IgKDsgaW5kZXggPCBsZW47IGluZGV4ICs9IDEpIHtcbiAgICBpZiAoaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBhcnJbaW5kZXhdLCBpbmRleCwgYXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTU2OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdCB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggcHJvcGVydHkgb2Ygb2JqZWN0IHdoaWNoIGFjdHVhbGx5IGV4aXN0LlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqICAyKSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAqICAzKSBUaGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlICBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBmb3JFYWNoT3duUHJvcGVydGllcyBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaE93blByb3BlcnRpZXMnO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaE93blByb3BlcnRpZXMgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaE93blByb3BlcnRpZXMnKTsgXG4gKlxuICogbGV0IHN1bSA9IDA7XG4gKlxuICogZm9yRWFjaE93blByb3BlcnRpZXMoe2E6MSxiOjIsYzozfSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaE93blByb3BlcnRpZXMob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICB2YXIga2V5O1xuXG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoT3duUHJvcGVydGllcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTkwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRyYW5zZm9ybSB0aGUgQXJyYXktbGlrZSBvYmplY3QgdG8gQXJyYXkuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGZvckVhY2hBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oODkzKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIEFycmF5LWxpa2Ugb2JqZWN0IHRvIEFycmF5LlxuICogSW4gbG93IElFIChiZWxvdyA4KSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwgaXMgbm90IHBlcmZlY3QuIFNvLCB0cnktY2F0Y2ggc3RhdGVtZW50IGlzIHVzZWQuXG4gKiBAcGFyYW0geyp9IGFycmF5TGlrZSBBcnJheS1saWtlIG9iamVjdFxuICogQHJldHVybnMge0FycmF5fSBBcnJheVxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgdG9BcnJheSBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vdG9BcnJheSc7IFxuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi90b0FycmF5Jyk7IFxuICpcbiAqIGNvbnN0IGFycmF5TGlrZSA9IHtcbiAqICAgMDogJ29uZScsXG4gKiAgIDE6ICd0d28nLFxuICogICAyOiAndGhyZWUnLFxuICogICAzOiAnZm91cicsXG4gKiAgIGxlbmd0aDogNFxuICogfTtcbiAqIGNvbnN0IHJlc3VsdCA9IHRvQXJyYXkoYXJyYXlMaWtlKTtcbiAqXG4gKiBhbGVydChyZXN1bHQgaW5zdGFuY2VvZiBBcnJheSk7IC8vIHRydWVcbiAqIGFsZXJ0KHJlc3VsdCk7IC8vIG9uZSx0d28sdGhyZWUsZm91clxuICovXG5mdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICB2YXIgYXJyO1xuICB0cnkge1xuICAgIGFyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhcnIgPSBbXTtcbiAgICBmb3JFYWNoQXJyYXkoYXJyYXlMaWtlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgYXJyLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NTU6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEdldCBldmVudCBjb2xsZWN0aW9uIGZvciBzcGVjaWZpYyBIVE1MIGVsZW1lbnRcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgRVZFTlRfS0VZID0gJ19mZUV2ZW50S2V5JztcblxuLyoqXG4gKiBHZXQgZXZlbnQgY29sbGVjdGlvbiBmb3Igc3BlY2lmaWMgSFRNTCBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gSFRNTCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGVcbiAqIEByZXR1cm5zIHthcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhZmVFdmVudChlbGVtZW50LCB0eXBlKSB7XG4gIHZhciBldmVudHMgPSBlbGVtZW50W0VWRU5UX0tFWV07XG4gIHZhciBoYW5kbGVycztcblxuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IGVsZW1lbnRbRVZFTlRfS0VZXSA9IHt9O1xuICB9XG5cbiAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcnMpIHtcbiAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXJzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVFdmVudDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQ5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFVuYmluZCBET00gZXZlbnRzXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTgpO1xudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5MCk7XG5cbnZhciBzYWZlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1NSk7XG5cbi8qKlxuICogVW5iaW5kIERPTSBldmVudHNcbiAqIElmIGEgaGFuZGxlciBmdW5jdGlvbiBpcyBub3QgcGFzc2VkLCByZW1vdmUgYWxsIGV2ZW50cyBvZiB0aGF0IHR5cGUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byB1bmJpbmQgZXZlbnRzXG4gKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgLSBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbUV2ZW50XG4gKiBAZXhhbXBsZVxuICogLy8gRm9sbG93aW5nIHRoZSBleGFtcGxlIG9mIGRvbUV2ZW50I29uXG4gKiBcbiAqIC8vIFVuYmluZCBvbmUgZXZlbnQgZnJvbSBhbiBlbGVtZW50LlxuICogb2ZmKGRpdiwgJ2NsaWNrJywgdG9nZ2xlKTtcbiAqIFxuICogLy8gVW5iaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGEgc2FtZSBoYW5kbGVyIGZyb20gbXVsdGlwbGUgZWxlbWVudHMgYXQgb25jZS5cbiAqIC8vIFVzZSBldmVudCBuYW1lcyBzcGxpdHRlZCBieSBhIHNwYWNlLlxuICogb2ZmKGVsZW1lbnQsICdtb3VzZWVudGVyIG1vdXNlbGVhdmUnLCBjaGFuZ2VDb2xvcik7XG4gKiBcbiAqIC8vIFVuYmluZCBtdWx0aXBsZSBldmVudHMgd2l0aCBkaWZmZXJlbnQgaGFuZGxlcnMgZnJvbSBhbiBlbGVtZW50IGF0IG9uY2UuXG4gKiAvLyBVc2UgYW4gb2JqZWN0IHdoaWNoIG9mIGtleSBpcyBhbiBldmVudCBuYW1lIGFuZCB2YWx1ZSBpcyBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gKiBvZmYoZGl2LCB7XG4gKiAgIGtleWRvd246IGhpZ2hsaWdodCxcbiAqICAga2V5dXA6IGRlaGlnaGxpZ2h0XG4gKiB9KTtcbiAqIFxuICogLy8gVW5iaW5kIGV2ZW50cyB3aXRob3V0IGhhbmRsZXJzLlxuICogb2ZmKGRpdiwgJ2RyYWcnKTtcbiAqL1xuZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGlmIChpc1N0cmluZyh0eXBlcykpIHtcbiAgICBmb3JFYWNoKHR5cGVzLnNwbGl0KC9cXHMrL2cpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2godHlwZXMsIGZ1bmN0aW9uKGZ1bmMsIHR5cGUpIHtcbiAgICB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBmdW5jKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVW5iaW5kIERPTSBldmVudHNcbiAqIElmIGEgaGFuZGxlciBmdW5jdGlvbiBpcyBub3QgcGFzc2VkLCByZW1vdmUgYWxsIGV2ZW50cyBvZiB0aGF0IHR5cGUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byB1bmJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBldmVudHMgPSBzYWZlRXZlbnQoZWxlbWVudCwgdHlwZSk7XG4gIHZhciBpbmRleDtcblxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCB0eXBlLCBpdGVtLndyYXBwZWRIYW5kbGVyKTtcbiAgICB9KTtcbiAgICBldmVudHMuc3BsaWNlKDAsIGV2ZW50cy5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihpdGVtLCBpZHgpIHtcbiAgICAgIGlmIChoYW5kbGVyID09PSBpdGVtLmhhbmRsZXIpIHtcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCB0eXBlLCBpdGVtLndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgaW5kZXggPSBpZHg7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gQW4gZWxlbWVudCB0byByZW1vdmUgYW4gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvZmY7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0ODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBCaW5kIERPTSBldmVudHNcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1OCk7XG52YXIgZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNjkwKTtcblxudmFyIHNhZmVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzU1KTtcblxuLyoqXG4gKiBCaW5kIERPTSBldmVudHMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBiaW5kIGV2ZW50c1xuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IHR5cGVzIC0gU3BhY2Ugc3BsaXR0ZWQgZXZlbnRzIG5hbWVzIG9yIGV2ZW50TmFtZTpoYW5kbGVyIG9iamVjdFxuICogQHBhcmFtIHsoZnVuY3Rpb258b2JqZWN0KX0gaGFuZGxlciAtIGhhbmRsZXIgZnVuY3Rpb24gb3IgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2RcbiAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gY29udGV4dCAtIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21FdmVudFxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGRpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICogXG4gKiAvLyBCaW5kIG9uZSBldmVudCB0byBhbiBlbGVtZW50LlxuICogb24oZGl2LCAnY2xpY2snLCB0b2dnbGUpO1xuICogXG4gKiAvLyBCaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGEgc2FtZSBoYW5kbGVyIHRvIG11bHRpcGxlIGVsZW1lbnRzIGF0IG9uY2UuXG4gKiAvLyBVc2UgZXZlbnQgbmFtZXMgc3BsaXR0ZWQgYnkgYSBzcGFjZS5cbiAqIG9uKGRpdiwgJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScsIGNoYW5nZUNvbG9yKTtcbiAqIFxuICogLy8gQmluZCBtdWx0aXBsZSBldmVudHMgd2l0aCBkaWZmZXJlbnQgaGFuZGxlcnMgdG8gYW4gZWxlbWVudCBhdCBvbmNlLlxuICogLy8gVXNlIGFuIG9iamVjdCB3aGljaCBvZiBrZXkgaXMgYW4gZXZlbnQgbmFtZSBhbmQgdmFsdWUgaXMgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICogb24oZGl2LCB7XG4gKiAgIGtleWRvd246IGhpZ2hsaWdodCxcbiAqICAga2V5dXA6IGRlaGlnaGxpZ2h0XG4gKiB9KTtcbiAqIFxuICogLy8gU2V0IGEgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gKiBjb25zdCBuYW1lID0gJ2dsb2JhbCc7XG4gKiBjb25zdCByZXBvc2l0b3J5ID0ge25hbWU6ICdDb2RlU25pcHBldCd9O1xuICogb24oZGl2LCAnZHJhZycsIGZ1bmN0aW9uKCkge1xuICogICBjb25zb2xlLmxvZyh0aGlzLm5hbWUpO1xuICogfSwgcmVwb3NpdG9yeSk7XG4gKiAvLyBSZXN1bHQgd2hlbiB5b3UgZHJhZyBhIGRpdjogXCJDb2RlU25pcHBldFwiXG4gKi9cbmZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gIGlmIChpc1N0cmluZyh0eXBlcykpIHtcbiAgICBmb3JFYWNoKHR5cGVzLnNwbGl0KC9cXHMrL2cpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBiaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoKHR5cGVzLCBmdW5jdGlvbihmdW5jLCB0eXBlKSB7XG4gICAgYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGhhbmRsZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBCaW5kIERPTSBldmVudHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZFxuICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSBjb250ZXh0IC0gY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBiaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSAtIGV2ZW50IG9iamVjdFxuICAgICAqL1xuICBmdW5jdGlvbiBldmVudEhhbmRsZXIoZSkge1xuICAgIGhhbmRsZXIuY2FsbChjb250ZXh0IHx8IGVsZW1lbnQsIGUgfHwgd2luZG93LmV2ZW50KTtcbiAgfVxuXG4gIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZWxlbWVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKCdhdHRhY2hFdmVudCcgaW4gZWxlbWVudCkge1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGV2ZW50SGFuZGxlcik7XG4gIH1cbiAgbWVtb3JpemVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGV2ZW50SGFuZGxlcik7XG59XG5cbi8qKlxuICogTWVtb3JpemUgRE9NIGV2ZW50IGhhbmRsZXIgZm9yIHVuYmluZGluZy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHVzZXIgcGFzc2VkIGF0IG9uKCkgdXNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB3cmFwcGVkSGFuZGxlciAtIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCB3cmFwcGVkIGJ5IGRvbWV2ZW50IGZvciBpbXBsZW1lbnRpbmcgc29tZSBmZWF0dXJlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWVtb3JpemVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIHdyYXBwZWRIYW5kbGVyKSB7XG4gIHZhciBldmVudHMgPSBzYWZlRXZlbnQoZWxlbWVudCwgdHlwZSk7XG4gIHZhciBleGlzdEluRXZlbnRzID0gZmFsc2U7XG5cbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgZXhpc3RJbkV2ZW50cyA9IHRydWU7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKCFleGlzdEluRXZlbnRzKSB7XG4gICAgZXZlbnRzLnB1c2goe1xuICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgIHdyYXBwZWRIYW5kbGVyOiB3cmFwcGVkSGFuZGxlclxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNldCBjbGFzc05hbWUgdmFsdWVcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIyKTtcbnZhciBpc1VuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5KTtcblxuLyoqXG4gKiBTZXQgY2xhc3NOYW1lIHZhbHVlXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0geyhzdHJpbmd8c3RyaW5nW10pfSBjc3NDbGFzcyAtIGNsYXNzIG5hbWVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDbGFzc05hbWUoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgY3NzQ2xhc3MgPSBpc0FycmF5KGNzc0NsYXNzKSA/IGNzc0NsYXNzLmpvaW4oJyAnKSA6IGNzc0NsYXNzO1xuXG4gIGNzc0NsYXNzID0gY3NzQ2xhc3MucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuICBpZiAoaXNVbmRlZmluZWQoZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCA9IGNzc0NsYXNzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENsYXNzTmFtZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFkZCBjc3MgY2xhc3MgdG8gZWxlbWVudFxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTApO1xudmFyIGluQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOCk7XG52YXIgZ2V0Q2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMik7XG52YXIgc2V0Q2xhc3NOYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbi8qKlxuICogZG9tVXRpbCBtb2R1bGVcbiAqIEBtb2R1bGUgZG9tVXRpbFxuICovXG5cbi8qKlxuICogQWRkIGNzcyBjbGFzcyB0byBlbGVtZW50XG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0gey4uLnN0cmluZ30gY3NzQ2xhc3MgLSBjc3MgY2xhc3NlcyB0byBhZGRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50KSB7XG4gIHZhciBjc3NDbGFzcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgdmFyIG5ld0NsYXNzID0gW107XG4gIHZhciBvcmlnaW47XG5cbiAgaWYgKGNsYXNzTGlzdCkge1xuICAgIGZvckVhY2goY3NzQ2xhc3MsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9yaWdpbiA9IGdldENsYXNzKGVsZW1lbnQpO1xuXG4gIGlmIChvcmlnaW4pIHtcbiAgICBjc3NDbGFzcyA9IFtdLmNvbmNhdChvcmlnaW4uc3BsaXQoL1xccysvKSwgY3NzQ2xhc3MpO1xuICB9XG5cbiAgZm9yRWFjaChjc3NDbGFzcywgZnVuY3Rpb24oY2xzKSB7XG4gICAgaWYgKGluQXJyYXkoY2xzLCBuZXdDbGFzcykgPCAwKSB7XG4gICAgICBuZXdDbGFzcy5wdXNoKGNscyk7XG4gICAgfVxuICB9KTtcblxuICBzZXRDbGFzc05hbWUoZWxlbWVudCwgbmV3Q2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZENsYXNzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2V0dGluZyBlbGVtZW50IHN0eWxlXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTgpO1xudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5MCk7XG5cbi8qKlxuICogU2V0dGluZyBlbGVtZW50IHN0eWxlXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIGVsZW1lbnQgdG8gc2V0dGluZyBzdHlsZVxuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IGtleSAtIHN0eWxlIHByb3AgbmFtZSBvciB7cHJvcDogdmFsdWV9IHBhaXIgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSAtIHN0eWxlIHZhbHVlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gY3NzKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblxuICBpZiAoaXNTdHJpbmcoa2V5KSkge1xuICAgIHN0eWxlW2tleV0gPSB2YWx1ZTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2goa2V5LCBmdW5jdGlvbih2LCBrKSB7XG4gICAgc3R5bGVba10gPSB2O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjc3M7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkwMjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBHZXQgSFRNTCBlbGVtZW50J3MgZGVzaWduIGNsYXNzZXMuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGlzVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjkpO1xuXG4vKipcbiAqIEdldCBIVE1MIGVsZW1lbnQncyBkZXNpZ24gY2xhc3Nlcy5cbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IHRhcmdldCBlbGVtZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBlbGVtZW50IGNzcyBjbGFzcyBuYW1lXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xhc3MoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q2xhc3M7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcxNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayBlbGVtZW50IGhhcyBzcGVjaWZpYyBjc3MgY2xhc3NcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaW5BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oOTI4KTtcbnZhciBnZXRDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAyKTtcblxuLyoqXG4gKiBDaGVjayBlbGVtZW50IGhhcyBzcGVjaWZpYyBjc3MgY2xhc3NcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NDbGFzcyAtIGNzcyBjbGFzc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgdmFyIG9yaWdpbjtcblxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpO1xuICB9XG5cbiAgb3JpZ2luID0gZ2V0Q2xhc3MoZWxlbWVudCkuc3BsaXQoL1xccysvKTtcblxuICByZXR1cm4gaW5BcnJheShjc3NDbGFzcywgb3JpZ2luKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0NsYXNzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzE6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgZWxlbWVudCBtYXRjaCBzZWxlY3RvclxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpbkFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjgpO1xudmFyIHRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MCk7XG5cbnZhciBlbFByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG52YXIgbWF0Y2hTZWxlY3RvciA9IGVsUHJvdG8ubWF0Y2hlcyB8fFxuICAgIGVsUHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZWxQcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBlbFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudDtcblxuICAgICAgcmV0dXJuIGluQXJyYXkodGhpcywgdG9BcnJheShkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpKSA+IC0xO1xuICAgIH07XG5cbi8qKlxuICogQ2hlY2sgZWxlbWVudCBtYXRjaCBzZWxlY3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIHNlbGVjdG9yIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXMgc2VsZWN0b3IgbWF0Y2hlZCB0byBlbGVtZW50P1xuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIG1hdGNoU2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDYyOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlbW92ZSBjc3MgY2xhc3MgZnJvbSBlbGVtZW50XG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGZvckVhY2hBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oODkzKTtcbnZhciBpbkFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjgpO1xudmFyIGdldENsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDIpO1xudmFyIHNldENsYXNzTmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG4vKipcbiAqIFJlbW92ZSBjc3MgY2xhc3MgZnJvbSBlbGVtZW50XG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0gey4uLnN0cmluZ30gY3NzQ2xhc3MgLSBjc3MgY2xhc3NlcyB0byByZW1vdmVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50KSB7XG4gIHZhciBjc3NDbGFzcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgdmFyIG9yaWdpbiwgbmV3Q2xhc3M7XG5cbiAgaWYgKGNsYXNzTGlzdCkge1xuICAgIGZvckVhY2hBcnJheShjc3NDbGFzcywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9yaWdpbiA9IGdldENsYXNzKGVsZW1lbnQpLnNwbGl0KC9cXHMrLyk7XG4gIG5ld0NsYXNzID0gW107XG4gIGZvckVhY2hBcnJheShvcmlnaW4sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoaW5BcnJheShuYW1lLCBjc3NDbGFzcykgPCAwKSB7XG4gICAgICBuZXdDbGFzcy5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2V0Q2xhc3NOYW1lKGVsZW1lbnQsIG5ld0NsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZW1vdmVDbGFzcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTY5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBFeHRlbmQgdGhlIHRhcmdldCBvYmplY3QgZnJvbSBvdGhlciBvYmplY3RzLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbi8qKlxuICogQG1vZHVsZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEV4dGVuZCB0aGUgdGFyZ2V0IG9iamVjdCBmcm9tIG90aGVyIG9iamVjdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IHRoYXQgd2lsbCBiZSBleHRlbmRlZFxuICogQHBhcmFtIHsuLi5vYmplY3R9IG9iamVjdHMgLSBPYmplY3RzIGFzIHNvdXJjZXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IEV4dGVuZGVkIG9iamVjdFxuICogQG1lbWJlcm9mIG1vZHVsZTpvYmplY3RcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgb2JqZWN0cykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHNvdXJjZSwgcHJvcCwgaSwgbGVuO1xuXG4gIGZvciAoaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNTQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWVzdCBpbWFnZSBwaW5nLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBmb3JFYWNoT3duUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2KTtcblxuLyoqXG4gKiBAbW9kdWxlIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaW1hZ2UgcGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgdXJsIGZvciBwaW5nIHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFja2luZ0luZm8gaW5mb3MgZm9yIG1ha2UgcXVlcnkgc3RyaW5nXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnJlcXVlc3RcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBpbWFnZVBpbmcgZnJvbSAndHVpLWNvZGUtc25pcHBldC9yZXF1ZXN0L2ltYWdlUGluZyc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBpbWFnZVBpbmcgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L3JlcXVlc3QvaW1hZ2VQaW5nJyk7XG4gKlxuICogaW1hZ2VQaW5nKCdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9jb2xsZWN0Jywge1xuICogICB2OiAxLFxuICogICB0OiAnZXZlbnQnLFxuICogICB0aWQ6ICd0cmFja2luZ2lkJyxcbiAqICAgY2lkOiAnY2lkJyxcbiAqICAgZHA6ICdkcCcsXG4gKiAgIGRoOiAnZGgnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gaW1hZ2VQaW5nKHVybCwgdHJhY2tpbmdJbmZvKSB7XG4gIHZhciB0cmFja2luZ0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gJyc7XG4gIGZvckVhY2hPd25Qcm9wZXJ0aWVzKHRyYWNraW5nSW5mbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHF1ZXJ5U3RyaW5nICs9ICcmJyArIGtleSArICc9JyArIHZhbHVlO1xuICB9KTtcbiAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zdWJzdHJpbmcoMSk7XG5cbiAgdHJhY2tpbmdFbGVtZW50LnNyYyA9IHVybCArICc/JyArIHF1ZXJ5U3RyaW5nO1xuXG4gIHRyYWNraW5nRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRyYWNraW5nRWxlbWVudCk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodHJhY2tpbmdFbGVtZW50KTtcblxuICByZXR1cm4gdHJhY2tpbmdFbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGltYWdlUGluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzkxOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlbmQgaG9zdG5hbWUgb24gRE9NQ29udGVudExvYWRlZC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOSk7XG52YXIgaW1hZ2VQaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTQpO1xuXG52YXIgbXM3ZGF5cyA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkYXRlIGhhcyBwYXNzZWQgNyBkYXlzXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0ZSAtIG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0V4cGlyZWQoZGF0ZSkge1xuICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgcmV0dXJuIG5vdyAtIGRhdGUgPiBtczdkYXlzO1xufVxuXG4vKipcbiAqIFNlbmQgaG9zdG5hbWUgb24gRE9NQ29udGVudExvYWRlZC5cbiAqIFRvIHByZXZlbnQgaG9zdG5hbWUgc2V0IHR1aS51c2FnZVN0YXRpc3RpY3MgdG8gZmFsc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwTmFtZSAtIGFwcGxpY2F0aW9uIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja2luZ0lkIC0gR0EgdHJhY2tpbmcgSURcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gc2VuZEhvc3RuYW1lKGFwcE5hbWUsIHRyYWNraW5nSWQpIHtcbiAgdmFyIHVybCA9ICdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9jb2xsZWN0JztcbiAgdmFyIGhvc3RuYW1lID0gbG9jYXRpb24uaG9zdG5hbWU7XG4gIHZhciBoaXRUeXBlID0gJ2V2ZW50JztcbiAgdmFyIGV2ZW50Q2F0ZWdvcnkgPSAndXNlJztcbiAgdmFyIGFwcGxpY2F0aW9uS2V5Rm9yU3RvcmFnZSA9ICdUT0FTVCBVSSAnICsgYXBwTmFtZSArICcgZm9yICcgKyBob3N0bmFtZSArICc6IFN0YXRpc3RpY3MnO1xuICB2YXIgZGF0ZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShhcHBsaWNhdGlvbktleUZvclN0b3JhZ2UpO1xuXG4gIC8vIHNraXAgaWYgdGhlIGZsYWcgaXMgZGVmaW5lZCBhbmQgaXMgc2V0IHRvIGZhbHNlIGV4cGxpY2l0bHlcbiAgaWYgKCFpc1VuZGVmaW5lZCh3aW5kb3cudHVpKSAmJiB3aW5kb3cudHVpLnVzYWdlU3RhdGlzdGljcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBza2lwIGlmIG5vdCBwYXNzIHNldmVuIGRheXMgb2xkXG4gIGlmIChkYXRlICYmICFpc0V4cGlyZWQoZGF0ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oYXBwbGljYXRpb25LZXlGb3JTdG9yYWdlLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBpbWFnZVBpbmcodXJsLCB7XG4gICAgICAgIHY6IDEsXG4gICAgICAgIHQ6IGhpdFR5cGUsXG4gICAgICAgIHRpZDogdHJhY2tpbmdJZCxcbiAgICAgICAgY2lkOiBob3N0bmFtZSxcbiAgICAgICAgZHA6IGhvc3RuYW1lLFxuICAgICAgICBkaDogYXBwTmFtZSxcbiAgICAgICAgZWw6IGFwcE5hbWUsXG4gICAgICAgIGVjOiBldmVudENhdGVnb3J5XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIDEwMDApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbmRIb3N0bmFtZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzIyOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQXJyYXksIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgYXJyYXkgaW5zdGFuY2U/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY1OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGV4aXN0aW5nIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOSk7XG52YXIgaXNOdWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzQpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGV4aXN0aW5nIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBub3QgbnVsbCBhbmQgbm90IHVuZGVmaW5lZCwgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSBwYXJhbSAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBleGlzdHk/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBpc0V4aXN0eSBmcm9tICd0dWktY29kZS1zbmlwcGV0L3R5cGUvaXNFeGlzdHknKTtcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGlzRXhpc3R5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC90eXBlL2lzRXhpc3R5Jyk7XG4gKlxuICogaXNFeGlzdHkoJycpOyAvL3RydWVcbiAqIGlzRXhpc3R5KDApOyAvL3RydWVcbiAqIGlzRXhpc3R5KFtdKTsgLy90cnVlXG4gKiBpc0V4aXN0eSh7fSk7IC8vdHJ1ZVxuICogaXNFeGlzdHkobnVsbCk7IC8vZmFsc2VcbiAqIGlzRXhpc3R5KHVuZGVmaW5lZCk7IC8vZmFsc2VcbiovXG5mdW5jdGlvbiBpc0V4aXN0eShwYXJhbSkge1xuICByZXR1cm4gIWlzVW5kZWZpbmVkKHBhcmFtKSAmJiAhaXNOdWxsKHBhcmFtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0V4aXN0eTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDA0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGZhbHN5IG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNUcnV0aHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5MCk7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZmFsc3kgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBmYWxzeT9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc0ZhbHN5KG9iaikge1xuICByZXR1cm4gIWlzVHJ1dGh5KG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGYWxzeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjk0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24sIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgZnVuY3Rpb24/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbnVsbCBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBudWxsIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZShhcmd1bWVudHNbMF0pIGlzIG51bGwsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIG51bGw/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNOdWxsKG9iaikge1xuICByZXR1cm4gb2JqID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVsbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzU4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZyBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZyBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBzdHJpbmcsIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgc3RyaW5nP1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgb2JqIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3OTA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdHJ1dGh5IG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNFeGlzdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB0cnV0aHkgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG5vdCBudWxsIG9yIG5vdCB1bmRlZmluZWQgb3Igbm90IGZhbHNlLCByZXR1cm5zIHRydWUuXG4gKiAoSXQgcmVnYXJkcyAwIGFzIHRydWUpXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyB0cnV0aHk/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNUcnV0aHkob2JqKSB7XG4gIHJldHVybiBpc0V4aXN0eShvYmopICYmIG9iaiAhPT0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUcnV0aHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyOTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyB1bmRlZmluZWQ/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZmluZWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDc5X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0ODE6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180ODFfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIDQzOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDNfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIDgxNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzgxNF9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMzExOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzExX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0ICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0XHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcbi8qKioqKiovIFx0XHRcdHRyeSB7XG4vKioqKioqLyBcdFx0XHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuLyoqKioqKi8gXHRcdFx0fSBjYXRjaCAoZSkge1xuLyoqKioqKi8gXHRcdFx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fSkoKTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsgfVxuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpbiBzdHJpY3QgbW9kZS5cbiFmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBcImRlZmF1bHRcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGluZGV4Vmlld2VyOyB9XG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgdHNsaWJfZXM2X2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdHNsaWJfZXM2X2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiB0c2xpYl9lczZfYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbGlicy90b2FzdG1hcmsvZGlzdC9lc20vaW5kZXguanNcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBlc21fZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZXNtX2V4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKVxuICAgICAgICAgICAgICAgIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBlc21fZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5mdW5jdGlvbiBlc21fZXh0ZW5kcyhkLCBiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgIGVzbV9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBlc21fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICAgIGVzbV9hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIGVzbV9hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBlc21fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgICAgIGlmICghYXIpXG4gICAgICAgICAgICAgICAgICAgIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcbnZhciBlbmNvZGVDYWNoZSA9IHt9O1xuLy8gQ3JlYXRlIGEgbG9va3VwIGFycmF5IHdoZXJlIGFueXRoaW5nIGJ1dCBjaGFyYWN0ZXJzIGluIGBjaGFyc2Agc3RyaW5nXG4vLyBhbmQgYWxwaGFudW1lcmljIGNoYXJzIGlzIHBlcmNlbnQtZW5jb2RlZC5cbi8vXG5mdW5jdGlvbiBnZXRFbmNvZGVDYWNoZShleGNsdWRlKSB7XG4gICAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICAgICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICBpZiAoL15bMC05YS16XSQvaS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgLy8gYWx3YXlzIGFsbG93IHVuZW5jb2RlZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgICAgICAgY2FjaGUucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWNoZS5wdXNoKCclJyArICgnMCcgKyBpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG59XG4vLyBFbmNvZGUgdW5zYWZlIGNoYXJhY3RlcnMgd2l0aCBwZXJjZW50LWVuY29kaW5nLCBza2lwcGluZyBhbHJlYWR5XG4vLyBlbmNvZGVkIHNlcXVlbmNlcy5cbi8vXG4vLyAgLSBzdHJpbmcgICAgICAgLSBzdHJpbmcgdG8gZW5jb2RlXG4vLyAgLSBleGNsdWRlICAgICAgLSBsaXN0IG9mIGNoYXJhY3RlcnMgdG8gaWdub3JlIChpbiBhZGRpdGlvbiB0byBhLXpBLVowLTkpXG4vLyAgLSBrZWVwRXNjYXBlZCAgLSBkb24ndCBlbmNvZGUgJyUnIGluIGEgY29ycmVjdCBlc2NhcGUgc2VxdWVuY2UgKGRlZmF1bHQ6IHRydWUpXG4vL1xuZnVuY3Rpb24gZW5jb2RlJDEoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICAgIHZhciBpLCBsLCBjb2RlLCBuZXh0Q29kZSwgY2FjaGUsIHJlc3VsdCA9ICcnO1xuICAgIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gZW5jb2RlKHN0cmluZywga2VlcEVzY2FwZWQpXG4gICAgICAgIGtlZXBFc2NhcGVkID0gZXhjbHVkZTtcbiAgICAgICAgZXhjbHVkZSA9IGVuY29kZSQxLmRlZmF1bHRDaGFycztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAga2VlcEVzY2FwZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUgPT09IDB4MjUgLyogJSAqLyAmJiBpICsgMiA8IGwpIHtcbiAgICAgICAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2FjaGVbY29kZV07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REJGRiAmJiBpICsgMSA8IGwpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dENvZGUgPj0gMHhEQzAwICYmIG5leHRDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmVuY29kZSQxLmRlZmF1bHRDaGFycyA9IFwiOy8/OkAmPSskLC1fLiF+KicoKSNcIjtcbmVuY29kZSQxLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcbnZhciBlbmNvZGVfMSA9IGVuY29kZSQxO1xudmFyIGxpYiA9IHt9O1xudmFyIGRlY29kZSA9IHt9O1xudmFyIEFhY3V0ZSQxID0gXCLDgVwiO1xudmFyIGFhY3V0ZSQxID0gXCLDoVwiO1xudmFyIEFicmV2ZSA9IFwixIJcIjtcbnZhciBhYnJldmUgPSBcIsSDXCI7XG52YXIgYWMgPSBcIuKIvlwiO1xudmFyIGFjZCA9IFwi4oi/XCI7XG52YXIgYWNFID0gXCLiiL7Ms1wiO1xudmFyIEFjaXJjJDEgPSBcIsOCXCI7XG52YXIgYWNpcmMkMSA9IFwiw6JcIjtcbnZhciBhY3V0ZSQxID0gXCLCtFwiO1xudmFyIEFjeSA9IFwi0JBcIjtcbnZhciBhY3kgPSBcItCwXCI7XG52YXIgQUVsaWckMSA9IFwiw4ZcIjtcbnZhciBhZWxpZyQxID0gXCLDplwiO1xudmFyIGFmID0gXCLigaFcIjtcbnZhciBBZnIgPSBcIvCdlIRcIjtcbnZhciBhZnIgPSBcIvCdlJ5cIjtcbnZhciBBZ3JhdmUkMSA9IFwiw4BcIjtcbnZhciBhZ3JhdmUkMSA9IFwiw6BcIjtcbnZhciBhbGVmc3ltID0gXCLihLVcIjtcbnZhciBhbGVwaCA9IFwi4oS1XCI7XG52YXIgQWxwaGEgPSBcIs6RXCI7XG52YXIgYWxwaGEgPSBcIs6xXCI7XG52YXIgQW1hY3IgPSBcIsSAXCI7XG52YXIgYW1hY3IgPSBcIsSBXCI7XG52YXIgYW1hbGcgPSBcIuKov1wiO1xudmFyIGFtcCQyID0gXCImXCI7XG52YXIgQU1QJDEgPSBcIiZcIjtcbnZhciBhbmRhbmQgPSBcIuKplVwiO1xudmFyIEFuZCA9IFwi4qmTXCI7XG52YXIgYW5kID0gXCLiiKdcIjtcbnZhciBhbmRkID0gXCLiqZxcIjtcbnZhciBhbmRzbG9wZSA9IFwi4qmYXCI7XG52YXIgYW5kdiA9IFwi4qmaXCI7XG52YXIgYW5nID0gXCLiiKBcIjtcbnZhciBhbmdlID0gXCLipqRcIjtcbnZhciBhbmdsZSA9IFwi4oigXCI7XG52YXIgYW5nbXNkYWEgPSBcIuKmqFwiO1xudmFyIGFuZ21zZGFiID0gXCLipqlcIjtcbnZhciBhbmdtc2RhYyA9IFwi4qaqXCI7XG52YXIgYW5nbXNkYWQgPSBcIuKmq1wiO1xudmFyIGFuZ21zZGFlID0gXCLipqxcIjtcbnZhciBhbmdtc2RhZiA9IFwi4qatXCI7XG52YXIgYW5nbXNkYWcgPSBcIuKmrlwiO1xudmFyIGFuZ21zZGFoID0gXCLipq9cIjtcbnZhciBhbmdtc2QgPSBcIuKIoVwiO1xudmFyIGFuZ3J0ID0gXCLiiJ9cIjtcbnZhciBhbmdydHZiID0gXCLiir5cIjtcbnZhciBhbmdydHZiZCA9IFwi4qadXCI7XG52YXIgYW5nc3BoID0gXCLiiKJcIjtcbnZhciBhbmdzdCA9IFwiw4VcIjtcbnZhciBhbmd6YXJyID0gXCLijbxcIjtcbnZhciBBb2dvbiA9IFwixIRcIjtcbnZhciBhb2dvbiA9IFwixIVcIjtcbnZhciBBb3BmID0gXCLwnZS4XCI7XG52YXIgYW9wZiA9IFwi8J2VklwiO1xudmFyIGFwYWNpciA9IFwi4qmvXCI7XG52YXIgYXAgPSBcIuKJiFwiO1xudmFyIGFwRSA9IFwi4qmwXCI7XG52YXIgYXBlID0gXCLiiYpcIjtcbnZhciBhcGlkID0gXCLiiYtcIjtcbnZhciBhcG9zJDEgPSBcIidcIjtcbnZhciBBcHBseUZ1bmN0aW9uID0gXCLigaFcIjtcbnZhciBhcHByb3ggPSBcIuKJiFwiO1xudmFyIGFwcHJveGVxID0gXCLiiYpcIjtcbnZhciBBcmluZyQxID0gXCLDhVwiO1xudmFyIGFyaW5nJDEgPSBcIsOlXCI7XG52YXIgQXNjciA9IFwi8J2SnFwiO1xudmFyIGFzY3IgPSBcIvCdkrZcIjtcbnZhciBBc3NpZ24gPSBcIuKJlFwiO1xudmFyIGFzdCA9IFwiKlwiO1xudmFyIGFzeW1wID0gXCLiiYhcIjtcbnZhciBhc3ltcGVxID0gXCLiiY1cIjtcbnZhciBBdGlsZGUkMSA9IFwiw4NcIjtcbnZhciBhdGlsZGUkMSA9IFwiw6NcIjtcbnZhciBBdW1sJDEgPSBcIsOEXCI7XG52YXIgYXVtbCQxID0gXCLDpFwiO1xudmFyIGF3Y29uaW50ID0gXCLiiLNcIjtcbnZhciBhd2ludCA9IFwi4qiRXCI7XG52YXIgYmFja2NvbmcgPSBcIuKJjFwiO1xudmFyIGJhY2tlcHNpbG9uID0gXCLPtlwiO1xudmFyIGJhY2twcmltZSA9IFwi4oC1XCI7XG52YXIgYmFja3NpbSA9IFwi4oi9XCI7XG52YXIgYmFja3NpbWVxID0gXCLii41cIjtcbnZhciBCYWNrc2xhc2ggPSBcIuKIllwiO1xudmFyIEJhcnYgPSBcIuKrp1wiO1xudmFyIGJhcnZlZSA9IFwi4oq9XCI7XG52YXIgYmFyd2VkID0gXCLijIVcIjtcbnZhciBCYXJ3ZWQgPSBcIuKMhlwiO1xudmFyIGJhcndlZGdlID0gXCLijIVcIjtcbnZhciBiYnJrID0gXCLijrVcIjtcbnZhciBiYnJrdGJyayA9IFwi4o62XCI7XG52YXIgYmNvbmcgPSBcIuKJjFwiO1xudmFyIEJjeSA9IFwi0JFcIjtcbnZhciBiY3kgPSBcItCxXCI7XG52YXIgYmRxdW8gPSBcIuKAnlwiO1xudmFyIGJlY2F1cyA9IFwi4oi1XCI7XG52YXIgYmVjYXVzZSA9IFwi4oi1XCI7XG52YXIgQmVjYXVzZSA9IFwi4oi1XCI7XG52YXIgYmVtcHR5diA9IFwi4qawXCI7XG52YXIgYmVwc2kgPSBcIs+2XCI7XG52YXIgYmVybm91ID0gXCLihKxcIjtcbnZhciBCZXJub3VsbGlzID0gXCLihKxcIjtcbnZhciBCZXRhID0gXCLOklwiO1xudmFyIGJldGEgPSBcIs6yXCI7XG52YXIgYmV0aCA9IFwi4oS2XCI7XG52YXIgYmV0d2VlbiA9IFwi4omsXCI7XG52YXIgQmZyID0gXCLwnZSFXCI7XG52YXIgYmZyID0gXCLwnZSfXCI7XG52YXIgYmlnY2FwID0gXCLii4JcIjtcbnZhciBiaWdjaXJjID0gXCLil69cIjtcbnZhciBiaWdjdXAgPSBcIuKLg1wiO1xudmFyIGJpZ29kb3QgPSBcIuKogFwiO1xudmFyIGJpZ29wbHVzID0gXCLiqIFcIjtcbnZhciBiaWdvdGltZXMgPSBcIuKoglwiO1xudmFyIGJpZ3NxY3VwID0gXCLiqIZcIjtcbnZhciBiaWdzdGFyID0gXCLimIVcIjtcbnZhciBiaWd0cmlhbmdsZWRvd24gPSBcIuKWvVwiO1xudmFyIGJpZ3RyaWFuZ2xldXAgPSBcIuKWs1wiO1xudmFyIGJpZ3VwbHVzID0gXCLiqIRcIjtcbnZhciBiaWd2ZWUgPSBcIuKLgVwiO1xudmFyIGJpZ3dlZGdlID0gXCLii4BcIjtcbnZhciBia2Fyb3cgPSBcIuKkjVwiO1xudmFyIGJsYWNrbG96ZW5nZSA9IFwi4qerXCI7XG52YXIgYmxhY2tzcXVhcmUgPSBcIuKWqlwiO1xudmFyIGJsYWNrdHJpYW5nbGUgPSBcIuKWtFwiO1xudmFyIGJsYWNrdHJpYW5nbGVkb3duID0gXCLilr5cIjtcbnZhciBibGFja3RyaWFuZ2xlbGVmdCA9IFwi4peCXCI7XG52YXIgYmxhY2t0cmlhbmdsZXJpZ2h0ID0gXCLilrhcIjtcbnZhciBibGFuayA9IFwi4pCjXCI7XG52YXIgYmxrMTIgPSBcIuKWklwiO1xudmFyIGJsazE0ID0gXCLilpFcIjtcbnZhciBibGszNCA9IFwi4paTXCI7XG52YXIgYmxvY2sgPSBcIuKWiFwiO1xudmFyIGJuZSA9IFwiPeKDpVwiO1xudmFyIGJuZXF1aXYgPSBcIuKJoeKDpVwiO1xudmFyIGJOb3QgPSBcIuKrrVwiO1xudmFyIGJub3QgPSBcIuKMkFwiO1xudmFyIEJvcGYgPSBcIvCdlLlcIjtcbnZhciBib3BmID0gXCLwnZWTXCI7XG52YXIgYm90ID0gXCLiiqVcIjtcbnZhciBib3R0b20gPSBcIuKKpVwiO1xudmFyIGJvd3RpZSA9IFwi4ouIXCI7XG52YXIgYm94Ym94ID0gXCLip4lcIjtcbnZhciBib3hkbCA9IFwi4pSQXCI7XG52YXIgYm94ZEwgPSBcIuKVlVwiO1xudmFyIGJveERsID0gXCLilZZcIjtcbnZhciBib3hETCA9IFwi4pWXXCI7XG52YXIgYm94ZHIgPSBcIuKUjFwiO1xudmFyIGJveGRSID0gXCLilZJcIjtcbnZhciBib3hEciA9IFwi4pWTXCI7XG52YXIgYm94RFIgPSBcIuKVlFwiO1xudmFyIGJveGggPSBcIuKUgFwiO1xudmFyIGJveEggPSBcIuKVkFwiO1xudmFyIGJveGhkID0gXCLilKxcIjtcbnZhciBib3hIZCA9IFwi4pWkXCI7XG52YXIgYm94aEQgPSBcIuKVpVwiO1xudmFyIGJveEhEID0gXCLilaZcIjtcbnZhciBib3hodSA9IFwi4pS0XCI7XG52YXIgYm94SHUgPSBcIuKVp1wiO1xudmFyIGJveGhVID0gXCLilahcIjtcbnZhciBib3hIVSA9IFwi4pWpXCI7XG52YXIgYm94bWludXMgPSBcIuKKn1wiO1xudmFyIGJveHBsdXMgPSBcIuKKnlwiO1xudmFyIGJveHRpbWVzID0gXCLiiqBcIjtcbnZhciBib3h1bCA9IFwi4pSYXCI7XG52YXIgYm94dUwgPSBcIuKVm1wiO1xudmFyIGJveFVsID0gXCLilZxcIjtcbnZhciBib3hVTCA9IFwi4pWdXCI7XG52YXIgYm94dXIgPSBcIuKUlFwiO1xudmFyIGJveHVSID0gXCLilZhcIjtcbnZhciBib3hVciA9IFwi4pWZXCI7XG52YXIgYm94VVIgPSBcIuKVmlwiO1xudmFyIGJveHYgPSBcIuKUglwiO1xudmFyIGJveFYgPSBcIuKVkVwiO1xudmFyIGJveHZoID0gXCLilLxcIjtcbnZhciBib3h2SCA9IFwi4pWqXCI7XG52YXIgYm94VmggPSBcIuKVq1wiO1xudmFyIGJveFZIID0gXCLilaxcIjtcbnZhciBib3h2bCA9IFwi4pSkXCI7XG52YXIgYm94dkwgPSBcIuKVoVwiO1xudmFyIGJveFZsID0gXCLilaJcIjtcbnZhciBib3hWTCA9IFwi4pWjXCI7XG52YXIgYm94dnIgPSBcIuKUnFwiO1xudmFyIGJveHZSID0gXCLilZ5cIjtcbnZhciBib3hWciA9IFwi4pWfXCI7XG52YXIgYm94VlIgPSBcIuKVoFwiO1xudmFyIGJwcmltZSA9IFwi4oC1XCI7XG52YXIgYnJldmUgPSBcIsuYXCI7XG52YXIgQnJldmUgPSBcIsuYXCI7XG52YXIgYnJ2YmFyJDEgPSBcIsKmXCI7XG52YXIgYnNjciA9IFwi8J2St1wiO1xudmFyIEJzY3IgPSBcIuKErFwiO1xudmFyIGJzZW1pID0gXCLigY9cIjtcbnZhciBic2ltID0gXCLiiL1cIjtcbnZhciBic2ltZSA9IFwi4ouNXCI7XG52YXIgYnNvbGIgPSBcIuKnhVwiO1xudmFyIGJzb2wgPSBcIlxcXFxcIjtcbnZhciBic29saHN1YiA9IFwi4p+IXCI7XG52YXIgYnVsbCA9IFwi4oCiXCI7XG52YXIgYnVsbGV0ID0gXCLigKJcIjtcbnZhciBidW1wID0gXCLiiY5cIjtcbnZhciBidW1wRSA9IFwi4qquXCI7XG52YXIgYnVtcGUgPSBcIuKJj1wiO1xudmFyIEJ1bXBlcSA9IFwi4omOXCI7XG52YXIgYnVtcGVxID0gXCLiiY9cIjtcbnZhciBDYWN1dGUgPSBcIsSGXCI7XG52YXIgY2FjdXRlID0gXCLEh1wiO1xudmFyIGNhcGFuZCA9IFwi4qmEXCI7XG52YXIgY2FwYnJjdXAgPSBcIuKpiVwiO1xudmFyIGNhcGNhcCA9IFwi4qmLXCI7XG52YXIgY2FwID0gXCLiiKlcIjtcbnZhciBDYXAgPSBcIuKLklwiO1xudmFyIGNhcGN1cCA9IFwi4qmHXCI7XG52YXIgY2FwZG90ID0gXCLiqYBcIjtcbnZhciBDYXBpdGFsRGlmZmVyZW50aWFsRCA9IFwi4oWFXCI7XG52YXIgY2FwcyA9IFwi4oip77iAXCI7XG52YXIgY2FyZXQgPSBcIuKBgVwiO1xudmFyIGNhcm9uID0gXCLLh1wiO1xudmFyIENheWxleXMgPSBcIuKErVwiO1xudmFyIGNjYXBzID0gXCLiqY1cIjtcbnZhciBDY2Fyb24gPSBcIsSMXCI7XG52YXIgY2Nhcm9uID0gXCLEjVwiO1xudmFyIENjZWRpbCQxID0gXCLDh1wiO1xudmFyIGNjZWRpbCQxID0gXCLDp1wiO1xudmFyIENjaXJjID0gXCLEiFwiO1xudmFyIGNjaXJjID0gXCLEiVwiO1xudmFyIENjb25pbnQgPSBcIuKIsFwiO1xudmFyIGNjdXBzID0gXCLiqYxcIjtcbnZhciBjY3Vwc3NtID0gXCLiqZBcIjtcbnZhciBDZG90ID0gXCLEilwiO1xudmFyIGNkb3QgPSBcIsSLXCI7XG52YXIgY2VkaWwkMSA9IFwiwrhcIjtcbnZhciBDZWRpbGxhID0gXCLCuFwiO1xudmFyIGNlbXB0eXYgPSBcIuKmslwiO1xudmFyIGNlbnQkMSA9IFwiwqJcIjtcbnZhciBjZW50ZXJkb3QgPSBcIsK3XCI7XG52YXIgQ2VudGVyRG90ID0gXCLCt1wiO1xudmFyIGNmciA9IFwi8J2UoFwiO1xudmFyIENmciA9IFwi4oStXCI7XG52YXIgQ0hjeSA9IFwi0KdcIjtcbnZhciBjaGN5ID0gXCLRh1wiO1xudmFyIGNoZWNrID0gXCLinJNcIjtcbnZhciBjaGVja21hcmsgPSBcIuKck1wiO1xudmFyIENoaSA9IFwizqdcIjtcbnZhciBjaGkgPSBcIs+HXCI7XG52YXIgY2lyYyA9IFwiy4ZcIjtcbnZhciBjaXJjZXEgPSBcIuKJl1wiO1xudmFyIGNpcmNsZWFycm93bGVmdCA9IFwi4oa6XCI7XG52YXIgY2lyY2xlYXJyb3dyaWdodCA9IFwi4oa7XCI7XG52YXIgY2lyY2xlZGFzdCA9IFwi4oqbXCI7XG52YXIgY2lyY2xlZGNpcmMgPSBcIuKKmlwiO1xudmFyIGNpcmNsZWRkYXNoID0gXCLiip1cIjtcbnZhciBDaXJjbGVEb3QgPSBcIuKKmVwiO1xudmFyIGNpcmNsZWRSID0gXCLCrlwiO1xudmFyIGNpcmNsZWRTID0gXCLik4hcIjtcbnZhciBDaXJjbGVNaW51cyA9IFwi4oqWXCI7XG52YXIgQ2lyY2xlUGx1cyA9IFwi4oqVXCI7XG52YXIgQ2lyY2xlVGltZXMgPSBcIuKKl1wiO1xudmFyIGNpciA9IFwi4peLXCI7XG52YXIgY2lyRSA9IFwi4qeDXCI7XG52YXIgY2lyZSA9IFwi4omXXCI7XG52YXIgY2lyZm5pbnQgPSBcIuKokFwiO1xudmFyIGNpcm1pZCA9IFwi4quvXCI7XG52YXIgY2lyc2NpciA9IFwi4qeCXCI7XG52YXIgQ2xvY2t3aXNlQ29udG91ckludGVncmFsID0gXCLiiLJcIjtcbnZhciBDbG9zZUN1cmx5RG91YmxlUXVvdGUgPSBcIuKAnVwiO1xudmFyIENsb3NlQ3VybHlRdW90ZSA9IFwi4oCZXCI7XG52YXIgY2x1YnMgPSBcIuKZo1wiO1xudmFyIGNsdWJzdWl0ID0gXCLimaNcIjtcbnZhciBjb2xvbiA9IFwiOlwiO1xudmFyIENvbG9uID0gXCLiiLdcIjtcbnZhciBDb2xvbmUgPSBcIuKptFwiO1xudmFyIGNvbG9uZSA9IFwi4omUXCI7XG52YXIgY29sb25lcSA9IFwi4omUXCI7XG52YXIgY29tbWEgPSBcIixcIjtcbnZhciBjb21tYXQgPSBcIkBcIjtcbnZhciBjb21wID0gXCLiiIFcIjtcbnZhciBjb21wZm4gPSBcIuKImFwiO1xudmFyIGNvbXBsZW1lbnQgPSBcIuKIgVwiO1xudmFyIGNvbXBsZXhlcyA9IFwi4oSCXCI7XG52YXIgY29uZyA9IFwi4omFXCI7XG52YXIgY29uZ2RvdCA9IFwi4qmtXCI7XG52YXIgQ29uZ3J1ZW50ID0gXCLiiaFcIjtcbnZhciBjb25pbnQgPSBcIuKIrlwiO1xudmFyIENvbmludCA9IFwi4oivXCI7XG52YXIgQ29udG91ckludGVncmFsID0gXCLiiK5cIjtcbnZhciBjb3BmID0gXCLwnZWUXCI7XG52YXIgQ29wZiA9IFwi4oSCXCI7XG52YXIgY29wcm9kID0gXCLiiJBcIjtcbnZhciBDb3Byb2R1Y3QgPSBcIuKIkFwiO1xudmFyIGNvcHkkMSA9IFwiwqlcIjtcbnZhciBDT1BZJDEgPSBcIsKpXCI7XG52YXIgY29weXNyID0gXCLihJdcIjtcbnZhciBDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsID0gXCLiiLNcIjtcbnZhciBjcmFyciA9IFwi4oa1XCI7XG52YXIgY3Jvc3MgPSBcIuKcl1wiO1xudmFyIENyb3NzID0gXCLiqK9cIjtcbnZhciBDc2NyID0gXCLwnZKeXCI7XG52YXIgY3NjciA9IFwi8J2SuFwiO1xudmFyIGNzdWIgPSBcIuKrj1wiO1xudmFyIGNzdWJlID0gXCLiq5FcIjtcbnZhciBjc3VwID0gXCLiq5BcIjtcbnZhciBjc3VwZSA9IFwi4quSXCI7XG52YXIgY3Rkb3QgPSBcIuKLr1wiO1xudmFyIGN1ZGFycmwgPSBcIuKkuFwiO1xudmFyIGN1ZGFycnIgPSBcIuKktVwiO1xudmFyIGN1ZXByID0gXCLii55cIjtcbnZhciBjdWVzYyA9IFwi4oufXCI7XG52YXIgY3VsYXJyID0gXCLihrZcIjtcbnZhciBjdWxhcnJwID0gXCLipL1cIjtcbnZhciBjdXBicmNhcCA9IFwi4qmIXCI7XG52YXIgY3VwY2FwID0gXCLiqYZcIjtcbnZhciBDdXBDYXAgPSBcIuKJjVwiO1xudmFyIGN1cCA9IFwi4oiqXCI7XG52YXIgQ3VwID0gXCLii5NcIjtcbnZhciBjdXBjdXAgPSBcIuKpilwiO1xudmFyIGN1cGRvdCA9IFwi4oqNXCI7XG52YXIgY3Vwb3IgPSBcIuKphVwiO1xudmFyIGN1cHMgPSBcIuKIqu+4gFwiO1xudmFyIGN1cmFyciA9IFwi4oa3XCI7XG52YXIgY3VyYXJybSA9IFwi4qS8XCI7XG52YXIgY3VybHllcXByZWMgPSBcIuKLnlwiO1xudmFyIGN1cmx5ZXFzdWNjID0gXCLii59cIjtcbnZhciBjdXJseXZlZSA9IFwi4ouOXCI7XG52YXIgY3VybHl3ZWRnZSA9IFwi4ouPXCI7XG52YXIgY3VycmVuJDEgPSBcIsKkXCI7XG52YXIgY3VydmVhcnJvd2xlZnQgPSBcIuKGtlwiO1xudmFyIGN1cnZlYXJyb3dyaWdodCA9IFwi4oa3XCI7XG52YXIgY3V2ZWUgPSBcIuKLjlwiO1xudmFyIGN1d2VkID0gXCLii49cIjtcbnZhciBjd2NvbmludCA9IFwi4oiyXCI7XG52YXIgY3dpbnQgPSBcIuKIsVwiO1xudmFyIGN5bGN0eSA9IFwi4oytXCI7XG52YXIgZGFnZ2VyID0gXCLigKBcIjtcbnZhciBEYWdnZXIgPSBcIuKAoVwiO1xudmFyIGRhbGV0aCA9IFwi4oS4XCI7XG52YXIgZGFyciA9IFwi4oaTXCI7XG52YXIgRGFyciA9IFwi4oahXCI7XG52YXIgZEFyciA9IFwi4oeTXCI7XG52YXIgZGFzaCA9IFwi4oCQXCI7XG52YXIgRGFzaHYgPSBcIuKrpFwiO1xudmFyIGRhc2h2ID0gXCLiiqNcIjtcbnZhciBkYmthcm93ID0gXCLipI9cIjtcbnZhciBkYmxhYyA9IFwiy51cIjtcbnZhciBEY2Fyb24gPSBcIsSOXCI7XG52YXIgZGNhcm9uID0gXCLEj1wiO1xudmFyIERjeSA9IFwi0JRcIjtcbnZhciBkY3kgPSBcItC0XCI7XG52YXIgZGRhZ2dlciA9IFwi4oChXCI7XG52YXIgZGRhcnIgPSBcIuKHilwiO1xudmFyIEREID0gXCLihYVcIjtcbnZhciBkZCA9IFwi4oWGXCI7XG52YXIgRERvdHJhaGQgPSBcIuKkkVwiO1xudmFyIGRkb3RzZXEgPSBcIuKpt1wiO1xudmFyIGRlZyQxID0gXCLCsFwiO1xudmFyIERlbCA9IFwi4oiHXCI7XG52YXIgRGVsdGEgPSBcIs6UXCI7XG52YXIgZGVsdGEgPSBcIs60XCI7XG52YXIgZGVtcHR5diA9IFwi4qaxXCI7XG52YXIgZGZpc2h0ID0gXCLipb9cIjtcbnZhciBEZnIgPSBcIvCdlIdcIjtcbnZhciBkZnIgPSBcIvCdlKFcIjtcbnZhciBkSGFyID0gXCLipaVcIjtcbnZhciBkaGFybCA9IFwi4oeDXCI7XG52YXIgZGhhcnIgPSBcIuKHglwiO1xudmFyIERpYWNyaXRpY2FsQWN1dGUgPSBcIsK0XCI7XG52YXIgRGlhY3JpdGljYWxEb3QgPSBcIsuZXCI7XG52YXIgRGlhY3JpdGljYWxEb3VibGVBY3V0ZSA9IFwiy51cIjtcbnZhciBEaWFjcml0aWNhbEdyYXZlID0gXCJgXCI7XG52YXIgRGlhY3JpdGljYWxUaWxkZSA9IFwiy5xcIjtcbnZhciBkaWFtID0gXCLii4RcIjtcbnZhciBkaWFtb25kID0gXCLii4RcIjtcbnZhciBEaWFtb25kID0gXCLii4RcIjtcbnZhciBkaWFtb25kc3VpdCA9IFwi4pmmXCI7XG52YXIgZGlhbXMgPSBcIuKZplwiO1xudmFyIGRpZSA9IFwiwqhcIjtcbnZhciBEaWZmZXJlbnRpYWxEID0gXCLihYZcIjtcbnZhciBkaWdhbW1hID0gXCLPnVwiO1xudmFyIGRpc2luID0gXCLii7JcIjtcbnZhciBkaXYgPSBcIsO3XCI7XG52YXIgZGl2aWRlJDEgPSBcIsO3XCI7XG52YXIgZGl2aWRlb250aW1lcyA9IFwi4ouHXCI7XG52YXIgZGl2b254ID0gXCLii4dcIjtcbnZhciBESmN5ID0gXCLQglwiO1xudmFyIGRqY3kgPSBcItGSXCI7XG52YXIgZGxjb3JuID0gXCLijJ5cIjtcbnZhciBkbGNyb3AgPSBcIuKMjVwiO1xudmFyIGRvbGxhciA9IFwiJFwiO1xudmFyIERvcGYgPSBcIvCdlLtcIjtcbnZhciBkb3BmID0gXCLwnZWVXCI7XG52YXIgRG90ID0gXCLCqFwiO1xudmFyIGRvdCA9IFwiy5lcIjtcbnZhciBEb3REb3QgPSBcIuKDnFwiO1xudmFyIGRvdGVxID0gXCLiiZBcIjtcbnZhciBkb3RlcWRvdCA9IFwi4omRXCI7XG52YXIgRG90RXF1YWwgPSBcIuKJkFwiO1xudmFyIGRvdG1pbnVzID0gXCLiiLhcIjtcbnZhciBkb3RwbHVzID0gXCLiiJRcIjtcbnZhciBkb3RzcXVhcmUgPSBcIuKKoVwiO1xudmFyIGRvdWJsZWJhcndlZGdlID0gXCLijIZcIjtcbnZhciBEb3VibGVDb250b3VySW50ZWdyYWwgPSBcIuKIr1wiO1xudmFyIERvdWJsZURvdCA9IFwiwqhcIjtcbnZhciBEb3VibGVEb3duQXJyb3cgPSBcIuKHk1wiO1xudmFyIERvdWJsZUxlZnRBcnJvdyA9IFwi4oeQXCI7XG52YXIgRG91YmxlTGVmdFJpZ2h0QXJyb3cgPSBcIuKHlFwiO1xudmFyIERvdWJsZUxlZnRUZWUgPSBcIuKrpFwiO1xudmFyIERvdWJsZUxvbmdMZWZ0QXJyb3cgPSBcIuKfuFwiO1xudmFyIERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyA9IFwi4p+6XCI7XG52YXIgRG91YmxlTG9uZ1JpZ2h0QXJyb3cgPSBcIuKfuVwiO1xudmFyIERvdWJsZVJpZ2h0QXJyb3cgPSBcIuKHklwiO1xudmFyIERvdWJsZVJpZ2h0VGVlID0gXCLiiqhcIjtcbnZhciBEb3VibGVVcEFycm93ID0gXCLih5FcIjtcbnZhciBEb3VibGVVcERvd25BcnJvdyA9IFwi4oeVXCI7XG52YXIgRG91YmxlVmVydGljYWxCYXIgPSBcIuKIpVwiO1xudmFyIERvd25BcnJvd0JhciA9IFwi4qSTXCI7XG52YXIgZG93bmFycm93ID0gXCLihpNcIjtcbnZhciBEb3duQXJyb3cgPSBcIuKGk1wiO1xudmFyIERvd25hcnJvdyA9IFwi4oeTXCI7XG52YXIgRG93bkFycm93VXBBcnJvdyA9IFwi4oe1XCI7XG52YXIgRG93bkJyZXZlID0gXCLMkVwiO1xudmFyIGRvd25kb3duYXJyb3dzID0gXCLih4pcIjtcbnZhciBkb3duaGFycG9vbmxlZnQgPSBcIuKHg1wiO1xudmFyIGRvd25oYXJwb29ucmlnaHQgPSBcIuKHglwiO1xudmFyIERvd25MZWZ0UmlnaHRWZWN0b3IgPSBcIuKlkFwiO1xudmFyIERvd25MZWZ0VGVlVmVjdG9yID0gXCLipZ5cIjtcbnZhciBEb3duTGVmdFZlY3RvckJhciA9IFwi4qWWXCI7XG52YXIgRG93bkxlZnRWZWN0b3IgPSBcIuKGvVwiO1xudmFyIERvd25SaWdodFRlZVZlY3RvciA9IFwi4qWfXCI7XG52YXIgRG93blJpZ2h0VmVjdG9yQmFyID0gXCLipZdcIjtcbnZhciBEb3duUmlnaHRWZWN0b3IgPSBcIuKHgVwiO1xudmFyIERvd25UZWVBcnJvdyA9IFwi4oanXCI7XG52YXIgRG93blRlZSA9IFwi4oqkXCI7XG52YXIgZHJia2Fyb3cgPSBcIuKkkFwiO1xudmFyIGRyY29ybiA9IFwi4oyfXCI7XG52YXIgZHJjcm9wID0gXCLijIxcIjtcbnZhciBEc2NyID0gXCLwnZKfXCI7XG52YXIgZHNjciA9IFwi8J2SuVwiO1xudmFyIERTY3kgPSBcItCFXCI7XG52YXIgZHNjeSA9IFwi0ZVcIjtcbnZhciBkc29sID0gXCLip7ZcIjtcbnZhciBEc3Ryb2sgPSBcIsSQXCI7XG52YXIgZHN0cm9rID0gXCLEkVwiO1xudmFyIGR0ZG90ID0gXCLii7FcIjtcbnZhciBkdHJpID0gXCLilr9cIjtcbnZhciBkdHJpZiA9IFwi4pa+XCI7XG52YXIgZHVhcnIgPSBcIuKHtVwiO1xudmFyIGR1aGFyID0gXCLipa9cIjtcbnZhciBkd2FuZ2xlID0gXCLipqZcIjtcbnZhciBEWmN5ID0gXCLQj1wiO1xudmFyIGR6Y3kgPSBcItGfXCI7XG52YXIgZHppZ3JhcnIgPSBcIuKfv1wiO1xudmFyIEVhY3V0ZSQxID0gXCLDiVwiO1xudmFyIGVhY3V0ZSQxID0gXCLDqVwiO1xudmFyIGVhc3RlciA9IFwi4qmuXCI7XG52YXIgRWNhcm9uID0gXCLEmlwiO1xudmFyIGVjYXJvbiA9IFwixJtcIjtcbnZhciBFY2lyYyQxID0gXCLDilwiO1xudmFyIGVjaXJjJDEgPSBcIsOqXCI7XG52YXIgZWNpciA9IFwi4omWXCI7XG52YXIgZWNvbG9uID0gXCLiiZVcIjtcbnZhciBFY3kgPSBcItCtXCI7XG52YXIgZWN5ID0gXCLRjVwiO1xudmFyIGVERG90ID0gXCLiqbdcIjtcbnZhciBFZG90ID0gXCLEllwiO1xudmFyIGVkb3QgPSBcIsSXXCI7XG52YXIgZURvdCA9IFwi4omRXCI7XG52YXIgZWUgPSBcIuKFh1wiO1xudmFyIGVmRG90ID0gXCLiiZJcIjtcbnZhciBFZnIgPSBcIvCdlIhcIjtcbnZhciBlZnIgPSBcIvCdlKJcIjtcbnZhciBlZyA9IFwi4qqaXCI7XG52YXIgRWdyYXZlJDEgPSBcIsOIXCI7XG52YXIgZWdyYXZlJDEgPSBcIsOoXCI7XG52YXIgZWdzID0gXCLiqpZcIjtcbnZhciBlZ3Nkb3QgPSBcIuKqmFwiO1xudmFyIGVsID0gXCLiqplcIjtcbnZhciBFbGVtZW50ID0gXCLiiIhcIjtcbnZhciBlbGludGVycyA9IFwi4o+nXCI7XG52YXIgZWxsID0gXCLihJNcIjtcbnZhciBlbHMgPSBcIuKqlVwiO1xudmFyIGVsc2RvdCA9IFwi4qqXXCI7XG52YXIgRW1hY3IgPSBcIsSSXCI7XG52YXIgZW1hY3IgPSBcIsSTXCI7XG52YXIgZW1wdHkgPSBcIuKIhVwiO1xudmFyIGVtcHR5c2V0ID0gXCLiiIVcIjtcbnZhciBFbXB0eVNtYWxsU3F1YXJlID0gXCLil7tcIjtcbnZhciBlbXB0eXYgPSBcIuKIhVwiO1xudmFyIEVtcHR5VmVyeVNtYWxsU3F1YXJlID0gXCLilqtcIjtcbnZhciBlbXNwMTMgPSBcIuKAhFwiO1xudmFyIGVtc3AxNCA9IFwi4oCFXCI7XG52YXIgZW1zcCA9IFwi4oCDXCI7XG52YXIgRU5HID0gXCLFilwiO1xudmFyIGVuZyA9IFwixYtcIjtcbnZhciBlbnNwID0gXCLigIJcIjtcbnZhciBFb2dvbiA9IFwixJhcIjtcbnZhciBlb2dvbiA9IFwixJlcIjtcbnZhciBFb3BmID0gXCLwnZS8XCI7XG52YXIgZW9wZiA9IFwi8J2VllwiO1xudmFyIGVwYXIgPSBcIuKLlVwiO1xudmFyIGVwYXJzbCA9IFwi4qejXCI7XG52YXIgZXBsdXMgPSBcIuKpsVwiO1xudmFyIGVwc2kgPSBcIs61XCI7XG52YXIgRXBzaWxvbiA9IFwizpVcIjtcbnZhciBlcHNpbG9uID0gXCLOtVwiO1xudmFyIGVwc2l2ID0gXCLPtVwiO1xudmFyIGVxY2lyYyA9IFwi4omWXCI7XG52YXIgZXFjb2xvbiA9IFwi4omVXCI7XG52YXIgZXFzaW0gPSBcIuKJglwiO1xudmFyIGVxc2xhbnRndHIgPSBcIuKqllwiO1xudmFyIGVxc2xhbnRsZXNzID0gXCLiqpVcIjtcbnZhciBFcXVhbCA9IFwi4qm1XCI7XG52YXIgZXF1YWxzID0gXCI9XCI7XG52YXIgRXF1YWxUaWxkZSA9IFwi4omCXCI7XG52YXIgZXF1ZXN0ID0gXCLiiZ9cIjtcbnZhciBFcXVpbGlicml1bSA9IFwi4oeMXCI7XG52YXIgZXF1aXYgPSBcIuKJoVwiO1xudmFyIGVxdWl2REQgPSBcIuKpuFwiO1xudmFyIGVxdnBhcnNsID0gXCLip6VcIjtcbnZhciBlcmFyciA9IFwi4qWxXCI7XG52YXIgZXJEb3QgPSBcIuKJk1wiO1xudmFyIGVzY3IgPSBcIuKEr1wiO1xudmFyIEVzY3IgPSBcIuKEsFwiO1xudmFyIGVzZG90ID0gXCLiiZBcIjtcbnZhciBFc2ltID0gXCLiqbNcIjtcbnZhciBlc2ltID0gXCLiiYJcIjtcbnZhciBFdGEgPSBcIs6XXCI7XG52YXIgZXRhID0gXCLOt1wiO1xudmFyIEVUSCQxID0gXCLDkFwiO1xudmFyIGV0aCQxID0gXCLDsFwiO1xudmFyIEV1bWwkMSA9IFwiw4tcIjtcbnZhciBldW1sJDEgPSBcIsOrXCI7XG52YXIgZXVybyA9IFwi4oKsXCI7XG52YXIgZXhjbCA9IFwiIVwiO1xudmFyIGV4aXN0ID0gXCLiiINcIjtcbnZhciBFeGlzdHMgPSBcIuKIg1wiO1xudmFyIGV4cGVjdGF0aW9uID0gXCLihLBcIjtcbnZhciBleHBvbmVudGlhbGUgPSBcIuKFh1wiO1xudmFyIEV4cG9uZW50aWFsRSA9IFwi4oWHXCI7XG52YXIgZmFsbGluZ2RvdHNlcSA9IFwi4omSXCI7XG52YXIgRmN5ID0gXCLQpFwiO1xudmFyIGZjeSA9IFwi0YRcIjtcbnZhciBmZW1hbGUgPSBcIuKZgFwiO1xudmFyIGZmaWxpZyA9IFwi76yDXCI7XG52YXIgZmZsaWcgPSBcIu+sgFwiO1xudmFyIGZmbGxpZyA9IFwi76yEXCI7XG52YXIgRmZyID0gXCLwnZSJXCI7XG52YXIgZmZyID0gXCLwnZSjXCI7XG52YXIgZmlsaWcgPSBcIu+sgVwiO1xudmFyIEZpbGxlZFNtYWxsU3F1YXJlID0gXCLil7xcIjtcbnZhciBGaWxsZWRWZXJ5U21hbGxTcXVhcmUgPSBcIuKWqlwiO1xudmFyIGZqbGlnID0gXCJmalwiO1xudmFyIGZsYXQgPSBcIuKZrVwiO1xudmFyIGZsbGlnID0gXCLvrIJcIjtcbnZhciBmbHRucyA9IFwi4paxXCI7XG52YXIgZm5vZiA9IFwixpJcIjtcbnZhciBGb3BmID0gXCLwnZS9XCI7XG52YXIgZm9wZiA9IFwi8J2Vl1wiO1xudmFyIGZvcmFsbCA9IFwi4oiAXCI7XG52YXIgRm9yQWxsID0gXCLiiIBcIjtcbnZhciBmb3JrID0gXCLii5RcIjtcbnZhciBmb3JrdiA9IFwi4quZXCI7XG52YXIgRm91cmllcnRyZiA9IFwi4oSxXCI7XG52YXIgZnBhcnRpbnQgPSBcIuKojVwiO1xudmFyIGZyYWMxMiQxID0gXCLCvVwiO1xudmFyIGZyYWMxMyA9IFwi4oWTXCI7XG52YXIgZnJhYzE0JDEgPSBcIsK8XCI7XG52YXIgZnJhYzE1ID0gXCLihZVcIjtcbnZhciBmcmFjMTYgPSBcIuKFmVwiO1xudmFyIGZyYWMxOCA9IFwi4oWbXCI7XG52YXIgZnJhYzIzID0gXCLihZRcIjtcbnZhciBmcmFjMjUgPSBcIuKFllwiO1xudmFyIGZyYWMzNCQxID0gXCLCvlwiO1xudmFyIGZyYWMzNSA9IFwi4oWXXCI7XG52YXIgZnJhYzM4ID0gXCLihZxcIjtcbnZhciBmcmFjNDUgPSBcIuKFmFwiO1xudmFyIGZyYWM1NiA9IFwi4oWaXCI7XG52YXIgZnJhYzU4ID0gXCLihZ1cIjtcbnZhciBmcmFjNzggPSBcIuKFnlwiO1xudmFyIGZyYXNsID0gXCLigYRcIjtcbnZhciBmcm93biA9IFwi4oyiXCI7XG52YXIgZnNjciA9IFwi8J2Su1wiO1xudmFyIEZzY3IgPSBcIuKEsVwiO1xudmFyIGdhY3V0ZSA9IFwix7VcIjtcbnZhciBHYW1tYSA9IFwizpNcIjtcbnZhciBnYW1tYSA9IFwizrNcIjtcbnZhciBHYW1tYWQgPSBcIs+cXCI7XG52YXIgZ2FtbWFkID0gXCLPnVwiO1xudmFyIGdhcCA9IFwi4qqGXCI7XG52YXIgR2JyZXZlID0gXCLEnlwiO1xudmFyIGdicmV2ZSA9IFwixJ9cIjtcbnZhciBHY2VkaWwgPSBcIsSiXCI7XG52YXIgR2NpcmMgPSBcIsScXCI7XG52YXIgZ2NpcmMgPSBcIsSdXCI7XG52YXIgR2N5ID0gXCLQk1wiO1xudmFyIGdjeSA9IFwi0LNcIjtcbnZhciBHZG90ID0gXCLEoFwiO1xudmFyIGdkb3QgPSBcIsShXCI7XG52YXIgZ2UgPSBcIuKJpVwiO1xudmFyIGdFID0gXCLiiadcIjtcbnZhciBnRWwgPSBcIuKqjFwiO1xudmFyIGdlbCA9IFwi4oubXCI7XG52YXIgZ2VxID0gXCLiiaVcIjtcbnZhciBnZXFxID0gXCLiiadcIjtcbnZhciBnZXFzbGFudCA9IFwi4qm+XCI7XG52YXIgZ2VzY2MgPSBcIuKqqVwiO1xudmFyIGdlcyA9IFwi4qm+XCI7XG52YXIgZ2VzZG90ID0gXCLiqoBcIjtcbnZhciBnZXNkb3RvID0gXCLiqoJcIjtcbnZhciBnZXNkb3RvbCA9IFwi4qqEXCI7XG52YXIgZ2VzbCA9IFwi4oub77iAXCI7XG52YXIgZ2VzbGVzID0gXCLiqpRcIjtcbnZhciBHZnIgPSBcIvCdlIpcIjtcbnZhciBnZnIgPSBcIvCdlKRcIjtcbnZhciBnZyA9IFwi4omrXCI7XG52YXIgR2cgPSBcIuKLmVwiO1xudmFyIGdnZyA9IFwi4ouZXCI7XG52YXIgZ2ltZWwgPSBcIuKEt1wiO1xudmFyIEdKY3kgPSBcItCDXCI7XG52YXIgZ2pjeSA9IFwi0ZNcIjtcbnZhciBnbGEgPSBcIuKqpVwiO1xudmFyIGdsID0gXCLiibdcIjtcbnZhciBnbEUgPSBcIuKqklwiO1xudmFyIGdsaiA9IFwi4qqkXCI7XG52YXIgZ25hcCA9IFwi4qqKXCI7XG52YXIgZ25hcHByb3ggPSBcIuKqilwiO1xudmFyIGduZSA9IFwi4qqIXCI7XG52YXIgZ25FID0gXCLiialcIjtcbnZhciBnbmVxID0gXCLiqohcIjtcbnZhciBnbmVxcSA9IFwi4ompXCI7XG52YXIgZ25zaW0gPSBcIuKLp1wiO1xudmFyIEdvcGYgPSBcIvCdlL5cIjtcbnZhciBnb3BmID0gXCLwnZWYXCI7XG52YXIgZ3JhdmUgPSBcImBcIjtcbnZhciBHcmVhdGVyRXF1YWwgPSBcIuKJpVwiO1xudmFyIEdyZWF0ZXJFcXVhbExlc3MgPSBcIuKLm1wiO1xudmFyIEdyZWF0ZXJGdWxsRXF1YWwgPSBcIuKJp1wiO1xudmFyIEdyZWF0ZXJHcmVhdGVyID0gXCLiqqJcIjtcbnZhciBHcmVhdGVyTGVzcyA9IFwi4om3XCI7XG52YXIgR3JlYXRlclNsYW50RXF1YWwgPSBcIuKpvlwiO1xudmFyIEdyZWF0ZXJUaWxkZSA9IFwi4omzXCI7XG52YXIgR3NjciA9IFwi8J2SolwiO1xudmFyIGdzY3IgPSBcIuKEilwiO1xudmFyIGdzaW0gPSBcIuKJs1wiO1xudmFyIGdzaW1lID0gXCLiqo5cIjtcbnZhciBnc2ltbCA9IFwi4qqQXCI7XG52YXIgZ3RjYyA9IFwi4qqnXCI7XG52YXIgZ3RjaXIgPSBcIuKpulwiO1xudmFyIGd0JDIgPSBcIj5cIjtcbnZhciBHVCQxID0gXCI+XCI7XG52YXIgR3QgPSBcIuKJq1wiO1xudmFyIGd0ZG90ID0gXCLii5dcIjtcbnZhciBndGxQYXIgPSBcIuKmlVwiO1xudmFyIGd0cXVlc3QgPSBcIuKpvFwiO1xudmFyIGd0cmFwcHJveCA9IFwi4qqGXCI7XG52YXIgZ3RyYXJyID0gXCLipbhcIjtcbnZhciBndHJkb3QgPSBcIuKLl1wiO1xudmFyIGd0cmVxbGVzcyA9IFwi4oubXCI7XG52YXIgZ3RyZXFxbGVzcyA9IFwi4qqMXCI7XG52YXIgZ3RybGVzcyA9IFwi4om3XCI7XG52YXIgZ3Ryc2ltID0gXCLiibNcIjtcbnZhciBndmVydG5lcXEgPSBcIuKJqe+4gFwiO1xudmFyIGd2bkUgPSBcIuKJqe+4gFwiO1xudmFyIEhhY2VrID0gXCLLh1wiO1xudmFyIGhhaXJzcCA9IFwi4oCKXCI7XG52YXIgaGFsZiA9IFwiwr1cIjtcbnZhciBoYW1pbHQgPSBcIuKEi1wiO1xudmFyIEhBUkRjeSA9IFwi0KpcIjtcbnZhciBoYXJkY3kgPSBcItGKXCI7XG52YXIgaGFycmNpciA9IFwi4qWIXCI7XG52YXIgaGFyciA9IFwi4oaUXCI7XG52YXIgaEFyciA9IFwi4oeUXCI7XG52YXIgaGFycncgPSBcIuKGrVwiO1xudmFyIEhhdCA9IFwiXlwiO1xudmFyIGhiYXIgPSBcIuKEj1wiO1xudmFyIEhjaXJjID0gXCLEpFwiO1xudmFyIGhjaXJjID0gXCLEpVwiO1xudmFyIGhlYXJ0cyA9IFwi4pmlXCI7XG52YXIgaGVhcnRzdWl0ID0gXCLimaVcIjtcbnZhciBoZWxsaXAgPSBcIuKAplwiO1xudmFyIGhlcmNvbiA9IFwi4oq5XCI7XG52YXIgaGZyID0gXCLwnZSlXCI7XG52YXIgSGZyID0gXCLihIxcIjtcbnZhciBIaWxiZXJ0U3BhY2UgPSBcIuKEi1wiO1xudmFyIGhrc2Vhcm93ID0gXCLipKVcIjtcbnZhciBoa3N3YXJvdyA9IFwi4qSmXCI7XG52YXIgaG9hcnIgPSBcIuKHv1wiO1xudmFyIGhvbXRodCA9IFwi4oi7XCI7XG52YXIgaG9va2xlZnRhcnJvdyA9IFwi4oapXCI7XG52YXIgaG9va3JpZ2h0YXJyb3cgPSBcIuKGqlwiO1xudmFyIGhvcGYgPSBcIvCdlZlcIjtcbnZhciBIb3BmID0gXCLihI1cIjtcbnZhciBob3JiYXIgPSBcIuKAlVwiO1xudmFyIEhvcml6b250YWxMaW5lID0gXCLilIBcIjtcbnZhciBoc2NyID0gXCLwnZK9XCI7XG52YXIgSHNjciA9IFwi4oSLXCI7XG52YXIgaHNsYXNoID0gXCLihI9cIjtcbnZhciBIc3Ryb2sgPSBcIsSmXCI7XG52YXIgaHN0cm9rID0gXCLEp1wiO1xudmFyIEh1bXBEb3duSHVtcCA9IFwi4omOXCI7XG52YXIgSHVtcEVxdWFsID0gXCLiiY9cIjtcbnZhciBoeWJ1bGwgPSBcIuKBg1wiO1xudmFyIGh5cGhlbiA9IFwi4oCQXCI7XG52YXIgSWFjdXRlJDEgPSBcIsONXCI7XG52YXIgaWFjdXRlJDEgPSBcIsOtXCI7XG52YXIgaWMgPSBcIuKBo1wiO1xudmFyIEljaXJjJDEgPSBcIsOOXCI7XG52YXIgaWNpcmMkMSA9IFwiw65cIjtcbnZhciBJY3kgPSBcItCYXCI7XG52YXIgaWN5ID0gXCLQuFwiO1xudmFyIElkb3QgPSBcIsSwXCI7XG52YXIgSUVjeSA9IFwi0JVcIjtcbnZhciBpZWN5ID0gXCLQtVwiO1xudmFyIGlleGNsJDEgPSBcIsKhXCI7XG52YXIgaWZmID0gXCLih5RcIjtcbnZhciBpZnIgPSBcIvCdlKZcIjtcbnZhciBJZnIgPSBcIuKEkVwiO1xudmFyIElncmF2ZSQxID0gXCLDjFwiO1xudmFyIGlncmF2ZSQxID0gXCLDrFwiO1xudmFyIGlpID0gXCLihYhcIjtcbnZhciBpaWlpbnQgPSBcIuKojFwiO1xudmFyIGlpaW50ID0gXCLiiK1cIjtcbnZhciBpaW5maW4gPSBcIuKnnFwiO1xudmFyIGlpb3RhID0gXCLihKlcIjtcbnZhciBJSmxpZyA9IFwixLJcIjtcbnZhciBpamxpZyA9IFwixLNcIjtcbnZhciBJbWFjciA9IFwixKpcIjtcbnZhciBpbWFjciA9IFwixKtcIjtcbnZhciBlc21faW1hZ2UgPSBcIuKEkVwiO1xudmFyIEltYWdpbmFyeUkgPSBcIuKFiFwiO1xudmFyIGltYWdsaW5lID0gXCLihJBcIjtcbnZhciBpbWFncGFydCA9IFwi4oSRXCI7XG52YXIgaW1hdGggPSBcIsSxXCI7XG52YXIgSW0gPSBcIuKEkVwiO1xudmFyIGltb2YgPSBcIuKKt1wiO1xudmFyIGltcGVkID0gXCLGtVwiO1xudmFyIEltcGxpZXMgPSBcIuKHklwiO1xudmFyIGluY2FyZSA9IFwi4oSFXCI7XG52YXIgaW5maW4gPSBcIuKInlwiO1xudmFyIGluZmludGllID0gXCLip51cIjtcbnZhciBpbm9kb3QgPSBcIsSxXCI7XG52YXIgaW50Y2FsID0gXCLiirpcIjtcbnZhciBlc21faW50ID0gXCLiiKtcIjtcbnZhciBJbnQgPSBcIuKIrFwiO1xudmFyIGludGVnZXJzID0gXCLihKRcIjtcbnZhciBJbnRlZ3JhbCA9IFwi4oirXCI7XG52YXIgaW50ZXJjYWwgPSBcIuKKulwiO1xudmFyIEludGVyc2VjdGlvbiA9IFwi4ouCXCI7XG52YXIgaW50bGFyaGsgPSBcIuKol1wiO1xudmFyIGludHByb2QgPSBcIuKovFwiO1xudmFyIEludmlzaWJsZUNvbW1hID0gXCLigaNcIjtcbnZhciBJbnZpc2libGVUaW1lcyA9IFwi4oGiXCI7XG52YXIgSU9jeSA9IFwi0IFcIjtcbnZhciBpb2N5ID0gXCLRkVwiO1xudmFyIElvZ29uID0gXCLErlwiO1xudmFyIGlvZ29uID0gXCLEr1wiO1xudmFyIElvcGYgPSBcIvCdlYBcIjtcbnZhciBpb3BmID0gXCLwnZWaXCI7XG52YXIgSW90YSA9IFwizplcIjtcbnZhciBpb3RhID0gXCLOuVwiO1xudmFyIGlwcm9kID0gXCLiqLxcIjtcbnZhciBpcXVlc3QkMSA9IFwiwr9cIjtcbnZhciBpc2NyID0gXCLwnZK+XCI7XG52YXIgSXNjciA9IFwi4oSQXCI7XG52YXIgaXNpbiA9IFwi4oiIXCI7XG52YXIgaXNpbmRvdCA9IFwi4ou1XCI7XG52YXIgaXNpbkUgPSBcIuKLuVwiO1xudmFyIGlzaW5zID0gXCLii7RcIjtcbnZhciBpc2luc3YgPSBcIuKLs1wiO1xudmFyIGlzaW52ID0gXCLiiIhcIjtcbnZhciBpdCA9IFwi4oGiXCI7XG52YXIgSXRpbGRlID0gXCLEqFwiO1xudmFyIGl0aWxkZSA9IFwixKlcIjtcbnZhciBJdWtjeSA9IFwi0IZcIjtcbnZhciBpdWtjeSA9IFwi0ZZcIjtcbnZhciBJdW1sJDEgPSBcIsOPXCI7XG52YXIgaXVtbCQxID0gXCLDr1wiO1xudmFyIEpjaXJjID0gXCLEtFwiO1xudmFyIGpjaXJjID0gXCLEtVwiO1xudmFyIEpjeSA9IFwi0JlcIjtcbnZhciBqY3kgPSBcItC5XCI7XG52YXIgSmZyID0gXCLwnZSNXCI7XG52YXIgamZyID0gXCLwnZSnXCI7XG52YXIgam1hdGggPSBcIsi3XCI7XG52YXIgSm9wZiA9IFwi8J2VgVwiO1xudmFyIGpvcGYgPSBcIvCdlZtcIjtcbnZhciBKc2NyID0gXCLwnZKlXCI7XG52YXIganNjciA9IFwi8J2Sv1wiO1xudmFyIEpzZXJjeSA9IFwi0IhcIjtcbnZhciBqc2VyY3kgPSBcItGYXCI7XG52YXIgSnVrY3kgPSBcItCEXCI7XG52YXIganVrY3kgPSBcItGUXCI7XG52YXIgS2FwcGEgPSBcIs6aXCI7XG52YXIga2FwcGEgPSBcIs66XCI7XG52YXIga2FwcGF2ID0gXCLPsFwiO1xudmFyIEtjZWRpbCA9IFwixLZcIjtcbnZhciBrY2VkaWwgPSBcIsS3XCI7XG52YXIgS2N5ID0gXCLQmlwiO1xudmFyIGtjeSA9IFwi0LpcIjtcbnZhciBLZnIgPSBcIvCdlI5cIjtcbnZhciBrZnIgPSBcIvCdlKhcIjtcbnZhciBrZ3JlZW4gPSBcIsS4XCI7XG52YXIgS0hjeSA9IFwi0KVcIjtcbnZhciBraGN5ID0gXCLRhVwiO1xudmFyIEtKY3kgPSBcItCMXCI7XG52YXIga2pjeSA9IFwi0ZxcIjtcbnZhciBLb3BmID0gXCLwnZWCXCI7XG52YXIga29wZiA9IFwi8J2VnFwiO1xudmFyIEtzY3IgPSBcIvCdkqZcIjtcbnZhciBrc2NyID0gXCLwnZOAXCI7XG52YXIgbEFhcnIgPSBcIuKHmlwiO1xudmFyIExhY3V0ZSA9IFwixLlcIjtcbnZhciBsYWN1dGUgPSBcIsS6XCI7XG52YXIgbGFlbXB0eXYgPSBcIuKmtFwiO1xudmFyIGxhZ3JhbiA9IFwi4oSSXCI7XG52YXIgTGFtYmRhID0gXCLOm1wiO1xudmFyIGxhbWJkYSA9IFwizrtcIjtcbnZhciBsYW5nID0gXCLin6hcIjtcbnZhciBMYW5nID0gXCLin6pcIjtcbnZhciBsYW5nZCA9IFwi4qaRXCI7XG52YXIgbGFuZ2xlID0gXCLin6hcIjtcbnZhciBsYXAgPSBcIuKqhVwiO1xudmFyIExhcGxhY2V0cmYgPSBcIuKEklwiO1xudmFyIGxhcXVvJDEgPSBcIsKrXCI7XG52YXIgbGFycmIgPSBcIuKHpFwiO1xudmFyIGxhcnJiZnMgPSBcIuKkn1wiO1xudmFyIGxhcnIgPSBcIuKGkFwiO1xudmFyIExhcnIgPSBcIuKGnlwiO1xudmFyIGxBcnIgPSBcIuKHkFwiO1xudmFyIGxhcnJmcyA9IFwi4qSdXCI7XG52YXIgbGFycmhrID0gXCLihqlcIjtcbnZhciBsYXJybHAgPSBcIuKGq1wiO1xudmFyIGxhcnJwbCA9IFwi4qS5XCI7XG52YXIgbGFycnNpbSA9IFwi4qWzXCI7XG52YXIgbGFycnRsID0gXCLihqJcIjtcbnZhciBsYXRhaWwgPSBcIuKkmVwiO1xudmFyIGxBdGFpbCA9IFwi4qSbXCI7XG52YXIgbGF0ID0gXCLiqqtcIjtcbnZhciBsYXRlID0gXCLiqq1cIjtcbnZhciBsYXRlcyA9IFwi4qqt77iAXCI7XG52YXIgbGJhcnIgPSBcIuKkjFwiO1xudmFyIGxCYXJyID0gXCLipI5cIjtcbnZhciBsYmJyayA9IFwi4p2yXCI7XG52YXIgbGJyYWNlID0gXCJ7XCI7XG52YXIgbGJyYWNrID0gXCJbXCI7XG52YXIgbGJya2UgPSBcIuKmi1wiO1xudmFyIGxicmtzbGQgPSBcIuKmj1wiO1xudmFyIGxicmtzbHUgPSBcIuKmjVwiO1xudmFyIExjYXJvbiA9IFwixL1cIjtcbnZhciBsY2Fyb24gPSBcIsS+XCI7XG52YXIgTGNlZGlsID0gXCLEu1wiO1xudmFyIGxjZWRpbCA9IFwixLxcIjtcbnZhciBsY2VpbCA9IFwi4oyIXCI7XG52YXIgbGN1YiA9IFwie1wiO1xudmFyIExjeSA9IFwi0JtcIjtcbnZhciBsY3kgPSBcItC7XCI7XG52YXIgbGRjYSA9IFwi4qS2XCI7XG52YXIgbGRxdW8gPSBcIuKAnFwiO1xudmFyIGxkcXVvciA9IFwi4oCeXCI7XG52YXIgbGRyZGhhciA9IFwi4qWnXCI7XG52YXIgbGRydXNoYXIgPSBcIuKli1wiO1xudmFyIGxkc2ggPSBcIuKGslwiO1xudmFyIGxlID0gXCLiiaRcIjtcbnZhciBsRSA9IFwi4ommXCI7XG52YXIgTGVmdEFuZ2xlQnJhY2tldCA9IFwi4p+oXCI7XG52YXIgTGVmdEFycm93QmFyID0gXCLih6RcIjtcbnZhciBsZWZ0YXJyb3cgPSBcIuKGkFwiO1xudmFyIExlZnRBcnJvdyA9IFwi4oaQXCI7XG52YXIgTGVmdGFycm93ID0gXCLih5BcIjtcbnZhciBMZWZ0QXJyb3dSaWdodEFycm93ID0gXCLih4ZcIjtcbnZhciBsZWZ0YXJyb3d0YWlsID0gXCLihqJcIjtcbnZhciBMZWZ0Q2VpbGluZyA9IFwi4oyIXCI7XG52YXIgTGVmdERvdWJsZUJyYWNrZXQgPSBcIuKfplwiO1xudmFyIExlZnREb3duVGVlVmVjdG9yID0gXCLipaFcIjtcbnZhciBMZWZ0RG93blZlY3RvckJhciA9IFwi4qWZXCI7XG52YXIgTGVmdERvd25WZWN0b3IgPSBcIuKHg1wiO1xudmFyIExlZnRGbG9vciA9IFwi4oyKXCI7XG52YXIgbGVmdGhhcnBvb25kb3duID0gXCLihr1cIjtcbnZhciBsZWZ0aGFycG9vbnVwID0gXCLihrxcIjtcbnZhciBsZWZ0bGVmdGFycm93cyA9IFwi4oeHXCI7XG52YXIgbGVmdHJpZ2h0YXJyb3cgPSBcIuKGlFwiO1xudmFyIExlZnRSaWdodEFycm93ID0gXCLihpRcIjtcbnZhciBMZWZ0cmlnaHRhcnJvdyA9IFwi4oeUXCI7XG52YXIgbGVmdHJpZ2h0YXJyb3dzID0gXCLih4ZcIjtcbnZhciBsZWZ0cmlnaHRoYXJwb29ucyA9IFwi4oeLXCI7XG52YXIgbGVmdHJpZ2h0c3F1aWdhcnJvdyA9IFwi4oatXCI7XG52YXIgTGVmdFJpZ2h0VmVjdG9yID0gXCLipY5cIjtcbnZhciBMZWZ0VGVlQXJyb3cgPSBcIuKGpFwiO1xudmFyIExlZnRUZWUgPSBcIuKKo1wiO1xudmFyIExlZnRUZWVWZWN0b3IgPSBcIuKlmlwiO1xudmFyIGxlZnR0aHJlZXRpbWVzID0gXCLii4tcIjtcbnZhciBMZWZ0VHJpYW5nbGVCYXIgPSBcIuKnj1wiO1xudmFyIExlZnRUcmlhbmdsZSA9IFwi4oqyXCI7XG52YXIgTGVmdFRyaWFuZ2xlRXF1YWwgPSBcIuKKtFwiO1xudmFyIExlZnRVcERvd25WZWN0b3IgPSBcIuKlkVwiO1xudmFyIExlZnRVcFRlZVZlY3RvciA9IFwi4qWgXCI7XG52YXIgTGVmdFVwVmVjdG9yQmFyID0gXCLipZhcIjtcbnZhciBMZWZ0VXBWZWN0b3IgPSBcIuKGv1wiO1xudmFyIExlZnRWZWN0b3JCYXIgPSBcIuKlklwiO1xudmFyIExlZnRWZWN0b3IgPSBcIuKGvFwiO1xudmFyIGxFZyA9IFwi4qqLXCI7XG52YXIgbGVnID0gXCLii5pcIjtcbnZhciBsZXEgPSBcIuKJpFwiO1xudmFyIGxlcXEgPSBcIuKJplwiO1xudmFyIGxlcXNsYW50ID0gXCLiqb1cIjtcbnZhciBsZXNjYyA9IFwi4qqoXCI7XG52YXIgbGVzID0gXCLiqb1cIjtcbnZhciBsZXNkb3QgPSBcIuKpv1wiO1xudmFyIGxlc2RvdG8gPSBcIuKqgVwiO1xudmFyIGxlc2RvdG9yID0gXCLiqoNcIjtcbnZhciBsZXNnID0gXCLii5rvuIBcIjtcbnZhciBsZXNnZXMgPSBcIuKqk1wiO1xudmFyIGxlc3NhcHByb3ggPSBcIuKqhVwiO1xudmFyIGxlc3Nkb3QgPSBcIuKLllwiO1xudmFyIGxlc3NlcWd0ciA9IFwi4ouaXCI7XG52YXIgbGVzc2VxcWd0ciA9IFwi4qqLXCI7XG52YXIgTGVzc0VxdWFsR3JlYXRlciA9IFwi4ouaXCI7XG52YXIgTGVzc0Z1bGxFcXVhbCA9IFwi4ommXCI7XG52YXIgTGVzc0dyZWF0ZXIgPSBcIuKJtlwiO1xudmFyIGxlc3NndHIgPSBcIuKJtlwiO1xudmFyIExlc3NMZXNzID0gXCLiqqFcIjtcbnZhciBsZXNzc2ltID0gXCLiibJcIjtcbnZhciBMZXNzU2xhbnRFcXVhbCA9IFwi4qm9XCI7XG52YXIgTGVzc1RpbGRlID0gXCLiibJcIjtcbnZhciBsZmlzaHQgPSBcIuKlvFwiO1xudmFyIGxmbG9vciA9IFwi4oyKXCI7XG52YXIgTGZyID0gXCLwnZSPXCI7XG52YXIgbGZyID0gXCLwnZSpXCI7XG52YXIgbGcgPSBcIuKJtlwiO1xudmFyIGxnRSA9IFwi4qqRXCI7XG52YXIgbEhhciA9IFwi4qWiXCI7XG52YXIgbGhhcmQgPSBcIuKGvVwiO1xudmFyIGxoYXJ1ID0gXCLihrxcIjtcbnZhciBsaGFydWwgPSBcIuKlqlwiO1xudmFyIGxoYmxrID0gXCLiloRcIjtcbnZhciBMSmN5ID0gXCLQiVwiO1xudmFyIGxqY3kgPSBcItGZXCI7XG52YXIgbGxhcnIgPSBcIuKHh1wiO1xudmFyIGxsID0gXCLiiapcIjtcbnZhciBMbCA9IFwi4ouYXCI7XG52YXIgbGxjb3JuZXIgPSBcIuKMnlwiO1xudmFyIExsZWZ0YXJyb3cgPSBcIuKHmlwiO1xudmFyIGxsaGFyZCA9IFwi4qWrXCI7XG52YXIgbGx0cmkgPSBcIuKXulwiO1xudmFyIExtaWRvdCA9IFwixL9cIjtcbnZhciBsbWlkb3QgPSBcIsWAXCI7XG52YXIgbG1vdXN0YWNoZSA9IFwi4o6wXCI7XG52YXIgbG1vdXN0ID0gXCLijrBcIjtcbnZhciBsbmFwID0gXCLiqolcIjtcbnZhciBsbmFwcHJveCA9IFwi4qqJXCI7XG52YXIgbG5lID0gXCLiqodcIjtcbnZhciBsbkUgPSBcIuKJqFwiO1xudmFyIGxuZXEgPSBcIuKqh1wiO1xudmFyIGxuZXFxID0gXCLiiahcIjtcbnZhciBsbnNpbSA9IFwi4oumXCI7XG52YXIgbG9hbmcgPSBcIuKfrFwiO1xudmFyIGxvYXJyID0gXCLih71cIjtcbnZhciBsb2JyayA9IFwi4p+mXCI7XG52YXIgbG9uZ2xlZnRhcnJvdyA9IFwi4p+1XCI7XG52YXIgTG9uZ0xlZnRBcnJvdyA9IFwi4p+1XCI7XG52YXIgTG9uZ2xlZnRhcnJvdyA9IFwi4p+4XCI7XG52YXIgbG9uZ2xlZnRyaWdodGFycm93ID0gXCLin7dcIjtcbnZhciBMb25nTGVmdFJpZ2h0QXJyb3cgPSBcIuKft1wiO1xudmFyIExvbmdsZWZ0cmlnaHRhcnJvdyA9IFwi4p+6XCI7XG52YXIgbG9uZ21hcHN0byA9IFwi4p+8XCI7XG52YXIgbG9uZ3JpZ2h0YXJyb3cgPSBcIuKftlwiO1xudmFyIExvbmdSaWdodEFycm93ID0gXCLin7ZcIjtcbnZhciBMb25ncmlnaHRhcnJvdyA9IFwi4p+5XCI7XG52YXIgbG9vcGFycm93bGVmdCA9IFwi4oarXCI7XG52YXIgbG9vcGFycm93cmlnaHQgPSBcIuKGrFwiO1xudmFyIGxvcGFyID0gXCLipoVcIjtcbnZhciBMb3BmID0gXCLwnZWDXCI7XG52YXIgbG9wZiA9IFwi8J2VnVwiO1xudmFyIGxvcGx1cyA9IFwi4qitXCI7XG52YXIgbG90aW1lcyA9IFwi4qi0XCI7XG52YXIgbG93YXN0ID0gXCLiiJdcIjtcbnZhciBsb3diYXIgPSBcIl9cIjtcbnZhciBMb3dlckxlZnRBcnJvdyA9IFwi4oaZXCI7XG52YXIgTG93ZXJSaWdodEFycm93ID0gXCLihphcIjtcbnZhciBsb3ogPSBcIuKXilwiO1xudmFyIGxvemVuZ2UgPSBcIuKXilwiO1xudmFyIGxvemYgPSBcIuKnq1wiO1xudmFyIGxwYXIgPSBcIihcIjtcbnZhciBscGFybHQgPSBcIuKmk1wiO1xudmFyIGxyYXJyID0gXCLih4ZcIjtcbnZhciBscmNvcm5lciA9IFwi4oyfXCI7XG52YXIgbHJoYXIgPSBcIuKHi1wiO1xudmFyIGxyaGFyZCA9IFwi4qWtXCI7XG52YXIgbHJtID0gXCLigI5cIjtcbnZhciBscnRyaSA9IFwi4oq/XCI7XG52YXIgbHNhcXVvID0gXCLigLlcIjtcbnZhciBsc2NyID0gXCLwnZOBXCI7XG52YXIgTHNjciA9IFwi4oSSXCI7XG52YXIgbHNoID0gXCLihrBcIjtcbnZhciBMc2ggPSBcIuKGsFwiO1xudmFyIGxzaW0gPSBcIuKJslwiO1xudmFyIGxzaW1lID0gXCLiqo1cIjtcbnZhciBsc2ltZyA9IFwi4qqPXCI7XG52YXIgbHNxYiA9IFwiW1wiO1xudmFyIGxzcXVvID0gXCLigJhcIjtcbnZhciBsc3F1b3IgPSBcIuKAmlwiO1xudmFyIExzdHJvayA9IFwixYFcIjtcbnZhciBsc3Ryb2sgPSBcIsWCXCI7XG52YXIgbHRjYyA9IFwi4qqmXCI7XG52YXIgbHRjaXIgPSBcIuKpuVwiO1xudmFyIGx0JDIgPSBcIjxcIjtcbnZhciBMVCQxID0gXCI8XCI7XG52YXIgTHQgPSBcIuKJqlwiO1xudmFyIGx0ZG90ID0gXCLii5ZcIjtcbnZhciBsdGhyZWUgPSBcIuKLi1wiO1xudmFyIGx0aW1lcyA9IFwi4ouJXCI7XG52YXIgbHRsYXJyID0gXCLipbZcIjtcbnZhciBsdHF1ZXN0ID0gXCLiqbtcIjtcbnZhciBsdHJpID0gXCLil4NcIjtcbnZhciBsdHJpZSA9IFwi4oq0XCI7XG52YXIgbHRyaWYgPSBcIuKXglwiO1xudmFyIGx0clBhciA9IFwi4qaWXCI7XG52YXIgbHVyZHNoYXIgPSBcIuKlilwiO1xudmFyIGx1cnVoYXIgPSBcIuKlplwiO1xudmFyIGx2ZXJ0bmVxcSA9IFwi4omo77iAXCI7XG52YXIgbHZuRSA9IFwi4omo77iAXCI7XG52YXIgbWFjciQxID0gXCLCr1wiO1xudmFyIG1hbGUgPSBcIuKZglwiO1xudmFyIG1hbHQgPSBcIuKcoFwiO1xudmFyIG1hbHRlc2UgPSBcIuKcoFwiO1xudmFyIG1hcCA9IFwi4oamXCI7XG52YXIgbWFwc3RvID0gXCLihqZcIjtcbnZhciBtYXBzdG9kb3duID0gXCLihqdcIjtcbnZhciBtYXBzdG9sZWZ0ID0gXCLihqRcIjtcbnZhciBtYXBzdG91cCA9IFwi4oalXCI7XG52YXIgbWFya2VyID0gXCLilq5cIjtcbnZhciBtY29tbWEgPSBcIuKoqVwiO1xudmFyIE1jeSA9IFwi0JxcIjtcbnZhciBtY3kgPSBcItC8XCI7XG52YXIgbWRhc2ggPSBcIuKAlFwiO1xudmFyIG1ERG90ID0gXCLiiLpcIjtcbnZhciBtZWFzdXJlZGFuZ2xlID0gXCLiiKFcIjtcbnZhciBNZWRpdW1TcGFjZSA9IFwi4oGfXCI7XG52YXIgTWVsbGludHJmID0gXCLihLNcIjtcbnZhciBNZnIgPSBcIvCdlJBcIjtcbnZhciBtZnIgPSBcIvCdlKpcIjtcbnZhciBtaG8gPSBcIuKEp1wiO1xudmFyIG1pY3JvJDEgPSBcIsK1XCI7XG52YXIgbWlkYXN0ID0gXCIqXCI7XG52YXIgbWlkY2lyID0gXCLiq7BcIjtcbnZhciBtaWQgPSBcIuKIo1wiO1xudmFyIG1pZGRvdCQxID0gXCLCt1wiO1xudmFyIG1pbnVzYiA9IFwi4oqfXCI7XG52YXIgbWludXMgPSBcIuKIklwiO1xudmFyIG1pbnVzZCA9IFwi4oi4XCI7XG52YXIgbWludXNkdSA9IFwi4qiqXCI7XG52YXIgTWludXNQbHVzID0gXCLiiJNcIjtcbnZhciBtbGNwID0gXCLiq5tcIjtcbnZhciBtbGRyID0gXCLigKZcIjtcbnZhciBtbnBsdXMgPSBcIuKIk1wiO1xudmFyIG1vZGVscyA9IFwi4oqnXCI7XG52YXIgTW9wZiA9IFwi8J2VhFwiO1xudmFyIG1vcGYgPSBcIvCdlZ5cIjtcbnZhciBtcCA9IFwi4oiTXCI7XG52YXIgbXNjciA9IFwi8J2TglwiO1xudmFyIE1zY3IgPSBcIuKEs1wiO1xudmFyIG1zdHBvcyA9IFwi4oi+XCI7XG52YXIgTXUgPSBcIs6cXCI7XG52YXIgbXUgPSBcIs68XCI7XG52YXIgbXVsdGltYXAgPSBcIuKKuFwiO1xudmFyIG11bWFwID0gXCLiirhcIjtcbnZhciBuYWJsYSA9IFwi4oiHXCI7XG52YXIgTmFjdXRlID0gXCLFg1wiO1xudmFyIG5hY3V0ZSA9IFwixYRcIjtcbnZhciBuYW5nID0gXCLiiKDig5JcIjtcbnZhciBuYXAgPSBcIuKJiVwiO1xudmFyIG5hcEUgPSBcIuKpsMy4XCI7XG52YXIgbmFwaWQgPSBcIuKJi8y4XCI7XG52YXIgbmFwb3MgPSBcIsWJXCI7XG52YXIgbmFwcHJveCA9IFwi4omJXCI7XG52YXIgbmF0dXJhbCA9IFwi4pmuXCI7XG52YXIgbmF0dXJhbHMgPSBcIuKElVwiO1xudmFyIG5hdHVyID0gXCLima5cIjtcbnZhciBuYnNwJDEgPSBcIsKgXCI7XG52YXIgbmJ1bXAgPSBcIuKJjsy4XCI7XG52YXIgbmJ1bXBlID0gXCLiiY/MuFwiO1xudmFyIG5jYXAgPSBcIuKpg1wiO1xudmFyIE5jYXJvbiA9IFwixYdcIjtcbnZhciBuY2Fyb24gPSBcIsWIXCI7XG52YXIgTmNlZGlsID0gXCLFhVwiO1xudmFyIG5jZWRpbCA9IFwixYZcIjtcbnZhciBuY29uZyA9IFwi4omHXCI7XG52YXIgbmNvbmdkb3QgPSBcIuKprcy4XCI7XG52YXIgbmN1cCA9IFwi4qmCXCI7XG52YXIgTmN5ID0gXCLQnVwiO1xudmFyIG5jeSA9IFwi0L1cIjtcbnZhciBuZGFzaCA9IFwi4oCTXCI7XG52YXIgbmVhcmhrID0gXCLipKRcIjtcbnZhciBuZWFyciA9IFwi4oaXXCI7XG52YXIgbmVBcnIgPSBcIuKHl1wiO1xudmFyIG5lYXJyb3cgPSBcIuKGl1wiO1xudmFyIG5lID0gXCLiiaBcIjtcbnZhciBuZWRvdCA9IFwi4omQzLhcIjtcbnZhciBOZWdhdGl2ZU1lZGl1bVNwYWNlID0gXCLigItcIjtcbnZhciBOZWdhdGl2ZVRoaWNrU3BhY2UgPSBcIuKAi1wiO1xudmFyIE5lZ2F0aXZlVGhpblNwYWNlID0gXCLigItcIjtcbnZhciBOZWdhdGl2ZVZlcnlUaGluU3BhY2UgPSBcIuKAi1wiO1xudmFyIG5lcXVpdiA9IFwi4omiXCI7XG52YXIgbmVzZWFyID0gXCLipKhcIjtcbnZhciBuZXNpbSA9IFwi4omCzLhcIjtcbnZhciBOZXN0ZWRHcmVhdGVyR3JlYXRlciA9IFwi4omrXCI7XG52YXIgTmVzdGVkTGVzc0xlc3MgPSBcIuKJqlwiO1xudmFyIE5ld0xpbmUgPSBcIlxcblwiO1xudmFyIG5leGlzdCA9IFwi4oiEXCI7XG52YXIgbmV4aXN0cyA9IFwi4oiEXCI7XG52YXIgTmZyID0gXCLwnZSRXCI7XG52YXIgbmZyID0gXCLwnZSrXCI7XG52YXIgbmdFID0gXCLiiafMuFwiO1xudmFyIG5nZSA9IFwi4omxXCI7XG52YXIgbmdlcSA9IFwi4omxXCI7XG52YXIgbmdlcXEgPSBcIuKJp8y4XCI7XG52YXIgbmdlcXNsYW50ID0gXCLiqb7MuFwiO1xudmFyIG5nZXMgPSBcIuKpvsy4XCI7XG52YXIgbkdnID0gXCLii5nMuFwiO1xudmFyIG5nc2ltID0gXCLiibVcIjtcbnZhciBuR3QgPSBcIuKJq+KDklwiO1xudmFyIG5ndCA9IFwi4omvXCI7XG52YXIgbmd0ciA9IFwi4omvXCI7XG52YXIgbkd0diA9IFwi4omrzLhcIjtcbnZhciBuaGFyciA9IFwi4oauXCI7XG52YXIgbmhBcnIgPSBcIuKHjlwiO1xudmFyIG5ocGFyID0gXCLiq7JcIjtcbnZhciBuaSA9IFwi4oiLXCI7XG52YXIgbmlzID0gXCLii7xcIjtcbnZhciBuaXNkID0gXCLii7pcIjtcbnZhciBuaXYgPSBcIuKIi1wiO1xudmFyIE5KY3kgPSBcItCKXCI7XG52YXIgbmpjeSA9IFwi0ZpcIjtcbnZhciBubGFyciA9IFwi4oaaXCI7XG52YXIgbmxBcnIgPSBcIuKHjVwiO1xudmFyIG5sZHIgPSBcIuKApVwiO1xudmFyIG5sRSA9IFwi4ommzLhcIjtcbnZhciBubGUgPSBcIuKJsFwiO1xudmFyIG5sZWZ0YXJyb3cgPSBcIuKGmlwiO1xudmFyIG5MZWZ0YXJyb3cgPSBcIuKHjVwiO1xudmFyIG5sZWZ0cmlnaHRhcnJvdyA9IFwi4oauXCI7XG52YXIgbkxlZnRyaWdodGFycm93ID0gXCLih45cIjtcbnZhciBubGVxID0gXCLiibBcIjtcbnZhciBubGVxcSA9IFwi4ommzLhcIjtcbnZhciBubGVxc2xhbnQgPSBcIuKpvcy4XCI7XG52YXIgbmxlcyA9IFwi4qm9zLhcIjtcbnZhciBubGVzcyA9IFwi4omuXCI7XG52YXIgbkxsID0gXCLii5jMuFwiO1xudmFyIG5sc2ltID0gXCLiibRcIjtcbnZhciBuTHQgPSBcIuKJquKDklwiO1xudmFyIG5sdCA9IFwi4omuXCI7XG52YXIgbmx0cmkgPSBcIuKLqlwiO1xudmFyIG5sdHJpZSA9IFwi4ousXCI7XG52YXIgbkx0diA9IFwi4omqzLhcIjtcbnZhciBubWlkID0gXCLiiKRcIjtcbnZhciBOb0JyZWFrID0gXCLigaBcIjtcbnZhciBOb25CcmVha2luZ1NwYWNlID0gXCLCoFwiO1xudmFyIG5vcGYgPSBcIvCdlZ9cIjtcbnZhciBOb3BmID0gXCLihJVcIjtcbnZhciBOb3QgPSBcIuKrrFwiO1xudmFyIG5vdCQxID0gXCLCrFwiO1xudmFyIE5vdENvbmdydWVudCA9IFwi4omiXCI7XG52YXIgTm90Q3VwQ2FwID0gXCLiia1cIjtcbnZhciBOb3REb3VibGVWZXJ0aWNhbEJhciA9IFwi4oimXCI7XG52YXIgTm90RWxlbWVudCA9IFwi4oiJXCI7XG52YXIgTm90RXF1YWwgPSBcIuKJoFwiO1xudmFyIE5vdEVxdWFsVGlsZGUgPSBcIuKJgsy4XCI7XG52YXIgTm90RXhpc3RzID0gXCLiiIRcIjtcbnZhciBOb3RHcmVhdGVyID0gXCLiia9cIjtcbnZhciBOb3RHcmVhdGVyRXF1YWwgPSBcIuKJsVwiO1xudmFyIE5vdEdyZWF0ZXJGdWxsRXF1YWwgPSBcIuKJp8y4XCI7XG52YXIgTm90R3JlYXRlckdyZWF0ZXIgPSBcIuKJq8y4XCI7XG52YXIgTm90R3JlYXRlckxlc3MgPSBcIuKJuVwiO1xudmFyIE5vdEdyZWF0ZXJTbGFudEVxdWFsID0gXCLiqb7MuFwiO1xudmFyIE5vdEdyZWF0ZXJUaWxkZSA9IFwi4om1XCI7XG52YXIgTm90SHVtcERvd25IdW1wID0gXCLiiY7MuFwiO1xudmFyIE5vdEh1bXBFcXVhbCA9IFwi4omPzLhcIjtcbnZhciBub3RpbiA9IFwi4oiJXCI7XG52YXIgbm90aW5kb3QgPSBcIuKLtcy4XCI7XG52YXIgbm90aW5FID0gXCLii7nMuFwiO1xudmFyIG5vdGludmEgPSBcIuKIiVwiO1xudmFyIG5vdGludmIgPSBcIuKLt1wiO1xudmFyIG5vdGludmMgPSBcIuKLtlwiO1xudmFyIE5vdExlZnRUcmlhbmdsZUJhciA9IFwi4qePzLhcIjtcbnZhciBOb3RMZWZ0VHJpYW5nbGUgPSBcIuKLqlwiO1xudmFyIE5vdExlZnRUcmlhbmdsZUVxdWFsID0gXCLii6xcIjtcbnZhciBOb3RMZXNzID0gXCLiia5cIjtcbnZhciBOb3RMZXNzRXF1YWwgPSBcIuKJsFwiO1xudmFyIE5vdExlc3NHcmVhdGVyID0gXCLiibhcIjtcbnZhciBOb3RMZXNzTGVzcyA9IFwi4omqzLhcIjtcbnZhciBOb3RMZXNzU2xhbnRFcXVhbCA9IFwi4qm9zLhcIjtcbnZhciBOb3RMZXNzVGlsZGUgPSBcIuKJtFwiO1xudmFyIE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyID0gXCLiqqLMuFwiO1xudmFyIE5vdE5lc3RlZExlc3NMZXNzID0gXCLiqqHMuFwiO1xudmFyIG5vdG5pID0gXCLiiIxcIjtcbnZhciBub3RuaXZhID0gXCLiiIxcIjtcbnZhciBub3RuaXZiID0gXCLii75cIjtcbnZhciBub3RuaXZjID0gXCLii71cIjtcbnZhciBOb3RQcmVjZWRlcyA9IFwi4oqAXCI7XG52YXIgTm90UHJlY2VkZXNFcXVhbCA9IFwi4qqvzLhcIjtcbnZhciBOb3RQcmVjZWRlc1NsYW50RXF1YWwgPSBcIuKLoFwiO1xudmFyIE5vdFJldmVyc2VFbGVtZW50ID0gXCLiiIxcIjtcbnZhciBOb3RSaWdodFRyaWFuZ2xlQmFyID0gXCLip5DMuFwiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGUgPSBcIuKLq1wiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGVFcXVhbCA9IFwi4outXCI7XG52YXIgTm90U3F1YXJlU3Vic2V0ID0gXCLiio/MuFwiO1xudmFyIE5vdFNxdWFyZVN1YnNldEVxdWFsID0gXCLii6JcIjtcbnZhciBOb3RTcXVhcmVTdXBlcnNldCA9IFwi4oqQzLhcIjtcbnZhciBOb3RTcXVhcmVTdXBlcnNldEVxdWFsID0gXCLii6NcIjtcbnZhciBOb3RTdWJzZXQgPSBcIuKKguKDklwiO1xudmFyIE5vdFN1YnNldEVxdWFsID0gXCLiiohcIjtcbnZhciBOb3RTdWNjZWVkcyA9IFwi4oqBXCI7XG52YXIgTm90U3VjY2VlZHNFcXVhbCA9IFwi4qqwzLhcIjtcbnZhciBOb3RTdWNjZWVkc1NsYW50RXF1YWwgPSBcIuKLoVwiO1xudmFyIE5vdFN1Y2NlZWRzVGlsZGUgPSBcIuKJv8y4XCI7XG52YXIgTm90U3VwZXJzZXQgPSBcIuKKg+KDklwiO1xudmFyIE5vdFN1cGVyc2V0RXF1YWwgPSBcIuKKiVwiO1xudmFyIE5vdFRpbGRlID0gXCLiiYFcIjtcbnZhciBOb3RUaWxkZUVxdWFsID0gXCLiiYRcIjtcbnZhciBOb3RUaWxkZUZ1bGxFcXVhbCA9IFwi4omHXCI7XG52YXIgTm90VGlsZGVUaWxkZSA9IFwi4omJXCI7XG52YXIgTm90VmVydGljYWxCYXIgPSBcIuKIpFwiO1xudmFyIG5wYXJhbGxlbCA9IFwi4oimXCI7XG52YXIgbnBhciA9IFwi4oimXCI7XG52YXIgbnBhcnNsID0gXCLiq73ig6VcIjtcbnZhciBucGFydCA9IFwi4oiCzLhcIjtcbnZhciBucG9saW50ID0gXCLiqJRcIjtcbnZhciBucHIgPSBcIuKKgFwiO1xudmFyIG5wcmN1ZSA9IFwi4ougXCI7XG52YXIgbnByZWMgPSBcIuKKgFwiO1xudmFyIG5wcmVjZXEgPSBcIuKqr8y4XCI7XG52YXIgbnByZSA9IFwi4qqvzLhcIjtcbnZhciBucmFycmMgPSBcIuKks8y4XCI7XG52YXIgbnJhcnIgPSBcIuKGm1wiO1xudmFyIG5yQXJyID0gXCLih49cIjtcbnZhciBucmFycncgPSBcIuKGncy4XCI7XG52YXIgbnJpZ2h0YXJyb3cgPSBcIuKGm1wiO1xudmFyIG5SaWdodGFycm93ID0gXCLih49cIjtcbnZhciBucnRyaSA9IFwi4ourXCI7XG52YXIgbnJ0cmllID0gXCLii61cIjtcbnZhciBuc2MgPSBcIuKKgVwiO1xudmFyIG5zY2N1ZSA9IFwi4ouhXCI7XG52YXIgbnNjZSA9IFwi4qqwzLhcIjtcbnZhciBOc2NyID0gXCLwnZKpXCI7XG52YXIgbnNjciA9IFwi8J2Tg1wiO1xudmFyIG5zaG9ydG1pZCA9IFwi4oikXCI7XG52YXIgbnNob3J0cGFyYWxsZWwgPSBcIuKIplwiO1xudmFyIG5zaW0gPSBcIuKJgVwiO1xudmFyIG5zaW1lID0gXCLiiYRcIjtcbnZhciBuc2ltZXEgPSBcIuKJhFwiO1xudmFyIG5zbWlkID0gXCLiiKRcIjtcbnZhciBuc3BhciA9IFwi4oimXCI7XG52YXIgbnNxc3ViZSA9IFwi4ouiXCI7XG52YXIgbnNxc3VwZSA9IFwi4oujXCI7XG52YXIgbnN1YiA9IFwi4oqEXCI7XG52YXIgbnN1YkUgPSBcIuKrhcy4XCI7XG52YXIgbnN1YmUgPSBcIuKKiFwiO1xudmFyIG5zdWJzZXQgPSBcIuKKguKDklwiO1xudmFyIG5zdWJzZXRlcSA9IFwi4oqIXCI7XG52YXIgbnN1YnNldGVxcSA9IFwi4quFzLhcIjtcbnZhciBuc3VjYyA9IFwi4oqBXCI7XG52YXIgbnN1Y2NlcSA9IFwi4qqwzLhcIjtcbnZhciBuc3VwID0gXCLiioVcIjtcbnZhciBuc3VwRSA9IFwi4quGzLhcIjtcbnZhciBuc3VwZSA9IFwi4oqJXCI7XG52YXIgbnN1cHNldCA9IFwi4oqD4oOSXCI7XG52YXIgbnN1cHNldGVxID0gXCLiiolcIjtcbnZhciBuc3Vwc2V0ZXFxID0gXCLiq4bMuFwiO1xudmFyIG50Z2wgPSBcIuKJuVwiO1xudmFyIE50aWxkZSQxID0gXCLDkVwiO1xudmFyIG50aWxkZSQxID0gXCLDsVwiO1xudmFyIG50bGcgPSBcIuKJuFwiO1xudmFyIG50cmlhbmdsZWxlZnQgPSBcIuKLqlwiO1xudmFyIG50cmlhbmdsZWxlZnRlcSA9IFwi4ousXCI7XG52YXIgbnRyaWFuZ2xlcmlnaHQgPSBcIuKLq1wiO1xudmFyIG50cmlhbmdsZXJpZ2h0ZXEgPSBcIuKLrVwiO1xudmFyIE51ID0gXCLOnVwiO1xudmFyIG51ID0gXCLOvVwiO1xudmFyIG51bSA9IFwiI1wiO1xudmFyIG51bWVybyA9IFwi4oSWXCI7XG52YXIgbnVtc3AgPSBcIuKAh1wiO1xudmFyIG52YXAgPSBcIuKJjeKDklwiO1xudmFyIG52ZGFzaCA9IFwi4oqsXCI7XG52YXIgbnZEYXNoID0gXCLiiq1cIjtcbnZhciBuVmRhc2ggPSBcIuKKrlwiO1xudmFyIG5WRGFzaCA9IFwi4oqvXCI7XG52YXIgbnZnZSA9IFwi4oml4oOSXCI7XG52YXIgbnZndCA9IFwiPuKDklwiO1xudmFyIG52SGFyciA9IFwi4qSEXCI7XG52YXIgbnZpbmZpbiA9IFwi4qeeXCI7XG52YXIgbnZsQXJyID0gXCLipIJcIjtcbnZhciBudmxlID0gXCLiiaTig5JcIjtcbnZhciBudmx0ID0gXCI84oOSXCI7XG52YXIgbnZsdHJpZSA9IFwi4oq04oOSXCI7XG52YXIgbnZyQXJyID0gXCLipINcIjtcbnZhciBudnJ0cmllID0gXCLiirXig5JcIjtcbnZhciBudnNpbSA9IFwi4oi84oOSXCI7XG52YXIgbndhcmhrID0gXCLipKNcIjtcbnZhciBud2FyciA9IFwi4oaWXCI7XG52YXIgbndBcnIgPSBcIuKHllwiO1xudmFyIG53YXJyb3cgPSBcIuKGllwiO1xudmFyIG53bmVhciA9IFwi4qSnXCI7XG52YXIgT2FjdXRlJDEgPSBcIsOTXCI7XG52YXIgb2FjdXRlJDEgPSBcIsOzXCI7XG52YXIgb2FzdCA9IFwi4oqbXCI7XG52YXIgT2NpcmMkMSA9IFwiw5RcIjtcbnZhciBvY2lyYyQxID0gXCLDtFwiO1xudmFyIG9jaXIgPSBcIuKKmlwiO1xudmFyIE9jeSA9IFwi0J5cIjtcbnZhciBvY3kgPSBcItC+XCI7XG52YXIgb2Rhc2ggPSBcIuKKnVwiO1xudmFyIE9kYmxhYyA9IFwixZBcIjtcbnZhciBvZGJsYWMgPSBcIsWRXCI7XG52YXIgb2RpdiA9IFwi4qi4XCI7XG52YXIgb2RvdCA9IFwi4oqZXCI7XG52YXIgb2Rzb2xkID0gXCLiprxcIjtcbnZhciBPRWxpZyA9IFwixZJcIjtcbnZhciBvZWxpZyA9IFwixZNcIjtcbnZhciBvZmNpciA9IFwi4qa/XCI7XG52YXIgT2ZyID0gXCLwnZSSXCI7XG52YXIgb2ZyID0gXCLwnZSsXCI7XG52YXIgb2dvbiA9IFwiy5tcIjtcbnZhciBPZ3JhdmUkMSA9IFwiw5JcIjtcbnZhciBvZ3JhdmUkMSA9IFwiw7JcIjtcbnZhciBvZ3QgPSBcIuKngVwiO1xudmFyIG9oYmFyID0gXCLiprVcIjtcbnZhciBvaG0gPSBcIs6pXCI7XG52YXIgb2ludCA9IFwi4oiuXCI7XG52YXIgb2xhcnIgPSBcIuKGulwiO1xudmFyIG9sY2lyID0gXCLipr5cIjtcbnZhciBvbGNyb3NzID0gXCLiprtcIjtcbnZhciBvbGluZSA9IFwi4oC+XCI7XG52YXIgb2x0ID0gXCLip4BcIjtcbnZhciBPbWFjciA9IFwixYxcIjtcbnZhciBvbWFjciA9IFwixY1cIjtcbnZhciBPbWVnYSA9IFwizqlcIjtcbnZhciBvbWVnYSA9IFwiz4lcIjtcbnZhciBPbWljcm9uID0gXCLOn1wiO1xudmFyIG9taWNyb24gPSBcIs6/XCI7XG52YXIgb21pZCA9IFwi4qa2XCI7XG52YXIgb21pbnVzID0gXCLiipZcIjtcbnZhciBPb3BmID0gXCLwnZWGXCI7XG52YXIgb29wZiA9IFwi8J2VoFwiO1xudmFyIG9wYXIgPSBcIuKmt1wiO1xudmFyIE9wZW5DdXJseURvdWJsZVF1b3RlID0gXCLigJxcIjtcbnZhciBPcGVuQ3VybHlRdW90ZSA9IFwi4oCYXCI7XG52YXIgb3BlcnAgPSBcIuKmuVwiO1xudmFyIG9wbHVzID0gXCLiipVcIjtcbnZhciBvcmFyciA9IFwi4oa7XCI7XG52YXIgT3IgPSBcIuKplFwiO1xudmFyIG9yID0gXCLiiKhcIjtcbnZhciBvcmQgPSBcIuKpnVwiO1xudmFyIG9yZGVyID0gXCLihLRcIjtcbnZhciBvcmRlcm9mID0gXCLihLRcIjtcbnZhciBvcmRmJDEgPSBcIsKqXCI7XG52YXIgb3JkbSQxID0gXCLCulwiO1xudmFyIG9yaWdvZiA9IFwi4oq2XCI7XG52YXIgb3JvciA9IFwi4qmWXCI7XG52YXIgb3JzbG9wZSA9IFwi4qmXXCI7XG52YXIgb3J2ID0gXCLiqZtcIjtcbnZhciBvUyA9IFwi4pOIXCI7XG52YXIgT3NjciA9IFwi8J2SqlwiO1xudmFyIG9zY3IgPSBcIuKEtFwiO1xudmFyIE9zbGFzaCQxID0gXCLDmFwiO1xudmFyIG9zbGFzaCQxID0gXCLDuFwiO1xudmFyIG9zb2wgPSBcIuKKmFwiO1xudmFyIE90aWxkZSQxID0gXCLDlVwiO1xudmFyIG90aWxkZSQxID0gXCLDtVwiO1xudmFyIG90aW1lc2FzID0gXCLiqLZcIjtcbnZhciBPdGltZXMgPSBcIuKot1wiO1xudmFyIG90aW1lcyA9IFwi4oqXXCI7XG52YXIgT3VtbCQxID0gXCLDllwiO1xudmFyIG91bWwkMSA9IFwiw7ZcIjtcbnZhciBvdmJhciA9IFwi4oy9XCI7XG52YXIgT3ZlckJhciA9IFwi4oC+XCI7XG52YXIgT3ZlckJyYWNlID0gXCLij55cIjtcbnZhciBPdmVyQnJhY2tldCA9IFwi4o60XCI7XG52YXIgT3ZlclBhcmVudGhlc2lzID0gXCLij5xcIjtcbnZhciBwYXJhJDEgPSBcIsK2XCI7XG52YXIgcGFyYWxsZWwgPSBcIuKIpVwiO1xudmFyIHBhciA9IFwi4oilXCI7XG52YXIgcGFyc2ltID0gXCLiq7NcIjtcbnZhciBwYXJzbCA9IFwi4qu9XCI7XG52YXIgcGFydCA9IFwi4oiCXCI7XG52YXIgUGFydGlhbEQgPSBcIuKIglwiO1xudmFyIFBjeSA9IFwi0J9cIjtcbnZhciBwY3kgPSBcItC/XCI7XG52YXIgcGVyY250ID0gXCIlXCI7XG52YXIgcGVyaW9kID0gXCIuXCI7XG52YXIgcGVybWlsID0gXCLigLBcIjtcbnZhciBwZXJwID0gXCLiiqVcIjtcbnZhciBwZXJ0ZW5rID0gXCLigLFcIjtcbnZhciBQZnIgPSBcIvCdlJNcIjtcbnZhciBwZnIgPSBcIvCdlK1cIjtcbnZhciBQaGkgPSBcIs6mXCI7XG52YXIgcGhpID0gXCLPhlwiO1xudmFyIHBoaXYgPSBcIs+VXCI7XG52YXIgcGhtbWF0ID0gXCLihLNcIjtcbnZhciBwaG9uZSA9IFwi4piOXCI7XG52YXIgUGkgPSBcIs6gXCI7XG52YXIgcGkgPSBcIs+AXCI7XG52YXIgcGl0Y2hmb3JrID0gXCLii5RcIjtcbnZhciBwaXYgPSBcIs+WXCI7XG52YXIgcGxhbmNrID0gXCLihI9cIjtcbnZhciBwbGFuY2toID0gXCLihI5cIjtcbnZhciBwbGFua3YgPSBcIuKEj1wiO1xudmFyIHBsdXNhY2lyID0gXCLiqKNcIjtcbnZhciBwbHVzYiA9IFwi4oqeXCI7XG52YXIgcGx1c2NpciA9IFwi4qiiXCI7XG52YXIgcGx1cyA9IFwiK1wiO1xudmFyIHBsdXNkbyA9IFwi4oiUXCI7XG52YXIgcGx1c2R1ID0gXCLiqKVcIjtcbnZhciBwbHVzZSA9IFwi4qmyXCI7XG52YXIgUGx1c01pbnVzID0gXCLCsVwiO1xudmFyIHBsdXNtbiQxID0gXCLCsVwiO1xudmFyIHBsdXNzaW0gPSBcIuKoplwiO1xudmFyIHBsdXN0d28gPSBcIuKop1wiO1xudmFyIHBtID0gXCLCsVwiO1xudmFyIFBvaW5jYXJlcGxhbmUgPSBcIuKEjFwiO1xudmFyIHBvaW50aW50ID0gXCLiqJVcIjtcbnZhciBwb3BmID0gXCLwnZWhXCI7XG52YXIgUG9wZiA9IFwi4oSZXCI7XG52YXIgcG91bmQkMSA9IFwiwqNcIjtcbnZhciBwcmFwID0gXCLiqrdcIjtcbnZhciBQciA9IFwi4qq7XCI7XG52YXIgcHIgPSBcIuKJulwiO1xudmFyIHByY3VlID0gXCLiibxcIjtcbnZhciBwcmVjYXBwcm94ID0gXCLiqrdcIjtcbnZhciBwcmVjID0gXCLiibpcIjtcbnZhciBwcmVjY3VybHllcSA9IFwi4om8XCI7XG52YXIgUHJlY2VkZXMgPSBcIuKJulwiO1xudmFyIFByZWNlZGVzRXF1YWwgPSBcIuKqr1wiO1xudmFyIFByZWNlZGVzU2xhbnRFcXVhbCA9IFwi4om8XCI7XG52YXIgUHJlY2VkZXNUaWxkZSA9IFwi4om+XCI7XG52YXIgcHJlY2VxID0gXCLiqq9cIjtcbnZhciBwcmVjbmFwcHJveCA9IFwi4qq5XCI7XG52YXIgcHJlY25lcXEgPSBcIuKqtVwiO1xudmFyIHByZWNuc2ltID0gXCLii6hcIjtcbnZhciBwcmUgPSBcIuKqr1wiO1xudmFyIHByRSA9IFwi4qqzXCI7XG52YXIgcHJlY3NpbSA9IFwi4om+XCI7XG52YXIgcHJpbWUgPSBcIuKAslwiO1xudmFyIFByaW1lID0gXCLigLNcIjtcbnZhciBwcmltZXMgPSBcIuKEmVwiO1xudmFyIHBybmFwID0gXCLiqrlcIjtcbnZhciBwcm5FID0gXCLiqrVcIjtcbnZhciBwcm5zaW0gPSBcIuKLqFwiO1xudmFyIHByb2QgPSBcIuKIj1wiO1xudmFyIFByb2R1Y3QgPSBcIuKIj1wiO1xudmFyIHByb2ZhbGFyID0gXCLijK5cIjtcbnZhciBwcm9mbGluZSA9IFwi4oySXCI7XG52YXIgcHJvZnN1cmYgPSBcIuKMk1wiO1xudmFyIHByb3AgPSBcIuKInVwiO1xudmFyIFByb3BvcnRpb25hbCA9IFwi4oidXCI7XG52YXIgUHJvcG9ydGlvbiA9IFwi4oi3XCI7XG52YXIgcHJvcHRvID0gXCLiiJ1cIjtcbnZhciBwcnNpbSA9IFwi4om+XCI7XG52YXIgcHJ1cmVsID0gXCLiirBcIjtcbnZhciBQc2NyID0gXCLwnZKrXCI7XG52YXIgcHNjciA9IFwi8J2ThVwiO1xudmFyIFBzaSA9IFwizqhcIjtcbnZhciBwc2kgPSBcIs+IXCI7XG52YXIgcHVuY3NwID0gXCLigIhcIjtcbnZhciBRZnIgPSBcIvCdlJRcIjtcbnZhciBxZnIgPSBcIvCdlK5cIjtcbnZhciBxaW50ID0gXCLiqIxcIjtcbnZhciBxb3BmID0gXCLwnZWiXCI7XG52YXIgUW9wZiA9IFwi4oSaXCI7XG52YXIgcXByaW1lID0gXCLigZdcIjtcbnZhciBRc2NyID0gXCLwnZKsXCI7XG52YXIgcXNjciA9IFwi8J2ThlwiO1xudmFyIHF1YXRlcm5pb25zID0gXCLihI1cIjtcbnZhciBxdWF0aW50ID0gXCLiqJZcIjtcbnZhciBxdWVzdCA9IFwiP1wiO1xudmFyIHF1ZXN0ZXEgPSBcIuKJn1wiO1xudmFyIHF1b3QkMiA9IFwiXFxcIlwiO1xudmFyIFFVT1QkMSA9IFwiXFxcIlwiO1xudmFyIHJBYXJyID0gXCLih5tcIjtcbnZhciByYWNlID0gXCLiiL3MsVwiO1xudmFyIFJhY3V0ZSA9IFwixZRcIjtcbnZhciByYWN1dGUgPSBcIsWVXCI7XG52YXIgcmFkaWMgPSBcIuKImlwiO1xudmFyIHJhZW1wdHl2ID0gXCLiprNcIjtcbnZhciByYW5nID0gXCLin6lcIjtcbnZhciBSYW5nID0gXCLin6tcIjtcbnZhciByYW5nZCA9IFwi4qaSXCI7XG52YXIgcmFuZ2UgPSBcIuKmpVwiO1xudmFyIHJhbmdsZSA9IFwi4p+pXCI7XG52YXIgcmFxdW8kMSA9IFwiwrtcIjtcbnZhciByYXJyYXAgPSBcIuKltVwiO1xudmFyIHJhcnJiID0gXCLih6VcIjtcbnZhciByYXJyYmZzID0gXCLipKBcIjtcbnZhciByYXJyYyA9IFwi4qSzXCI7XG52YXIgcmFyciA9IFwi4oaSXCI7XG52YXIgUmFyciA9IFwi4oagXCI7XG52YXIgckFyciA9IFwi4oeSXCI7XG52YXIgcmFycmZzID0gXCLipJ5cIjtcbnZhciByYXJyaGsgPSBcIuKGqlwiO1xudmFyIHJhcnJscCA9IFwi4oasXCI7XG52YXIgcmFycnBsID0gXCLipYVcIjtcbnZhciByYXJyc2ltID0gXCLipbRcIjtcbnZhciBSYXJydGwgPSBcIuKkllwiO1xudmFyIHJhcnJ0bCA9IFwi4oajXCI7XG52YXIgcmFycncgPSBcIuKGnVwiO1xudmFyIHJhdGFpbCA9IFwi4qSaXCI7XG52YXIgckF0YWlsID0gXCLipJxcIjtcbnZhciByYXRpbyA9IFwi4oi2XCI7XG52YXIgcmF0aW9uYWxzID0gXCLihJpcIjtcbnZhciByYmFyciA9IFwi4qSNXCI7XG52YXIgckJhcnIgPSBcIuKkj1wiO1xudmFyIFJCYXJyID0gXCLipJBcIjtcbnZhciByYmJyayA9IFwi4p2zXCI7XG52YXIgcmJyYWNlID0gXCJ9XCI7XG52YXIgcmJyYWNrID0gXCJdXCI7XG52YXIgcmJya2UgPSBcIuKmjFwiO1xudmFyIHJicmtzbGQgPSBcIuKmjlwiO1xudmFyIHJicmtzbHUgPSBcIuKmkFwiO1xudmFyIFJjYXJvbiA9IFwixZhcIjtcbnZhciByY2Fyb24gPSBcIsWZXCI7XG52YXIgUmNlZGlsID0gXCLFllwiO1xudmFyIHJjZWRpbCA9IFwixZdcIjtcbnZhciByY2VpbCA9IFwi4oyJXCI7XG52YXIgcmN1YiA9IFwifVwiO1xudmFyIFJjeSA9IFwi0KBcIjtcbnZhciByY3kgPSBcItGAXCI7XG52YXIgcmRjYSA9IFwi4qS3XCI7XG52YXIgcmRsZGhhciA9IFwi4qWpXCI7XG52YXIgcmRxdW8gPSBcIuKAnVwiO1xudmFyIHJkcXVvciA9IFwi4oCdXCI7XG52YXIgcmRzaCA9IFwi4oazXCI7XG52YXIgcmVhbCA9IFwi4oScXCI7XG52YXIgcmVhbGluZSA9IFwi4oSbXCI7XG52YXIgcmVhbHBhcnQgPSBcIuKEnFwiO1xudmFyIHJlYWxzID0gXCLihJ1cIjtcbnZhciBSZSA9IFwi4oScXCI7XG52YXIgcmVjdCA9IFwi4patXCI7XG52YXIgcmVnJDEgPSBcIsKuXCI7XG52YXIgUkVHJDEgPSBcIsKuXCI7XG52YXIgUmV2ZXJzZUVsZW1lbnQgPSBcIuKIi1wiO1xudmFyIFJldmVyc2VFcXVpbGlicml1bSA9IFwi4oeLXCI7XG52YXIgUmV2ZXJzZVVwRXF1aWxpYnJpdW0gPSBcIuKlr1wiO1xudmFyIHJmaXNodCA9IFwi4qW9XCI7XG52YXIgcmZsb29yID0gXCLijItcIjtcbnZhciByZnIgPSBcIvCdlK9cIjtcbnZhciBSZnIgPSBcIuKEnFwiO1xudmFyIHJIYXIgPSBcIuKlpFwiO1xudmFyIHJoYXJkID0gXCLih4FcIjtcbnZhciByaGFydSA9IFwi4oeAXCI7XG52YXIgcmhhcnVsID0gXCLipaxcIjtcbnZhciBSaG8gPSBcIs6hXCI7XG52YXIgcmhvID0gXCLPgVwiO1xudmFyIHJob3YgPSBcIs+xXCI7XG52YXIgUmlnaHRBbmdsZUJyYWNrZXQgPSBcIuKfqVwiO1xudmFyIFJpZ2h0QXJyb3dCYXIgPSBcIuKHpVwiO1xudmFyIHJpZ2h0YXJyb3cgPSBcIuKGklwiO1xudmFyIFJpZ2h0QXJyb3cgPSBcIuKGklwiO1xudmFyIFJpZ2h0YXJyb3cgPSBcIuKHklwiO1xudmFyIFJpZ2h0QXJyb3dMZWZ0QXJyb3cgPSBcIuKHhFwiO1xudmFyIHJpZ2h0YXJyb3d0YWlsID0gXCLihqNcIjtcbnZhciBSaWdodENlaWxpbmcgPSBcIuKMiVwiO1xudmFyIFJpZ2h0RG91YmxlQnJhY2tldCA9IFwi4p+nXCI7XG52YXIgUmlnaHREb3duVGVlVmVjdG9yID0gXCLipZ1cIjtcbnZhciBSaWdodERvd25WZWN0b3JCYXIgPSBcIuKllVwiO1xudmFyIFJpZ2h0RG93blZlY3RvciA9IFwi4oeCXCI7XG52YXIgUmlnaHRGbG9vciA9IFwi4oyLXCI7XG52YXIgcmlnaHRoYXJwb29uZG93biA9IFwi4oeBXCI7XG52YXIgcmlnaHRoYXJwb29udXAgPSBcIuKHgFwiO1xudmFyIHJpZ2h0bGVmdGFycm93cyA9IFwi4oeEXCI7XG52YXIgcmlnaHRsZWZ0aGFycG9vbnMgPSBcIuKHjFwiO1xudmFyIHJpZ2h0cmlnaHRhcnJvd3MgPSBcIuKHiVwiO1xudmFyIHJpZ2h0c3F1aWdhcnJvdyA9IFwi4oadXCI7XG52YXIgUmlnaHRUZWVBcnJvdyA9IFwi4oamXCI7XG52YXIgUmlnaHRUZWUgPSBcIuKKolwiO1xudmFyIFJpZ2h0VGVlVmVjdG9yID0gXCLipZtcIjtcbnZhciByaWdodHRocmVldGltZXMgPSBcIuKLjFwiO1xudmFyIFJpZ2h0VHJpYW5nbGVCYXIgPSBcIuKnkFwiO1xudmFyIFJpZ2h0VHJpYW5nbGUgPSBcIuKKs1wiO1xudmFyIFJpZ2h0VHJpYW5nbGVFcXVhbCA9IFwi4oq1XCI7XG52YXIgUmlnaHRVcERvd25WZWN0b3IgPSBcIuKlj1wiO1xudmFyIFJpZ2h0VXBUZWVWZWN0b3IgPSBcIuKlnFwiO1xudmFyIFJpZ2h0VXBWZWN0b3JCYXIgPSBcIuKllFwiO1xudmFyIFJpZ2h0VXBWZWN0b3IgPSBcIuKGvlwiO1xudmFyIFJpZ2h0VmVjdG9yQmFyID0gXCLipZNcIjtcbnZhciBSaWdodFZlY3RvciA9IFwi4oeAXCI7XG52YXIgcmluZyA9IFwiy5pcIjtcbnZhciByaXNpbmdkb3RzZXEgPSBcIuKJk1wiO1xudmFyIHJsYXJyID0gXCLih4RcIjtcbnZhciBybGhhciA9IFwi4oeMXCI7XG52YXIgcmxtID0gXCLigI9cIjtcbnZhciBybW91c3RhY2hlID0gXCLijrFcIjtcbnZhciBybW91c3QgPSBcIuKOsVwiO1xudmFyIHJubWlkID0gXCLiq65cIjtcbnZhciByb2FuZyA9IFwi4p+tXCI7XG52YXIgcm9hcnIgPSBcIuKHvlwiO1xudmFyIHJvYnJrID0gXCLin6dcIjtcbnZhciByb3BhciA9IFwi4qaGXCI7XG52YXIgcm9wZiA9IFwi8J2Vo1wiO1xudmFyIFJvcGYgPSBcIuKEnVwiO1xudmFyIHJvcGx1cyA9IFwi4qiuXCI7XG52YXIgcm90aW1lcyA9IFwi4qi1XCI7XG52YXIgUm91bmRJbXBsaWVzID0gXCLipbBcIjtcbnZhciBycGFyID0gXCIpXCI7XG52YXIgcnBhcmd0ID0gXCLippRcIjtcbnZhciBycHBvbGludCA9IFwi4qiSXCI7XG52YXIgcnJhcnIgPSBcIuKHiVwiO1xudmFyIFJyaWdodGFycm93ID0gXCLih5tcIjtcbnZhciByc2FxdW8gPSBcIuKAulwiO1xudmFyIHJzY3IgPSBcIvCdk4dcIjtcbnZhciBSc2NyID0gXCLihJtcIjtcbnZhciByc2ggPSBcIuKGsVwiO1xudmFyIFJzaCA9IFwi4oaxXCI7XG52YXIgcnNxYiA9IFwiXVwiO1xudmFyIHJzcXVvID0gXCLigJlcIjtcbnZhciByc3F1b3IgPSBcIuKAmVwiO1xudmFyIHJ0aHJlZSA9IFwi4ouMXCI7XG52YXIgcnRpbWVzID0gXCLii4pcIjtcbnZhciBydHJpID0gXCLilrlcIjtcbnZhciBydHJpZSA9IFwi4oq1XCI7XG52YXIgcnRyaWYgPSBcIuKWuFwiO1xudmFyIHJ0cmlsdHJpID0gXCLip45cIjtcbnZhciBSdWxlRGVsYXllZCA9IFwi4qe0XCI7XG52YXIgcnVsdWhhciA9IFwi4qWoXCI7XG52YXIgcnggPSBcIuKEnlwiO1xudmFyIFNhY3V0ZSA9IFwixZpcIjtcbnZhciBzYWN1dGUgPSBcIsWbXCI7XG52YXIgc2JxdW8gPSBcIuKAmlwiO1xudmFyIHNjYXAgPSBcIuKquFwiO1xudmFyIFNjYXJvbiA9IFwixaBcIjtcbnZhciBzY2Fyb24gPSBcIsWhXCI7XG52YXIgU2MgPSBcIuKqvFwiO1xudmFyIHNjID0gXCLiibtcIjtcbnZhciBzY2N1ZSA9IFwi4om9XCI7XG52YXIgc2NlID0gXCLiqrBcIjtcbnZhciBzY0UgPSBcIuKqtFwiO1xudmFyIFNjZWRpbCA9IFwixZ5cIjtcbnZhciBzY2VkaWwgPSBcIsWfXCI7XG52YXIgU2NpcmMgPSBcIsWcXCI7XG52YXIgc2NpcmMgPSBcIsWdXCI7XG52YXIgc2NuYXAgPSBcIuKqulwiO1xudmFyIHNjbkUgPSBcIuKqtlwiO1xudmFyIHNjbnNpbSA9IFwi4oupXCI7XG52YXIgc2Nwb2xpbnQgPSBcIuKok1wiO1xudmFyIHNjc2ltID0gXCLiib9cIjtcbnZhciBTY3kgPSBcItChXCI7XG52YXIgc2N5ID0gXCLRgVwiO1xudmFyIHNkb3RiID0gXCLiiqFcIjtcbnZhciBzZG90ID0gXCLii4VcIjtcbnZhciBzZG90ZSA9IFwi4qmmXCI7XG52YXIgc2VhcmhrID0gXCLipKVcIjtcbnZhciBzZWFyciA9IFwi4oaYXCI7XG52YXIgc2VBcnIgPSBcIuKHmFwiO1xudmFyIHNlYXJyb3cgPSBcIuKGmFwiO1xudmFyIHNlY3QkMSA9IFwiwqdcIjtcbnZhciBzZW1pID0gXCI7XCI7XG52YXIgc2Vzd2FyID0gXCLipKlcIjtcbnZhciBzZXRtaW51cyA9IFwi4oiWXCI7XG52YXIgc2V0bW4gPSBcIuKIllwiO1xudmFyIHNleHQgPSBcIuKctlwiO1xudmFyIFNmciA9IFwi8J2UllwiO1xudmFyIHNmciA9IFwi8J2UsFwiO1xudmFyIHNmcm93biA9IFwi4oyiXCI7XG52YXIgc2hhcnAgPSBcIuKZr1wiO1xudmFyIFNIQ0hjeSA9IFwi0KlcIjtcbnZhciBzaGNoY3kgPSBcItGJXCI7XG52YXIgU0hjeSA9IFwi0KhcIjtcbnZhciBzaGN5ID0gXCLRiFwiO1xudmFyIFNob3J0RG93bkFycm93ID0gXCLihpNcIjtcbnZhciBTaG9ydExlZnRBcnJvdyA9IFwi4oaQXCI7XG52YXIgc2hvcnRtaWQgPSBcIuKIo1wiO1xudmFyIHNob3J0cGFyYWxsZWwgPSBcIuKIpVwiO1xudmFyIFNob3J0UmlnaHRBcnJvdyA9IFwi4oaSXCI7XG52YXIgU2hvcnRVcEFycm93ID0gXCLihpFcIjtcbnZhciBzaHkkMSA9IFwiwq1cIjtcbnZhciBTaWdtYSA9IFwizqNcIjtcbnZhciBzaWdtYSA9IFwiz4NcIjtcbnZhciBzaWdtYWYgPSBcIs+CXCI7XG52YXIgc2lnbWF2ID0gXCLPglwiO1xudmFyIHNpbSA9IFwi4oi8XCI7XG52YXIgc2ltZG90ID0gXCLiqapcIjtcbnZhciBzaW1lID0gXCLiiYNcIjtcbnZhciBzaW1lcSA9IFwi4omDXCI7XG52YXIgc2ltZyA9IFwi4qqeXCI7XG52YXIgc2ltZ0UgPSBcIuKqoFwiO1xudmFyIHNpbWwgPSBcIuKqnVwiO1xudmFyIHNpbWxFID0gXCLiqp9cIjtcbnZhciBzaW1uZSA9IFwi4omGXCI7XG52YXIgc2ltcGx1cyA9IFwi4qikXCI7XG52YXIgc2ltcmFyciA9IFwi4qWyXCI7XG52YXIgc2xhcnIgPSBcIuKGkFwiO1xudmFyIFNtYWxsQ2lyY2xlID0gXCLiiJhcIjtcbnZhciBzbWFsbHNldG1pbnVzID0gXCLiiJZcIjtcbnZhciBzbWFzaHAgPSBcIuKos1wiO1xudmFyIHNtZXBhcnNsID0gXCLip6RcIjtcbnZhciBzbWlkID0gXCLiiKNcIjtcbnZhciBzbWlsZSA9IFwi4oyjXCI7XG52YXIgc210ID0gXCLiqqpcIjtcbnZhciBzbXRlID0gXCLiqqxcIjtcbnZhciBzbXRlcyA9IFwi4qqs77iAXCI7XG52YXIgU09GVGN5ID0gXCLQrFwiO1xudmFyIHNvZnRjeSA9IFwi0YxcIjtcbnZhciBzb2xiYXIgPSBcIuKMv1wiO1xudmFyIHNvbGIgPSBcIuKnhFwiO1xudmFyIHNvbCA9IFwiL1wiO1xudmFyIFNvcGYgPSBcIvCdlYpcIjtcbnZhciBzb3BmID0gXCLwnZWkXCI7XG52YXIgc3BhZGVzID0gXCLimaBcIjtcbnZhciBzcGFkZXN1aXQgPSBcIuKZoFwiO1xudmFyIHNwYXIgPSBcIuKIpVwiO1xudmFyIHNxY2FwID0gXCLiipNcIjtcbnZhciBzcWNhcHMgPSBcIuKKk++4gFwiO1xudmFyIHNxY3VwID0gXCLiipRcIjtcbnZhciBzcWN1cHMgPSBcIuKKlO+4gFwiO1xudmFyIFNxcnQgPSBcIuKImlwiO1xudmFyIHNxc3ViID0gXCLiio9cIjtcbnZhciBzcXN1YmUgPSBcIuKKkVwiO1xudmFyIHNxc3Vic2V0ID0gXCLiio9cIjtcbnZhciBzcXN1YnNldGVxID0gXCLiipFcIjtcbnZhciBzcXN1cCA9IFwi4oqQXCI7XG52YXIgc3FzdXBlID0gXCLiipJcIjtcbnZhciBzcXN1cHNldCA9IFwi4oqQXCI7XG52YXIgc3FzdXBzZXRlcSA9IFwi4oqSXCI7XG52YXIgc3F1YXJlID0gXCLilqFcIjtcbnZhciBTcXVhcmUgPSBcIuKWoVwiO1xudmFyIFNxdWFyZUludGVyc2VjdGlvbiA9IFwi4oqTXCI7XG52YXIgU3F1YXJlU3Vic2V0ID0gXCLiio9cIjtcbnZhciBTcXVhcmVTdWJzZXRFcXVhbCA9IFwi4oqRXCI7XG52YXIgU3F1YXJlU3VwZXJzZXQgPSBcIuKKkFwiO1xudmFyIFNxdWFyZVN1cGVyc2V0RXF1YWwgPSBcIuKKklwiO1xudmFyIFNxdWFyZVVuaW9uID0gXCLiipRcIjtcbnZhciBzcXVhcmYgPSBcIuKWqlwiO1xudmFyIHNxdSA9IFwi4pahXCI7XG52YXIgc3F1ZiA9IFwi4paqXCI7XG52YXIgc3JhcnIgPSBcIuKGklwiO1xudmFyIFNzY3IgPSBcIvCdkq5cIjtcbnZhciBzc2NyID0gXCLwnZOIXCI7XG52YXIgc3NldG1uID0gXCLiiJZcIjtcbnZhciBzc21pbGUgPSBcIuKMo1wiO1xudmFyIHNzdGFyZiA9IFwi4ouGXCI7XG52YXIgU3RhciA9IFwi4ouGXCI7XG52YXIgc3RhciA9IFwi4piGXCI7XG52YXIgc3RhcmYgPSBcIuKYhVwiO1xudmFyIHN0cmFpZ2h0ZXBzaWxvbiA9IFwiz7VcIjtcbnZhciBzdHJhaWdodHBoaSA9IFwiz5VcIjtcbnZhciBzdHJucyA9IFwiwq9cIjtcbnZhciBzdWIgPSBcIuKKglwiO1xudmFyIFN1YiA9IFwi4ouQXCI7XG52YXIgc3ViZG90ID0gXCLiqr1cIjtcbnZhciBzdWJFID0gXCLiq4VcIjtcbnZhciBzdWJlID0gXCLiioZcIjtcbnZhciBzdWJlZG90ID0gXCLiq4NcIjtcbnZhciBzdWJtdWx0ID0gXCLiq4FcIjtcbnZhciBzdWJuRSA9IFwi4quLXCI7XG52YXIgc3VibmUgPSBcIuKKilwiO1xudmFyIHN1YnBsdXMgPSBcIuKqv1wiO1xudmFyIHN1YnJhcnIgPSBcIuKluVwiO1xudmFyIHN1YnNldCA9IFwi4oqCXCI7XG52YXIgU3Vic2V0ID0gXCLii5BcIjtcbnZhciBzdWJzZXRlcSA9IFwi4oqGXCI7XG52YXIgc3Vic2V0ZXFxID0gXCLiq4VcIjtcbnZhciBTdWJzZXRFcXVhbCA9IFwi4oqGXCI7XG52YXIgc3Vic2V0bmVxID0gXCLiiopcIjtcbnZhciBzdWJzZXRuZXFxID0gXCLiq4tcIjtcbnZhciBzdWJzaW0gPSBcIuKrh1wiO1xudmFyIHN1YnN1YiA9IFwi4quVXCI7XG52YXIgc3Vic3VwID0gXCLiq5NcIjtcbnZhciBzdWNjYXBwcm94ID0gXCLiqrhcIjtcbnZhciBzdWNjID0gXCLiibtcIjtcbnZhciBzdWNjY3VybHllcSA9IFwi4om9XCI7XG52YXIgU3VjY2VlZHMgPSBcIuKJu1wiO1xudmFyIFN1Y2NlZWRzRXF1YWwgPSBcIuKqsFwiO1xudmFyIFN1Y2NlZWRzU2xhbnRFcXVhbCA9IFwi4om9XCI7XG52YXIgU3VjY2VlZHNUaWxkZSA9IFwi4om/XCI7XG52YXIgc3VjY2VxID0gXCLiqrBcIjtcbnZhciBzdWNjbmFwcHJveCA9IFwi4qq6XCI7XG52YXIgc3VjY25lcXEgPSBcIuKqtlwiO1xudmFyIHN1Y2Nuc2ltID0gXCLii6lcIjtcbnZhciBzdWNjc2ltID0gXCLiib9cIjtcbnZhciBTdWNoVGhhdCA9IFwi4oiLXCI7XG52YXIgc3VtID0gXCLiiJFcIjtcbnZhciBTdW0gPSBcIuKIkVwiO1xudmFyIHN1bmcgPSBcIuKZqlwiO1xudmFyIHN1cDEkMSA9IFwiwrlcIjtcbnZhciBzdXAyJDEgPSBcIsKyXCI7XG52YXIgc3VwMyQxID0gXCLCs1wiO1xudmFyIHN1cCA9IFwi4oqDXCI7XG52YXIgU3VwID0gXCLii5FcIjtcbnZhciBzdXBkb3QgPSBcIuKqvlwiO1xudmFyIHN1cGRzdWIgPSBcIuKrmFwiO1xudmFyIHN1cEUgPSBcIuKrhlwiO1xudmFyIHN1cGUgPSBcIuKKh1wiO1xudmFyIHN1cGVkb3QgPSBcIuKrhFwiO1xudmFyIFN1cGVyc2V0ID0gXCLiioNcIjtcbnZhciBTdXBlcnNldEVxdWFsID0gXCLiiodcIjtcbnZhciBzdXBoc29sID0gXCLin4lcIjtcbnZhciBzdXBoc3ViID0gXCLiq5dcIjtcbnZhciBzdXBsYXJyID0gXCLipbtcIjtcbnZhciBzdXBtdWx0ID0gXCLiq4JcIjtcbnZhciBzdXBuRSA9IFwi4quMXCI7XG52YXIgc3VwbmUgPSBcIuKKi1wiO1xudmFyIHN1cHBsdXMgPSBcIuKrgFwiO1xudmFyIHN1cHNldCA9IFwi4oqDXCI7XG52YXIgU3Vwc2V0ID0gXCLii5FcIjtcbnZhciBzdXBzZXRlcSA9IFwi4oqHXCI7XG52YXIgc3Vwc2V0ZXFxID0gXCLiq4ZcIjtcbnZhciBzdXBzZXRuZXEgPSBcIuKKi1wiO1xudmFyIHN1cHNldG5lcXEgPSBcIuKrjFwiO1xudmFyIHN1cHNpbSA9IFwi4quIXCI7XG52YXIgc3Vwc3ViID0gXCLiq5RcIjtcbnZhciBzdXBzdXAgPSBcIuKrllwiO1xudmFyIHN3YXJoayA9IFwi4qSmXCI7XG52YXIgc3dhcnIgPSBcIuKGmVwiO1xudmFyIHN3QXJyID0gXCLih5lcIjtcbnZhciBzd2Fycm93ID0gXCLihplcIjtcbnZhciBzd253YXIgPSBcIuKkqlwiO1xudmFyIHN6bGlnJDEgPSBcIsOfXCI7XG52YXIgVGFiID0gXCJcXHRcIjtcbnZhciB0YXJnZXQgPSBcIuKMllwiO1xudmFyIFRhdSA9IFwizqRcIjtcbnZhciB0YXUgPSBcIs+EXCI7XG52YXIgdGJyayA9IFwi4o60XCI7XG52YXIgVGNhcm9uID0gXCLFpFwiO1xudmFyIHRjYXJvbiA9IFwixaVcIjtcbnZhciBUY2VkaWwgPSBcIsWiXCI7XG52YXIgdGNlZGlsID0gXCLFo1wiO1xudmFyIFRjeSA9IFwi0KJcIjtcbnZhciB0Y3kgPSBcItGCXCI7XG52YXIgdGRvdCA9IFwi4oObXCI7XG52YXIgdGVscmVjID0gXCLijJVcIjtcbnZhciBUZnIgPSBcIvCdlJdcIjtcbnZhciB0ZnIgPSBcIvCdlLFcIjtcbnZhciB0aGVyZTQgPSBcIuKItFwiO1xudmFyIHRoZXJlZm9yZSA9IFwi4oi0XCI7XG52YXIgVGhlcmVmb3JlID0gXCLiiLRcIjtcbnZhciBUaGV0YSA9IFwizphcIjtcbnZhciB0aGV0YSA9IFwizrhcIjtcbnZhciB0aGV0YXN5bSA9IFwiz5FcIjtcbnZhciB0aGV0YXYgPSBcIs+RXCI7XG52YXIgdGhpY2thcHByb3ggPSBcIuKJiFwiO1xudmFyIHRoaWNrc2ltID0gXCLiiLxcIjtcbnZhciBUaGlja1NwYWNlID0gXCLigZ/igIpcIjtcbnZhciBUaGluU3BhY2UgPSBcIuKAiVwiO1xudmFyIHRoaW5zcCA9IFwi4oCJXCI7XG52YXIgdGhrYXAgPSBcIuKJiFwiO1xudmFyIHRoa3NpbSA9IFwi4oi8XCI7XG52YXIgVEhPUk4kMSA9IFwiw55cIjtcbnZhciB0aG9ybiQxID0gXCLDvlwiO1xudmFyIHRpbGRlID0gXCLLnFwiO1xudmFyIFRpbGRlID0gXCLiiLxcIjtcbnZhciBUaWxkZUVxdWFsID0gXCLiiYNcIjtcbnZhciBUaWxkZUZ1bGxFcXVhbCA9IFwi4omFXCI7XG52YXIgVGlsZGVUaWxkZSA9IFwi4omIXCI7XG52YXIgdGltZXNiYXIgPSBcIuKosVwiO1xudmFyIHRpbWVzYiA9IFwi4oqgXCI7XG52YXIgdGltZXMkMSA9IFwiw5dcIjtcbnZhciB0aW1lc2QgPSBcIuKosFwiO1xudmFyIHRpbnQgPSBcIuKIrVwiO1xudmFyIHRvZWEgPSBcIuKkqFwiO1xudmFyIHRvcGJvdCA9IFwi4oy2XCI7XG52YXIgdG9wY2lyID0gXCLiq7FcIjtcbnZhciBlc21fdG9wID0gXCLiiqRcIjtcbnZhciBUb3BmID0gXCLwnZWLXCI7XG52YXIgdG9wZiA9IFwi8J2VpVwiO1xudmFyIHRvcGZvcmsgPSBcIuKrmlwiO1xudmFyIHRvc2EgPSBcIuKkqVwiO1xudmFyIHRwcmltZSA9IFwi4oC0XCI7XG52YXIgdHJhZGUgPSBcIuKEolwiO1xudmFyIFRSQURFID0gXCLihKJcIjtcbnZhciB0cmlhbmdsZSA9IFwi4pa1XCI7XG52YXIgdHJpYW5nbGVkb3duID0gXCLilr9cIjtcbnZhciB0cmlhbmdsZWxlZnQgPSBcIuKXg1wiO1xudmFyIHRyaWFuZ2xlbGVmdGVxID0gXCLiirRcIjtcbnZhciB0cmlhbmdsZXEgPSBcIuKJnFwiO1xudmFyIHRyaWFuZ2xlcmlnaHQgPSBcIuKWuVwiO1xudmFyIHRyaWFuZ2xlcmlnaHRlcSA9IFwi4oq1XCI7XG52YXIgdHJpZG90ID0gXCLil6xcIjtcbnZhciB0cmllID0gXCLiiZxcIjtcbnZhciB0cmltaW51cyA9IFwi4qi6XCI7XG52YXIgVHJpcGxlRG90ID0gXCLig5tcIjtcbnZhciB0cmlwbHVzID0gXCLiqLlcIjtcbnZhciB0cmlzYiA9IFwi4qeNXCI7XG52YXIgdHJpdGltZSA9IFwi4qi7XCI7XG52YXIgdHJwZXppdW0gPSBcIuKPolwiO1xudmFyIFRzY3IgPSBcIvCdkq9cIjtcbnZhciB0c2NyID0gXCLwnZOJXCI7XG52YXIgVFNjeSA9IFwi0KZcIjtcbnZhciB0c2N5ID0gXCLRhlwiO1xudmFyIFRTSGN5ID0gXCLQi1wiO1xudmFyIHRzaGN5ID0gXCLRm1wiO1xudmFyIFRzdHJvayA9IFwixaZcIjtcbnZhciB0c3Ryb2sgPSBcIsWnXCI7XG52YXIgdHdpeHQgPSBcIuKJrFwiO1xudmFyIHR3b2hlYWRsZWZ0YXJyb3cgPSBcIuKGnlwiO1xudmFyIHR3b2hlYWRyaWdodGFycm93ID0gXCLihqBcIjtcbnZhciBVYWN1dGUkMSA9IFwiw5pcIjtcbnZhciB1YWN1dGUkMSA9IFwiw7pcIjtcbnZhciB1YXJyID0gXCLihpFcIjtcbnZhciBVYXJyID0gXCLihp9cIjtcbnZhciB1QXJyID0gXCLih5FcIjtcbnZhciBVYXJyb2NpciA9IFwi4qWJXCI7XG52YXIgVWJyY3kgPSBcItCOXCI7XG52YXIgdWJyY3kgPSBcItGeXCI7XG52YXIgVWJyZXZlID0gXCLFrFwiO1xudmFyIHVicmV2ZSA9IFwixa1cIjtcbnZhciBVY2lyYyQxID0gXCLDm1wiO1xudmFyIHVjaXJjJDEgPSBcIsO7XCI7XG52YXIgVWN5ID0gXCLQo1wiO1xudmFyIHVjeSA9IFwi0YNcIjtcbnZhciB1ZGFyciA9IFwi4oeFXCI7XG52YXIgVWRibGFjID0gXCLFsFwiO1xudmFyIHVkYmxhYyA9IFwixbFcIjtcbnZhciB1ZGhhciA9IFwi4qWuXCI7XG52YXIgdWZpc2h0ID0gXCLipb5cIjtcbnZhciBVZnIgPSBcIvCdlJhcIjtcbnZhciB1ZnIgPSBcIvCdlLJcIjtcbnZhciBVZ3JhdmUkMSA9IFwiw5lcIjtcbnZhciB1Z3JhdmUkMSA9IFwiw7lcIjtcbnZhciB1SGFyID0gXCLipaNcIjtcbnZhciB1aGFybCA9IFwi4oa/XCI7XG52YXIgdWhhcnIgPSBcIuKGvlwiO1xudmFyIHVoYmxrID0gXCLiloBcIjtcbnZhciB1bGNvcm4gPSBcIuKMnFwiO1xudmFyIHVsY29ybmVyID0gXCLijJxcIjtcbnZhciB1bGNyb3AgPSBcIuKMj1wiO1xudmFyIHVsdHJpID0gXCLil7hcIjtcbnZhciBVbWFjciA9IFwixapcIjtcbnZhciB1bWFjciA9IFwixatcIjtcbnZhciB1bWwkMSA9IFwiwqhcIjtcbnZhciBVbmRlckJhciA9IFwiX1wiO1xudmFyIFVuZGVyQnJhY2UgPSBcIuKPn1wiO1xudmFyIFVuZGVyQnJhY2tldCA9IFwi4o61XCI7XG52YXIgVW5kZXJQYXJlbnRoZXNpcyA9IFwi4o+dXCI7XG52YXIgVW5pb24gPSBcIuKLg1wiO1xudmFyIFVuaW9uUGx1cyA9IFwi4oqOXCI7XG52YXIgVW9nb24gPSBcIsWyXCI7XG52YXIgdW9nb24gPSBcIsWzXCI7XG52YXIgVW9wZiA9IFwi8J2VjFwiO1xudmFyIHVvcGYgPSBcIvCdlaZcIjtcbnZhciBVcEFycm93QmFyID0gXCLipJJcIjtcbnZhciB1cGFycm93ID0gXCLihpFcIjtcbnZhciBVcEFycm93ID0gXCLihpFcIjtcbnZhciBVcGFycm93ID0gXCLih5FcIjtcbnZhciBVcEFycm93RG93bkFycm93ID0gXCLih4VcIjtcbnZhciB1cGRvd25hcnJvdyA9IFwi4oaVXCI7XG52YXIgVXBEb3duQXJyb3cgPSBcIuKGlVwiO1xudmFyIFVwZG93bmFycm93ID0gXCLih5VcIjtcbnZhciBVcEVxdWlsaWJyaXVtID0gXCLipa5cIjtcbnZhciB1cGhhcnBvb25sZWZ0ID0gXCLihr9cIjtcbnZhciB1cGhhcnBvb25yaWdodCA9IFwi4oa+XCI7XG52YXIgdXBsdXMgPSBcIuKKjlwiO1xudmFyIFVwcGVyTGVmdEFycm93ID0gXCLihpZcIjtcbnZhciBVcHBlclJpZ2h0QXJyb3cgPSBcIuKGl1wiO1xudmFyIHVwc2kgPSBcIs+FXCI7XG52YXIgVXBzaSA9IFwiz5JcIjtcbnZhciB1cHNpaCA9IFwiz5JcIjtcbnZhciBVcHNpbG9uID0gXCLOpVwiO1xudmFyIHVwc2lsb24gPSBcIs+FXCI7XG52YXIgVXBUZWVBcnJvdyA9IFwi4oalXCI7XG52YXIgVXBUZWUgPSBcIuKKpVwiO1xudmFyIHVwdXBhcnJvd3MgPSBcIuKHiFwiO1xudmFyIHVyY29ybiA9IFwi4oydXCI7XG52YXIgdXJjb3JuZXIgPSBcIuKMnVwiO1xudmFyIHVyY3JvcCA9IFwi4oyOXCI7XG52YXIgVXJpbmcgPSBcIsWuXCI7XG52YXIgdXJpbmcgPSBcIsWvXCI7XG52YXIgdXJ0cmkgPSBcIuKXuVwiO1xudmFyIFVzY3IgPSBcIvCdkrBcIjtcbnZhciB1c2NyID0gXCLwnZOKXCI7XG52YXIgdXRkb3QgPSBcIuKLsFwiO1xudmFyIFV0aWxkZSA9IFwixahcIjtcbnZhciB1dGlsZGUgPSBcIsWpXCI7XG52YXIgdXRyaSA9IFwi4pa1XCI7XG52YXIgdXRyaWYgPSBcIuKWtFwiO1xudmFyIHV1YXJyID0gXCLih4hcIjtcbnZhciBVdW1sJDEgPSBcIsOcXCI7XG52YXIgdXVtbCQxID0gXCLDvFwiO1xudmFyIHV3YW5nbGUgPSBcIuKmp1wiO1xudmFyIHZhbmdydCA9IFwi4qacXCI7XG52YXIgdmFyZXBzaWxvbiA9IFwiz7VcIjtcbnZhciB2YXJrYXBwYSA9IFwiz7BcIjtcbnZhciB2YXJub3RoaW5nID0gXCLiiIVcIjtcbnZhciB2YXJwaGkgPSBcIs+VXCI7XG52YXIgdmFycGkgPSBcIs+WXCI7XG52YXIgdmFycHJvcHRvID0gXCLiiJ1cIjtcbnZhciB2YXJyID0gXCLihpVcIjtcbnZhciB2QXJyID0gXCLih5VcIjtcbnZhciB2YXJyaG8gPSBcIs+xXCI7XG52YXIgdmFyc2lnbWEgPSBcIs+CXCI7XG52YXIgdmFyc3Vic2V0bmVxID0gXCLiiorvuIBcIjtcbnZhciB2YXJzdWJzZXRuZXFxID0gXCLiq4vvuIBcIjtcbnZhciB2YXJzdXBzZXRuZXEgPSBcIuKKi++4gFwiO1xudmFyIHZhcnN1cHNldG5lcXEgPSBcIuKrjO+4gFwiO1xudmFyIHZhcnRoZXRhID0gXCLPkVwiO1xudmFyIHZhcnRyaWFuZ2xlbGVmdCA9IFwi4oqyXCI7XG52YXIgdmFydHJpYW5nbGVyaWdodCA9IFwi4oqzXCI7XG52YXIgdkJhciA9IFwi4quoXCI7XG52YXIgVmJhciA9IFwi4qurXCI7XG52YXIgdkJhcnYgPSBcIuKrqVwiO1xudmFyIFZjeSA9IFwi0JJcIjtcbnZhciB2Y3kgPSBcItCyXCI7XG52YXIgdmRhc2ggPSBcIuKKolwiO1xudmFyIHZEYXNoID0gXCLiiqhcIjtcbnZhciBWZGFzaCA9IFwi4oqpXCI7XG52YXIgVkRhc2ggPSBcIuKKq1wiO1xudmFyIFZkYXNobCA9IFwi4qumXCI7XG52YXIgdmVlYmFyID0gXCLiirtcIjtcbnZhciB2ZWUgPSBcIuKIqFwiO1xudmFyIFZlZSA9IFwi4ouBXCI7XG52YXIgdmVlZXEgPSBcIuKJmlwiO1xudmFyIHZlbGxpcCA9IFwi4ouuXCI7XG52YXIgdmVyYmFyID0gXCJ8XCI7XG52YXIgVmVyYmFyID0gXCLigJZcIjtcbnZhciB2ZXJ0ID0gXCJ8XCI7XG52YXIgVmVydCA9IFwi4oCWXCI7XG52YXIgVmVydGljYWxCYXIgPSBcIuKIo1wiO1xudmFyIFZlcnRpY2FsTGluZSA9IFwifFwiO1xudmFyIFZlcnRpY2FsU2VwYXJhdG9yID0gXCLinZhcIjtcbnZhciBWZXJ0aWNhbFRpbGRlID0gXCLiiYBcIjtcbnZhciBWZXJ5VGhpblNwYWNlID0gXCLigIpcIjtcbnZhciBWZnIgPSBcIvCdlJlcIjtcbnZhciB2ZnIgPSBcIvCdlLNcIjtcbnZhciB2bHRyaSA9IFwi4oqyXCI7XG52YXIgdm5zdWIgPSBcIuKKguKDklwiO1xudmFyIHZuc3VwID0gXCLiioPig5JcIjtcbnZhciBWb3BmID0gXCLwnZWNXCI7XG52YXIgdm9wZiA9IFwi8J2Vp1wiO1xudmFyIHZwcm9wID0gXCLiiJ1cIjtcbnZhciB2cnRyaSA9IFwi4oqzXCI7XG52YXIgVnNjciA9IFwi8J2SsVwiO1xudmFyIHZzY3IgPSBcIvCdk4tcIjtcbnZhciB2c3VibkUgPSBcIuKri++4gFwiO1xudmFyIHZzdWJuZSA9IFwi4oqK77iAXCI7XG52YXIgdnN1cG5FID0gXCLiq4zvuIBcIjtcbnZhciB2c3VwbmUgPSBcIuKKi++4gFwiO1xudmFyIFZ2ZGFzaCA9IFwi4oqqXCI7XG52YXIgdnppZ3phZyA9IFwi4qaaXCI7XG52YXIgV2NpcmMgPSBcIsW0XCI7XG52YXIgd2NpcmMgPSBcIsW1XCI7XG52YXIgd2VkYmFyID0gXCLiqZ9cIjtcbnZhciB3ZWRnZSA9IFwi4oinXCI7XG52YXIgV2VkZ2UgPSBcIuKLgFwiO1xudmFyIHdlZGdlcSA9IFwi4omZXCI7XG52YXIgd2VpZXJwID0gXCLihJhcIjtcbnZhciBXZnIgPSBcIvCdlJpcIjtcbnZhciB3ZnIgPSBcIvCdlLRcIjtcbnZhciBXb3BmID0gXCLwnZWOXCI7XG52YXIgd29wZiA9IFwi8J2VqFwiO1xudmFyIHdwID0gXCLihJhcIjtcbnZhciB3ciA9IFwi4omAXCI7XG52YXIgd3JlYXRoID0gXCLiiYBcIjtcbnZhciBXc2NyID0gXCLwnZKyXCI7XG52YXIgd3NjciA9IFwi8J2TjFwiO1xudmFyIHhjYXAgPSBcIuKLglwiO1xudmFyIHhjaXJjID0gXCLil69cIjtcbnZhciB4Y3VwID0gXCLii4NcIjtcbnZhciB4ZHRyaSA9IFwi4pa9XCI7XG52YXIgWGZyID0gXCLwnZSbXCI7XG52YXIgeGZyID0gXCLwnZS1XCI7XG52YXIgeGhhcnIgPSBcIuKft1wiO1xudmFyIHhoQXJyID0gXCLin7pcIjtcbnZhciBYaSA9IFwizp5cIjtcbnZhciB4aSA9IFwizr5cIjtcbnZhciB4bGFyciA9IFwi4p+1XCI7XG52YXIgeGxBcnIgPSBcIuKfuFwiO1xudmFyIHhtYXAgPSBcIuKfvFwiO1xudmFyIHhuaXMgPSBcIuKLu1wiO1xudmFyIHhvZG90ID0gXCLiqIBcIjtcbnZhciBYb3BmID0gXCLwnZWPXCI7XG52YXIgeG9wZiA9IFwi8J2VqVwiO1xudmFyIHhvcGx1cyA9IFwi4qiBXCI7XG52YXIgeG90aW1lID0gXCLiqIJcIjtcbnZhciB4cmFyciA9IFwi4p+2XCI7XG52YXIgeHJBcnIgPSBcIuKfuVwiO1xudmFyIFhzY3IgPSBcIvCdkrNcIjtcbnZhciB4c2NyID0gXCLwnZONXCI7XG52YXIgeHNxY3VwID0gXCLiqIZcIjtcbnZhciB4dXBsdXMgPSBcIuKohFwiO1xudmFyIHh1dHJpID0gXCLilrNcIjtcbnZhciB4dmVlID0gXCLii4FcIjtcbnZhciB4d2VkZ2UgPSBcIuKLgFwiO1xudmFyIFlhY3V0ZSQxID0gXCLDnVwiO1xudmFyIHlhY3V0ZSQxID0gXCLDvVwiO1xudmFyIFlBY3kgPSBcItCvXCI7XG52YXIgeWFjeSA9IFwi0Y9cIjtcbnZhciBZY2lyYyA9IFwixbZcIjtcbnZhciB5Y2lyYyA9IFwixbdcIjtcbnZhciBZY3kgPSBcItCrXCI7XG52YXIgeWN5ID0gXCLRi1wiO1xudmFyIHllbiQxID0gXCLCpVwiO1xudmFyIFlmciA9IFwi8J2UnFwiO1xudmFyIHlmciA9IFwi8J2UtlwiO1xudmFyIFlJY3kgPSBcItCHXCI7XG52YXIgeWljeSA9IFwi0ZdcIjtcbnZhciBZb3BmID0gXCLwnZWQXCI7XG52YXIgeW9wZiA9IFwi8J2VqlwiO1xudmFyIFlzY3IgPSBcIvCdkrRcIjtcbnZhciB5c2NyID0gXCLwnZOOXCI7XG52YXIgWVVjeSA9IFwi0K5cIjtcbnZhciB5dWN5ID0gXCLRjlwiO1xudmFyIHl1bWwkMSA9IFwiw79cIjtcbnZhciBZdW1sID0gXCLFuFwiO1xudmFyIFphY3V0ZSA9IFwixblcIjtcbnZhciB6YWN1dGUgPSBcIsW6XCI7XG52YXIgWmNhcm9uID0gXCLFvVwiO1xudmFyIHpjYXJvbiA9IFwixb5cIjtcbnZhciBaY3kgPSBcItCXXCI7XG52YXIgemN5ID0gXCLQt1wiO1xudmFyIFpkb3QgPSBcIsW7XCI7XG52YXIgemRvdCA9IFwixbxcIjtcbnZhciB6ZWV0cmYgPSBcIuKEqFwiO1xudmFyIFplcm9XaWR0aFNwYWNlID0gXCLigItcIjtcbnZhciBaZXRhID0gXCLOllwiO1xudmFyIHpldGEgPSBcIs62XCI7XG52YXIgemZyID0gXCLwnZS3XCI7XG52YXIgWmZyID0gXCLihKhcIjtcbnZhciBaSGN5ID0gXCLQllwiO1xudmFyIHpoY3kgPSBcItC2XCI7XG52YXIgemlncmFyciA9IFwi4oedXCI7XG52YXIgem9wZiA9IFwi8J2Vq1wiO1xudmFyIFpvcGYgPSBcIuKEpFwiO1xudmFyIFpzY3IgPSBcIvCdkrVcIjtcbnZhciB6c2NyID0gXCLwnZOPXCI7XG52YXIgendqID0gXCLigI1cIjtcbnZhciB6d25qID0gXCLigIxcIjtcbnZhciByZXF1aXJlJCQxJDEgPSB7XG4gICAgQWFjdXRlOiBBYWN1dGUkMSxcbiAgICBhYWN1dGU6IGFhY3V0ZSQxLFxuICAgIEFicmV2ZTogQWJyZXZlLFxuICAgIGFicmV2ZTogYWJyZXZlLFxuICAgIGFjOiBhYyxcbiAgICBhY2Q6IGFjZCxcbiAgICBhY0U6IGFjRSxcbiAgICBBY2lyYzogQWNpcmMkMSxcbiAgICBhY2lyYzogYWNpcmMkMSxcbiAgICBhY3V0ZTogYWN1dGUkMSxcbiAgICBBY3k6IEFjeSxcbiAgICBhY3k6IGFjeSxcbiAgICBBRWxpZzogQUVsaWckMSxcbiAgICBhZWxpZzogYWVsaWckMSxcbiAgICBhZjogYWYsXG4gICAgQWZyOiBBZnIsXG4gICAgYWZyOiBhZnIsXG4gICAgQWdyYXZlOiBBZ3JhdmUkMSxcbiAgICBhZ3JhdmU6IGFncmF2ZSQxLFxuICAgIGFsZWZzeW06IGFsZWZzeW0sXG4gICAgYWxlcGg6IGFsZXBoLFxuICAgIEFscGhhOiBBbHBoYSxcbiAgICBhbHBoYTogYWxwaGEsXG4gICAgQW1hY3I6IEFtYWNyLFxuICAgIGFtYWNyOiBhbWFjcixcbiAgICBhbWFsZzogYW1hbGcsXG4gICAgYW1wOiBhbXAkMixcbiAgICBBTVA6IEFNUCQxLFxuICAgIGFuZGFuZDogYW5kYW5kLFxuICAgIEFuZDogQW5kLFxuICAgIGFuZDogYW5kLFxuICAgIGFuZGQ6IGFuZGQsXG4gICAgYW5kc2xvcGU6IGFuZHNsb3BlLFxuICAgIGFuZHY6IGFuZHYsXG4gICAgYW5nOiBhbmcsXG4gICAgYW5nZTogYW5nZSxcbiAgICBhbmdsZTogYW5nbGUsXG4gICAgYW5nbXNkYWE6IGFuZ21zZGFhLFxuICAgIGFuZ21zZGFiOiBhbmdtc2RhYixcbiAgICBhbmdtc2RhYzogYW5nbXNkYWMsXG4gICAgYW5nbXNkYWQ6IGFuZ21zZGFkLFxuICAgIGFuZ21zZGFlOiBhbmdtc2RhZSxcbiAgICBhbmdtc2RhZjogYW5nbXNkYWYsXG4gICAgYW5nbXNkYWc6IGFuZ21zZGFnLFxuICAgIGFuZ21zZGFoOiBhbmdtc2RhaCxcbiAgICBhbmdtc2Q6IGFuZ21zZCxcbiAgICBhbmdydDogYW5ncnQsXG4gICAgYW5ncnR2YjogYW5ncnR2YixcbiAgICBhbmdydHZiZDogYW5ncnR2YmQsXG4gICAgYW5nc3BoOiBhbmdzcGgsXG4gICAgYW5nc3Q6IGFuZ3N0LFxuICAgIGFuZ3phcnI6IGFuZ3phcnIsXG4gICAgQW9nb246IEFvZ29uLFxuICAgIGFvZ29uOiBhb2dvbixcbiAgICBBb3BmOiBBb3BmLFxuICAgIGFvcGY6IGFvcGYsXG4gICAgYXBhY2lyOiBhcGFjaXIsXG4gICAgYXA6IGFwLFxuICAgIGFwRTogYXBFLFxuICAgIGFwZTogYXBlLFxuICAgIGFwaWQ6IGFwaWQsXG4gICAgYXBvczogYXBvcyQxLFxuICAgIEFwcGx5RnVuY3Rpb246IEFwcGx5RnVuY3Rpb24sXG4gICAgYXBwcm94OiBhcHByb3gsXG4gICAgYXBwcm94ZXE6IGFwcHJveGVxLFxuICAgIEFyaW5nOiBBcmluZyQxLFxuICAgIGFyaW5nOiBhcmluZyQxLFxuICAgIEFzY3I6IEFzY3IsXG4gICAgYXNjcjogYXNjcixcbiAgICBBc3NpZ246IEFzc2lnbixcbiAgICBhc3Q6IGFzdCxcbiAgICBhc3ltcDogYXN5bXAsXG4gICAgYXN5bXBlcTogYXN5bXBlcSxcbiAgICBBdGlsZGU6IEF0aWxkZSQxLFxuICAgIGF0aWxkZTogYXRpbGRlJDEsXG4gICAgQXVtbDogQXVtbCQxLFxuICAgIGF1bWw6IGF1bWwkMSxcbiAgICBhd2NvbmludDogYXdjb25pbnQsXG4gICAgYXdpbnQ6IGF3aW50LFxuICAgIGJhY2tjb25nOiBiYWNrY29uZyxcbiAgICBiYWNrZXBzaWxvbjogYmFja2Vwc2lsb24sXG4gICAgYmFja3ByaW1lOiBiYWNrcHJpbWUsXG4gICAgYmFja3NpbTogYmFja3NpbSxcbiAgICBiYWNrc2ltZXE6IGJhY2tzaW1lcSxcbiAgICBCYWNrc2xhc2g6IEJhY2tzbGFzaCxcbiAgICBCYXJ2OiBCYXJ2LFxuICAgIGJhcnZlZTogYmFydmVlLFxuICAgIGJhcndlZDogYmFyd2VkLFxuICAgIEJhcndlZDogQmFyd2VkLFxuICAgIGJhcndlZGdlOiBiYXJ3ZWRnZSxcbiAgICBiYnJrOiBiYnJrLFxuICAgIGJicmt0YnJrOiBiYnJrdGJyayxcbiAgICBiY29uZzogYmNvbmcsXG4gICAgQmN5OiBCY3ksXG4gICAgYmN5OiBiY3ksXG4gICAgYmRxdW86IGJkcXVvLFxuICAgIGJlY2F1czogYmVjYXVzLFxuICAgIGJlY2F1c2U6IGJlY2F1c2UsXG4gICAgQmVjYXVzZTogQmVjYXVzZSxcbiAgICBiZW1wdHl2OiBiZW1wdHl2LFxuICAgIGJlcHNpOiBiZXBzaSxcbiAgICBiZXJub3U6IGJlcm5vdSxcbiAgICBCZXJub3VsbGlzOiBCZXJub3VsbGlzLFxuICAgIEJldGE6IEJldGEsXG4gICAgYmV0YTogYmV0YSxcbiAgICBiZXRoOiBiZXRoLFxuICAgIGJldHdlZW46IGJldHdlZW4sXG4gICAgQmZyOiBCZnIsXG4gICAgYmZyOiBiZnIsXG4gICAgYmlnY2FwOiBiaWdjYXAsXG4gICAgYmlnY2lyYzogYmlnY2lyYyxcbiAgICBiaWdjdXA6IGJpZ2N1cCxcbiAgICBiaWdvZG90OiBiaWdvZG90LFxuICAgIGJpZ29wbHVzOiBiaWdvcGx1cyxcbiAgICBiaWdvdGltZXM6IGJpZ290aW1lcyxcbiAgICBiaWdzcWN1cDogYmlnc3FjdXAsXG4gICAgYmlnc3RhcjogYmlnc3RhcixcbiAgICBiaWd0cmlhbmdsZWRvd246IGJpZ3RyaWFuZ2xlZG93bixcbiAgICBiaWd0cmlhbmdsZXVwOiBiaWd0cmlhbmdsZXVwLFxuICAgIGJpZ3VwbHVzOiBiaWd1cGx1cyxcbiAgICBiaWd2ZWU6IGJpZ3ZlZSxcbiAgICBiaWd3ZWRnZTogYmlnd2VkZ2UsXG4gICAgYmthcm93OiBia2Fyb3csXG4gICAgYmxhY2tsb3plbmdlOiBibGFja2xvemVuZ2UsXG4gICAgYmxhY2tzcXVhcmU6IGJsYWNrc3F1YXJlLFxuICAgIGJsYWNrdHJpYW5nbGU6IGJsYWNrdHJpYW5nbGUsXG4gICAgYmxhY2t0cmlhbmdsZWRvd246IGJsYWNrdHJpYW5nbGVkb3duLFxuICAgIGJsYWNrdHJpYW5nbGVsZWZ0OiBibGFja3RyaWFuZ2xlbGVmdCxcbiAgICBibGFja3RyaWFuZ2xlcmlnaHQ6IGJsYWNrdHJpYW5nbGVyaWdodCxcbiAgICBibGFuazogYmxhbmssXG4gICAgYmxrMTI6IGJsazEyLFxuICAgIGJsazE0OiBibGsxNCxcbiAgICBibGszNDogYmxrMzQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGJuZTogYm5lLFxuICAgIGJuZXF1aXY6IGJuZXF1aXYsXG4gICAgYk5vdDogYk5vdCxcbiAgICBibm90OiBibm90LFxuICAgIEJvcGY6IEJvcGYsXG4gICAgYm9wZjogYm9wZixcbiAgICBib3Q6IGJvdCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICBib3d0aWU6IGJvd3RpZSxcbiAgICBib3hib3g6IGJveGJveCxcbiAgICBib3hkbDogYm94ZGwsXG4gICAgYm94ZEw6IGJveGRMLFxuICAgIGJveERsOiBib3hEbCxcbiAgICBib3hETDogYm94REwsXG4gICAgYm94ZHI6IGJveGRyLFxuICAgIGJveGRSOiBib3hkUixcbiAgICBib3hEcjogYm94RHIsXG4gICAgYm94RFI6IGJveERSLFxuICAgIGJveGg6IGJveGgsXG4gICAgYm94SDogYm94SCxcbiAgICBib3hoZDogYm94aGQsXG4gICAgYm94SGQ6IGJveEhkLFxuICAgIGJveGhEOiBib3hoRCxcbiAgICBib3hIRDogYm94SEQsXG4gICAgYm94aHU6IGJveGh1LFxuICAgIGJveEh1OiBib3hIdSxcbiAgICBib3hoVTogYm94aFUsXG4gICAgYm94SFU6IGJveEhVLFxuICAgIGJveG1pbnVzOiBib3htaW51cyxcbiAgICBib3hwbHVzOiBib3hwbHVzLFxuICAgIGJveHRpbWVzOiBib3h0aW1lcyxcbiAgICBib3h1bDogYm94dWwsXG4gICAgYm94dUw6IGJveHVMLFxuICAgIGJveFVsOiBib3hVbCxcbiAgICBib3hVTDogYm94VUwsXG4gICAgYm94dXI6IGJveHVyLFxuICAgIGJveHVSOiBib3h1UixcbiAgICBib3hVcjogYm94VXIsXG4gICAgYm94VVI6IGJveFVSLFxuICAgIGJveHY6IGJveHYsXG4gICAgYm94VjogYm94VixcbiAgICBib3h2aDogYm94dmgsXG4gICAgYm94dkg6IGJveHZILFxuICAgIGJveFZoOiBib3hWaCxcbiAgICBib3hWSDogYm94VkgsXG4gICAgYm94dmw6IGJveHZsLFxuICAgIGJveHZMOiBib3h2TCxcbiAgICBib3hWbDogYm94VmwsXG4gICAgYm94Vkw6IGJveFZMLFxuICAgIGJveHZyOiBib3h2cixcbiAgICBib3h2UjogYm94dlIsXG4gICAgYm94VnI6IGJveFZyLFxuICAgIGJveFZSOiBib3hWUixcbiAgICBicHJpbWU6IGJwcmltZSxcbiAgICBicmV2ZTogYnJldmUsXG4gICAgQnJldmU6IEJyZXZlLFxuICAgIGJydmJhcjogYnJ2YmFyJDEsXG4gICAgYnNjcjogYnNjcixcbiAgICBCc2NyOiBCc2NyLFxuICAgIGJzZW1pOiBic2VtaSxcbiAgICBic2ltOiBic2ltLFxuICAgIGJzaW1lOiBic2ltZSxcbiAgICBic29sYjogYnNvbGIsXG4gICAgYnNvbDogYnNvbCxcbiAgICBic29saHN1YjogYnNvbGhzdWIsXG4gICAgYnVsbDogYnVsbCxcbiAgICBidWxsZXQ6IGJ1bGxldCxcbiAgICBidW1wOiBidW1wLFxuICAgIGJ1bXBFOiBidW1wRSxcbiAgICBidW1wZTogYnVtcGUsXG4gICAgQnVtcGVxOiBCdW1wZXEsXG4gICAgYnVtcGVxOiBidW1wZXEsXG4gICAgQ2FjdXRlOiBDYWN1dGUsXG4gICAgY2FjdXRlOiBjYWN1dGUsXG4gICAgY2FwYW5kOiBjYXBhbmQsXG4gICAgY2FwYnJjdXA6IGNhcGJyY3VwLFxuICAgIGNhcGNhcDogY2FwY2FwLFxuICAgIGNhcDogY2FwLFxuICAgIENhcDogQ2FwLFxuICAgIGNhcGN1cDogY2FwY3VwLFxuICAgIGNhcGRvdDogY2FwZG90LFxuICAgIENhcGl0YWxEaWZmZXJlbnRpYWxEOiBDYXBpdGFsRGlmZmVyZW50aWFsRCxcbiAgICBjYXBzOiBjYXBzLFxuICAgIGNhcmV0OiBjYXJldCxcbiAgICBjYXJvbjogY2Fyb24sXG4gICAgQ2F5bGV5czogQ2F5bGV5cyxcbiAgICBjY2FwczogY2NhcHMsXG4gICAgQ2Nhcm9uOiBDY2Fyb24sXG4gICAgY2Nhcm9uOiBjY2Fyb24sXG4gICAgQ2NlZGlsOiBDY2VkaWwkMSxcbiAgICBjY2VkaWw6IGNjZWRpbCQxLFxuICAgIENjaXJjOiBDY2lyYyxcbiAgICBjY2lyYzogY2NpcmMsXG4gICAgQ2NvbmludDogQ2NvbmludCxcbiAgICBjY3VwczogY2N1cHMsXG4gICAgY2N1cHNzbTogY2N1cHNzbSxcbiAgICBDZG90OiBDZG90LFxuICAgIGNkb3Q6IGNkb3QsXG4gICAgY2VkaWw6IGNlZGlsJDEsXG4gICAgQ2VkaWxsYTogQ2VkaWxsYSxcbiAgICBjZW1wdHl2OiBjZW1wdHl2LFxuICAgIGNlbnQ6IGNlbnQkMSxcbiAgICBjZW50ZXJkb3Q6IGNlbnRlcmRvdCxcbiAgICBDZW50ZXJEb3Q6IENlbnRlckRvdCxcbiAgICBjZnI6IGNmcixcbiAgICBDZnI6IENmcixcbiAgICBDSGN5OiBDSGN5LFxuICAgIGNoY3k6IGNoY3ksXG4gICAgY2hlY2s6IGNoZWNrLFxuICAgIGNoZWNrbWFyazogY2hlY2ttYXJrLFxuICAgIENoaTogQ2hpLFxuICAgIGNoaTogY2hpLFxuICAgIGNpcmM6IGNpcmMsXG4gICAgY2lyY2VxOiBjaXJjZXEsXG4gICAgY2lyY2xlYXJyb3dsZWZ0OiBjaXJjbGVhcnJvd2xlZnQsXG4gICAgY2lyY2xlYXJyb3dyaWdodDogY2lyY2xlYXJyb3dyaWdodCxcbiAgICBjaXJjbGVkYXN0OiBjaXJjbGVkYXN0LFxuICAgIGNpcmNsZWRjaXJjOiBjaXJjbGVkY2lyYyxcbiAgICBjaXJjbGVkZGFzaDogY2lyY2xlZGRhc2gsXG4gICAgQ2lyY2xlRG90OiBDaXJjbGVEb3QsXG4gICAgY2lyY2xlZFI6IGNpcmNsZWRSLFxuICAgIGNpcmNsZWRTOiBjaXJjbGVkUyxcbiAgICBDaXJjbGVNaW51czogQ2lyY2xlTWludXMsXG4gICAgQ2lyY2xlUGx1czogQ2lyY2xlUGx1cyxcbiAgICBDaXJjbGVUaW1lczogQ2lyY2xlVGltZXMsXG4gICAgY2lyOiBjaXIsXG4gICAgY2lyRTogY2lyRSxcbiAgICBjaXJlOiBjaXJlLFxuICAgIGNpcmZuaW50OiBjaXJmbmludCxcbiAgICBjaXJtaWQ6IGNpcm1pZCxcbiAgICBjaXJzY2lyOiBjaXJzY2lyLFxuICAgIENsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDogQ2xvY2t3aXNlQ29udG91ckludGVncmFsLFxuICAgIENsb3NlQ3VybHlEb3VibGVRdW90ZTogQ2xvc2VDdXJseURvdWJsZVF1b3RlLFxuICAgIENsb3NlQ3VybHlRdW90ZTogQ2xvc2VDdXJseVF1b3RlLFxuICAgIGNsdWJzOiBjbHVicyxcbiAgICBjbHVic3VpdDogY2x1YnN1aXQsXG4gICAgY29sb246IGNvbG9uLFxuICAgIENvbG9uOiBDb2xvbixcbiAgICBDb2xvbmU6IENvbG9uZSxcbiAgICBjb2xvbmU6IGNvbG9uZSxcbiAgICBjb2xvbmVxOiBjb2xvbmVxLFxuICAgIGNvbW1hOiBjb21tYSxcbiAgICBjb21tYXQ6IGNvbW1hdCxcbiAgICBjb21wOiBjb21wLFxuICAgIGNvbXBmbjogY29tcGZuLFxuICAgIGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQsXG4gICAgY29tcGxleGVzOiBjb21wbGV4ZXMsXG4gICAgY29uZzogY29uZyxcbiAgICBjb25nZG90OiBjb25nZG90LFxuICAgIENvbmdydWVudDogQ29uZ3J1ZW50LFxuICAgIGNvbmludDogY29uaW50LFxuICAgIENvbmludDogQ29uaW50LFxuICAgIENvbnRvdXJJbnRlZ3JhbDogQ29udG91ckludGVncmFsLFxuICAgIGNvcGY6IGNvcGYsXG4gICAgQ29wZjogQ29wZixcbiAgICBjb3Byb2Q6IGNvcHJvZCxcbiAgICBDb3Byb2R1Y3Q6IENvcHJvZHVjdCxcbiAgICBjb3B5OiBjb3B5JDEsXG4gICAgQ09QWTogQ09QWSQxLFxuICAgIGNvcHlzcjogY29weXNyLFxuICAgIENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw6IENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwsXG4gICAgY3JhcnI6IGNyYXJyLFxuICAgIGNyb3NzOiBjcm9zcyxcbiAgICBDcm9zczogQ3Jvc3MsXG4gICAgQ3NjcjogQ3NjcixcbiAgICBjc2NyOiBjc2NyLFxuICAgIGNzdWI6IGNzdWIsXG4gICAgY3N1YmU6IGNzdWJlLFxuICAgIGNzdXA6IGNzdXAsXG4gICAgY3N1cGU6IGNzdXBlLFxuICAgIGN0ZG90OiBjdGRvdCxcbiAgICBjdWRhcnJsOiBjdWRhcnJsLFxuICAgIGN1ZGFycnI6IGN1ZGFycnIsXG4gICAgY3VlcHI6IGN1ZXByLFxuICAgIGN1ZXNjOiBjdWVzYyxcbiAgICBjdWxhcnI6IGN1bGFycixcbiAgICBjdWxhcnJwOiBjdWxhcnJwLFxuICAgIGN1cGJyY2FwOiBjdXBicmNhcCxcbiAgICBjdXBjYXA6IGN1cGNhcCxcbiAgICBDdXBDYXA6IEN1cENhcCxcbiAgICBjdXA6IGN1cCxcbiAgICBDdXA6IEN1cCxcbiAgICBjdXBjdXA6IGN1cGN1cCxcbiAgICBjdXBkb3Q6IGN1cGRvdCxcbiAgICBjdXBvcjogY3Vwb3IsXG4gICAgY3VwczogY3VwcyxcbiAgICBjdXJhcnI6IGN1cmFycixcbiAgICBjdXJhcnJtOiBjdXJhcnJtLFxuICAgIGN1cmx5ZXFwcmVjOiBjdXJseWVxcHJlYyxcbiAgICBjdXJseWVxc3VjYzogY3VybHllcXN1Y2MsXG4gICAgY3VybHl2ZWU6IGN1cmx5dmVlLFxuICAgIGN1cmx5d2VkZ2U6IGN1cmx5d2VkZ2UsXG4gICAgY3VycmVuOiBjdXJyZW4kMSxcbiAgICBjdXJ2ZWFycm93bGVmdDogY3VydmVhcnJvd2xlZnQsXG4gICAgY3VydmVhcnJvd3JpZ2h0OiBjdXJ2ZWFycm93cmlnaHQsXG4gICAgY3V2ZWU6IGN1dmVlLFxuICAgIGN1d2VkOiBjdXdlZCxcbiAgICBjd2NvbmludDogY3djb25pbnQsXG4gICAgY3dpbnQ6IGN3aW50LFxuICAgIGN5bGN0eTogY3lsY3R5LFxuICAgIGRhZ2dlcjogZGFnZ2VyLFxuICAgIERhZ2dlcjogRGFnZ2VyLFxuICAgIGRhbGV0aDogZGFsZXRoLFxuICAgIGRhcnI6IGRhcnIsXG4gICAgRGFycjogRGFycixcbiAgICBkQXJyOiBkQXJyLFxuICAgIGRhc2g6IGRhc2gsXG4gICAgRGFzaHY6IERhc2h2LFxuICAgIGRhc2h2OiBkYXNodixcbiAgICBkYmthcm93OiBkYmthcm93LFxuICAgIGRibGFjOiBkYmxhYyxcbiAgICBEY2Fyb246IERjYXJvbixcbiAgICBkY2Fyb246IGRjYXJvbixcbiAgICBEY3k6IERjeSxcbiAgICBkY3k6IGRjeSxcbiAgICBkZGFnZ2VyOiBkZGFnZ2VyLFxuICAgIGRkYXJyOiBkZGFycixcbiAgICBERDogREQsXG4gICAgZGQ6IGRkLFxuICAgIEREb3RyYWhkOiBERG90cmFoZCxcbiAgICBkZG90c2VxOiBkZG90c2VxLFxuICAgIGRlZzogZGVnJDEsXG4gICAgRGVsOiBEZWwsXG4gICAgRGVsdGE6IERlbHRhLFxuICAgIGRlbHRhOiBkZWx0YSxcbiAgICBkZW1wdHl2OiBkZW1wdHl2LFxuICAgIGRmaXNodDogZGZpc2h0LFxuICAgIERmcjogRGZyLFxuICAgIGRmcjogZGZyLFxuICAgIGRIYXI6IGRIYXIsXG4gICAgZGhhcmw6IGRoYXJsLFxuICAgIGRoYXJyOiBkaGFycixcbiAgICBEaWFjcml0aWNhbEFjdXRlOiBEaWFjcml0aWNhbEFjdXRlLFxuICAgIERpYWNyaXRpY2FsRG90OiBEaWFjcml0aWNhbERvdCxcbiAgICBEaWFjcml0aWNhbERvdWJsZUFjdXRlOiBEaWFjcml0aWNhbERvdWJsZUFjdXRlLFxuICAgIERpYWNyaXRpY2FsR3JhdmU6IERpYWNyaXRpY2FsR3JhdmUsXG4gICAgRGlhY3JpdGljYWxUaWxkZTogRGlhY3JpdGljYWxUaWxkZSxcbiAgICBkaWFtOiBkaWFtLFxuICAgIGRpYW1vbmQ6IGRpYW1vbmQsXG4gICAgRGlhbW9uZDogRGlhbW9uZCxcbiAgICBkaWFtb25kc3VpdDogZGlhbW9uZHN1aXQsXG4gICAgZGlhbXM6IGRpYW1zLFxuICAgIGRpZTogZGllLFxuICAgIERpZmZlcmVudGlhbEQ6IERpZmZlcmVudGlhbEQsXG4gICAgZGlnYW1tYTogZGlnYW1tYSxcbiAgICBkaXNpbjogZGlzaW4sXG4gICAgZGl2OiBkaXYsXG4gICAgZGl2aWRlOiBkaXZpZGUkMSxcbiAgICBkaXZpZGVvbnRpbWVzOiBkaXZpZGVvbnRpbWVzLFxuICAgIGRpdm9ueDogZGl2b254LFxuICAgIERKY3k6IERKY3ksXG4gICAgZGpjeTogZGpjeSxcbiAgICBkbGNvcm46IGRsY29ybixcbiAgICBkbGNyb3A6IGRsY3JvcCxcbiAgICBkb2xsYXI6IGRvbGxhcixcbiAgICBEb3BmOiBEb3BmLFxuICAgIGRvcGY6IGRvcGYsXG4gICAgRG90OiBEb3QsXG4gICAgZG90OiBkb3QsXG4gICAgRG90RG90OiBEb3REb3QsXG4gICAgZG90ZXE6IGRvdGVxLFxuICAgIGRvdGVxZG90OiBkb3RlcWRvdCxcbiAgICBEb3RFcXVhbDogRG90RXF1YWwsXG4gICAgZG90bWludXM6IGRvdG1pbnVzLFxuICAgIGRvdHBsdXM6IGRvdHBsdXMsXG4gICAgZG90c3F1YXJlOiBkb3RzcXVhcmUsXG4gICAgZG91YmxlYmFyd2VkZ2U6IGRvdWJsZWJhcndlZGdlLFxuICAgIERvdWJsZUNvbnRvdXJJbnRlZ3JhbDogRG91YmxlQ29udG91ckludGVncmFsLFxuICAgIERvdWJsZURvdDogRG91YmxlRG90LFxuICAgIERvdWJsZURvd25BcnJvdzogRG91YmxlRG93bkFycm93LFxuICAgIERvdWJsZUxlZnRBcnJvdzogRG91YmxlTGVmdEFycm93LFxuICAgIERvdWJsZUxlZnRSaWdodEFycm93OiBEb3VibGVMZWZ0UmlnaHRBcnJvdyxcbiAgICBEb3VibGVMZWZ0VGVlOiBEb3VibGVMZWZ0VGVlLFxuICAgIERvdWJsZUxvbmdMZWZ0QXJyb3c6IERvdWJsZUxvbmdMZWZ0QXJyb3csXG4gICAgRG91YmxlTG9uZ0xlZnRSaWdodEFycm93OiBEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3csXG4gICAgRG91YmxlTG9uZ1JpZ2h0QXJyb3c6IERvdWJsZUxvbmdSaWdodEFycm93LFxuICAgIERvdWJsZVJpZ2h0QXJyb3c6IERvdWJsZVJpZ2h0QXJyb3csXG4gICAgRG91YmxlUmlnaHRUZWU6IERvdWJsZVJpZ2h0VGVlLFxuICAgIERvdWJsZVVwQXJyb3c6IERvdWJsZVVwQXJyb3csXG4gICAgRG91YmxlVXBEb3duQXJyb3c6IERvdWJsZVVwRG93bkFycm93LFxuICAgIERvdWJsZVZlcnRpY2FsQmFyOiBEb3VibGVWZXJ0aWNhbEJhcixcbiAgICBEb3duQXJyb3dCYXI6IERvd25BcnJvd0JhcixcbiAgICBkb3duYXJyb3c6IGRvd25hcnJvdyxcbiAgICBEb3duQXJyb3c6IERvd25BcnJvdyxcbiAgICBEb3duYXJyb3c6IERvd25hcnJvdyxcbiAgICBEb3duQXJyb3dVcEFycm93OiBEb3duQXJyb3dVcEFycm93LFxuICAgIERvd25CcmV2ZTogRG93bkJyZXZlLFxuICAgIGRvd25kb3duYXJyb3dzOiBkb3duZG93bmFycm93cyxcbiAgICBkb3duaGFycG9vbmxlZnQ6IGRvd25oYXJwb29ubGVmdCxcbiAgICBkb3duaGFycG9vbnJpZ2h0OiBkb3duaGFycG9vbnJpZ2h0LFxuICAgIERvd25MZWZ0UmlnaHRWZWN0b3I6IERvd25MZWZ0UmlnaHRWZWN0b3IsXG4gICAgRG93bkxlZnRUZWVWZWN0b3I6IERvd25MZWZ0VGVlVmVjdG9yLFxuICAgIERvd25MZWZ0VmVjdG9yQmFyOiBEb3duTGVmdFZlY3RvckJhcixcbiAgICBEb3duTGVmdFZlY3RvcjogRG93bkxlZnRWZWN0b3IsXG4gICAgRG93blJpZ2h0VGVlVmVjdG9yOiBEb3duUmlnaHRUZWVWZWN0b3IsXG4gICAgRG93blJpZ2h0VmVjdG9yQmFyOiBEb3duUmlnaHRWZWN0b3JCYXIsXG4gICAgRG93blJpZ2h0VmVjdG9yOiBEb3duUmlnaHRWZWN0b3IsXG4gICAgRG93blRlZUFycm93OiBEb3duVGVlQXJyb3csXG4gICAgRG93blRlZTogRG93blRlZSxcbiAgICBkcmJrYXJvdzogZHJia2Fyb3csXG4gICAgZHJjb3JuOiBkcmNvcm4sXG4gICAgZHJjcm9wOiBkcmNyb3AsXG4gICAgRHNjcjogRHNjcixcbiAgICBkc2NyOiBkc2NyLFxuICAgIERTY3k6IERTY3ksXG4gICAgZHNjeTogZHNjeSxcbiAgICBkc29sOiBkc29sLFxuICAgIERzdHJvazogRHN0cm9rLFxuICAgIGRzdHJvazogZHN0cm9rLFxuICAgIGR0ZG90OiBkdGRvdCxcbiAgICBkdHJpOiBkdHJpLFxuICAgIGR0cmlmOiBkdHJpZixcbiAgICBkdWFycjogZHVhcnIsXG4gICAgZHVoYXI6IGR1aGFyLFxuICAgIGR3YW5nbGU6IGR3YW5nbGUsXG4gICAgRFpjeTogRFpjeSxcbiAgICBkemN5OiBkemN5LFxuICAgIGR6aWdyYXJyOiBkemlncmFycixcbiAgICBFYWN1dGU6IEVhY3V0ZSQxLFxuICAgIGVhY3V0ZTogZWFjdXRlJDEsXG4gICAgZWFzdGVyOiBlYXN0ZXIsXG4gICAgRWNhcm9uOiBFY2Fyb24sXG4gICAgZWNhcm9uOiBlY2Fyb24sXG4gICAgRWNpcmM6IEVjaXJjJDEsXG4gICAgZWNpcmM6IGVjaXJjJDEsXG4gICAgZWNpcjogZWNpcixcbiAgICBlY29sb246IGVjb2xvbixcbiAgICBFY3k6IEVjeSxcbiAgICBlY3k6IGVjeSxcbiAgICBlRERvdDogZUREb3QsXG4gICAgRWRvdDogRWRvdCxcbiAgICBlZG90OiBlZG90LFxuICAgIGVEb3Q6IGVEb3QsXG4gICAgZWU6IGVlLFxuICAgIGVmRG90OiBlZkRvdCxcbiAgICBFZnI6IEVmcixcbiAgICBlZnI6IGVmcixcbiAgICBlZzogZWcsXG4gICAgRWdyYXZlOiBFZ3JhdmUkMSxcbiAgICBlZ3JhdmU6IGVncmF2ZSQxLFxuICAgIGVnczogZWdzLFxuICAgIGVnc2RvdDogZWdzZG90LFxuICAgIGVsOiBlbCxcbiAgICBFbGVtZW50OiBFbGVtZW50LFxuICAgIGVsaW50ZXJzOiBlbGludGVycyxcbiAgICBlbGw6IGVsbCxcbiAgICBlbHM6IGVscyxcbiAgICBlbHNkb3Q6IGVsc2RvdCxcbiAgICBFbWFjcjogRW1hY3IsXG4gICAgZW1hY3I6IGVtYWNyLFxuICAgIGVtcHR5OiBlbXB0eSxcbiAgICBlbXB0eXNldDogZW1wdHlzZXQsXG4gICAgRW1wdHlTbWFsbFNxdWFyZTogRW1wdHlTbWFsbFNxdWFyZSxcbiAgICBlbXB0eXY6IGVtcHR5dixcbiAgICBFbXB0eVZlcnlTbWFsbFNxdWFyZTogRW1wdHlWZXJ5U21hbGxTcXVhcmUsXG4gICAgZW1zcDEzOiBlbXNwMTMsXG4gICAgZW1zcDE0OiBlbXNwMTQsXG4gICAgZW1zcDogZW1zcCxcbiAgICBFTkc6IEVORyxcbiAgICBlbmc6IGVuZyxcbiAgICBlbnNwOiBlbnNwLFxuICAgIEVvZ29uOiBFb2dvbixcbiAgICBlb2dvbjogZW9nb24sXG4gICAgRW9wZjogRW9wZixcbiAgICBlb3BmOiBlb3BmLFxuICAgIGVwYXI6IGVwYXIsXG4gICAgZXBhcnNsOiBlcGFyc2wsXG4gICAgZXBsdXM6IGVwbHVzLFxuICAgIGVwc2k6IGVwc2ksXG4gICAgRXBzaWxvbjogRXBzaWxvbixcbiAgICBlcHNpbG9uOiBlcHNpbG9uLFxuICAgIGVwc2l2OiBlcHNpdixcbiAgICBlcWNpcmM6IGVxY2lyYyxcbiAgICBlcWNvbG9uOiBlcWNvbG9uLFxuICAgIGVxc2ltOiBlcXNpbSxcbiAgICBlcXNsYW50Z3RyOiBlcXNsYW50Z3RyLFxuICAgIGVxc2xhbnRsZXNzOiBlcXNsYW50bGVzcyxcbiAgICBFcXVhbDogRXF1YWwsXG4gICAgZXF1YWxzOiBlcXVhbHMsXG4gICAgRXF1YWxUaWxkZTogRXF1YWxUaWxkZSxcbiAgICBlcXVlc3Q6IGVxdWVzdCxcbiAgICBFcXVpbGlicml1bTogRXF1aWxpYnJpdW0sXG4gICAgZXF1aXY6IGVxdWl2LFxuICAgIGVxdWl2REQ6IGVxdWl2REQsXG4gICAgZXF2cGFyc2w6IGVxdnBhcnNsLFxuICAgIGVyYXJyOiBlcmFycixcbiAgICBlckRvdDogZXJEb3QsXG4gICAgZXNjcjogZXNjcixcbiAgICBFc2NyOiBFc2NyLFxuICAgIGVzZG90OiBlc2RvdCxcbiAgICBFc2ltOiBFc2ltLFxuICAgIGVzaW06IGVzaW0sXG4gICAgRXRhOiBFdGEsXG4gICAgZXRhOiBldGEsXG4gICAgRVRIOiBFVEgkMSxcbiAgICBldGg6IGV0aCQxLFxuICAgIEV1bWw6IEV1bWwkMSxcbiAgICBldW1sOiBldW1sJDEsXG4gICAgZXVybzogZXVybyxcbiAgICBleGNsOiBleGNsLFxuICAgIGV4aXN0OiBleGlzdCxcbiAgICBFeGlzdHM6IEV4aXN0cyxcbiAgICBleHBlY3RhdGlvbjogZXhwZWN0YXRpb24sXG4gICAgZXhwb25lbnRpYWxlOiBleHBvbmVudGlhbGUsXG4gICAgRXhwb25lbnRpYWxFOiBFeHBvbmVudGlhbEUsXG4gICAgZmFsbGluZ2RvdHNlcTogZmFsbGluZ2RvdHNlcSxcbiAgICBGY3k6IEZjeSxcbiAgICBmY3k6IGZjeSxcbiAgICBmZW1hbGU6IGZlbWFsZSxcbiAgICBmZmlsaWc6IGZmaWxpZyxcbiAgICBmZmxpZzogZmZsaWcsXG4gICAgZmZsbGlnOiBmZmxsaWcsXG4gICAgRmZyOiBGZnIsXG4gICAgZmZyOiBmZnIsXG4gICAgZmlsaWc6IGZpbGlnLFxuICAgIEZpbGxlZFNtYWxsU3F1YXJlOiBGaWxsZWRTbWFsbFNxdWFyZSxcbiAgICBGaWxsZWRWZXJ5U21hbGxTcXVhcmU6IEZpbGxlZFZlcnlTbWFsbFNxdWFyZSxcbiAgICBmamxpZzogZmpsaWcsXG4gICAgZmxhdDogZmxhdCxcbiAgICBmbGxpZzogZmxsaWcsXG4gICAgZmx0bnM6IGZsdG5zLFxuICAgIGZub2Y6IGZub2YsXG4gICAgRm9wZjogRm9wZixcbiAgICBmb3BmOiBmb3BmLFxuICAgIGZvcmFsbDogZm9yYWxsLFxuICAgIEZvckFsbDogRm9yQWxsLFxuICAgIGZvcms6IGZvcmssXG4gICAgZm9ya3Y6IGZvcmt2LFxuICAgIEZvdXJpZXJ0cmY6IEZvdXJpZXJ0cmYsXG4gICAgZnBhcnRpbnQ6IGZwYXJ0aW50LFxuICAgIGZyYWMxMjogZnJhYzEyJDEsXG4gICAgZnJhYzEzOiBmcmFjMTMsXG4gICAgZnJhYzE0OiBmcmFjMTQkMSxcbiAgICBmcmFjMTU6IGZyYWMxNSxcbiAgICBmcmFjMTY6IGZyYWMxNixcbiAgICBmcmFjMTg6IGZyYWMxOCxcbiAgICBmcmFjMjM6IGZyYWMyMyxcbiAgICBmcmFjMjU6IGZyYWMyNSxcbiAgICBmcmFjMzQ6IGZyYWMzNCQxLFxuICAgIGZyYWMzNTogZnJhYzM1LFxuICAgIGZyYWMzODogZnJhYzM4LFxuICAgIGZyYWM0NTogZnJhYzQ1LFxuICAgIGZyYWM1NjogZnJhYzU2LFxuICAgIGZyYWM1ODogZnJhYzU4LFxuICAgIGZyYWM3ODogZnJhYzc4LFxuICAgIGZyYXNsOiBmcmFzbCxcbiAgICBmcm93bjogZnJvd24sXG4gICAgZnNjcjogZnNjcixcbiAgICBGc2NyOiBGc2NyLFxuICAgIGdhY3V0ZTogZ2FjdXRlLFxuICAgIEdhbW1hOiBHYW1tYSxcbiAgICBnYW1tYTogZ2FtbWEsXG4gICAgR2FtbWFkOiBHYW1tYWQsXG4gICAgZ2FtbWFkOiBnYW1tYWQsXG4gICAgZ2FwOiBnYXAsXG4gICAgR2JyZXZlOiBHYnJldmUsXG4gICAgZ2JyZXZlOiBnYnJldmUsXG4gICAgR2NlZGlsOiBHY2VkaWwsXG4gICAgR2NpcmM6IEdjaXJjLFxuICAgIGdjaXJjOiBnY2lyYyxcbiAgICBHY3k6IEdjeSxcbiAgICBnY3k6IGdjeSxcbiAgICBHZG90OiBHZG90LFxuICAgIGdkb3Q6IGdkb3QsXG4gICAgZ2U6IGdlLFxuICAgIGdFOiBnRSxcbiAgICBnRWw6IGdFbCxcbiAgICBnZWw6IGdlbCxcbiAgICBnZXE6IGdlcSxcbiAgICBnZXFxOiBnZXFxLFxuICAgIGdlcXNsYW50OiBnZXFzbGFudCxcbiAgICBnZXNjYzogZ2VzY2MsXG4gICAgZ2VzOiBnZXMsXG4gICAgZ2VzZG90OiBnZXNkb3QsXG4gICAgZ2VzZG90bzogZ2VzZG90byxcbiAgICBnZXNkb3RvbDogZ2VzZG90b2wsXG4gICAgZ2VzbDogZ2VzbCxcbiAgICBnZXNsZXM6IGdlc2xlcyxcbiAgICBHZnI6IEdmcixcbiAgICBnZnI6IGdmcixcbiAgICBnZzogZ2csXG4gICAgR2c6IEdnLFxuICAgIGdnZzogZ2dnLFxuICAgIGdpbWVsOiBnaW1lbCxcbiAgICBHSmN5OiBHSmN5LFxuICAgIGdqY3k6IGdqY3ksXG4gICAgZ2xhOiBnbGEsXG4gICAgZ2w6IGdsLFxuICAgIGdsRTogZ2xFLFxuICAgIGdsajogZ2xqLFxuICAgIGduYXA6IGduYXAsXG4gICAgZ25hcHByb3g6IGduYXBwcm94LFxuICAgIGduZTogZ25lLFxuICAgIGduRTogZ25FLFxuICAgIGduZXE6IGduZXEsXG4gICAgZ25lcXE6IGduZXFxLFxuICAgIGduc2ltOiBnbnNpbSxcbiAgICBHb3BmOiBHb3BmLFxuICAgIGdvcGY6IGdvcGYsXG4gICAgZ3JhdmU6IGdyYXZlLFxuICAgIEdyZWF0ZXJFcXVhbDogR3JlYXRlckVxdWFsLFxuICAgIEdyZWF0ZXJFcXVhbExlc3M6IEdyZWF0ZXJFcXVhbExlc3MsXG4gICAgR3JlYXRlckZ1bGxFcXVhbDogR3JlYXRlckZ1bGxFcXVhbCxcbiAgICBHcmVhdGVyR3JlYXRlcjogR3JlYXRlckdyZWF0ZXIsXG4gICAgR3JlYXRlckxlc3M6IEdyZWF0ZXJMZXNzLFxuICAgIEdyZWF0ZXJTbGFudEVxdWFsOiBHcmVhdGVyU2xhbnRFcXVhbCxcbiAgICBHcmVhdGVyVGlsZGU6IEdyZWF0ZXJUaWxkZSxcbiAgICBHc2NyOiBHc2NyLFxuICAgIGdzY3I6IGdzY3IsXG4gICAgZ3NpbTogZ3NpbSxcbiAgICBnc2ltZTogZ3NpbWUsXG4gICAgZ3NpbWw6IGdzaW1sLFxuICAgIGd0Y2M6IGd0Y2MsXG4gICAgZ3RjaXI6IGd0Y2lyLFxuICAgIGd0OiBndCQyLFxuICAgIEdUOiBHVCQxLFxuICAgIEd0OiBHdCxcbiAgICBndGRvdDogZ3Rkb3QsXG4gICAgZ3RsUGFyOiBndGxQYXIsXG4gICAgZ3RxdWVzdDogZ3RxdWVzdCxcbiAgICBndHJhcHByb3g6IGd0cmFwcHJveCxcbiAgICBndHJhcnI6IGd0cmFycixcbiAgICBndHJkb3Q6IGd0cmRvdCxcbiAgICBndHJlcWxlc3M6IGd0cmVxbGVzcyxcbiAgICBndHJlcXFsZXNzOiBndHJlcXFsZXNzLFxuICAgIGd0cmxlc3M6IGd0cmxlc3MsXG4gICAgZ3Ryc2ltOiBndHJzaW0sXG4gICAgZ3ZlcnRuZXFxOiBndmVydG5lcXEsXG4gICAgZ3ZuRTogZ3ZuRSxcbiAgICBIYWNlazogSGFjZWssXG4gICAgaGFpcnNwOiBoYWlyc3AsXG4gICAgaGFsZjogaGFsZixcbiAgICBoYW1pbHQ6IGhhbWlsdCxcbiAgICBIQVJEY3k6IEhBUkRjeSxcbiAgICBoYXJkY3k6IGhhcmRjeSxcbiAgICBoYXJyY2lyOiBoYXJyY2lyLFxuICAgIGhhcnI6IGhhcnIsXG4gICAgaEFycjogaEFycixcbiAgICBoYXJydzogaGFycncsXG4gICAgSGF0OiBIYXQsXG4gICAgaGJhcjogaGJhcixcbiAgICBIY2lyYzogSGNpcmMsXG4gICAgaGNpcmM6IGhjaXJjLFxuICAgIGhlYXJ0czogaGVhcnRzLFxuICAgIGhlYXJ0c3VpdDogaGVhcnRzdWl0LFxuICAgIGhlbGxpcDogaGVsbGlwLFxuICAgIGhlcmNvbjogaGVyY29uLFxuICAgIGhmcjogaGZyLFxuICAgIEhmcjogSGZyLFxuICAgIEhpbGJlcnRTcGFjZTogSGlsYmVydFNwYWNlLFxuICAgIGhrc2Vhcm93OiBoa3NlYXJvdyxcbiAgICBoa3N3YXJvdzogaGtzd2Fyb3csXG4gICAgaG9hcnI6IGhvYXJyLFxuICAgIGhvbXRodDogaG9tdGh0LFxuICAgIGhvb2tsZWZ0YXJyb3c6IGhvb2tsZWZ0YXJyb3csXG4gICAgaG9va3JpZ2h0YXJyb3c6IGhvb2tyaWdodGFycm93LFxuICAgIGhvcGY6IGhvcGYsXG4gICAgSG9wZjogSG9wZixcbiAgICBob3JiYXI6IGhvcmJhcixcbiAgICBIb3Jpem9udGFsTGluZTogSG9yaXpvbnRhbExpbmUsXG4gICAgaHNjcjogaHNjcixcbiAgICBIc2NyOiBIc2NyLFxuICAgIGhzbGFzaDogaHNsYXNoLFxuICAgIEhzdHJvazogSHN0cm9rLFxuICAgIGhzdHJvazogaHN0cm9rLFxuICAgIEh1bXBEb3duSHVtcDogSHVtcERvd25IdW1wLFxuICAgIEh1bXBFcXVhbDogSHVtcEVxdWFsLFxuICAgIGh5YnVsbDogaHlidWxsLFxuICAgIGh5cGhlbjogaHlwaGVuLFxuICAgIElhY3V0ZTogSWFjdXRlJDEsXG4gICAgaWFjdXRlOiBpYWN1dGUkMSxcbiAgICBpYzogaWMsXG4gICAgSWNpcmM6IEljaXJjJDEsXG4gICAgaWNpcmM6IGljaXJjJDEsXG4gICAgSWN5OiBJY3ksXG4gICAgaWN5OiBpY3ksXG4gICAgSWRvdDogSWRvdCxcbiAgICBJRWN5OiBJRWN5LFxuICAgIGllY3k6IGllY3ksXG4gICAgaWV4Y2w6IGlleGNsJDEsXG4gICAgaWZmOiBpZmYsXG4gICAgaWZyOiBpZnIsXG4gICAgSWZyOiBJZnIsXG4gICAgSWdyYXZlOiBJZ3JhdmUkMSxcbiAgICBpZ3JhdmU6IGlncmF2ZSQxLFxuICAgIGlpOiBpaSxcbiAgICBpaWlpbnQ6IGlpaWludCxcbiAgICBpaWludDogaWlpbnQsXG4gICAgaWluZmluOiBpaW5maW4sXG4gICAgaWlvdGE6IGlpb3RhLFxuICAgIElKbGlnOiBJSmxpZyxcbiAgICBpamxpZzogaWpsaWcsXG4gICAgSW1hY3I6IEltYWNyLFxuICAgIGltYWNyOiBpbWFjcixcbiAgICBpbWFnZTogZXNtX2ltYWdlLFxuICAgIEltYWdpbmFyeUk6IEltYWdpbmFyeUksXG4gICAgaW1hZ2xpbmU6IGltYWdsaW5lLFxuICAgIGltYWdwYXJ0OiBpbWFncGFydCxcbiAgICBpbWF0aDogaW1hdGgsXG4gICAgSW06IEltLFxuICAgIGltb2Y6IGltb2YsXG4gICAgaW1wZWQ6IGltcGVkLFxuICAgIEltcGxpZXM6IEltcGxpZXMsXG4gICAgaW5jYXJlOiBpbmNhcmUsXG4gICAgXCJpblwiOiBcIuKIiFwiLFxuICAgIGluZmluOiBpbmZpbixcbiAgICBpbmZpbnRpZTogaW5maW50aWUsXG4gICAgaW5vZG90OiBpbm9kb3QsXG4gICAgaW50Y2FsOiBpbnRjYWwsXG4gICAgaW50OiBlc21faW50LFxuICAgIEludDogSW50LFxuICAgIGludGVnZXJzOiBpbnRlZ2VycyxcbiAgICBJbnRlZ3JhbDogSW50ZWdyYWwsXG4gICAgaW50ZXJjYWw6IGludGVyY2FsLFxuICAgIEludGVyc2VjdGlvbjogSW50ZXJzZWN0aW9uLFxuICAgIGludGxhcmhrOiBpbnRsYXJoayxcbiAgICBpbnRwcm9kOiBpbnRwcm9kLFxuICAgIEludmlzaWJsZUNvbW1hOiBJbnZpc2libGVDb21tYSxcbiAgICBJbnZpc2libGVUaW1lczogSW52aXNpYmxlVGltZXMsXG4gICAgSU9jeTogSU9jeSxcbiAgICBpb2N5OiBpb2N5LFxuICAgIElvZ29uOiBJb2dvbixcbiAgICBpb2dvbjogaW9nb24sXG4gICAgSW9wZjogSW9wZixcbiAgICBpb3BmOiBpb3BmLFxuICAgIElvdGE6IElvdGEsXG4gICAgaW90YTogaW90YSxcbiAgICBpcHJvZDogaXByb2QsXG4gICAgaXF1ZXN0OiBpcXVlc3QkMSxcbiAgICBpc2NyOiBpc2NyLFxuICAgIElzY3I6IElzY3IsXG4gICAgaXNpbjogaXNpbixcbiAgICBpc2luZG90OiBpc2luZG90LFxuICAgIGlzaW5FOiBpc2luRSxcbiAgICBpc2luczogaXNpbnMsXG4gICAgaXNpbnN2OiBpc2luc3YsXG4gICAgaXNpbnY6IGlzaW52LFxuICAgIGl0OiBpdCxcbiAgICBJdGlsZGU6IEl0aWxkZSxcbiAgICBpdGlsZGU6IGl0aWxkZSxcbiAgICBJdWtjeTogSXVrY3ksXG4gICAgaXVrY3k6IGl1a2N5LFxuICAgIEl1bWw6IEl1bWwkMSxcbiAgICBpdW1sOiBpdW1sJDEsXG4gICAgSmNpcmM6IEpjaXJjLFxuICAgIGpjaXJjOiBqY2lyYyxcbiAgICBKY3k6IEpjeSxcbiAgICBqY3k6IGpjeSxcbiAgICBKZnI6IEpmcixcbiAgICBqZnI6IGpmcixcbiAgICBqbWF0aDogam1hdGgsXG4gICAgSm9wZjogSm9wZixcbiAgICBqb3BmOiBqb3BmLFxuICAgIEpzY3I6IEpzY3IsXG4gICAganNjcjoganNjcixcbiAgICBKc2VyY3k6IEpzZXJjeSxcbiAgICBqc2VyY3k6IGpzZXJjeSxcbiAgICBKdWtjeTogSnVrY3ksXG4gICAganVrY3k6IGp1a2N5LFxuICAgIEthcHBhOiBLYXBwYSxcbiAgICBrYXBwYToga2FwcGEsXG4gICAga2FwcGF2OiBrYXBwYXYsXG4gICAgS2NlZGlsOiBLY2VkaWwsXG4gICAga2NlZGlsOiBrY2VkaWwsXG4gICAgS2N5OiBLY3ksXG4gICAga2N5OiBrY3ksXG4gICAgS2ZyOiBLZnIsXG4gICAga2ZyOiBrZnIsXG4gICAga2dyZWVuOiBrZ3JlZW4sXG4gICAgS0hjeTogS0hjeSxcbiAgICBraGN5OiBraGN5LFxuICAgIEtKY3k6IEtKY3ksXG4gICAga2pjeToga2pjeSxcbiAgICBLb3BmOiBLb3BmLFxuICAgIGtvcGY6IGtvcGYsXG4gICAgS3NjcjogS3NjcixcbiAgICBrc2NyOiBrc2NyLFxuICAgIGxBYXJyOiBsQWFycixcbiAgICBMYWN1dGU6IExhY3V0ZSxcbiAgICBsYWN1dGU6IGxhY3V0ZSxcbiAgICBsYWVtcHR5djogbGFlbXB0eXYsXG4gICAgbGFncmFuOiBsYWdyYW4sXG4gICAgTGFtYmRhOiBMYW1iZGEsXG4gICAgbGFtYmRhOiBsYW1iZGEsXG4gICAgbGFuZzogbGFuZyxcbiAgICBMYW5nOiBMYW5nLFxuICAgIGxhbmdkOiBsYW5nZCxcbiAgICBsYW5nbGU6IGxhbmdsZSxcbiAgICBsYXA6IGxhcCxcbiAgICBMYXBsYWNldHJmOiBMYXBsYWNldHJmLFxuICAgIGxhcXVvOiBsYXF1byQxLFxuICAgIGxhcnJiOiBsYXJyYixcbiAgICBsYXJyYmZzOiBsYXJyYmZzLFxuICAgIGxhcnI6IGxhcnIsXG4gICAgTGFycjogTGFycixcbiAgICBsQXJyOiBsQXJyLFxuICAgIGxhcnJmczogbGFycmZzLFxuICAgIGxhcnJoazogbGFycmhrLFxuICAgIGxhcnJscDogbGFycmxwLFxuICAgIGxhcnJwbDogbGFycnBsLFxuICAgIGxhcnJzaW06IGxhcnJzaW0sXG4gICAgbGFycnRsOiBsYXJydGwsXG4gICAgbGF0YWlsOiBsYXRhaWwsXG4gICAgbEF0YWlsOiBsQXRhaWwsXG4gICAgbGF0OiBsYXQsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBsYXRlczogbGF0ZXMsXG4gICAgbGJhcnI6IGxiYXJyLFxuICAgIGxCYXJyOiBsQmFycixcbiAgICBsYmJyazogbGJicmssXG4gICAgbGJyYWNlOiBsYnJhY2UsXG4gICAgbGJyYWNrOiBsYnJhY2ssXG4gICAgbGJya2U6IGxicmtlLFxuICAgIGxicmtzbGQ6IGxicmtzbGQsXG4gICAgbGJya3NsdTogbGJya3NsdSxcbiAgICBMY2Fyb246IExjYXJvbixcbiAgICBsY2Fyb246IGxjYXJvbixcbiAgICBMY2VkaWw6IExjZWRpbCxcbiAgICBsY2VkaWw6IGxjZWRpbCxcbiAgICBsY2VpbDogbGNlaWwsXG4gICAgbGN1YjogbGN1YixcbiAgICBMY3k6IExjeSxcbiAgICBsY3k6IGxjeSxcbiAgICBsZGNhOiBsZGNhLFxuICAgIGxkcXVvOiBsZHF1byxcbiAgICBsZHF1b3I6IGxkcXVvcixcbiAgICBsZHJkaGFyOiBsZHJkaGFyLFxuICAgIGxkcnVzaGFyOiBsZHJ1c2hhcixcbiAgICBsZHNoOiBsZHNoLFxuICAgIGxlOiBsZSxcbiAgICBsRTogbEUsXG4gICAgTGVmdEFuZ2xlQnJhY2tldDogTGVmdEFuZ2xlQnJhY2tldCxcbiAgICBMZWZ0QXJyb3dCYXI6IExlZnRBcnJvd0JhcixcbiAgICBsZWZ0YXJyb3c6IGxlZnRhcnJvdyxcbiAgICBMZWZ0QXJyb3c6IExlZnRBcnJvdyxcbiAgICBMZWZ0YXJyb3c6IExlZnRhcnJvdyxcbiAgICBMZWZ0QXJyb3dSaWdodEFycm93OiBMZWZ0QXJyb3dSaWdodEFycm93LFxuICAgIGxlZnRhcnJvd3RhaWw6IGxlZnRhcnJvd3RhaWwsXG4gICAgTGVmdENlaWxpbmc6IExlZnRDZWlsaW5nLFxuICAgIExlZnREb3VibGVCcmFja2V0OiBMZWZ0RG91YmxlQnJhY2tldCxcbiAgICBMZWZ0RG93blRlZVZlY3RvcjogTGVmdERvd25UZWVWZWN0b3IsXG4gICAgTGVmdERvd25WZWN0b3JCYXI6IExlZnREb3duVmVjdG9yQmFyLFxuICAgIExlZnREb3duVmVjdG9yOiBMZWZ0RG93blZlY3RvcixcbiAgICBMZWZ0Rmxvb3I6IExlZnRGbG9vcixcbiAgICBsZWZ0aGFycG9vbmRvd246IGxlZnRoYXJwb29uZG93bixcbiAgICBsZWZ0aGFycG9vbnVwOiBsZWZ0aGFycG9vbnVwLFxuICAgIGxlZnRsZWZ0YXJyb3dzOiBsZWZ0bGVmdGFycm93cyxcbiAgICBsZWZ0cmlnaHRhcnJvdzogbGVmdHJpZ2h0YXJyb3csXG4gICAgTGVmdFJpZ2h0QXJyb3c6IExlZnRSaWdodEFycm93LFxuICAgIExlZnRyaWdodGFycm93OiBMZWZ0cmlnaHRhcnJvdyxcbiAgICBsZWZ0cmlnaHRhcnJvd3M6IGxlZnRyaWdodGFycm93cyxcbiAgICBsZWZ0cmlnaHRoYXJwb29uczogbGVmdHJpZ2h0aGFycG9vbnMsXG4gICAgbGVmdHJpZ2h0c3F1aWdhcnJvdzogbGVmdHJpZ2h0c3F1aWdhcnJvdyxcbiAgICBMZWZ0UmlnaHRWZWN0b3I6IExlZnRSaWdodFZlY3RvcixcbiAgICBMZWZ0VGVlQXJyb3c6IExlZnRUZWVBcnJvdyxcbiAgICBMZWZ0VGVlOiBMZWZ0VGVlLFxuICAgIExlZnRUZWVWZWN0b3I6IExlZnRUZWVWZWN0b3IsXG4gICAgbGVmdHRocmVldGltZXM6IGxlZnR0aHJlZXRpbWVzLFxuICAgIExlZnRUcmlhbmdsZUJhcjogTGVmdFRyaWFuZ2xlQmFyLFxuICAgIExlZnRUcmlhbmdsZTogTGVmdFRyaWFuZ2xlLFxuICAgIExlZnRUcmlhbmdsZUVxdWFsOiBMZWZ0VHJpYW5nbGVFcXVhbCxcbiAgICBMZWZ0VXBEb3duVmVjdG9yOiBMZWZ0VXBEb3duVmVjdG9yLFxuICAgIExlZnRVcFRlZVZlY3RvcjogTGVmdFVwVGVlVmVjdG9yLFxuICAgIExlZnRVcFZlY3RvckJhcjogTGVmdFVwVmVjdG9yQmFyLFxuICAgIExlZnRVcFZlY3RvcjogTGVmdFVwVmVjdG9yLFxuICAgIExlZnRWZWN0b3JCYXI6IExlZnRWZWN0b3JCYXIsXG4gICAgTGVmdFZlY3RvcjogTGVmdFZlY3RvcixcbiAgICBsRWc6IGxFZyxcbiAgICBsZWc6IGxlZyxcbiAgICBsZXE6IGxlcSxcbiAgICBsZXFxOiBsZXFxLFxuICAgIGxlcXNsYW50OiBsZXFzbGFudCxcbiAgICBsZXNjYzogbGVzY2MsXG4gICAgbGVzOiBsZXMsXG4gICAgbGVzZG90OiBsZXNkb3QsXG4gICAgbGVzZG90bzogbGVzZG90byxcbiAgICBsZXNkb3RvcjogbGVzZG90b3IsXG4gICAgbGVzZzogbGVzZyxcbiAgICBsZXNnZXM6IGxlc2dlcyxcbiAgICBsZXNzYXBwcm94OiBsZXNzYXBwcm94LFxuICAgIGxlc3Nkb3Q6IGxlc3Nkb3QsXG4gICAgbGVzc2VxZ3RyOiBsZXNzZXFndHIsXG4gICAgbGVzc2VxcWd0cjogbGVzc2VxcWd0cixcbiAgICBMZXNzRXF1YWxHcmVhdGVyOiBMZXNzRXF1YWxHcmVhdGVyLFxuICAgIExlc3NGdWxsRXF1YWw6IExlc3NGdWxsRXF1YWwsXG4gICAgTGVzc0dyZWF0ZXI6IExlc3NHcmVhdGVyLFxuICAgIGxlc3NndHI6IGxlc3NndHIsXG4gICAgTGVzc0xlc3M6IExlc3NMZXNzLFxuICAgIGxlc3NzaW06IGxlc3NzaW0sXG4gICAgTGVzc1NsYW50RXF1YWw6IExlc3NTbGFudEVxdWFsLFxuICAgIExlc3NUaWxkZTogTGVzc1RpbGRlLFxuICAgIGxmaXNodDogbGZpc2h0LFxuICAgIGxmbG9vcjogbGZsb29yLFxuICAgIExmcjogTGZyLFxuICAgIGxmcjogbGZyLFxuICAgIGxnOiBsZyxcbiAgICBsZ0U6IGxnRSxcbiAgICBsSGFyOiBsSGFyLFxuICAgIGxoYXJkOiBsaGFyZCxcbiAgICBsaGFydTogbGhhcnUsXG4gICAgbGhhcnVsOiBsaGFydWwsXG4gICAgbGhibGs6IGxoYmxrLFxuICAgIExKY3k6IExKY3ksXG4gICAgbGpjeTogbGpjeSxcbiAgICBsbGFycjogbGxhcnIsXG4gICAgbGw6IGxsLFxuICAgIExsOiBMbCxcbiAgICBsbGNvcm5lcjogbGxjb3JuZXIsXG4gICAgTGxlZnRhcnJvdzogTGxlZnRhcnJvdyxcbiAgICBsbGhhcmQ6IGxsaGFyZCxcbiAgICBsbHRyaTogbGx0cmksXG4gICAgTG1pZG90OiBMbWlkb3QsXG4gICAgbG1pZG90OiBsbWlkb3QsXG4gICAgbG1vdXN0YWNoZTogbG1vdXN0YWNoZSxcbiAgICBsbW91c3Q6IGxtb3VzdCxcbiAgICBsbmFwOiBsbmFwLFxuICAgIGxuYXBwcm94OiBsbmFwcHJveCxcbiAgICBsbmU6IGxuZSxcbiAgICBsbkU6IGxuRSxcbiAgICBsbmVxOiBsbmVxLFxuICAgIGxuZXFxOiBsbmVxcSxcbiAgICBsbnNpbTogbG5zaW0sXG4gICAgbG9hbmc6IGxvYW5nLFxuICAgIGxvYXJyOiBsb2FycixcbiAgICBsb2JyazogbG9icmssXG4gICAgbG9uZ2xlZnRhcnJvdzogbG9uZ2xlZnRhcnJvdyxcbiAgICBMb25nTGVmdEFycm93OiBMb25nTGVmdEFycm93LFxuICAgIExvbmdsZWZ0YXJyb3c6IExvbmdsZWZ0YXJyb3csXG4gICAgbG9uZ2xlZnRyaWdodGFycm93OiBsb25nbGVmdHJpZ2h0YXJyb3csXG4gICAgTG9uZ0xlZnRSaWdodEFycm93OiBMb25nTGVmdFJpZ2h0QXJyb3csXG4gICAgTG9uZ2xlZnRyaWdodGFycm93OiBMb25nbGVmdHJpZ2h0YXJyb3csXG4gICAgbG9uZ21hcHN0bzogbG9uZ21hcHN0byxcbiAgICBsb25ncmlnaHRhcnJvdzogbG9uZ3JpZ2h0YXJyb3csXG4gICAgTG9uZ1JpZ2h0QXJyb3c6IExvbmdSaWdodEFycm93LFxuICAgIExvbmdyaWdodGFycm93OiBMb25ncmlnaHRhcnJvdyxcbiAgICBsb29wYXJyb3dsZWZ0OiBsb29wYXJyb3dsZWZ0LFxuICAgIGxvb3BhcnJvd3JpZ2h0OiBsb29wYXJyb3dyaWdodCxcbiAgICBsb3BhcjogbG9wYXIsXG4gICAgTG9wZjogTG9wZixcbiAgICBsb3BmOiBsb3BmLFxuICAgIGxvcGx1czogbG9wbHVzLFxuICAgIGxvdGltZXM6IGxvdGltZXMsXG4gICAgbG93YXN0OiBsb3dhc3QsXG4gICAgbG93YmFyOiBsb3diYXIsXG4gICAgTG93ZXJMZWZ0QXJyb3c6IExvd2VyTGVmdEFycm93LFxuICAgIExvd2VyUmlnaHRBcnJvdzogTG93ZXJSaWdodEFycm93LFxuICAgIGxvejogbG96LFxuICAgIGxvemVuZ2U6IGxvemVuZ2UsXG4gICAgbG96ZjogbG96ZixcbiAgICBscGFyOiBscGFyLFxuICAgIGxwYXJsdDogbHBhcmx0LFxuICAgIGxyYXJyOiBscmFycixcbiAgICBscmNvcm5lcjogbHJjb3JuZXIsXG4gICAgbHJoYXI6IGxyaGFyLFxuICAgIGxyaGFyZDogbHJoYXJkLFxuICAgIGxybTogbHJtLFxuICAgIGxydHJpOiBscnRyaSxcbiAgICBsc2FxdW86IGxzYXF1byxcbiAgICBsc2NyOiBsc2NyLFxuICAgIExzY3I6IExzY3IsXG4gICAgbHNoOiBsc2gsXG4gICAgTHNoOiBMc2gsXG4gICAgbHNpbTogbHNpbSxcbiAgICBsc2ltZTogbHNpbWUsXG4gICAgbHNpbWc6IGxzaW1nLFxuICAgIGxzcWI6IGxzcWIsXG4gICAgbHNxdW86IGxzcXVvLFxuICAgIGxzcXVvcjogbHNxdW9yLFxuICAgIExzdHJvazogTHN0cm9rLFxuICAgIGxzdHJvazogbHN0cm9rLFxuICAgIGx0Y2M6IGx0Y2MsXG4gICAgbHRjaXI6IGx0Y2lyLFxuICAgIGx0OiBsdCQyLFxuICAgIExUOiBMVCQxLFxuICAgIEx0OiBMdCxcbiAgICBsdGRvdDogbHRkb3QsXG4gICAgbHRocmVlOiBsdGhyZWUsXG4gICAgbHRpbWVzOiBsdGltZXMsXG4gICAgbHRsYXJyOiBsdGxhcnIsXG4gICAgbHRxdWVzdDogbHRxdWVzdCxcbiAgICBsdHJpOiBsdHJpLFxuICAgIGx0cmllOiBsdHJpZSxcbiAgICBsdHJpZjogbHRyaWYsXG4gICAgbHRyUGFyOiBsdHJQYXIsXG4gICAgbHVyZHNoYXI6IGx1cmRzaGFyLFxuICAgIGx1cnVoYXI6IGx1cnVoYXIsXG4gICAgbHZlcnRuZXFxOiBsdmVydG5lcXEsXG4gICAgbHZuRTogbHZuRSxcbiAgICBtYWNyOiBtYWNyJDEsXG4gICAgbWFsZTogbWFsZSxcbiAgICBtYWx0OiBtYWx0LFxuICAgIG1hbHRlc2U6IG1hbHRlc2UsXG4gICAgXCJNYXBcIjogXCLipIVcIixcbiAgICBtYXA6IG1hcCxcbiAgICBtYXBzdG86IG1hcHN0byxcbiAgICBtYXBzdG9kb3duOiBtYXBzdG9kb3duLFxuICAgIG1hcHN0b2xlZnQ6IG1hcHN0b2xlZnQsXG4gICAgbWFwc3RvdXA6IG1hcHN0b3VwLFxuICAgIG1hcmtlcjogbWFya2VyLFxuICAgIG1jb21tYTogbWNvbW1hLFxuICAgIE1jeTogTWN5LFxuICAgIG1jeTogbWN5LFxuICAgIG1kYXNoOiBtZGFzaCxcbiAgICBtRERvdDogbUREb3QsXG4gICAgbWVhc3VyZWRhbmdsZTogbWVhc3VyZWRhbmdsZSxcbiAgICBNZWRpdW1TcGFjZTogTWVkaXVtU3BhY2UsXG4gICAgTWVsbGludHJmOiBNZWxsaW50cmYsXG4gICAgTWZyOiBNZnIsXG4gICAgbWZyOiBtZnIsXG4gICAgbWhvOiBtaG8sXG4gICAgbWljcm86IG1pY3JvJDEsXG4gICAgbWlkYXN0OiBtaWRhc3QsXG4gICAgbWlkY2lyOiBtaWRjaXIsXG4gICAgbWlkOiBtaWQsXG4gICAgbWlkZG90OiBtaWRkb3QkMSxcbiAgICBtaW51c2I6IG1pbnVzYixcbiAgICBtaW51czogbWludXMsXG4gICAgbWludXNkOiBtaW51c2QsXG4gICAgbWludXNkdTogbWludXNkdSxcbiAgICBNaW51c1BsdXM6IE1pbnVzUGx1cyxcbiAgICBtbGNwOiBtbGNwLFxuICAgIG1sZHI6IG1sZHIsXG4gICAgbW5wbHVzOiBtbnBsdXMsXG4gICAgbW9kZWxzOiBtb2RlbHMsXG4gICAgTW9wZjogTW9wZixcbiAgICBtb3BmOiBtb3BmLFxuICAgIG1wOiBtcCxcbiAgICBtc2NyOiBtc2NyLFxuICAgIE1zY3I6IE1zY3IsXG4gICAgbXN0cG9zOiBtc3Rwb3MsXG4gICAgTXU6IE11LFxuICAgIG11OiBtdSxcbiAgICBtdWx0aW1hcDogbXVsdGltYXAsXG4gICAgbXVtYXA6IG11bWFwLFxuICAgIG5hYmxhOiBuYWJsYSxcbiAgICBOYWN1dGU6IE5hY3V0ZSxcbiAgICBuYWN1dGU6IG5hY3V0ZSxcbiAgICBuYW5nOiBuYW5nLFxuICAgIG5hcDogbmFwLFxuICAgIG5hcEU6IG5hcEUsXG4gICAgbmFwaWQ6IG5hcGlkLFxuICAgIG5hcG9zOiBuYXBvcyxcbiAgICBuYXBwcm94OiBuYXBwcm94LFxuICAgIG5hdHVyYWw6IG5hdHVyYWwsXG4gICAgbmF0dXJhbHM6IG5hdHVyYWxzLFxuICAgIG5hdHVyOiBuYXR1cixcbiAgICBuYnNwOiBuYnNwJDEsXG4gICAgbmJ1bXA6IG5idW1wLFxuICAgIG5idW1wZTogbmJ1bXBlLFxuICAgIG5jYXA6IG5jYXAsXG4gICAgTmNhcm9uOiBOY2Fyb24sXG4gICAgbmNhcm9uOiBuY2Fyb24sXG4gICAgTmNlZGlsOiBOY2VkaWwsXG4gICAgbmNlZGlsOiBuY2VkaWwsXG4gICAgbmNvbmc6IG5jb25nLFxuICAgIG5jb25nZG90OiBuY29uZ2RvdCxcbiAgICBuY3VwOiBuY3VwLFxuICAgIE5jeTogTmN5LFxuICAgIG5jeTogbmN5LFxuICAgIG5kYXNoOiBuZGFzaCxcbiAgICBuZWFyaGs6IG5lYXJoayxcbiAgICBuZWFycjogbmVhcnIsXG4gICAgbmVBcnI6IG5lQXJyLFxuICAgIG5lYXJyb3c6IG5lYXJyb3csXG4gICAgbmU6IG5lLFxuICAgIG5lZG90OiBuZWRvdCxcbiAgICBOZWdhdGl2ZU1lZGl1bVNwYWNlOiBOZWdhdGl2ZU1lZGl1bVNwYWNlLFxuICAgIE5lZ2F0aXZlVGhpY2tTcGFjZTogTmVnYXRpdmVUaGlja1NwYWNlLFxuICAgIE5lZ2F0aXZlVGhpblNwYWNlOiBOZWdhdGl2ZVRoaW5TcGFjZSxcbiAgICBOZWdhdGl2ZVZlcnlUaGluU3BhY2U6IE5lZ2F0aXZlVmVyeVRoaW5TcGFjZSxcbiAgICBuZXF1aXY6IG5lcXVpdixcbiAgICBuZXNlYXI6IG5lc2VhcixcbiAgICBuZXNpbTogbmVzaW0sXG4gICAgTmVzdGVkR3JlYXRlckdyZWF0ZXI6IE5lc3RlZEdyZWF0ZXJHcmVhdGVyLFxuICAgIE5lc3RlZExlc3NMZXNzOiBOZXN0ZWRMZXNzTGVzcyxcbiAgICBOZXdMaW5lOiBOZXdMaW5lLFxuICAgIG5leGlzdDogbmV4aXN0LFxuICAgIG5leGlzdHM6IG5leGlzdHMsXG4gICAgTmZyOiBOZnIsXG4gICAgbmZyOiBuZnIsXG4gICAgbmdFOiBuZ0UsXG4gICAgbmdlOiBuZ2UsXG4gICAgbmdlcTogbmdlcSxcbiAgICBuZ2VxcTogbmdlcXEsXG4gICAgbmdlcXNsYW50OiBuZ2Vxc2xhbnQsXG4gICAgbmdlczogbmdlcyxcbiAgICBuR2c6IG5HZyxcbiAgICBuZ3NpbTogbmdzaW0sXG4gICAgbkd0OiBuR3QsXG4gICAgbmd0OiBuZ3QsXG4gICAgbmd0cjogbmd0cixcbiAgICBuR3R2OiBuR3R2LFxuICAgIG5oYXJyOiBuaGFycixcbiAgICBuaEFycjogbmhBcnIsXG4gICAgbmhwYXI6IG5ocGFyLFxuICAgIG5pOiBuaSxcbiAgICBuaXM6IG5pcyxcbiAgICBuaXNkOiBuaXNkLFxuICAgIG5pdjogbml2LFxuICAgIE5KY3k6IE5KY3ksXG4gICAgbmpjeTogbmpjeSxcbiAgICBubGFycjogbmxhcnIsXG4gICAgbmxBcnI6IG5sQXJyLFxuICAgIG5sZHI6IG5sZHIsXG4gICAgbmxFOiBubEUsXG4gICAgbmxlOiBubGUsXG4gICAgbmxlZnRhcnJvdzogbmxlZnRhcnJvdyxcbiAgICBuTGVmdGFycm93OiBuTGVmdGFycm93LFxuICAgIG5sZWZ0cmlnaHRhcnJvdzogbmxlZnRyaWdodGFycm93LFxuICAgIG5MZWZ0cmlnaHRhcnJvdzogbkxlZnRyaWdodGFycm93LFxuICAgIG5sZXE6IG5sZXEsXG4gICAgbmxlcXE6IG5sZXFxLFxuICAgIG5sZXFzbGFudDogbmxlcXNsYW50LFxuICAgIG5sZXM6IG5sZXMsXG4gICAgbmxlc3M6IG5sZXNzLFxuICAgIG5MbDogbkxsLFxuICAgIG5sc2ltOiBubHNpbSxcbiAgICBuTHQ6IG5MdCxcbiAgICBubHQ6IG5sdCxcbiAgICBubHRyaTogbmx0cmksXG4gICAgbmx0cmllOiBubHRyaWUsXG4gICAgbkx0djogbkx0dixcbiAgICBubWlkOiBubWlkLFxuICAgIE5vQnJlYWs6IE5vQnJlYWssXG4gICAgTm9uQnJlYWtpbmdTcGFjZTogTm9uQnJlYWtpbmdTcGFjZSxcbiAgICBub3BmOiBub3BmLFxuICAgIE5vcGY6IE5vcGYsXG4gICAgTm90OiBOb3QsXG4gICAgbm90OiBub3QkMSxcbiAgICBOb3RDb25ncnVlbnQ6IE5vdENvbmdydWVudCxcbiAgICBOb3RDdXBDYXA6IE5vdEN1cENhcCxcbiAgICBOb3REb3VibGVWZXJ0aWNhbEJhcjogTm90RG91YmxlVmVydGljYWxCYXIsXG4gICAgTm90RWxlbWVudDogTm90RWxlbWVudCxcbiAgICBOb3RFcXVhbDogTm90RXF1YWwsXG4gICAgTm90RXF1YWxUaWxkZTogTm90RXF1YWxUaWxkZSxcbiAgICBOb3RFeGlzdHM6IE5vdEV4aXN0cyxcbiAgICBOb3RHcmVhdGVyOiBOb3RHcmVhdGVyLFxuICAgIE5vdEdyZWF0ZXJFcXVhbDogTm90R3JlYXRlckVxdWFsLFxuICAgIE5vdEdyZWF0ZXJGdWxsRXF1YWw6IE5vdEdyZWF0ZXJGdWxsRXF1YWwsXG4gICAgTm90R3JlYXRlckdyZWF0ZXI6IE5vdEdyZWF0ZXJHcmVhdGVyLFxuICAgIE5vdEdyZWF0ZXJMZXNzOiBOb3RHcmVhdGVyTGVzcyxcbiAgICBOb3RHcmVhdGVyU2xhbnRFcXVhbDogTm90R3JlYXRlclNsYW50RXF1YWwsXG4gICAgTm90R3JlYXRlclRpbGRlOiBOb3RHcmVhdGVyVGlsZGUsXG4gICAgTm90SHVtcERvd25IdW1wOiBOb3RIdW1wRG93bkh1bXAsXG4gICAgTm90SHVtcEVxdWFsOiBOb3RIdW1wRXF1YWwsXG4gICAgbm90aW46IG5vdGluLFxuICAgIG5vdGluZG90OiBub3RpbmRvdCxcbiAgICBub3RpbkU6IG5vdGluRSxcbiAgICBub3RpbnZhOiBub3RpbnZhLFxuICAgIG5vdGludmI6IG5vdGludmIsXG4gICAgbm90aW52Yzogbm90aW52YyxcbiAgICBOb3RMZWZ0VHJpYW5nbGVCYXI6IE5vdExlZnRUcmlhbmdsZUJhcixcbiAgICBOb3RMZWZ0VHJpYW5nbGU6IE5vdExlZnRUcmlhbmdsZSxcbiAgICBOb3RMZWZ0VHJpYW5nbGVFcXVhbDogTm90TGVmdFRyaWFuZ2xlRXF1YWwsXG4gICAgTm90TGVzczogTm90TGVzcyxcbiAgICBOb3RMZXNzRXF1YWw6IE5vdExlc3NFcXVhbCxcbiAgICBOb3RMZXNzR3JlYXRlcjogTm90TGVzc0dyZWF0ZXIsXG4gICAgTm90TGVzc0xlc3M6IE5vdExlc3NMZXNzLFxuICAgIE5vdExlc3NTbGFudEVxdWFsOiBOb3RMZXNzU2xhbnRFcXVhbCxcbiAgICBOb3RMZXNzVGlsZGU6IE5vdExlc3NUaWxkZSxcbiAgICBOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjogTm90TmVzdGVkR3JlYXRlckdyZWF0ZXIsXG4gICAgTm90TmVzdGVkTGVzc0xlc3M6IE5vdE5lc3RlZExlc3NMZXNzLFxuICAgIG5vdG5pOiBub3RuaSxcbiAgICBub3RuaXZhOiBub3RuaXZhLFxuICAgIG5vdG5pdmI6IG5vdG5pdmIsXG4gICAgbm90bml2Yzogbm90bml2YyxcbiAgICBOb3RQcmVjZWRlczogTm90UHJlY2VkZXMsXG4gICAgTm90UHJlY2VkZXNFcXVhbDogTm90UHJlY2VkZXNFcXVhbCxcbiAgICBOb3RQcmVjZWRlc1NsYW50RXF1YWw6IE5vdFByZWNlZGVzU2xhbnRFcXVhbCxcbiAgICBOb3RSZXZlcnNlRWxlbWVudDogTm90UmV2ZXJzZUVsZW1lbnQsXG4gICAgTm90UmlnaHRUcmlhbmdsZUJhcjogTm90UmlnaHRUcmlhbmdsZUJhcixcbiAgICBOb3RSaWdodFRyaWFuZ2xlOiBOb3RSaWdodFRyaWFuZ2xlLFxuICAgIE5vdFJpZ2h0VHJpYW5nbGVFcXVhbDogTm90UmlnaHRUcmlhbmdsZUVxdWFsLFxuICAgIE5vdFNxdWFyZVN1YnNldDogTm90U3F1YXJlU3Vic2V0LFxuICAgIE5vdFNxdWFyZVN1YnNldEVxdWFsOiBOb3RTcXVhcmVTdWJzZXRFcXVhbCxcbiAgICBOb3RTcXVhcmVTdXBlcnNldDogTm90U3F1YXJlU3VwZXJzZXQsXG4gICAgTm90U3F1YXJlU3VwZXJzZXRFcXVhbDogTm90U3F1YXJlU3VwZXJzZXRFcXVhbCxcbiAgICBOb3RTdWJzZXQ6IE5vdFN1YnNldCxcbiAgICBOb3RTdWJzZXRFcXVhbDogTm90U3Vic2V0RXF1YWwsXG4gICAgTm90U3VjY2VlZHM6IE5vdFN1Y2NlZWRzLFxuICAgIE5vdFN1Y2NlZWRzRXF1YWw6IE5vdFN1Y2NlZWRzRXF1YWwsXG4gICAgTm90U3VjY2VlZHNTbGFudEVxdWFsOiBOb3RTdWNjZWVkc1NsYW50RXF1YWwsXG4gICAgTm90U3VjY2VlZHNUaWxkZTogTm90U3VjY2VlZHNUaWxkZSxcbiAgICBOb3RTdXBlcnNldDogTm90U3VwZXJzZXQsXG4gICAgTm90U3VwZXJzZXRFcXVhbDogTm90U3VwZXJzZXRFcXVhbCxcbiAgICBOb3RUaWxkZTogTm90VGlsZGUsXG4gICAgTm90VGlsZGVFcXVhbDogTm90VGlsZGVFcXVhbCxcbiAgICBOb3RUaWxkZUZ1bGxFcXVhbDogTm90VGlsZGVGdWxsRXF1YWwsXG4gICAgTm90VGlsZGVUaWxkZTogTm90VGlsZGVUaWxkZSxcbiAgICBOb3RWZXJ0aWNhbEJhcjogTm90VmVydGljYWxCYXIsXG4gICAgbnBhcmFsbGVsOiBucGFyYWxsZWwsXG4gICAgbnBhcjogbnBhcixcbiAgICBucGFyc2w6IG5wYXJzbCxcbiAgICBucGFydDogbnBhcnQsXG4gICAgbnBvbGludDogbnBvbGludCxcbiAgICBucHI6IG5wcixcbiAgICBucHJjdWU6IG5wcmN1ZSxcbiAgICBucHJlYzogbnByZWMsXG4gICAgbnByZWNlcTogbnByZWNlcSxcbiAgICBucHJlOiBucHJlLFxuICAgIG5yYXJyYzogbnJhcnJjLFxuICAgIG5yYXJyOiBucmFycixcbiAgICBuckFycjogbnJBcnIsXG4gICAgbnJhcnJ3OiBucmFycncsXG4gICAgbnJpZ2h0YXJyb3c6IG5yaWdodGFycm93LFxuICAgIG5SaWdodGFycm93OiBuUmlnaHRhcnJvdyxcbiAgICBucnRyaTogbnJ0cmksXG4gICAgbnJ0cmllOiBucnRyaWUsXG4gICAgbnNjOiBuc2MsXG4gICAgbnNjY3VlOiBuc2NjdWUsXG4gICAgbnNjZTogbnNjZSxcbiAgICBOc2NyOiBOc2NyLFxuICAgIG5zY3I6IG5zY3IsXG4gICAgbnNob3J0bWlkOiBuc2hvcnRtaWQsXG4gICAgbnNob3J0cGFyYWxsZWw6IG5zaG9ydHBhcmFsbGVsLFxuICAgIG5zaW06IG5zaW0sXG4gICAgbnNpbWU6IG5zaW1lLFxuICAgIG5zaW1lcTogbnNpbWVxLFxuICAgIG5zbWlkOiBuc21pZCxcbiAgICBuc3BhcjogbnNwYXIsXG4gICAgbnNxc3ViZTogbnNxc3ViZSxcbiAgICBuc3FzdXBlOiBuc3FzdXBlLFxuICAgIG5zdWI6IG5zdWIsXG4gICAgbnN1YkU6IG5zdWJFLFxuICAgIG5zdWJlOiBuc3ViZSxcbiAgICBuc3Vic2V0OiBuc3Vic2V0LFxuICAgIG5zdWJzZXRlcTogbnN1YnNldGVxLFxuICAgIG5zdWJzZXRlcXE6IG5zdWJzZXRlcXEsXG4gICAgbnN1Y2M6IG5zdWNjLFxuICAgIG5zdWNjZXE6IG5zdWNjZXEsXG4gICAgbnN1cDogbnN1cCxcbiAgICBuc3VwRTogbnN1cEUsXG4gICAgbnN1cGU6IG5zdXBlLFxuICAgIG5zdXBzZXQ6IG5zdXBzZXQsXG4gICAgbnN1cHNldGVxOiBuc3Vwc2V0ZXEsXG4gICAgbnN1cHNldGVxcTogbnN1cHNldGVxcSxcbiAgICBudGdsOiBudGdsLFxuICAgIE50aWxkZTogTnRpbGRlJDEsXG4gICAgbnRpbGRlOiBudGlsZGUkMSxcbiAgICBudGxnOiBudGxnLFxuICAgIG50cmlhbmdsZWxlZnQ6IG50cmlhbmdsZWxlZnQsXG4gICAgbnRyaWFuZ2xlbGVmdGVxOiBudHJpYW5nbGVsZWZ0ZXEsXG4gICAgbnRyaWFuZ2xlcmlnaHQ6IG50cmlhbmdsZXJpZ2h0LFxuICAgIG50cmlhbmdsZXJpZ2h0ZXE6IG50cmlhbmdsZXJpZ2h0ZXEsXG4gICAgTnU6IE51LFxuICAgIG51OiBudSxcbiAgICBudW06IG51bSxcbiAgICBudW1lcm86IG51bWVybyxcbiAgICBudW1zcDogbnVtc3AsXG4gICAgbnZhcDogbnZhcCxcbiAgICBudmRhc2g6IG52ZGFzaCxcbiAgICBudkRhc2g6IG52RGFzaCxcbiAgICBuVmRhc2g6IG5WZGFzaCxcbiAgICBuVkRhc2g6IG5WRGFzaCxcbiAgICBudmdlOiBudmdlLFxuICAgIG52Z3Q6IG52Z3QsXG4gICAgbnZIYXJyOiBudkhhcnIsXG4gICAgbnZpbmZpbjogbnZpbmZpbixcbiAgICBudmxBcnI6IG52bEFycixcbiAgICBudmxlOiBudmxlLFxuICAgIG52bHQ6IG52bHQsXG4gICAgbnZsdHJpZTogbnZsdHJpZSxcbiAgICBudnJBcnI6IG52ckFycixcbiAgICBudnJ0cmllOiBudnJ0cmllLFxuICAgIG52c2ltOiBudnNpbSxcbiAgICBud2FyaGs6IG53YXJoayxcbiAgICBud2FycjogbndhcnIsXG4gICAgbndBcnI6IG53QXJyLFxuICAgIG53YXJyb3c6IG53YXJyb3csXG4gICAgbnduZWFyOiBud25lYXIsXG4gICAgT2FjdXRlOiBPYWN1dGUkMSxcbiAgICBvYWN1dGU6IG9hY3V0ZSQxLFxuICAgIG9hc3Q6IG9hc3QsXG4gICAgT2NpcmM6IE9jaXJjJDEsXG4gICAgb2NpcmM6IG9jaXJjJDEsXG4gICAgb2Npcjogb2NpcixcbiAgICBPY3k6IE9jeSxcbiAgICBvY3k6IG9jeSxcbiAgICBvZGFzaDogb2Rhc2gsXG4gICAgT2RibGFjOiBPZGJsYWMsXG4gICAgb2RibGFjOiBvZGJsYWMsXG4gICAgb2Rpdjogb2RpdixcbiAgICBvZG90OiBvZG90LFxuICAgIG9kc29sZDogb2Rzb2xkLFxuICAgIE9FbGlnOiBPRWxpZyxcbiAgICBvZWxpZzogb2VsaWcsXG4gICAgb2ZjaXI6IG9mY2lyLFxuICAgIE9mcjogT2ZyLFxuICAgIG9mcjogb2ZyLFxuICAgIG9nb246IG9nb24sXG4gICAgT2dyYXZlOiBPZ3JhdmUkMSxcbiAgICBvZ3JhdmU6IG9ncmF2ZSQxLFxuICAgIG9ndDogb2d0LFxuICAgIG9oYmFyOiBvaGJhcixcbiAgICBvaG06IG9obSxcbiAgICBvaW50OiBvaW50LFxuICAgIG9sYXJyOiBvbGFycixcbiAgICBvbGNpcjogb2xjaXIsXG4gICAgb2xjcm9zczogb2xjcm9zcyxcbiAgICBvbGluZTogb2xpbmUsXG4gICAgb2x0OiBvbHQsXG4gICAgT21hY3I6IE9tYWNyLFxuICAgIG9tYWNyOiBvbWFjcixcbiAgICBPbWVnYTogT21lZ2EsXG4gICAgb21lZ2E6IG9tZWdhLFxuICAgIE9taWNyb246IE9taWNyb24sXG4gICAgb21pY3Jvbjogb21pY3JvbixcbiAgICBvbWlkOiBvbWlkLFxuICAgIG9taW51czogb21pbnVzLFxuICAgIE9vcGY6IE9vcGYsXG4gICAgb29wZjogb29wZixcbiAgICBvcGFyOiBvcGFyLFxuICAgIE9wZW5DdXJseURvdWJsZVF1b3RlOiBPcGVuQ3VybHlEb3VibGVRdW90ZSxcbiAgICBPcGVuQ3VybHlRdW90ZTogT3BlbkN1cmx5UXVvdGUsXG4gICAgb3BlcnA6IG9wZXJwLFxuICAgIG9wbHVzOiBvcGx1cyxcbiAgICBvcmFycjogb3JhcnIsXG4gICAgT3I6IE9yLFxuICAgIG9yOiBvcixcbiAgICBvcmQ6IG9yZCxcbiAgICBvcmRlcjogb3JkZXIsXG4gICAgb3JkZXJvZjogb3JkZXJvZixcbiAgICBvcmRmOiBvcmRmJDEsXG4gICAgb3JkbTogb3JkbSQxLFxuICAgIG9yaWdvZjogb3JpZ29mLFxuICAgIG9yb3I6IG9yb3IsXG4gICAgb3JzbG9wZTogb3JzbG9wZSxcbiAgICBvcnY6IG9ydixcbiAgICBvUzogb1MsXG4gICAgT3NjcjogT3NjcixcbiAgICBvc2NyOiBvc2NyLFxuICAgIE9zbGFzaDogT3NsYXNoJDEsXG4gICAgb3NsYXNoOiBvc2xhc2gkMSxcbiAgICBvc29sOiBvc29sLFxuICAgIE90aWxkZTogT3RpbGRlJDEsXG4gICAgb3RpbGRlOiBvdGlsZGUkMSxcbiAgICBvdGltZXNhczogb3RpbWVzYXMsXG4gICAgT3RpbWVzOiBPdGltZXMsXG4gICAgb3RpbWVzOiBvdGltZXMsXG4gICAgT3VtbDogT3VtbCQxLFxuICAgIG91bWw6IG91bWwkMSxcbiAgICBvdmJhcjogb3ZiYXIsXG4gICAgT3ZlckJhcjogT3ZlckJhcixcbiAgICBPdmVyQnJhY2U6IE92ZXJCcmFjZSxcbiAgICBPdmVyQnJhY2tldDogT3ZlckJyYWNrZXQsXG4gICAgT3ZlclBhcmVudGhlc2lzOiBPdmVyUGFyZW50aGVzaXMsXG4gICAgcGFyYTogcGFyYSQxLFxuICAgIHBhcmFsbGVsOiBwYXJhbGxlbCxcbiAgICBwYXI6IHBhcixcbiAgICBwYXJzaW06IHBhcnNpbSxcbiAgICBwYXJzbDogcGFyc2wsXG4gICAgcGFydDogcGFydCxcbiAgICBQYXJ0aWFsRDogUGFydGlhbEQsXG4gICAgUGN5OiBQY3ksXG4gICAgcGN5OiBwY3ksXG4gICAgcGVyY250OiBwZXJjbnQsXG4gICAgcGVyaW9kOiBwZXJpb2QsXG4gICAgcGVybWlsOiBwZXJtaWwsXG4gICAgcGVycDogcGVycCxcbiAgICBwZXJ0ZW5rOiBwZXJ0ZW5rLFxuICAgIFBmcjogUGZyLFxuICAgIHBmcjogcGZyLFxuICAgIFBoaTogUGhpLFxuICAgIHBoaTogcGhpLFxuICAgIHBoaXY6IHBoaXYsXG4gICAgcGhtbWF0OiBwaG1tYXQsXG4gICAgcGhvbmU6IHBob25lLFxuICAgIFBpOiBQaSxcbiAgICBwaTogcGksXG4gICAgcGl0Y2hmb3JrOiBwaXRjaGZvcmssXG4gICAgcGl2OiBwaXYsXG4gICAgcGxhbmNrOiBwbGFuY2ssXG4gICAgcGxhbmNraDogcGxhbmNraCxcbiAgICBwbGFua3Y6IHBsYW5rdixcbiAgICBwbHVzYWNpcjogcGx1c2FjaXIsXG4gICAgcGx1c2I6IHBsdXNiLFxuICAgIHBsdXNjaXI6IHBsdXNjaXIsXG4gICAgcGx1czogcGx1cyxcbiAgICBwbHVzZG86IHBsdXNkbyxcbiAgICBwbHVzZHU6IHBsdXNkdSxcbiAgICBwbHVzZTogcGx1c2UsXG4gICAgUGx1c01pbnVzOiBQbHVzTWludXMsXG4gICAgcGx1c21uOiBwbHVzbW4kMSxcbiAgICBwbHVzc2ltOiBwbHVzc2ltLFxuICAgIHBsdXN0d286IHBsdXN0d28sXG4gICAgcG06IHBtLFxuICAgIFBvaW5jYXJlcGxhbmU6IFBvaW5jYXJlcGxhbmUsXG4gICAgcG9pbnRpbnQ6IHBvaW50aW50LFxuICAgIHBvcGY6IHBvcGYsXG4gICAgUG9wZjogUG9wZixcbiAgICBwb3VuZDogcG91bmQkMSxcbiAgICBwcmFwOiBwcmFwLFxuICAgIFByOiBQcixcbiAgICBwcjogcHIsXG4gICAgcHJjdWU6IHByY3VlLFxuICAgIHByZWNhcHByb3g6IHByZWNhcHByb3gsXG4gICAgcHJlYzogcHJlYyxcbiAgICBwcmVjY3VybHllcTogcHJlY2N1cmx5ZXEsXG4gICAgUHJlY2VkZXM6IFByZWNlZGVzLFxuICAgIFByZWNlZGVzRXF1YWw6IFByZWNlZGVzRXF1YWwsXG4gICAgUHJlY2VkZXNTbGFudEVxdWFsOiBQcmVjZWRlc1NsYW50RXF1YWwsXG4gICAgUHJlY2VkZXNUaWxkZTogUHJlY2VkZXNUaWxkZSxcbiAgICBwcmVjZXE6IHByZWNlcSxcbiAgICBwcmVjbmFwcHJveDogcHJlY25hcHByb3gsXG4gICAgcHJlY25lcXE6IHByZWNuZXFxLFxuICAgIHByZWNuc2ltOiBwcmVjbnNpbSxcbiAgICBwcmU6IHByZSxcbiAgICBwckU6IHByRSxcbiAgICBwcmVjc2ltOiBwcmVjc2ltLFxuICAgIHByaW1lOiBwcmltZSxcbiAgICBQcmltZTogUHJpbWUsXG4gICAgcHJpbWVzOiBwcmltZXMsXG4gICAgcHJuYXA6IHBybmFwLFxuICAgIHBybkU6IHBybkUsXG4gICAgcHJuc2ltOiBwcm5zaW0sXG4gICAgcHJvZDogcHJvZCxcbiAgICBQcm9kdWN0OiBQcm9kdWN0LFxuICAgIHByb2ZhbGFyOiBwcm9mYWxhcixcbiAgICBwcm9mbGluZTogcHJvZmxpbmUsXG4gICAgcHJvZnN1cmY6IHByb2ZzdXJmLFxuICAgIHByb3A6IHByb3AsXG4gICAgUHJvcG9ydGlvbmFsOiBQcm9wb3J0aW9uYWwsXG4gICAgUHJvcG9ydGlvbjogUHJvcG9ydGlvbixcbiAgICBwcm9wdG86IHByb3B0byxcbiAgICBwcnNpbTogcHJzaW0sXG4gICAgcHJ1cmVsOiBwcnVyZWwsXG4gICAgUHNjcjogUHNjcixcbiAgICBwc2NyOiBwc2NyLFxuICAgIFBzaTogUHNpLFxuICAgIHBzaTogcHNpLFxuICAgIHB1bmNzcDogcHVuY3NwLFxuICAgIFFmcjogUWZyLFxuICAgIHFmcjogcWZyLFxuICAgIHFpbnQ6IHFpbnQsXG4gICAgcW9wZjogcW9wZixcbiAgICBRb3BmOiBRb3BmLFxuICAgIHFwcmltZTogcXByaW1lLFxuICAgIFFzY3I6IFFzY3IsXG4gICAgcXNjcjogcXNjcixcbiAgICBxdWF0ZXJuaW9uczogcXVhdGVybmlvbnMsXG4gICAgcXVhdGludDogcXVhdGludCxcbiAgICBxdWVzdDogcXVlc3QsXG4gICAgcXVlc3RlcTogcXVlc3RlcSxcbiAgICBxdW90OiBxdW90JDIsXG4gICAgUVVPVDogUVVPVCQxLFxuICAgIHJBYXJyOiByQWFycixcbiAgICByYWNlOiByYWNlLFxuICAgIFJhY3V0ZTogUmFjdXRlLFxuICAgIHJhY3V0ZTogcmFjdXRlLFxuICAgIHJhZGljOiByYWRpYyxcbiAgICByYWVtcHR5djogcmFlbXB0eXYsXG4gICAgcmFuZzogcmFuZyxcbiAgICBSYW5nOiBSYW5nLFxuICAgIHJhbmdkOiByYW5nZCxcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgcmFuZ2xlOiByYW5nbGUsXG4gICAgcmFxdW86IHJhcXVvJDEsXG4gICAgcmFycmFwOiByYXJyYXAsXG4gICAgcmFycmI6IHJhcnJiLFxuICAgIHJhcnJiZnM6IHJhcnJiZnMsXG4gICAgcmFycmM6IHJhcnJjLFxuICAgIHJhcnI6IHJhcnIsXG4gICAgUmFycjogUmFycixcbiAgICByQXJyOiByQXJyLFxuICAgIHJhcnJmczogcmFycmZzLFxuICAgIHJhcnJoazogcmFycmhrLFxuICAgIHJhcnJscDogcmFycmxwLFxuICAgIHJhcnJwbDogcmFycnBsLFxuICAgIHJhcnJzaW06IHJhcnJzaW0sXG4gICAgUmFycnRsOiBSYXJydGwsXG4gICAgcmFycnRsOiByYXJydGwsXG4gICAgcmFycnc6IHJhcnJ3LFxuICAgIHJhdGFpbDogcmF0YWlsLFxuICAgIHJBdGFpbDogckF0YWlsLFxuICAgIHJhdGlvOiByYXRpbyxcbiAgICByYXRpb25hbHM6IHJhdGlvbmFscyxcbiAgICByYmFycjogcmJhcnIsXG4gICAgckJhcnI6IHJCYXJyLFxuICAgIFJCYXJyOiBSQmFycixcbiAgICByYmJyazogcmJicmssXG4gICAgcmJyYWNlOiByYnJhY2UsXG4gICAgcmJyYWNrOiByYnJhY2ssXG4gICAgcmJya2U6IHJicmtlLFxuICAgIHJicmtzbGQ6IHJicmtzbGQsXG4gICAgcmJya3NsdTogcmJya3NsdSxcbiAgICBSY2Fyb246IFJjYXJvbixcbiAgICByY2Fyb246IHJjYXJvbixcbiAgICBSY2VkaWw6IFJjZWRpbCxcbiAgICByY2VkaWw6IHJjZWRpbCxcbiAgICByY2VpbDogcmNlaWwsXG4gICAgcmN1YjogcmN1YixcbiAgICBSY3k6IFJjeSxcbiAgICByY3k6IHJjeSxcbiAgICByZGNhOiByZGNhLFxuICAgIHJkbGRoYXI6IHJkbGRoYXIsXG4gICAgcmRxdW86IHJkcXVvLFxuICAgIHJkcXVvcjogcmRxdW9yLFxuICAgIHJkc2g6IHJkc2gsXG4gICAgcmVhbDogcmVhbCxcbiAgICByZWFsaW5lOiByZWFsaW5lLFxuICAgIHJlYWxwYXJ0OiByZWFscGFydCxcbiAgICByZWFsczogcmVhbHMsXG4gICAgUmU6IFJlLFxuICAgIHJlY3Q6IHJlY3QsXG4gICAgcmVnOiByZWckMSxcbiAgICBSRUc6IFJFRyQxLFxuICAgIFJldmVyc2VFbGVtZW50OiBSZXZlcnNlRWxlbWVudCxcbiAgICBSZXZlcnNlRXF1aWxpYnJpdW06IFJldmVyc2VFcXVpbGlicml1bSxcbiAgICBSZXZlcnNlVXBFcXVpbGlicml1bTogUmV2ZXJzZVVwRXF1aWxpYnJpdW0sXG4gICAgcmZpc2h0OiByZmlzaHQsXG4gICAgcmZsb29yOiByZmxvb3IsXG4gICAgcmZyOiByZnIsXG4gICAgUmZyOiBSZnIsXG4gICAgckhhcjogckhhcixcbiAgICByaGFyZDogcmhhcmQsXG4gICAgcmhhcnU6IHJoYXJ1LFxuICAgIHJoYXJ1bDogcmhhcnVsLFxuICAgIFJobzogUmhvLFxuICAgIHJobzogcmhvLFxuICAgIHJob3Y6IHJob3YsXG4gICAgUmlnaHRBbmdsZUJyYWNrZXQ6IFJpZ2h0QW5nbGVCcmFja2V0LFxuICAgIFJpZ2h0QXJyb3dCYXI6IFJpZ2h0QXJyb3dCYXIsXG4gICAgcmlnaHRhcnJvdzogcmlnaHRhcnJvdyxcbiAgICBSaWdodEFycm93OiBSaWdodEFycm93LFxuICAgIFJpZ2h0YXJyb3c6IFJpZ2h0YXJyb3csXG4gICAgUmlnaHRBcnJvd0xlZnRBcnJvdzogUmlnaHRBcnJvd0xlZnRBcnJvdyxcbiAgICByaWdodGFycm93dGFpbDogcmlnaHRhcnJvd3RhaWwsXG4gICAgUmlnaHRDZWlsaW5nOiBSaWdodENlaWxpbmcsXG4gICAgUmlnaHREb3VibGVCcmFja2V0OiBSaWdodERvdWJsZUJyYWNrZXQsXG4gICAgUmlnaHREb3duVGVlVmVjdG9yOiBSaWdodERvd25UZWVWZWN0b3IsXG4gICAgUmlnaHREb3duVmVjdG9yQmFyOiBSaWdodERvd25WZWN0b3JCYXIsXG4gICAgUmlnaHREb3duVmVjdG9yOiBSaWdodERvd25WZWN0b3IsXG4gICAgUmlnaHRGbG9vcjogUmlnaHRGbG9vcixcbiAgICByaWdodGhhcnBvb25kb3duOiByaWdodGhhcnBvb25kb3duLFxuICAgIHJpZ2h0aGFycG9vbnVwOiByaWdodGhhcnBvb251cCxcbiAgICByaWdodGxlZnRhcnJvd3M6IHJpZ2h0bGVmdGFycm93cyxcbiAgICByaWdodGxlZnRoYXJwb29uczogcmlnaHRsZWZ0aGFycG9vbnMsXG4gICAgcmlnaHRyaWdodGFycm93czogcmlnaHRyaWdodGFycm93cyxcbiAgICByaWdodHNxdWlnYXJyb3c6IHJpZ2h0c3F1aWdhcnJvdyxcbiAgICBSaWdodFRlZUFycm93OiBSaWdodFRlZUFycm93LFxuICAgIFJpZ2h0VGVlOiBSaWdodFRlZSxcbiAgICBSaWdodFRlZVZlY3RvcjogUmlnaHRUZWVWZWN0b3IsXG4gICAgcmlnaHR0aHJlZXRpbWVzOiByaWdodHRocmVldGltZXMsXG4gICAgUmlnaHRUcmlhbmdsZUJhcjogUmlnaHRUcmlhbmdsZUJhcixcbiAgICBSaWdodFRyaWFuZ2xlOiBSaWdodFRyaWFuZ2xlLFxuICAgIFJpZ2h0VHJpYW5nbGVFcXVhbDogUmlnaHRUcmlhbmdsZUVxdWFsLFxuICAgIFJpZ2h0VXBEb3duVmVjdG9yOiBSaWdodFVwRG93blZlY3RvcixcbiAgICBSaWdodFVwVGVlVmVjdG9yOiBSaWdodFVwVGVlVmVjdG9yLFxuICAgIFJpZ2h0VXBWZWN0b3JCYXI6IFJpZ2h0VXBWZWN0b3JCYXIsXG4gICAgUmlnaHRVcFZlY3RvcjogUmlnaHRVcFZlY3RvcixcbiAgICBSaWdodFZlY3RvckJhcjogUmlnaHRWZWN0b3JCYXIsXG4gICAgUmlnaHRWZWN0b3I6IFJpZ2h0VmVjdG9yLFxuICAgIHJpbmc6IHJpbmcsXG4gICAgcmlzaW5nZG90c2VxOiByaXNpbmdkb3RzZXEsXG4gICAgcmxhcnI6IHJsYXJyLFxuICAgIHJsaGFyOiBybGhhcixcbiAgICBybG06IHJsbSxcbiAgICBybW91c3RhY2hlOiBybW91c3RhY2hlLFxuICAgIHJtb3VzdDogcm1vdXN0LFxuICAgIHJubWlkOiBybm1pZCxcbiAgICByb2FuZzogcm9hbmcsXG4gICAgcm9hcnI6IHJvYXJyLFxuICAgIHJvYnJrOiByb2JyayxcbiAgICByb3Bhcjogcm9wYXIsXG4gICAgcm9wZjogcm9wZixcbiAgICBSb3BmOiBSb3BmLFxuICAgIHJvcGx1czogcm9wbHVzLFxuICAgIHJvdGltZXM6IHJvdGltZXMsXG4gICAgUm91bmRJbXBsaWVzOiBSb3VuZEltcGxpZXMsXG4gICAgcnBhcjogcnBhcixcbiAgICBycGFyZ3Q6IHJwYXJndCxcbiAgICBycHBvbGludDogcnBwb2xpbnQsXG4gICAgcnJhcnI6IHJyYXJyLFxuICAgIFJyaWdodGFycm93OiBScmlnaHRhcnJvdyxcbiAgICByc2FxdW86IHJzYXF1byxcbiAgICByc2NyOiByc2NyLFxuICAgIFJzY3I6IFJzY3IsXG4gICAgcnNoOiByc2gsXG4gICAgUnNoOiBSc2gsXG4gICAgcnNxYjogcnNxYixcbiAgICByc3F1bzogcnNxdW8sXG4gICAgcnNxdW9yOiByc3F1b3IsXG4gICAgcnRocmVlOiBydGhyZWUsXG4gICAgcnRpbWVzOiBydGltZXMsXG4gICAgcnRyaTogcnRyaSxcbiAgICBydHJpZTogcnRyaWUsXG4gICAgcnRyaWY6IHJ0cmlmLFxuICAgIHJ0cmlsdHJpOiBydHJpbHRyaSxcbiAgICBSdWxlRGVsYXllZDogUnVsZURlbGF5ZWQsXG4gICAgcnVsdWhhcjogcnVsdWhhcixcbiAgICByeDogcngsXG4gICAgU2FjdXRlOiBTYWN1dGUsXG4gICAgc2FjdXRlOiBzYWN1dGUsXG4gICAgc2JxdW86IHNicXVvLFxuICAgIHNjYXA6IHNjYXAsXG4gICAgU2Nhcm9uOiBTY2Fyb24sXG4gICAgc2Nhcm9uOiBzY2Fyb24sXG4gICAgU2M6IFNjLFxuICAgIHNjOiBzYyxcbiAgICBzY2N1ZTogc2NjdWUsXG4gICAgc2NlOiBzY2UsXG4gICAgc2NFOiBzY0UsXG4gICAgU2NlZGlsOiBTY2VkaWwsXG4gICAgc2NlZGlsOiBzY2VkaWwsXG4gICAgU2NpcmM6IFNjaXJjLFxuICAgIHNjaXJjOiBzY2lyYyxcbiAgICBzY25hcDogc2NuYXAsXG4gICAgc2NuRTogc2NuRSxcbiAgICBzY25zaW06IHNjbnNpbSxcbiAgICBzY3BvbGludDogc2Nwb2xpbnQsXG4gICAgc2NzaW06IHNjc2ltLFxuICAgIFNjeTogU2N5LFxuICAgIHNjeTogc2N5LFxuICAgIHNkb3RiOiBzZG90YixcbiAgICBzZG90OiBzZG90LFxuICAgIHNkb3RlOiBzZG90ZSxcbiAgICBzZWFyaGs6IHNlYXJoayxcbiAgICBzZWFycjogc2VhcnIsXG4gICAgc2VBcnI6IHNlQXJyLFxuICAgIHNlYXJyb3c6IHNlYXJyb3csXG4gICAgc2VjdDogc2VjdCQxLFxuICAgIHNlbWk6IHNlbWksXG4gICAgc2Vzd2FyOiBzZXN3YXIsXG4gICAgc2V0bWludXM6IHNldG1pbnVzLFxuICAgIHNldG1uOiBzZXRtbixcbiAgICBzZXh0OiBzZXh0LFxuICAgIFNmcjogU2ZyLFxuICAgIHNmcjogc2ZyLFxuICAgIHNmcm93bjogc2Zyb3duLFxuICAgIHNoYXJwOiBzaGFycCxcbiAgICBTSENIY3k6IFNIQ0hjeSxcbiAgICBzaGNoY3k6IHNoY2hjeSxcbiAgICBTSGN5OiBTSGN5LFxuICAgIHNoY3k6IHNoY3ksXG4gICAgU2hvcnREb3duQXJyb3c6IFNob3J0RG93bkFycm93LFxuICAgIFNob3J0TGVmdEFycm93OiBTaG9ydExlZnRBcnJvdyxcbiAgICBzaG9ydG1pZDogc2hvcnRtaWQsXG4gICAgc2hvcnRwYXJhbGxlbDogc2hvcnRwYXJhbGxlbCxcbiAgICBTaG9ydFJpZ2h0QXJyb3c6IFNob3J0UmlnaHRBcnJvdyxcbiAgICBTaG9ydFVwQXJyb3c6IFNob3J0VXBBcnJvdyxcbiAgICBzaHk6IHNoeSQxLFxuICAgIFNpZ21hOiBTaWdtYSxcbiAgICBzaWdtYTogc2lnbWEsXG4gICAgc2lnbWFmOiBzaWdtYWYsXG4gICAgc2lnbWF2OiBzaWdtYXYsXG4gICAgc2ltOiBzaW0sXG4gICAgc2ltZG90OiBzaW1kb3QsXG4gICAgc2ltZTogc2ltZSxcbiAgICBzaW1lcTogc2ltZXEsXG4gICAgc2ltZzogc2ltZyxcbiAgICBzaW1nRTogc2ltZ0UsXG4gICAgc2ltbDogc2ltbCxcbiAgICBzaW1sRTogc2ltbEUsXG4gICAgc2ltbmU6IHNpbW5lLFxuICAgIHNpbXBsdXM6IHNpbXBsdXMsXG4gICAgc2ltcmFycjogc2ltcmFycixcbiAgICBzbGFycjogc2xhcnIsXG4gICAgU21hbGxDaXJjbGU6IFNtYWxsQ2lyY2xlLFxuICAgIHNtYWxsc2V0bWludXM6IHNtYWxsc2V0bWludXMsXG4gICAgc21hc2hwOiBzbWFzaHAsXG4gICAgc21lcGFyc2w6IHNtZXBhcnNsLFxuICAgIHNtaWQ6IHNtaWQsXG4gICAgc21pbGU6IHNtaWxlLFxuICAgIHNtdDogc210LFxuICAgIHNtdGU6IHNtdGUsXG4gICAgc210ZXM6IHNtdGVzLFxuICAgIFNPRlRjeTogU09GVGN5LFxuICAgIHNvZnRjeTogc29mdGN5LFxuICAgIHNvbGJhcjogc29sYmFyLFxuICAgIHNvbGI6IHNvbGIsXG4gICAgc29sOiBzb2wsXG4gICAgU29wZjogU29wZixcbiAgICBzb3BmOiBzb3BmLFxuICAgIHNwYWRlczogc3BhZGVzLFxuICAgIHNwYWRlc3VpdDogc3BhZGVzdWl0LFxuICAgIHNwYXI6IHNwYXIsXG4gICAgc3FjYXA6IHNxY2FwLFxuICAgIHNxY2Fwczogc3FjYXBzLFxuICAgIHNxY3VwOiBzcWN1cCxcbiAgICBzcWN1cHM6IHNxY3VwcyxcbiAgICBTcXJ0OiBTcXJ0LFxuICAgIHNxc3ViOiBzcXN1YixcbiAgICBzcXN1YmU6IHNxc3ViZSxcbiAgICBzcXN1YnNldDogc3FzdWJzZXQsXG4gICAgc3FzdWJzZXRlcTogc3FzdWJzZXRlcSxcbiAgICBzcXN1cDogc3FzdXAsXG4gICAgc3FzdXBlOiBzcXN1cGUsXG4gICAgc3FzdXBzZXQ6IHNxc3Vwc2V0LFxuICAgIHNxc3Vwc2V0ZXE6IHNxc3Vwc2V0ZXEsXG4gICAgc3F1YXJlOiBzcXVhcmUsXG4gICAgU3F1YXJlOiBTcXVhcmUsXG4gICAgU3F1YXJlSW50ZXJzZWN0aW9uOiBTcXVhcmVJbnRlcnNlY3Rpb24sXG4gICAgU3F1YXJlU3Vic2V0OiBTcXVhcmVTdWJzZXQsXG4gICAgU3F1YXJlU3Vic2V0RXF1YWw6IFNxdWFyZVN1YnNldEVxdWFsLFxuICAgIFNxdWFyZVN1cGVyc2V0OiBTcXVhcmVTdXBlcnNldCxcbiAgICBTcXVhcmVTdXBlcnNldEVxdWFsOiBTcXVhcmVTdXBlcnNldEVxdWFsLFxuICAgIFNxdWFyZVVuaW9uOiBTcXVhcmVVbmlvbixcbiAgICBzcXVhcmY6IHNxdWFyZixcbiAgICBzcXU6IHNxdSxcbiAgICBzcXVmOiBzcXVmLFxuICAgIHNyYXJyOiBzcmFycixcbiAgICBTc2NyOiBTc2NyLFxuICAgIHNzY3I6IHNzY3IsXG4gICAgc3NldG1uOiBzc2V0bW4sXG4gICAgc3NtaWxlOiBzc21pbGUsXG4gICAgc3N0YXJmOiBzc3RhcmYsXG4gICAgU3RhcjogU3RhcixcbiAgICBzdGFyOiBzdGFyLFxuICAgIHN0YXJmOiBzdGFyZixcbiAgICBzdHJhaWdodGVwc2lsb246IHN0cmFpZ2h0ZXBzaWxvbixcbiAgICBzdHJhaWdodHBoaTogc3RyYWlnaHRwaGksXG4gICAgc3RybnM6IHN0cm5zLFxuICAgIHN1Yjogc3ViLFxuICAgIFN1YjogU3ViLFxuICAgIHN1YmRvdDogc3ViZG90LFxuICAgIHN1YkU6IHN1YkUsXG4gICAgc3ViZTogc3ViZSxcbiAgICBzdWJlZG90OiBzdWJlZG90LFxuICAgIHN1Ym11bHQ6IHN1Ym11bHQsXG4gICAgc3VibkU6IHN1Ym5FLFxuICAgIHN1Ym5lOiBzdWJuZSxcbiAgICBzdWJwbHVzOiBzdWJwbHVzLFxuICAgIHN1YnJhcnI6IHN1YnJhcnIsXG4gICAgc3Vic2V0OiBzdWJzZXQsXG4gICAgU3Vic2V0OiBTdWJzZXQsXG4gICAgc3Vic2V0ZXE6IHN1YnNldGVxLFxuICAgIHN1YnNldGVxcTogc3Vic2V0ZXFxLFxuICAgIFN1YnNldEVxdWFsOiBTdWJzZXRFcXVhbCxcbiAgICBzdWJzZXRuZXE6IHN1YnNldG5lcSxcbiAgICBzdWJzZXRuZXFxOiBzdWJzZXRuZXFxLFxuICAgIHN1YnNpbTogc3Vic2ltLFxuICAgIHN1YnN1Yjogc3Vic3ViLFxuICAgIHN1YnN1cDogc3Vic3VwLFxuICAgIHN1Y2NhcHByb3g6IHN1Y2NhcHByb3gsXG4gICAgc3VjYzogc3VjYyxcbiAgICBzdWNjY3VybHllcTogc3VjY2N1cmx5ZXEsXG4gICAgU3VjY2VlZHM6IFN1Y2NlZWRzLFxuICAgIFN1Y2NlZWRzRXF1YWw6IFN1Y2NlZWRzRXF1YWwsXG4gICAgU3VjY2VlZHNTbGFudEVxdWFsOiBTdWNjZWVkc1NsYW50RXF1YWwsXG4gICAgU3VjY2VlZHNUaWxkZTogU3VjY2VlZHNUaWxkZSxcbiAgICBzdWNjZXE6IHN1Y2NlcSxcbiAgICBzdWNjbmFwcHJveDogc3VjY25hcHByb3gsXG4gICAgc3VjY25lcXE6IHN1Y2NuZXFxLFxuICAgIHN1Y2Nuc2ltOiBzdWNjbnNpbSxcbiAgICBzdWNjc2ltOiBzdWNjc2ltLFxuICAgIFN1Y2hUaGF0OiBTdWNoVGhhdCxcbiAgICBzdW06IHN1bSxcbiAgICBTdW06IFN1bSxcbiAgICBzdW5nOiBzdW5nLFxuICAgIHN1cDE6IHN1cDEkMSxcbiAgICBzdXAyOiBzdXAyJDEsXG4gICAgc3VwMzogc3VwMyQxLFxuICAgIHN1cDogc3VwLFxuICAgIFN1cDogU3VwLFxuICAgIHN1cGRvdDogc3VwZG90LFxuICAgIHN1cGRzdWI6IHN1cGRzdWIsXG4gICAgc3VwRTogc3VwRSxcbiAgICBzdXBlOiBzdXBlLFxuICAgIHN1cGVkb3Q6IHN1cGVkb3QsXG4gICAgU3VwZXJzZXQ6IFN1cGVyc2V0LFxuICAgIFN1cGVyc2V0RXF1YWw6IFN1cGVyc2V0RXF1YWwsXG4gICAgc3VwaHNvbDogc3VwaHNvbCxcbiAgICBzdXBoc3ViOiBzdXBoc3ViLFxuICAgIHN1cGxhcnI6IHN1cGxhcnIsXG4gICAgc3VwbXVsdDogc3VwbXVsdCxcbiAgICBzdXBuRTogc3VwbkUsXG4gICAgc3VwbmU6IHN1cG5lLFxuICAgIHN1cHBsdXM6IHN1cHBsdXMsXG4gICAgc3Vwc2V0OiBzdXBzZXQsXG4gICAgU3Vwc2V0OiBTdXBzZXQsXG4gICAgc3Vwc2V0ZXE6IHN1cHNldGVxLFxuICAgIHN1cHNldGVxcTogc3Vwc2V0ZXFxLFxuICAgIHN1cHNldG5lcTogc3Vwc2V0bmVxLFxuICAgIHN1cHNldG5lcXE6IHN1cHNldG5lcXEsXG4gICAgc3Vwc2ltOiBzdXBzaW0sXG4gICAgc3Vwc3ViOiBzdXBzdWIsXG4gICAgc3Vwc3VwOiBzdXBzdXAsXG4gICAgc3dhcmhrOiBzd2FyaGssXG4gICAgc3dhcnI6IHN3YXJyLFxuICAgIHN3QXJyOiBzd0FycixcbiAgICBzd2Fycm93OiBzd2Fycm93LFxuICAgIHN3bndhcjogc3dud2FyLFxuICAgIHN6bGlnOiBzemxpZyQxLFxuICAgIFRhYjogVGFiLFxuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIFRhdTogVGF1LFxuICAgIHRhdTogdGF1LFxuICAgIHRicms6IHRicmssXG4gICAgVGNhcm9uOiBUY2Fyb24sXG4gICAgdGNhcm9uOiB0Y2Fyb24sXG4gICAgVGNlZGlsOiBUY2VkaWwsXG4gICAgdGNlZGlsOiB0Y2VkaWwsXG4gICAgVGN5OiBUY3ksXG4gICAgdGN5OiB0Y3ksXG4gICAgdGRvdDogdGRvdCxcbiAgICB0ZWxyZWM6IHRlbHJlYyxcbiAgICBUZnI6IFRmcixcbiAgICB0ZnI6IHRmcixcbiAgICB0aGVyZTQ6IHRoZXJlNCxcbiAgICB0aGVyZWZvcmU6IHRoZXJlZm9yZSxcbiAgICBUaGVyZWZvcmU6IFRoZXJlZm9yZSxcbiAgICBUaGV0YTogVGhldGEsXG4gICAgdGhldGE6IHRoZXRhLFxuICAgIHRoZXRhc3ltOiB0aGV0YXN5bSxcbiAgICB0aGV0YXY6IHRoZXRhdixcbiAgICB0aGlja2FwcHJveDogdGhpY2thcHByb3gsXG4gICAgdGhpY2tzaW06IHRoaWNrc2ltLFxuICAgIFRoaWNrU3BhY2U6IFRoaWNrU3BhY2UsXG4gICAgVGhpblNwYWNlOiBUaGluU3BhY2UsXG4gICAgdGhpbnNwOiB0aGluc3AsXG4gICAgdGhrYXA6IHRoa2FwLFxuICAgIHRoa3NpbTogdGhrc2ltLFxuICAgIFRIT1JOOiBUSE9STiQxLFxuICAgIHRob3JuOiB0aG9ybiQxLFxuICAgIHRpbGRlOiB0aWxkZSxcbiAgICBUaWxkZTogVGlsZGUsXG4gICAgVGlsZGVFcXVhbDogVGlsZGVFcXVhbCxcbiAgICBUaWxkZUZ1bGxFcXVhbDogVGlsZGVGdWxsRXF1YWwsXG4gICAgVGlsZGVUaWxkZTogVGlsZGVUaWxkZSxcbiAgICB0aW1lc2JhcjogdGltZXNiYXIsXG4gICAgdGltZXNiOiB0aW1lc2IsXG4gICAgdGltZXM6IHRpbWVzJDEsXG4gICAgdGltZXNkOiB0aW1lc2QsXG4gICAgdGludDogdGludCxcbiAgICB0b2VhOiB0b2VhLFxuICAgIHRvcGJvdDogdG9wYm90LFxuICAgIHRvcGNpcjogdG9wY2lyLFxuICAgIHRvcDogZXNtX3RvcCxcbiAgICBUb3BmOiBUb3BmLFxuICAgIHRvcGY6IHRvcGYsXG4gICAgdG9wZm9yazogdG9wZm9yayxcbiAgICB0b3NhOiB0b3NhLFxuICAgIHRwcmltZTogdHByaW1lLFxuICAgIHRyYWRlOiB0cmFkZSxcbiAgICBUUkFERTogVFJBREUsXG4gICAgdHJpYW5nbGU6IHRyaWFuZ2xlLFxuICAgIHRyaWFuZ2xlZG93bjogdHJpYW5nbGVkb3duLFxuICAgIHRyaWFuZ2xlbGVmdDogdHJpYW5nbGVsZWZ0LFxuICAgIHRyaWFuZ2xlbGVmdGVxOiB0cmlhbmdsZWxlZnRlcSxcbiAgICB0cmlhbmdsZXE6IHRyaWFuZ2xlcSxcbiAgICB0cmlhbmdsZXJpZ2h0OiB0cmlhbmdsZXJpZ2h0LFxuICAgIHRyaWFuZ2xlcmlnaHRlcTogdHJpYW5nbGVyaWdodGVxLFxuICAgIHRyaWRvdDogdHJpZG90LFxuICAgIHRyaWU6IHRyaWUsXG4gICAgdHJpbWludXM6IHRyaW1pbnVzLFxuICAgIFRyaXBsZURvdDogVHJpcGxlRG90LFxuICAgIHRyaXBsdXM6IHRyaXBsdXMsXG4gICAgdHJpc2I6IHRyaXNiLFxuICAgIHRyaXRpbWU6IHRyaXRpbWUsXG4gICAgdHJwZXppdW06IHRycGV6aXVtLFxuICAgIFRzY3I6IFRzY3IsXG4gICAgdHNjcjogdHNjcixcbiAgICBUU2N5OiBUU2N5LFxuICAgIHRzY3k6IHRzY3ksXG4gICAgVFNIY3k6IFRTSGN5LFxuICAgIHRzaGN5OiB0c2hjeSxcbiAgICBUc3Ryb2s6IFRzdHJvayxcbiAgICB0c3Ryb2s6IHRzdHJvayxcbiAgICB0d2l4dDogdHdpeHQsXG4gICAgdHdvaGVhZGxlZnRhcnJvdzogdHdvaGVhZGxlZnRhcnJvdyxcbiAgICB0d29oZWFkcmlnaHRhcnJvdzogdHdvaGVhZHJpZ2h0YXJyb3csXG4gICAgVWFjdXRlOiBVYWN1dGUkMSxcbiAgICB1YWN1dGU6IHVhY3V0ZSQxLFxuICAgIHVhcnI6IHVhcnIsXG4gICAgVWFycjogVWFycixcbiAgICB1QXJyOiB1QXJyLFxuICAgIFVhcnJvY2lyOiBVYXJyb2NpcixcbiAgICBVYnJjeTogVWJyY3ksXG4gICAgdWJyY3k6IHVicmN5LFxuICAgIFVicmV2ZTogVWJyZXZlLFxuICAgIHVicmV2ZTogdWJyZXZlLFxuICAgIFVjaXJjOiBVY2lyYyQxLFxuICAgIHVjaXJjOiB1Y2lyYyQxLFxuICAgIFVjeTogVWN5LFxuICAgIHVjeTogdWN5LFxuICAgIHVkYXJyOiB1ZGFycixcbiAgICBVZGJsYWM6IFVkYmxhYyxcbiAgICB1ZGJsYWM6IHVkYmxhYyxcbiAgICB1ZGhhcjogdWRoYXIsXG4gICAgdWZpc2h0OiB1ZmlzaHQsXG4gICAgVWZyOiBVZnIsXG4gICAgdWZyOiB1ZnIsXG4gICAgVWdyYXZlOiBVZ3JhdmUkMSxcbiAgICB1Z3JhdmU6IHVncmF2ZSQxLFxuICAgIHVIYXI6IHVIYXIsXG4gICAgdWhhcmw6IHVoYXJsLFxuICAgIHVoYXJyOiB1aGFycixcbiAgICB1aGJsazogdWhibGssXG4gICAgdWxjb3JuOiB1bGNvcm4sXG4gICAgdWxjb3JuZXI6IHVsY29ybmVyLFxuICAgIHVsY3JvcDogdWxjcm9wLFxuICAgIHVsdHJpOiB1bHRyaSxcbiAgICBVbWFjcjogVW1hY3IsXG4gICAgdW1hY3I6IHVtYWNyLFxuICAgIHVtbDogdW1sJDEsXG4gICAgVW5kZXJCYXI6IFVuZGVyQmFyLFxuICAgIFVuZGVyQnJhY2U6IFVuZGVyQnJhY2UsXG4gICAgVW5kZXJCcmFja2V0OiBVbmRlckJyYWNrZXQsXG4gICAgVW5kZXJQYXJlbnRoZXNpczogVW5kZXJQYXJlbnRoZXNpcyxcbiAgICBVbmlvbjogVW5pb24sXG4gICAgVW5pb25QbHVzOiBVbmlvblBsdXMsXG4gICAgVW9nb246IFVvZ29uLFxuICAgIHVvZ29uOiB1b2dvbixcbiAgICBVb3BmOiBVb3BmLFxuICAgIHVvcGY6IHVvcGYsXG4gICAgVXBBcnJvd0JhcjogVXBBcnJvd0JhcixcbiAgICB1cGFycm93OiB1cGFycm93LFxuICAgIFVwQXJyb3c6IFVwQXJyb3csXG4gICAgVXBhcnJvdzogVXBhcnJvdyxcbiAgICBVcEFycm93RG93bkFycm93OiBVcEFycm93RG93bkFycm93LFxuICAgIHVwZG93bmFycm93OiB1cGRvd25hcnJvdyxcbiAgICBVcERvd25BcnJvdzogVXBEb3duQXJyb3csXG4gICAgVXBkb3duYXJyb3c6IFVwZG93bmFycm93LFxuICAgIFVwRXF1aWxpYnJpdW06IFVwRXF1aWxpYnJpdW0sXG4gICAgdXBoYXJwb29ubGVmdDogdXBoYXJwb29ubGVmdCxcbiAgICB1cGhhcnBvb25yaWdodDogdXBoYXJwb29ucmlnaHQsXG4gICAgdXBsdXM6IHVwbHVzLFxuICAgIFVwcGVyTGVmdEFycm93OiBVcHBlckxlZnRBcnJvdyxcbiAgICBVcHBlclJpZ2h0QXJyb3c6IFVwcGVyUmlnaHRBcnJvdyxcbiAgICB1cHNpOiB1cHNpLFxuICAgIFVwc2k6IFVwc2ksXG4gICAgdXBzaWg6IHVwc2loLFxuICAgIFVwc2lsb246IFVwc2lsb24sXG4gICAgdXBzaWxvbjogdXBzaWxvbixcbiAgICBVcFRlZUFycm93OiBVcFRlZUFycm93LFxuICAgIFVwVGVlOiBVcFRlZSxcbiAgICB1cHVwYXJyb3dzOiB1cHVwYXJyb3dzLFxuICAgIHVyY29ybjogdXJjb3JuLFxuICAgIHVyY29ybmVyOiB1cmNvcm5lcixcbiAgICB1cmNyb3A6IHVyY3JvcCxcbiAgICBVcmluZzogVXJpbmcsXG4gICAgdXJpbmc6IHVyaW5nLFxuICAgIHVydHJpOiB1cnRyaSxcbiAgICBVc2NyOiBVc2NyLFxuICAgIHVzY3I6IHVzY3IsXG4gICAgdXRkb3Q6IHV0ZG90LFxuICAgIFV0aWxkZTogVXRpbGRlLFxuICAgIHV0aWxkZTogdXRpbGRlLFxuICAgIHV0cmk6IHV0cmksXG4gICAgdXRyaWY6IHV0cmlmLFxuICAgIHV1YXJyOiB1dWFycixcbiAgICBVdW1sOiBVdW1sJDEsXG4gICAgdXVtbDogdXVtbCQxLFxuICAgIHV3YW5nbGU6IHV3YW5nbGUsXG4gICAgdmFuZ3J0OiB2YW5ncnQsXG4gICAgdmFyZXBzaWxvbjogdmFyZXBzaWxvbixcbiAgICB2YXJrYXBwYTogdmFya2FwcGEsXG4gICAgdmFybm90aGluZzogdmFybm90aGluZyxcbiAgICB2YXJwaGk6IHZhcnBoaSxcbiAgICB2YXJwaTogdmFycGksXG4gICAgdmFycHJvcHRvOiB2YXJwcm9wdG8sXG4gICAgdmFycjogdmFycixcbiAgICB2QXJyOiB2QXJyLFxuICAgIHZhcnJobzogdmFycmhvLFxuICAgIHZhcnNpZ21hOiB2YXJzaWdtYSxcbiAgICB2YXJzdWJzZXRuZXE6IHZhcnN1YnNldG5lcSxcbiAgICB2YXJzdWJzZXRuZXFxOiB2YXJzdWJzZXRuZXFxLFxuICAgIHZhcnN1cHNldG5lcTogdmFyc3Vwc2V0bmVxLFxuICAgIHZhcnN1cHNldG5lcXE6IHZhcnN1cHNldG5lcXEsXG4gICAgdmFydGhldGE6IHZhcnRoZXRhLFxuICAgIHZhcnRyaWFuZ2xlbGVmdDogdmFydHJpYW5nbGVsZWZ0LFxuICAgIHZhcnRyaWFuZ2xlcmlnaHQ6IHZhcnRyaWFuZ2xlcmlnaHQsXG4gICAgdkJhcjogdkJhcixcbiAgICBWYmFyOiBWYmFyLFxuICAgIHZCYXJ2OiB2QmFydixcbiAgICBWY3k6IFZjeSxcbiAgICB2Y3k6IHZjeSxcbiAgICB2ZGFzaDogdmRhc2gsXG4gICAgdkRhc2g6IHZEYXNoLFxuICAgIFZkYXNoOiBWZGFzaCxcbiAgICBWRGFzaDogVkRhc2gsXG4gICAgVmRhc2hsOiBWZGFzaGwsXG4gICAgdmVlYmFyOiB2ZWViYXIsXG4gICAgdmVlOiB2ZWUsXG4gICAgVmVlOiBWZWUsXG4gICAgdmVlZXE6IHZlZWVxLFxuICAgIHZlbGxpcDogdmVsbGlwLFxuICAgIHZlcmJhcjogdmVyYmFyLFxuICAgIFZlcmJhcjogVmVyYmFyLFxuICAgIHZlcnQ6IHZlcnQsXG4gICAgVmVydDogVmVydCxcbiAgICBWZXJ0aWNhbEJhcjogVmVydGljYWxCYXIsXG4gICAgVmVydGljYWxMaW5lOiBWZXJ0aWNhbExpbmUsXG4gICAgVmVydGljYWxTZXBhcmF0b3I6IFZlcnRpY2FsU2VwYXJhdG9yLFxuICAgIFZlcnRpY2FsVGlsZGU6IFZlcnRpY2FsVGlsZGUsXG4gICAgVmVyeVRoaW5TcGFjZTogVmVyeVRoaW5TcGFjZSxcbiAgICBWZnI6IFZmcixcbiAgICB2ZnI6IHZmcixcbiAgICB2bHRyaTogdmx0cmksXG4gICAgdm5zdWI6IHZuc3ViLFxuICAgIHZuc3VwOiB2bnN1cCxcbiAgICBWb3BmOiBWb3BmLFxuICAgIHZvcGY6IHZvcGYsXG4gICAgdnByb3A6IHZwcm9wLFxuICAgIHZydHJpOiB2cnRyaSxcbiAgICBWc2NyOiBWc2NyLFxuICAgIHZzY3I6IHZzY3IsXG4gICAgdnN1Ym5FOiB2c3VibkUsXG4gICAgdnN1Ym5lOiB2c3VibmUsXG4gICAgdnN1cG5FOiB2c3VwbkUsXG4gICAgdnN1cG5lOiB2c3VwbmUsXG4gICAgVnZkYXNoOiBWdmRhc2gsXG4gICAgdnppZ3phZzogdnppZ3phZyxcbiAgICBXY2lyYzogV2NpcmMsXG4gICAgd2NpcmM6IHdjaXJjLFxuICAgIHdlZGJhcjogd2VkYmFyLFxuICAgIHdlZGdlOiB3ZWRnZSxcbiAgICBXZWRnZTogV2VkZ2UsXG4gICAgd2VkZ2VxOiB3ZWRnZXEsXG4gICAgd2VpZXJwOiB3ZWllcnAsXG4gICAgV2ZyOiBXZnIsXG4gICAgd2ZyOiB3ZnIsXG4gICAgV29wZjogV29wZixcbiAgICB3b3BmOiB3b3BmLFxuICAgIHdwOiB3cCxcbiAgICB3cjogd3IsXG4gICAgd3JlYXRoOiB3cmVhdGgsXG4gICAgV3NjcjogV3NjcixcbiAgICB3c2NyOiB3c2NyLFxuICAgIHhjYXA6IHhjYXAsXG4gICAgeGNpcmM6IHhjaXJjLFxuICAgIHhjdXA6IHhjdXAsXG4gICAgeGR0cmk6IHhkdHJpLFxuICAgIFhmcjogWGZyLFxuICAgIHhmcjogeGZyLFxuICAgIHhoYXJyOiB4aGFycixcbiAgICB4aEFycjogeGhBcnIsXG4gICAgWGk6IFhpLFxuICAgIHhpOiB4aSxcbiAgICB4bGFycjogeGxhcnIsXG4gICAgeGxBcnI6IHhsQXJyLFxuICAgIHhtYXA6IHhtYXAsXG4gICAgeG5pczogeG5pcyxcbiAgICB4b2RvdDogeG9kb3QsXG4gICAgWG9wZjogWG9wZixcbiAgICB4b3BmOiB4b3BmLFxuICAgIHhvcGx1czogeG9wbHVzLFxuICAgIHhvdGltZTogeG90aW1lLFxuICAgIHhyYXJyOiB4cmFycixcbiAgICB4ckFycjogeHJBcnIsXG4gICAgWHNjcjogWHNjcixcbiAgICB4c2NyOiB4c2NyLFxuICAgIHhzcWN1cDogeHNxY3VwLFxuICAgIHh1cGx1czogeHVwbHVzLFxuICAgIHh1dHJpOiB4dXRyaSxcbiAgICB4dmVlOiB4dmVlLFxuICAgIHh3ZWRnZTogeHdlZGdlLFxuICAgIFlhY3V0ZTogWWFjdXRlJDEsXG4gICAgeWFjdXRlOiB5YWN1dGUkMSxcbiAgICBZQWN5OiBZQWN5LFxuICAgIHlhY3k6IHlhY3ksXG4gICAgWWNpcmM6IFljaXJjLFxuICAgIHljaXJjOiB5Y2lyYyxcbiAgICBZY3k6IFljeSxcbiAgICB5Y3k6IHljeSxcbiAgICB5ZW46IHllbiQxLFxuICAgIFlmcjogWWZyLFxuICAgIHlmcjogeWZyLFxuICAgIFlJY3k6IFlJY3ksXG4gICAgeWljeTogeWljeSxcbiAgICBZb3BmOiBZb3BmLFxuICAgIHlvcGY6IHlvcGYsXG4gICAgWXNjcjogWXNjcixcbiAgICB5c2NyOiB5c2NyLFxuICAgIFlVY3k6IFlVY3ksXG4gICAgeXVjeTogeXVjeSxcbiAgICB5dW1sOiB5dW1sJDEsXG4gICAgWXVtbDogWXVtbCxcbiAgICBaYWN1dGU6IFphY3V0ZSxcbiAgICB6YWN1dGU6IHphY3V0ZSxcbiAgICBaY2Fyb246IFpjYXJvbixcbiAgICB6Y2Fyb246IHpjYXJvbixcbiAgICBaY3k6IFpjeSxcbiAgICB6Y3k6IHpjeSxcbiAgICBaZG90OiBaZG90LFxuICAgIHpkb3Q6IHpkb3QsXG4gICAgemVldHJmOiB6ZWV0cmYsXG4gICAgWmVyb1dpZHRoU3BhY2U6IFplcm9XaWR0aFNwYWNlLFxuICAgIFpldGE6IFpldGEsXG4gICAgemV0YTogemV0YSxcbiAgICB6ZnI6IHpmcixcbiAgICBaZnI6IFpmcixcbiAgICBaSGN5OiBaSGN5LFxuICAgIHpoY3k6IHpoY3ksXG4gICAgemlncmFycjogemlncmFycixcbiAgICB6b3BmOiB6b3BmLFxuICAgIFpvcGY6IFpvcGYsXG4gICAgWnNjcjogWnNjcixcbiAgICB6c2NyOiB6c2NyLFxuICAgIHp3ajogendqLFxuICAgIHp3bmo6IHp3bmpcbn07XG52YXIgQWFjdXRlID0gXCLDgVwiO1xudmFyIGFhY3V0ZSA9IFwiw6FcIjtcbnZhciBBY2lyYyA9IFwiw4JcIjtcbnZhciBhY2lyYyA9IFwiw6JcIjtcbnZhciBhY3V0ZSA9IFwiwrRcIjtcbnZhciBBRWxpZyA9IFwiw4ZcIjtcbnZhciBhZWxpZyA9IFwiw6ZcIjtcbnZhciBBZ3JhdmUgPSBcIsOAXCI7XG52YXIgYWdyYXZlID0gXCLDoFwiO1xudmFyIGFtcCQxID0gXCImXCI7XG52YXIgQU1QID0gXCImXCI7XG52YXIgQXJpbmcgPSBcIsOFXCI7XG52YXIgYXJpbmcgPSBcIsOlXCI7XG52YXIgQXRpbGRlID0gXCLDg1wiO1xudmFyIGF0aWxkZSA9IFwiw6NcIjtcbnZhciBBdW1sID0gXCLDhFwiO1xudmFyIGF1bWwgPSBcIsOkXCI7XG52YXIgYnJ2YmFyID0gXCLCplwiO1xudmFyIENjZWRpbCA9IFwiw4dcIjtcbnZhciBjY2VkaWwgPSBcIsOnXCI7XG52YXIgY2VkaWwgPSBcIsK4XCI7XG52YXIgY2VudCA9IFwiwqJcIjtcbnZhciBjb3B5ID0gXCLCqVwiO1xudmFyIENPUFkgPSBcIsKpXCI7XG52YXIgY3VycmVuID0gXCLCpFwiO1xudmFyIGRlZyA9IFwiwrBcIjtcbnZhciBkaXZpZGUgPSBcIsO3XCI7XG52YXIgRWFjdXRlID0gXCLDiVwiO1xudmFyIGVhY3V0ZSA9IFwiw6lcIjtcbnZhciBFY2lyYyA9IFwiw4pcIjtcbnZhciBlY2lyYyA9IFwiw6pcIjtcbnZhciBFZ3JhdmUgPSBcIsOIXCI7XG52YXIgZWdyYXZlID0gXCLDqFwiO1xudmFyIEVUSCA9IFwiw5BcIjtcbnZhciBldGggPSBcIsOwXCI7XG52YXIgRXVtbCA9IFwiw4tcIjtcbnZhciBldW1sID0gXCLDq1wiO1xudmFyIGZyYWMxMiA9IFwiwr1cIjtcbnZhciBmcmFjMTQgPSBcIsK8XCI7XG52YXIgZnJhYzM0ID0gXCLCvlwiO1xudmFyIGd0JDEgPSBcIj5cIjtcbnZhciBHVCA9IFwiPlwiO1xudmFyIElhY3V0ZSA9IFwiw41cIjtcbnZhciBpYWN1dGUgPSBcIsOtXCI7XG52YXIgSWNpcmMgPSBcIsOOXCI7XG52YXIgaWNpcmMgPSBcIsOuXCI7XG52YXIgaWV4Y2wgPSBcIsKhXCI7XG52YXIgSWdyYXZlID0gXCLDjFwiO1xudmFyIGlncmF2ZSA9IFwiw6xcIjtcbnZhciBpcXVlc3QgPSBcIsK/XCI7XG52YXIgSXVtbCA9IFwiw49cIjtcbnZhciBpdW1sID0gXCLDr1wiO1xudmFyIGxhcXVvID0gXCLCq1wiO1xudmFyIGx0JDEgPSBcIjxcIjtcbnZhciBMVCA9IFwiPFwiO1xudmFyIG1hY3IgPSBcIsKvXCI7XG52YXIgbWljcm8gPSBcIsK1XCI7XG52YXIgbWlkZG90ID0gXCLCt1wiO1xudmFyIG5ic3AgPSBcIsKgXCI7XG52YXIgbm90ID0gXCLCrFwiO1xudmFyIE50aWxkZSA9IFwiw5FcIjtcbnZhciBudGlsZGUgPSBcIsOxXCI7XG52YXIgT2FjdXRlID0gXCLDk1wiO1xudmFyIG9hY3V0ZSA9IFwiw7NcIjtcbnZhciBPY2lyYyA9IFwiw5RcIjtcbnZhciBvY2lyYyA9IFwiw7RcIjtcbnZhciBPZ3JhdmUgPSBcIsOSXCI7XG52YXIgb2dyYXZlID0gXCLDslwiO1xudmFyIG9yZGYgPSBcIsKqXCI7XG52YXIgb3JkbSA9IFwiwrpcIjtcbnZhciBPc2xhc2ggPSBcIsOYXCI7XG52YXIgb3NsYXNoID0gXCLDuFwiO1xudmFyIE90aWxkZSA9IFwiw5VcIjtcbnZhciBvdGlsZGUgPSBcIsO1XCI7XG52YXIgT3VtbCA9IFwiw5ZcIjtcbnZhciBvdW1sID0gXCLDtlwiO1xudmFyIHBhcmEgPSBcIsK2XCI7XG52YXIgcGx1c21uID0gXCLCsVwiO1xudmFyIHBvdW5kID0gXCLCo1wiO1xudmFyIHF1b3QkMSA9IFwiXFxcIlwiO1xudmFyIFFVT1QgPSBcIlxcXCJcIjtcbnZhciByYXF1byA9IFwiwrtcIjtcbnZhciByZWcgPSBcIsKuXCI7XG52YXIgUkVHID0gXCLCrlwiO1xudmFyIHNlY3QgPSBcIsKnXCI7XG52YXIgc2h5ID0gXCLCrVwiO1xudmFyIHN1cDEgPSBcIsK5XCI7XG52YXIgc3VwMiA9IFwiwrJcIjtcbnZhciBzdXAzID0gXCLCs1wiO1xudmFyIHN6bGlnID0gXCLDn1wiO1xudmFyIFRIT1JOID0gXCLDnlwiO1xudmFyIHRob3JuID0gXCLDvlwiO1xudmFyIHRpbWVzID0gXCLDl1wiO1xudmFyIFVhY3V0ZSA9IFwiw5pcIjtcbnZhciB1YWN1dGUgPSBcIsO6XCI7XG52YXIgVWNpcmMgPSBcIsObXCI7XG52YXIgdWNpcmMgPSBcIsO7XCI7XG52YXIgVWdyYXZlID0gXCLDmVwiO1xudmFyIHVncmF2ZSA9IFwiw7lcIjtcbnZhciB1bWwgPSBcIsKoXCI7XG52YXIgVXVtbCA9IFwiw5xcIjtcbnZhciB1dW1sID0gXCLDvFwiO1xudmFyIFlhY3V0ZSA9IFwiw51cIjtcbnZhciB5YWN1dGUgPSBcIsO9XCI7XG52YXIgeWVuID0gXCLCpVwiO1xudmFyIHl1bWwgPSBcIsO/XCI7XG52YXIgcmVxdWlyZSQkMSA9IHtcbiAgICBBYWN1dGU6IEFhY3V0ZSxcbiAgICBhYWN1dGU6IGFhY3V0ZSxcbiAgICBBY2lyYzogQWNpcmMsXG4gICAgYWNpcmM6IGFjaXJjLFxuICAgIGFjdXRlOiBhY3V0ZSxcbiAgICBBRWxpZzogQUVsaWcsXG4gICAgYWVsaWc6IGFlbGlnLFxuICAgIEFncmF2ZTogQWdyYXZlLFxuICAgIGFncmF2ZTogYWdyYXZlLFxuICAgIGFtcDogYW1wJDEsXG4gICAgQU1QOiBBTVAsXG4gICAgQXJpbmc6IEFyaW5nLFxuICAgIGFyaW5nOiBhcmluZyxcbiAgICBBdGlsZGU6IEF0aWxkZSxcbiAgICBhdGlsZGU6IGF0aWxkZSxcbiAgICBBdW1sOiBBdW1sLFxuICAgIGF1bWw6IGF1bWwsXG4gICAgYnJ2YmFyOiBicnZiYXIsXG4gICAgQ2NlZGlsOiBDY2VkaWwsXG4gICAgY2NlZGlsOiBjY2VkaWwsXG4gICAgY2VkaWw6IGNlZGlsLFxuICAgIGNlbnQ6IGNlbnQsXG4gICAgY29weTogY29weSxcbiAgICBDT1BZOiBDT1BZLFxuICAgIGN1cnJlbjogY3VycmVuLFxuICAgIGRlZzogZGVnLFxuICAgIGRpdmlkZTogZGl2aWRlLFxuICAgIEVhY3V0ZTogRWFjdXRlLFxuICAgIGVhY3V0ZTogZWFjdXRlLFxuICAgIEVjaXJjOiBFY2lyYyxcbiAgICBlY2lyYzogZWNpcmMsXG4gICAgRWdyYXZlOiBFZ3JhdmUsXG4gICAgZWdyYXZlOiBlZ3JhdmUsXG4gICAgRVRIOiBFVEgsXG4gICAgZXRoOiBldGgsXG4gICAgRXVtbDogRXVtbCxcbiAgICBldW1sOiBldW1sLFxuICAgIGZyYWMxMjogZnJhYzEyLFxuICAgIGZyYWMxNDogZnJhYzE0LFxuICAgIGZyYWMzNDogZnJhYzM0LFxuICAgIGd0OiBndCQxLFxuICAgIEdUOiBHVCxcbiAgICBJYWN1dGU6IElhY3V0ZSxcbiAgICBpYWN1dGU6IGlhY3V0ZSxcbiAgICBJY2lyYzogSWNpcmMsXG4gICAgaWNpcmM6IGljaXJjLFxuICAgIGlleGNsOiBpZXhjbCxcbiAgICBJZ3JhdmU6IElncmF2ZSxcbiAgICBpZ3JhdmU6IGlncmF2ZSxcbiAgICBpcXVlc3Q6IGlxdWVzdCxcbiAgICBJdW1sOiBJdW1sLFxuICAgIGl1bWw6IGl1bWwsXG4gICAgbGFxdW86IGxhcXVvLFxuICAgIGx0OiBsdCQxLFxuICAgIExUOiBMVCxcbiAgICBtYWNyOiBtYWNyLFxuICAgIG1pY3JvOiBtaWNybyxcbiAgICBtaWRkb3Q6IG1pZGRvdCxcbiAgICBuYnNwOiBuYnNwLFxuICAgIG5vdDogbm90LFxuICAgIE50aWxkZTogTnRpbGRlLFxuICAgIG50aWxkZTogbnRpbGRlLFxuICAgIE9hY3V0ZTogT2FjdXRlLFxuICAgIG9hY3V0ZTogb2FjdXRlLFxuICAgIE9jaXJjOiBPY2lyYyxcbiAgICBvY2lyYzogb2NpcmMsXG4gICAgT2dyYXZlOiBPZ3JhdmUsXG4gICAgb2dyYXZlOiBvZ3JhdmUsXG4gICAgb3JkZjogb3JkZixcbiAgICBvcmRtOiBvcmRtLFxuICAgIE9zbGFzaDogT3NsYXNoLFxuICAgIG9zbGFzaDogb3NsYXNoLFxuICAgIE90aWxkZTogT3RpbGRlLFxuICAgIG90aWxkZTogb3RpbGRlLFxuICAgIE91bWw6IE91bWwsXG4gICAgb3VtbDogb3VtbCxcbiAgICBwYXJhOiBwYXJhLFxuICAgIHBsdXNtbjogcGx1c21uLFxuICAgIHBvdW5kOiBwb3VuZCxcbiAgICBxdW90OiBxdW90JDEsXG4gICAgUVVPVDogUVVPVCxcbiAgICByYXF1bzogcmFxdW8sXG4gICAgcmVnOiByZWcsXG4gICAgUkVHOiBSRUcsXG4gICAgc2VjdDogc2VjdCxcbiAgICBzaHk6IHNoeSxcbiAgICBzdXAxOiBzdXAxLFxuICAgIHN1cDI6IHN1cDIsXG4gICAgc3VwMzogc3VwMyxcbiAgICBzemxpZzogc3psaWcsXG4gICAgVEhPUk46IFRIT1JOLFxuICAgIHRob3JuOiB0aG9ybixcbiAgICB0aW1lczogdGltZXMsXG4gICAgVWFjdXRlOiBVYWN1dGUsXG4gICAgdWFjdXRlOiB1YWN1dGUsXG4gICAgVWNpcmM6IFVjaXJjLFxuICAgIHVjaXJjOiB1Y2lyYyxcbiAgICBVZ3JhdmU6IFVncmF2ZSxcbiAgICB1Z3JhdmU6IHVncmF2ZSxcbiAgICB1bWw6IHVtbCxcbiAgICBVdW1sOiBVdW1sLFxuICAgIHV1bWw6IHV1bWwsXG4gICAgWWFjdXRlOiBZYWN1dGUsXG4gICAgeWFjdXRlOiB5YWN1dGUsXG4gICAgeWVuOiB5ZW4sXG4gICAgeXVtbDogeXVtbFxufTtcbnZhciBhbXAgPSBcIiZcIjtcbnZhciBhcG9zID0gXCInXCI7XG52YXIgZ3QgPSBcIj5cIjtcbnZhciBsdCA9IFwiPFwiO1xudmFyIHF1b3QgPSBcIlxcXCJcIjtcbnZhciByZXF1aXJlJCQwJDEgPSB7XG4gICAgYW1wOiBhbXAsXG4gICAgYXBvczogYXBvcyxcbiAgICBndDogZ3QsXG4gICAgbHQ6IGx0LFxuICAgIHF1b3Q6IHF1b3Rcbn07XG52YXIgZGVjb2RlX2NvZGVwb2ludCA9IHt9O1xudmFyIHJlcXVpcmUkJDAgPSB7XG4gICAgXCIwXCI6IDY1NTMzLFxuICAgIFwiMTI4XCI6IDgzNjQsXG4gICAgXCIxMzBcIjogODIxOCxcbiAgICBcIjEzMVwiOiA0MDIsXG4gICAgXCIxMzJcIjogODIyMixcbiAgICBcIjEzM1wiOiA4MjMwLFxuICAgIFwiMTM0XCI6IDgyMjQsXG4gICAgXCIxMzVcIjogODIyNSxcbiAgICBcIjEzNlwiOiA3MTAsXG4gICAgXCIxMzdcIjogODI0MCxcbiAgICBcIjEzOFwiOiAzNTIsXG4gICAgXCIxMzlcIjogODI0OSxcbiAgICBcIjE0MFwiOiAzMzgsXG4gICAgXCIxNDJcIjogMzgxLFxuICAgIFwiMTQ1XCI6IDgyMTYsXG4gICAgXCIxNDZcIjogODIxNyxcbiAgICBcIjE0N1wiOiA4MjIwLFxuICAgIFwiMTQ4XCI6IDgyMjEsXG4gICAgXCIxNDlcIjogODIyNixcbiAgICBcIjE1MFwiOiA4MjExLFxuICAgIFwiMTUxXCI6IDgyMTIsXG4gICAgXCIxNTJcIjogNzMyLFxuICAgIFwiMTUzXCI6IDg0ODIsXG4gICAgXCIxNTRcIjogMzUzLFxuICAgIFwiMTU1XCI6IDgyNTAsXG4gICAgXCIxNTZcIjogMzM5LFxuICAgIFwiMTU4XCI6IDM4MixcbiAgICBcIjE1OVwiOiAzNzZcbn07XG52YXIgX19pbXBvcnREZWZhdWx0JDIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlY29kZV9jb2RlcG9pbnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlY29kZV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQkMihyZXF1aXJlJCQwKTtcbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9oZS9ibG9iL21hc3Rlci9zcmMvaGUuanMjTDk0LUwxMTlcbnZhciBmcm9tQ29kZVBvaW50JDIgPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG5TdHJpbmcuZnJvbUNvZGVQb2ludCB8fFxuICAgIGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweGZmZmYpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMCk7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSAweGRjMDAgfCAoY29kZVBvaW50ICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcbiAgICBpZiAoKGNvZGVQb2ludCA+PSAweGQ4MDAgJiYgY29kZVBvaW50IDw9IDB4ZGZmZikgfHwgY29kZVBvaW50ID4gMHgxMGZmZmYpIHtcbiAgICAgICAgcmV0dXJuIFwiXFx1RkZGRFwiO1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50IGluIGRlY29kZV9qc29uXzEuZGVmYXVsdCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBkZWNvZGVfanNvbl8xLmRlZmF1bHRbY29kZVBvaW50XTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21Db2RlUG9pbnQkMihjb2RlUG9pbnQpO1xufVxuZGVjb2RlX2NvZGVwb2ludC5kZWZhdWx0ID0gZGVjb2RlQ29kZVBvaW50O1xudmFyIF9faW1wb3J0RGVmYXVsdCQxID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWNvZGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZGVjb2RlLmRlY29kZUhUTUwgPSBkZWNvZGUuZGVjb2RlSFRNTFN0cmljdCA9IGRlY29kZS5kZWNvZGVYTUwgPSB2b2lkIDA7XG52YXIgZW50aXRpZXNfanNvbl8xJDEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQxJDEpO1xudmFyIGxlZ2FjeV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQxKTtcbnZhciB4bWxfanNvbl8xJDEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQwJDEpO1xudmFyIGRlY29kZV9jb2RlcG9pbnRfMSA9IF9faW1wb3J0RGVmYXVsdCQxKGRlY29kZV9jb2RlcG9pbnQpO1xudmFyIHN0cmljdEVudGl0eVJlID0gLyYoPzpbYS16QS1aMC05XSt8I1t4WF1bXFxkYS1mQS1GXSt8I1xcZCspOy9nO1xuZGVjb2RlLmRlY29kZVhNTCA9IGdldFN0cmljdERlY29kZXIoeG1sX2pzb25fMSQxLmRlZmF1bHQpO1xuZGVjb2RlLmRlY29kZUhUTUxTdHJpY3QgPSBnZXRTdHJpY3REZWNvZGVyKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpO1xuZnVuY3Rpb24gZ2V0U3RyaWN0RGVjb2RlcihtYXApIHtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKG1hcCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2Uoc3RyaWN0RW50aXR5UmUsIHJlcGxhY2UpOyB9O1xufVxudmFyIHNvcnRlciA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYSA8IGIgPyAxIDogLTEpOyB9O1xuZGVjb2RlLmRlY29kZUhUTUwgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZWdhY3kgPSBPYmplY3Qua2V5cyhsZWdhY3lfanNvbl8xLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZWdhY3lbal0gPT09IGtleXNbaV0pIHtcbiAgICAgICAgICAgIGtleXNbaV0gKz0gXCI7P1wiO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5c1tpXSArPSBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cy5qb2luKFwifFwiKSArIFwifCNbeFhdW1xcXFxkYS1mQS1GXSs7P3wjXFxcXGQrOz8pXCIsIFwiZ1wiKTtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKHN0cikge1xuICAgICAgICBpZiAoc3RyLnN1YnN0cigtMSkgIT09IFwiO1wiKVxuICAgICAgICAgICAgc3RyICs9IFwiO1wiO1xuICAgICAgICByZXR1cm4gcmVwbGFjZShzdHIpO1xuICAgIH1cbiAgICAvLyBUT0RPIGNvbnNpZGVyIGNyZWF0aW5nIGEgbWVyZ2VkIG1hcFxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHJlLCByZXBsYWNlcik7IH07XG59KSgpO1xuZnVuY3Rpb24gZ2V0UmVwbGFjZXIobWFwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2Uoc3RyKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDEpID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIHNlY29uZENoYXIgPSBzdHIuY2hhckF0KDIpO1xuICAgICAgICAgICAgaWYgKHNlY29uZENoYXIgPT09IFwiWFwiIHx8IHNlY29uZENoYXIgPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZV9jb2RlcG9pbnRfMS5kZWZhdWx0KHBhcnNlSW50KHN0ci5zdWJzdHIoMyksIDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlX2NvZGVwb2ludF8xLmRlZmF1bHQocGFyc2VJbnQoc3RyLnN1YnN0cigyKSwgMTApKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgcmV0dXJuIG1hcFtzdHIuc2xpY2UoMSwgLTEpXSB8fCBzdHI7XG4gICAgfTtcbn1cbnZhciBlbmNvZGUgPSB7fTtcbnZhciBlc21faW1wb3J0RGVmYXVsdCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW5jb2RlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmVuY29kZS5lc2NhcGVVVEY4ID0gZW5jb2RlLmVzY2FwZSA9IGVuY29kZS5lbmNvZGVOb25Bc2NpaUhUTUwgPSBlbmNvZGUuZW5jb2RlSFRNTCA9IGVuY29kZS5lbmNvZGVYTUwgPSB2b2lkIDA7XG52YXIgeG1sX2pzb25fMSA9IGVzbV9pbXBvcnREZWZhdWx0KHJlcXVpcmUkJDAkMSk7XG52YXIgaW52ZXJzZVhNTCA9IGdldEludmVyc2VPYmooeG1sX2pzb25fMS5kZWZhdWx0KTtcbnZhciB4bWxSZXBsYWNlciA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlWE1MKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgWE1MIGVudGl0aWVzLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlWE1MID0gZ2V0QVNDSUlFbmNvZGVyKGludmVyc2VYTUwpO1xudmFyIGVudGl0aWVzX2pzb25fMSA9IGVzbV9pbXBvcnREZWZhdWx0KHJlcXVpcmUkJDEkMSk7XG52YXIgaW52ZXJzZUhUTUwgPSBnZXRJbnZlcnNlT2JqKGVudGl0aWVzX2pzb25fMS5kZWZhdWx0KTtcbnZhciBodG1sUmVwbGFjZXIgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZUhUTUwpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBlbnRpdGllcyBhbmQgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0LlxuICpcbiAqIFRoaXMgaW5jbHVkZXMgY2hhcmFjdGVycyB0aGF0IGFyZSB2YWxpZCBBU0NJSSBjaGFyYWN0ZXJzIGluIEhUTUwgZG9jdW1lbnRzLlxuICogRm9yIGV4YW1wbGUgYCNgIHdpbGwgYmUgZW5jb2RlZCBhcyBgJm51bTtgLiBUbyBnZXQgYSBtb3JlIGNvbXBhY3Qgb3V0cHV0LFxuICogY29uc2lkZXIgdXNpbmcgdGhlIGBlbmNvZGVOb25Bc2NpaUhUTUxgIGZ1bmN0aW9uLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlSFRNTCA9IGdldEludmVyc2UoaW52ZXJzZUhUTUwsIGh0bWxSZXBsYWNlcik7XG4vKipcbiAqIEVuY29kZXMgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIEhUTUxcbiAqIGRvY3VtZW50cyB1c2luZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlTm9uQXNjaWlIVE1MID0gZ2V0QVNDSUlFbmNvZGVyKGludmVyc2VIVE1MKTtcbmZ1bmN0aW9uIGdldEludmVyc2VPYmoob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChpbnZlcnNlLCBuYW1lKSB7XG4gICAgICAgIGludmVyc2Vbb2JqW25hbWVdXSA9IFwiJlwiICsgbmFtZSArIFwiO1wiO1xuICAgICAgICByZXR1cm4gaW52ZXJzZTtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZSkge1xuICAgIHZhciBzaW5nbGUgPSBbXTtcbiAgICB2YXIgbXVsdGlwbGUgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMoaW52ZXJzZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICBpZiAoay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZSB0byBzaW5nbGUgYXJyYXlcbiAgICAgICAgICAgIHNpbmdsZS5wdXNoKFwiXFxcXFwiICsgayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgdmFsdWUgdG8gbXVsdGlwbGUgYXJyYXlcbiAgICAgICAgICAgIG11bHRpcGxlLnB1c2goayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIHJhbmdlcyB0byBzaW5nbGUgY2hhcmFjdGVycy5cbiAgICBzaW5nbGUuc29ydCgpO1xuICAgIGZvciAodmFyIHN0YXJ0ID0gMDsgc3RhcnQgPCBzaW5nbGUubGVuZ3RoIC0gMTsgc3RhcnQrKykge1xuICAgICAgICAvLyBGaW5kIHRoZSBlbmQgb2YgYSBydW4gb2YgY2hhcmFjdGVyc1xuICAgICAgICB2YXIgZW5kID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlIChlbmQgPCBzaW5nbGUubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgc2luZ2xlW2VuZF0uY2hhckNvZGVBdCgxKSArIDEgPT09IHNpbmdsZVtlbmQgKyAxXS5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgICAgICBlbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY291bnQgPSAxICsgZW5kIC0gc3RhcnQ7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcmVwbGFjZSBhdCBsZWFzdCB0aHJlZSBjaGFyYWN0ZXJzXG4gICAgICAgIGlmIChjb3VudCA8IDMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc2luZ2xlLnNwbGljZShzdGFydCwgY291bnQsIHNpbmdsZVtzdGFydF0gKyBcIi1cIiArIHNpbmdsZVtlbmRdKTtcbiAgICB9XG4gICAgbXVsdGlwbGUudW5zaGlmdChcIltcIiArIHNpbmdsZS5qb2luKFwiXCIpICsgXCJdXCIpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKG11bHRpcGxlLmpvaW4oXCJ8XCIpLCBcImdcIik7XG59XG4vLyAvW15cXDAtXFx4N0ZdL2d1XG52YXIgcmVOb25BU0NJSSA9IC8oPzpbXFx4ODAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvZztcbnZhciBnZXRDb2RlUG9pbnQgPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG5TdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ICE9IG51bGxcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5jb2RlUG9pbnRBdCgwKTsgfVxuICAgIDogLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiAoYy5jaGFyQ29kZUF0KDApIC0gMHhkODAwKSAqIDB4NDAwICtcbiAgICAgICAgICAgICAgICBjLmNoYXJDb2RlQXQoMSkgLVxuICAgICAgICAgICAgICAgIDB4ZGMwMCArXG4gICAgICAgICAgICAgICAgMHgxMDAwMDtcbiAgICAgICAgfTtcbmZ1bmN0aW9uIHNpbmdsZUNoYXJSZXBsYWNlcihjKSB7XG4gICAgcmV0dXJuIFwiJiN4XCIgKyAoYy5sZW5ndGggPiAxID8gZ2V0Q29kZVBvaW50KGMpIDogYy5jaGFyQ29kZUF0KDApKVxuICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpICsgXCI7XCI7XG59XG5mdW5jdGlvbiBnZXRJbnZlcnNlKGludmVyc2UsIHJlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgICAgICAucmVwbGFjZShyZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGludmVyc2VbbmFtZV07IH0pXG4gICAgICAgICAgICAucmVwbGFjZShyZU5vbkFTQ0lJLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xuICAgIH07XG59XG52YXIgcmVFc2NhcGVDaGFycyA9IG5ldyBSZWdFeHAoeG1sUmVwbGFjZXIuc291cmNlICsgXCJ8XCIgKyByZU5vbkFTQ0lJLnNvdXJjZSwgXCJnXCIpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBYTUxcbiAqIGRvY3VtZW50cyB1c2luZyBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKS5cbiAqXG4gKiBIYXZlIGEgbG9vayBhdCBgZXNjYXBlVVRGOGAgaWYgeW91IHdhbnQgYSBtb3JlIGNvbmNpc2Ugb3V0cHV0IGF0IHRoZSBleHBlbnNlXG4gKiBvZiByZWR1Y2VkIHRyYW5zcG9ydGFiaWxpdHkuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZnVuY3Rpb24gZXNtX2VzY2FwZShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZShyZUVzY2FwZUNoYXJzLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xufVxuZW5jb2RlLmVzY2FwZSA9IGVzbV9lc2NhcGU7XG4vKipcbiAqIEVuY29kZXMgYWxsIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIFhNTCBkb2N1bWVudHMgdXNpbmcgbnVtZXJpYyBoZXhhZGVjaW1hbFxuICogcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgb3V0cHV0IHdpbGwgYmUgY2hhcmFjdGVyLXNldCBkZXBlbmRlbnQuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVVRGOChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSh4bWxSZXBsYWNlciwgc2luZ2xlQ2hhclJlcGxhY2VyKTtcbn1cbmVuY29kZS5lc2NhcGVVVEY4ID0gZXNjYXBlVVRGODtcbmZ1bmN0aW9uIGdldEFTQ0lJRW5jb2RlcihvYmopIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZShyZUVzY2FwZUNoYXJzLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gb2JqW2NdIHx8IHNpbmdsZUNoYXJSZXBsYWNlcihjKTsgfSk7XG4gICAgfTtcbn1cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLmRlY29kZVhNTFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDVTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw0U3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNSA9IGV4cG9ydHMuZGVjb2RlSFRNTDQgPSBleHBvcnRzLmRlY29kZUhUTUxTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUwgPSBleHBvcnRzLmRlY29kZVhNTCA9IGV4cG9ydHMuZW5jb2RlSFRNTDUgPSBleHBvcnRzLmVuY29kZUhUTUw0ID0gZXhwb3J0cy5lc2NhcGVVVEY4ID0gZXhwb3J0cy5lc2NhcGUgPSBleHBvcnRzLmVuY29kZU5vbkFzY2lpSFRNTCA9IGV4cG9ydHMuZW5jb2RlSFRNTCA9IGV4cG9ydHMuZW5jb2RlWE1MID0gZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZVN0cmljdCA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuICAgIHZhciBkZWNvZGVfMSA9IGRlY29kZTtcbiAgICB2YXIgZW5jb2RlXzEgPSBlbmNvZGU7XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlWE1MYCBvciBgZGVjb2RlSFRNTGAgZGlyZWN0bHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjb2RlJDEoZGF0YSwgbGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGRlY29kZV8xLmRlY29kZVhNTCA6IGRlY29kZV8xLmRlY29kZUhUTUwpKGRhdGEpO1xuICAgIH1cbiAgICBleHBvcnRzLmRlY29kZSA9IGRlY29kZSQxO1xuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy4gRG9lcyBub3QgYWxsb3cgbWlzc2luZyB0cmFpbGluZyBzZW1pY29sb25zIGZvciBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGRlY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZUhUTUxTdHJpY3RgIG9yIGBkZWNvZGVYTUxgIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY29kZVN0cmljdChkYXRhLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlXzEuZGVjb2RlWE1MIDogZGVjb2RlXzEuZGVjb2RlSFRNTFN0cmljdCkoZGF0YSk7XG4gICAgfVxuICAgIGV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZGVjb2RlU3RyaWN0O1xuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGVuY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGVuY29kZUhUTUxgLCBgZW5jb2RlWE1MYCBvciBgZW5jb2RlTm9uQXNjaWlIVE1MYCBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmNvZGUkMShkYXRhLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZW5jb2RlXzEuZW5jb2RlWE1MIDogZW5jb2RlXzEuZW5jb2RlSFRNTCkoZGF0YSk7XG4gICAgfVxuICAgIGV4cG9ydHMuZW5jb2RlID0gZW5jb2RlJDE7XG4gICAgdmFyIGVuY29kZV8yID0gZW5jb2RlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVhNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlWE1MOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZUhUTUw7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlTm9uQXNjaWlIVE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVOb25Bc2NpaUhUTUw7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lc2NhcGU7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlVVRGOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZXNjYXBlVVRGODsgfSB9KTtcbiAgICAvLyBMZWdhY3kgYWxpYXNlcyAoZGVwcmVjYXRlZClcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MNVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbiAgICB2YXIgZGVjb2RlXzIgPSBkZWNvZGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlWE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVYTUw7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTDsgfSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MU3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuICAgIC8vIExlZ2FjeSBhbGlhc2VzIChkZXByZWNhdGVkKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw0U3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1U3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVhNTFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlWE1MOyB9IH0pO1xufShsaWIpKTtcbnZhciBFTlRJVFkgPSAnJig/OiN4W2EtZjAtOV17MSw2fXwjWzAtOV17MSw3fXxbYS16XVthLXowLTldezEsMzF9KTsnO1xudmFyIENfQkFDS1NMQVNIJDEgPSA5MjtcbnZhciByZUJhY2tzbGFzaE9yQW1wID0gL1tcXFxcJl0vO1xudmFyIEVTQ0FQQUJMRSA9ICdbIVwiIyQlJlxcJygpKissLi86Ozw9Pj9AW1xcXFxcXFxcXFxcXF1eX2B7fH1+LV0nO1xudmFyIHJlRW50aXR5T3JFc2NhcGVkQ2hhciA9IG5ldyBSZWdFeHAoXCJcXFxcXFxcXFwiICsgRVNDQVBBQkxFICsgXCJ8XCIgKyBFTlRJVFksICdnaScpO1xudmFyIFhNTFNQRUNJQUwgPSAnWyY8PlwiXSc7XG52YXIgcmVYbWxTcGVjaWFsID0gbmV3IFJlZ0V4cChYTUxTUEVDSUFMLCAnZycpO1xudmFyIHVuZXNjYXBlQ2hhciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdCgwKSA9PT0gQ19CQUNLU0xBU0gkMSkge1xuICAgICAgICByZXR1cm4gcy5jaGFyQXQoMSk7XG4gICAgfVxuICAgIHJldHVybiBsaWIuZGVjb2RlSFRNTChzKTtcbn07XG4vLyBSZXBsYWNlIGVudGl0aWVzIGFuZCBiYWNrc2xhc2ggZXNjYXBlcyB3aXRoIGxpdGVyYWwgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHVuZXNjYXBlU3RyaW5nKHMpIHtcbiAgICBpZiAocmVCYWNrc2xhc2hPckFtcC50ZXN0KHMpKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UocmVFbnRpdHlPckVzY2FwZWRDaGFyLCB1bmVzY2FwZUNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSSSh1cmkpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZW5jb2RlXzEodXJpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VVbnNhZmVDaGFyKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZVhtbChzKSB7XG4gICAgaWYgKHJlWG1sU3BlY2lhbC50ZXN0KHMpKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UocmVYbWxTcGVjaWFsLCByZXBsYWNlVW5zYWZlQ2hhcik7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGFyci5wdXNoKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBhcnIuam9pbignJyk7XG59XG5mdW5jdGlvbiBpc0VtcHR5KHN0cikge1xuICAgIGlmICghc3RyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIS9bXiBcXHRdKy8udGVzdChzdHIpO1xufVxudmFyIE5vZGVXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZVdhbGtlcihyb290KSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHJvb3Q7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBOb2RlV2Fsa2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSB0aGlzLmVudGVyaW5nO1xuICAgICAgICBpZiAoY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGFpbmVyID0gaXNDb250YWluZXIoY3VyKTtcbiAgICAgICAgaWYgKGVudGVyaW5nICYmIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGN1ci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdGF5IG9uIG5vZGUgYnV0IGV4aXRcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIubmV4dDtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVudGVyaW5nOiBlbnRlcmluZywgbm9kZTogY3VyIH07XG4gICAgfTtcbiAgICBOb2RlV2Fsa2VyLnByb3RvdHlwZS5yZXN1bWVBdCA9IGZ1bmN0aW9uIChub2RlLCBlbnRlcmluZykge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICB0aGlzLmVudGVyaW5nID0gZW50ZXJpbmcgPT09IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZVdhbGtlcjtcbn0oKSk7XG5mdW5jdGlvbiBpc0NvbnRhaW5lcihub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICBjYXNlICdibG9ja1F1b3RlJzpcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgY2FzZSAnZW1waCc6XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgY2FzZSAndGFibGVIZWFkJzpcbiAgICAgICAgY2FzZSAndGFibGVCb2R5JzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUNlbGwnOlxuICAgICAgICBjYXNlICd0YWJsZURlbGltUm93JzpcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbnZhciBsYXN0Tm9kZUlkID0gMTtcbnZhciBub2RlTWFwID0ge307XG5mdW5jdGlvbiBnZXROb2RlQnlJZChpZCkge1xuICAgIHJldHVybiBub2RlTWFwW2lkXTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGVCeUlkKGlkKSB7XG4gICAgZGVsZXRlIG5vZGVNYXBbaWRdO1xufVxuZnVuY3Rpb24gcmVtb3ZlQWxsTm9kZSgpIHtcbiAgICBub2RlTWFwID0ge307XG59XG52YXIgZXNtX05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShub2RlVHlwZSwgc291cmNlcG9zKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gb25seSBmb3IgY29udGFpbmVyIG5vZGVcbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgICAvLyBvbmx5IGZvciBsZWFmIG5vZGVcbiAgICAgICAgdGhpcy5saXRlcmFsID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGVUeXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gbGFzdE5vZGVJZCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGVUeXBlO1xuICAgICAgICB0aGlzLnNvdXJjZXBvcyA9IHNvdXJjZXBvcztcbiAgICAgICAgbm9kZU1hcFt0aGlzLmlkXSA9IHRoaXM7XG4gICAgfVxuICAgIE5vZGUucHJvdG90eXBlLmlzQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNDb250YWluZXIodGhpcyk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXYpIHtcbiAgICAgICAgICAgIHRoaXMucHJldi5uZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5maXJzdENoaWxkID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5wcmV2ID0gdGhpcy5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5sYXN0Q2hpbGQgPSB0aGlzLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgICAgdGhpcy51bmxpbmsoKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKHNpYmxpbmcpIHtcbiAgICAgICAgc2libGluZy51bmxpbmsoKTtcbiAgICAgICAgc2libGluZy5uZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoc2libGluZy5uZXh0KSB7XG4gICAgICAgICAgICBzaWJsaW5nLm5leHQucHJldiA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5wcmV2ID0gdGhpcztcbiAgICAgICAgdGhpcy5uZXh0ID0gc2libGluZztcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgaWYgKCFzaWJsaW5nLm5leHQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudC5sYXN0Q2hpbGQgPSBzaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoc2libGluZykge1xuICAgICAgICBzaWJsaW5nLnVubGluaygpO1xuICAgICAgICBzaWJsaW5nLnByZXYgPSB0aGlzLnByZXY7XG4gICAgICAgIGlmIChzaWJsaW5nLnByZXYpIHtcbiAgICAgICAgICAgIHNpYmxpbmcucHJldi5uZXh0ID0gc2libGluZztcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLm5leHQgPSB0aGlzO1xuICAgICAgICB0aGlzLnByZXYgPSBzaWJsaW5nO1xuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXNpYmxpbmcucHJldikge1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnQuZmlyc3RDaGlsZCA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnVubGluaygpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkLm5leHQgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLnByZXYgPSB0aGlzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnByZXBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC51bmxpbmsoKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkLnByZXYgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLm5leHQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUud2Fsa2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVXYWxrZXIodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZTtcbn0oKSk7XG52YXIgQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKEJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja05vZGUobm9kZVR5cGUsIHNvdXJjZXBvcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBub2RlVHlwZSwgc291cmNlcG9zKSB8fCB0aGlzO1xuICAgICAgICAvLyB0ZW1wb3JhbCBkYXRhIChmb3IgcGFyc2luZylcbiAgICAgICAgX3RoaXMub3BlbiA9IHRydWU7XG4gICAgICAgIF90aGlzLmxpbmVPZmZzZXRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3RMaW5lQmxhbmsgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGFzdExpbmVDaGVja2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnR5cGUgPSBub2RlVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQmxvY2tOb2RlO1xufShlc21fTm9kZSkpO1xudmFyIExpc3ROb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKExpc3ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3ROb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGlzdERhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXN0Tm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgSGVhZGluZ05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoSGVhZGluZ05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGluZ05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZXZlbCA9IDA7XG4gICAgICAgIF90aGlzLmhlYWRpbmdUeXBlID0gJ2F0eCc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRpbmdOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBDb2RlQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKENvZGVCbG9ja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZUJsb2NrTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzRmVuY2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmZlbmNlQ2hhciA9IG51bGw7XG4gICAgICAgIF90aGlzLmZlbmNlTGVuZ3RoID0gMDtcbiAgICAgICAgX3RoaXMuZmVuY2VPZmZzZXQgPSAtMTtcbiAgICAgICAgX3RoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIF90aGlzLmluZm9QYWRkaW5nID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29kZUJsb2NrTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgVGFibGVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKFRhYmxlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgVGFibGVDZWxsTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlc21fZXh0ZW5kcyhUYWJsZUNlbGxOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQ2VsbE5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGFydElkeCA9IDA7XG4gICAgICAgIF90aGlzLmVuZElkeCA9IDA7XG4gICAgICAgIF90aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgICAgX3RoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMuaWdub3JlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJsZUNlbGxOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBSZWZEZWZOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKFJlZkRlZk5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmRGVmTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRpdGxlID0gJyc7XG4gICAgICAgIF90aGlzLmRlc3QgPSAnJztcbiAgICAgICAgX3RoaXMubGFiZWwgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVmRGVmTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgQ3VzdG9tQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKEN1c3RvbUJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21CbG9ja05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeW50YXhMZW5ndGggPSAwO1xuICAgICAgICBfdGhpcy5vZmZzZXQgPSAtMTtcbiAgICAgICAgX3RoaXMuaW5mbyA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDdXN0b21CbG9ja05vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIEh0bWxCbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoSHRtbEJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdG1sQmxvY2tOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaHRtbEJsb2NrVHlwZSA9IC0xO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIdG1sQmxvY2tOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBMaW5rTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlc21fZXh0ZW5kcyhMaW5rTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMudGl0bGUgPSBudWxsO1xuICAgICAgICBfdGhpcy5leHRlbmRlZEF1dG9saW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpbmtOb2RlO1xufShlc21fTm9kZSkpO1xudmFyIENvZGVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKENvZGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGVOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGlja0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29kZU5vZGU7XG59KGVzbV9Ob2RlKSk7XG52YXIgQ3VzdG9tSW5saW5lTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlc21fZXh0ZW5kcyhDdXN0b21JbmxpbmVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUlubGluZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbmZvID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEN1c3RvbUlubGluZU5vZGU7XG59KGVzbV9Ob2RlKSk7XG5mdW5jdGlvbiBjcmVhdGVOb2RlKHR5cGUsIHNvdXJjZXBvcykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVhZGluZ05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0Tm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5rTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjb2RlQmxvY2snOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2RlQmxvY2tOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2h0bWxCbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh0bWxCbG9ja05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAndGFibGVDZWxsJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFibGVDZWxsTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrUXVvdGUnOlxuICAgICAgICBjYXNlICd0aGVtYXRpY0JyZWFrJzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUJvZHknOlxuICAgICAgICBjYXNlICd0YWJsZUhlYWQnOlxuICAgICAgICBjYXNlICdmcm9udE1hdHRlcic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29kZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAncmVmRGVmJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmRGVmTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjdXN0b21CbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjdXN0b21JbmxpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21JbmxpbmVOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGVzbV9Ob2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDb2RlQmxvY2sobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjb2RlQmxvY2snO1xufVxuZnVuY3Rpb24gaXNIdG1sQmxvY2sobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdodG1sQmxvY2snO1xufVxuZnVuY3Rpb24gaXNIZWFkaW5nKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnaGVhZGluZyc7XG59XG5mdW5jdGlvbiBpc0xpc3Qobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdsaXN0Jztcbn1cbmZ1bmN0aW9uIGlzVGFibGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICd0YWJsZSc7XG59XG5mdW5jdGlvbiBpc1JlZkRlZihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ3JlZkRlZic7XG59XG5mdW5jdGlvbiBpc0N1c3RvbUJsb2NrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnY3VzdG9tQmxvY2snO1xufVxuZnVuY3Rpb24gaXNDdXN0b21JbmxpbmUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjdXN0b21JbmxpbmUnO1xufVxuZnVuY3Rpb24gZXNtX3RleHQocywgc291cmNlcG9zKSB7XG4gICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlKCd0ZXh0Jywgc291cmNlcG9zKTtcbiAgICBub2RlLmxpdGVyYWwgPSBzO1xuICAgIHJldHVybiBub2RlO1xufVxudmFyIFRBR05BTUUgPSAnW0EtWmEtel1bQS1aYS16MC05LV0qJztcbnZhciBBVFRSSUJVVEVOQU1FID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcbnZhciBVTlFVT1RFRFZBTFVFID0gJ1teXCJcXCc9PD5gXFxcXHgwMC1cXFxceDIwXSsnO1xudmFyIFNJTkdMRVFVT1RFRFZBTFVFID0gXCInW14nXSonXCI7XG52YXIgRE9VQkxFUVVPVEVEVkFMVUUgPSAnXCJbXlwiXSpcIic7XG52YXIgQVRUUklCVVRFVkFMVUUgPSBcIig/OlwiICsgVU5RVU9URURWQUxVRSArIFwifFwiICsgU0lOR0xFUVVPVEVEVkFMVUUgKyBcInxcIiArIERPVUJMRVFVT1RFRFZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFVkFMVUVTUEVDID0gXCJcIiArICcoPzpcXFxccyo9XFxcXHMqJyArIEFUVFJJQlVURVZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFID0gXCJcIiArICcoPzpcXFxccysnICsgQVRUUklCVVRFTkFNRSArIEFUVFJJQlVURVZBTFVFU1BFQyArIFwiPylcIjtcbnZhciBPUEVOVEFHID0gXCI8XCIgKyBUQUdOQU1FICsgQVRUUklCVVRFICsgXCIqXFxcXHMqLz8+XCI7XG52YXIgQ0xPU0VUQUcgPSBcIjwvXCIgKyBUQUdOQU1FICsgXCJcXFxccypbPl1cIjtcbnZhciBIVE1MQ09NTUVOVCA9ICc8IS0tLS0+fDwhLS0oPzotP1tePi1dKSg/Oi0/W14tXSkqLS0+JztcbnZhciBQUk9DRVNTSU5HSU5TVFJVQ1RJT04gPSAnWzxdWz9dLio/Wz9dWz5dJztcbnZhciBERUNMQVJBVElPTiA9ICc8IVtBLVpdK1xcXFxzK1tePl0qPic7XG52YXIgQ0RBVEEgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JztcbnZhciBIVE1MVEFHID0gXCIoPzpcIiArIE9QRU5UQUcgKyBcInxcIiArIENMT1NFVEFHICsgXCJ8XCIgKyBIVE1MQ09NTUVOVCArIFwifFwiICsgUFJPQ0VTU0lOR0lOU1RSVUNUSU9OICsgXCJ8XCIgKyBERUNMQVJBVElPTiArIFwifFwiICsgQ0RBVEEgKyBcIilcIjtcbnZhciByZUh0bWxUYWcgPSBuZXcgUmVnRXhwKFwiXlwiICsgSFRNTFRBRywgJ2knKTtcbi8vIGRlcml2ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcuZnJvbUNvZGVQb2ludFxuLyohIGh0dHA6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMi4xIGJ5IEBtYXRoaWFzICovXG52YXIgZnJvbUNvZGVQb2ludDtcbmlmIChTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KF8pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweGZmZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5lbHNlIHtcbiAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlXzEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIHZhciBmbG9vcl8xID0gTWF0aC5mbG9vcjtcbiAgICBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMDtcbiAgICAgICAgdmFyIGNvZGVVbml0cyA9IFtdO1xuICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZTtcbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZTtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gTnVtYmVyKGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICAgICAgY29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPiAweDEwZmZmZiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICBmbG9vcl8xKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmZmZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4ZDgwMDtcbiAgICAgICAgICAgICAgICBsb3dTdXJyb2dhdGUgPSAoY29kZVBvaW50ICUgMHg0MDApICsgMHhkYzAwO1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZV8xLmFwcGx5KHZvaWQgMCwgY29kZVVuaXRzKTtcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG52YXIgZnJvbUNvZGVQb2ludCQxID0gZnJvbUNvZGVQb2ludDtcbnZhciBET01BSU4gPSAnKD86W3ctXSsuKSpbQS1aYS16MC05LV0rLltBLVphLXowLTktXSsnO1xudmFyIFBBVEggPSAnW148XFxcXHNdKltePD8hLiw6Kl8/flxcXFxzXSc7XG52YXIgRU1BSUwgPSAnW1xcXFx3ListXStAKD86W1xcXFx3LV0rXFxcXC4pK1tcXFxcdy1dKyc7XG5mdW5jdGlvbiB0cmltVW5tYXRjaGVkVHJhaWxpbmdQYXJlbnMoc291cmNlKSB7XG4gICAgdmFyIHRyYWlsaW5nUGFyZW4gPSAvXFwpKyQvLmV4ZWMoc291cmNlKTtcbiAgICBpZiAodHJhaWxpbmdQYXJlbikge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZV8xID0gc291cmNlOyBfaSA8IHNvdXJjZV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNoID0gc291cmNlXzFbX2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAgICAgdmFyIHRyaW1Db3VudCA9IE1hdGgubWluKC1jb3VudCwgdHJhaWxpbmdQYXJlblswXS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzdHJpbmcoMCwgc291cmNlLmxlbmd0aCAtIHRyaW1Db3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIHRyaW1UcmFpbGluZ0VudGl0eShzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoLyZbQS1aYS16MC05XSs7JC8sICcnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRW1haWxMaW5rKHNvdXJjZSkge1xuICAgIHZhciByZUVtYWlsTGluayA9IG5ldyBSZWdFeHAoRU1BSUwsICdnJyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBtO1xuICAgIHdoaWxlICgobSA9IHJlRW1haWxMaW5rLmV4ZWMoc291cmNlKSkpIHtcbiAgICAgICAgdmFyIHRleHRfMSA9IG1bMF07XG4gICAgICAgIGlmICghL1tfLV0rJC8udGVzdCh0ZXh0XzEpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dF8xLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbbS5pbmRleCwgbS5pbmRleCArIHRleHRfMS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICB1cmw6IFwibWFpbHRvOlwiICsgdGV4dF8xLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVXJsTGluayhzb3VyY2UpIHtcbiAgICB2YXIgcmVXd3dBdXRvbGluayA9IG5ldyBSZWdFeHAoXCIod3d3fGh0dHBzPzovLykuXCIgKyBET01BSU4gKyBQQVRILCAnZycpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbTtcbiAgICB3aGlsZSAoKG0gPSByZVd3d0F1dG9saW5rLmV4ZWMoc291cmNlKSkpIHtcbiAgICAgICAgdmFyIHRleHRfMiA9IHRyaW1UcmFpbGluZ0VudGl0eSh0cmltVW5tYXRjaGVkVHJhaWxpbmdQYXJlbnMobVswXSkpO1xuICAgICAgICB2YXIgc2NoZW1lID0gbVsxXSA9PT0gJ3d3dycgPyAnaHR0cDovLycgOiAnJztcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgdGV4dDogdGV4dF8yLFxuICAgICAgICAgICAgcmFuZ2U6IFttLmluZGV4LCBtLmluZGV4ICsgdGV4dF8yLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgdXJsOiBcIlwiICsgc2NoZW1lICsgdGV4dF8yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJhc2VBdXRvbGlua1BhcnNlcihzb3VyY2UpIHtcbiAgICByZXR1cm4gZXNtX3NwcmVhZEFycmF5KGVzbV9zcHJlYWRBcnJheShbXSwgcGFyc2VVcmxMaW5rKHNvdXJjZSkpLCBwYXJzZUVtYWlsTGluayhzb3VyY2UpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnJhbmdlWzBdIC0gYi5yYW5nZVswXTsgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RXh0QXV0b0xpbmtzKHdhbGtlciwgYXV0b2xpbmtQYXJzZXIpIHtcbiAgICBpZiAodHlwZW9mIGF1dG9saW5rUGFyc2VyID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgYXV0b2xpbmtQYXJzZXIgPSBiYXNlQXV0b2xpbmtQYXJzZXI7XG4gICAgfVxuICAgIHZhciBldmVudDtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmcsIG5vZGUgPSBldmVudC5ub2RlO1xuICAgICAgICBpZiAoZW50ZXJpbmcgJiYgbm9kZS50eXBlID09PSAndGV4dCcgJiYgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgICAgIHZhciBsaW5rSW5mb3MgPSBhdXRvbGlua1BhcnNlcihsaXRlcmFsKTtcbiAgICAgICAgICAgIGlmICghbGlua0luZm9zIHx8ICFsaW5rSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0SWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBfYSA9IG5vZGUuc291cmNlcG9zWzBdLCBsaW5lTnVtXzEgPSBfYVswXSwgY2hQb3NfMSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHNvdXJjZXBvcyA9IGZ1bmN0aW9uIChzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgW2xpbmVOdW1fMSwgY2hQb3NfMSArIHN0YXJ0SWR4XSxcbiAgICAgICAgICAgICAgICAgICAgW2xpbmVOdW1fMSwgY2hQb3NfMSArIGVuZElkeF0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlua0luZm9zXzEgPSBsaW5rSW5mb3M7IF9pIDwgbGlua0luZm9zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gbGlua0luZm9zXzFbX2ldLCByYW5nZSA9IF9iLnJhbmdlLCB1cmwgPSBfYi51cmwsIGxpbmtUZXh0ID0gX2IudGV4dDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VbMF0gPiBsYXN0SWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2goZXNtX3RleHQobGl0ZXJhbC5zdWJzdHJpbmcobGFzdElkeCwgcmFuZ2VbMF0pLCBzb3VyY2Vwb3MobGFzdElkeCwgcmFuZ2VbMF0gLSAxKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGlua05vZGUgPSBjcmVhdGVOb2RlKCdsaW5rJywgc291cmNlcG9zLmFwcGx5KHZvaWQgMCwgcmFuZ2UpKTtcbiAgICAgICAgICAgICAgICBsaW5rTm9kZS5hcHBlbmRDaGlsZChlc21fdGV4dChsaW5rVGV4dCwgc291cmNlcG9zLmFwcGx5KHZvaWQgMCwgcmFuZ2UpKSk7XG4gICAgICAgICAgICAgICAgbGlua05vZGUuZGVzdGluYXRpb24gPSB1cmw7XG4gICAgICAgICAgICAgICAgbGlua05vZGUuZXh0ZW5kZWRBdXRvbGluayA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaChsaW5rTm9kZSk7XG4gICAgICAgICAgICAgICAgbGFzdElkeCA9IHJhbmdlWzFdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0SWR4IDwgbGl0ZXJhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKGVzbV90ZXh0KGxpdGVyYWwuc3Vic3RyaW5nKGxhc3RJZHgpLCBzb3VyY2Vwb3MobGFzdElkeCwgbGl0ZXJhbC5sZW5ndGggLSAxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSAwLCBuZXdOb2Rlc18xID0gbmV3Tm9kZXM7IF9jIDwgbmV3Tm9kZXNfMS5sZW5ndGg7IF9jKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG5ld05vZGVzXzFbX2NdO1xuICAgICAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIF9sb29wXzEoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsYXN0KGFycikge1xuICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuLy8gbm9ybWFsaXplIGEgcmVmZXJlbmNlIGluIHJlZmVyZW5jZSBsaW5rIChyZW1vdmUgW11zLCB0cmltLFxuLy8gY29sbGFwc2UgaW50ZXJuYWwgc3BhY2UsIHVuaWNvZGUgY2FzZSBmb2xkLlxuLy8gU2VlIGNvbW1vbm1hcmsvY29tbW9ubWFyay5qcyMxNjguXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAuc2xpY2UoMSwgc3RyLmxlbmd0aCAtIDEpXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL1sgXFx0XFxyXFxuXSsvLCAnICcpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaXRlcmF0ZU9iamVjdChvYmosIGl0ZXJhdGVlKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaXRlcmF0ZWUoa2V5LCBvYmpba2V5XSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBvbWl0KG9iaikge1xuICAgIHZhciBwcm9wTmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwcm9wTmFtZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHRNYXAgPSBlc21fYXNzaWduKHt9LCBvYmopO1xuICAgIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdE1hcFtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRNYXA7XG59XG5mdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICAgIHJldHVybiAhT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGVhck9iaihvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgfSk7XG59XG52YXIgQ19ORVdMSU5FID0gMTA7XG52YXIgQ19BU1RFUklTSyA9IDQyO1xudmFyIENfVU5ERVJTQ09SRSA9IDk1O1xudmFyIENfQkFDS1RJQ0sgPSA5NjtcbnZhciBDX09QRU5fQlJBQ0tFVCQxID0gOTE7XG52YXIgQ19DTE9TRV9CUkFDS0VUID0gOTM7XG52YXIgQ19USUxERSA9IDEyNjtcbnZhciBDX0xFU1NUSEFOJDEgPSA2MDtcbnZhciBDX0JBTkcgPSAzMztcbnZhciBDX0JBQ0tTTEFTSCA9IDkyO1xudmFyIENfQU1QRVJTQU5EID0gMzg7XG52YXIgQ19PUEVOX1BBUkVOID0gNDA7XG52YXIgQ19DTE9TRV9QQVJFTiA9IDQxO1xudmFyIENfQ09MT04gPSA1ODtcbnZhciBDX1NJTkdMRVFVT1RFID0gMzk7XG52YXIgQ19ET1VCTEVRVU9URSA9IDM0O1xudmFyIENfRE9MTEFSID0gMzY7XG4vLyBTb21lIHJlZ2V4cHMgdXNlZCBpbiBpbmxpbmUgcGFyc2VyOlxudmFyIEVTQ0FQRURfQ0hBUiA9IFwiXFxcXFxcXFxcIiArIEVTQ0FQQUJMRTtcbnZhciByZVB1bmN0dWF0aW9uID0gbmV3IFJlZ0V4cCgvWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9flxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDJcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REYzQy1cXHVERjNFXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODJGXFx1REM5RnxcXHVEODM2W1xcdURFODctXFx1REU4Ql0vKTtcbnZhciByZUxpbmtUaXRsZSA9IG5ldyBSZWdFeHAoXCJeKD86XFxcIihcIiArIEVTQ0FQRURfQ0hBUiArIFwifFteXFxcIlxcXFx4MDBdKSpcXFwiXCIgK1xuICAgIFwifFwiICtcbiAgICAoXCInKFwiICsgRVNDQVBFRF9DSEFSICsgXCJ8W14nXFxcXHgwMF0pKidcIikgK1xuICAgIFwifFwiICtcbiAgICAoXCJcXFxcKChcIiArIEVTQ0FQRURfQ0hBUiArIFwifFteKClcXFxceDAwXSkqXFxcXCkpXCIpKTtcbnZhciByZUxpbmtEZXN0aW5hdGlvbkJyYWNlcyA9IC9eKD86PCg/OltePD5cXG5cXFxcXFx4MDBdfFxcXFwuKSo+KS87XG52YXIgcmVFc2NhcGFibGUgPSBuZXcgUmVnRXhwKFwiXlwiICsgRVNDQVBBQkxFKTtcbnZhciByZUVudGl0eUhlcmUgPSBuZXcgUmVnRXhwKFwiXlwiICsgRU5USVRZLCAnaScpO1xudmFyIHJlVGlja3MgPSAvYCsvO1xudmFyIHJlVGlja3NIZXJlID0gL15gKy87XG52YXIgcmVFbGxpcHNlcyA9IC9cXC5cXC5cXC4vZztcbnZhciByZURhc2ggPSAvLS0rL2c7XG52YXIgcmVFbWFpbEF1dG9saW5rID0gL148KFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopPi87XG52YXIgcmVBdXRvbGluayA9IC9ePFtBLVphLXpdW0EtWmEtejAtOS4rLV17MSwzMX06W148PlxceDAwLVxceDIwXSo+L2k7XG52YXIgcmVTcG5sID0gL14gKig/OlxcbiAqKT8vO1xudmFyIHJlV2hpdGVzcGFjZUNoYXIgPSAvXlsgXFx0XFxuXFx4MGJcXHgwY1xceDBkXS87XG52YXIgcmVVbmljb2RlV2hpdGVzcGFjZUNoYXIgPSAvXlxccy87XG52YXIgcmVGaW5hbFNwYWNlID0gLyAqJC87XG52YXIgcmVJbml0aWFsU3BhY2UgPSAvXiAqLztcbnZhciByZVNwYWNlQXRFbmRPZkxpbmUgPSAvXiAqKD86XFxufCQpLztcbnZhciByZUxpbmtMYWJlbCA9IC9eXFxbKD86W15cXFxcXFxbXFxdXXxcXFxcLil7MCwxMDAwfVxcXS87XG4vLyBNYXRjaGVzIGEgc3RyaW5nIG9mIG5vbi1zcGVjaWFsIGNoYXJhY3RlcnMuXG52YXIgcmVNYWluID0gL15bXlxcbmBcXFtcXF1cXFxcITwmKl8nXCJ+JF0rL207XG52YXIgSW5saW5lUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElubGluZVBhcnNlcihvcHRpb25zKSB7XG4gICAgICAgIC8vIEFuIElubGluZVBhcnNlciBrZWVwcyB0cmFjayBvZiBhIHN1YmplY3QgKGEgc3RyaW5nIHRvIGJlIHBhcnNlZClcbiAgICAgICAgLy8gYW5kIGEgcG9zaXRpb24gaW4gdGhhdCBzdWJqZWN0LlxuICAgICAgICB0aGlzLnN1YmplY3QgPSAnJztcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gbnVsbDsgLy8gdXNlZCBieSBoYW5kbGVEZWxpbSBtZXRob2RcbiAgICAgICAgdGhpcy5icmFja2V0cyA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5saW5lU3RhcnROdW0gPSAwO1xuICAgICAgICB0aGlzLmxpbmVJZHggPSAwO1xuICAgICAgICB0aGlzLmxpbmVPZmZzZXRzID0gWzBdO1xuICAgICAgICB0aGlzLmxpbmVQb3NPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5zb3VyY2Vwb3MgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbGluZVBvc09mZnNldCA9IHRoaXMubGluZVBvc09mZnNldCArIHRoaXMubGluZU9mZnNldHNbdGhpcy5saW5lSWR4XTtcbiAgICAgICAgdmFyIGxpbmVOdW0gPSB0aGlzLmxpbmVTdGFydE51bSArIHRoaXMubGluZUlkeDtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gW2xpbmVOdW0sIHN0YXJ0ICsgbGluZVBvc09mZnNldF07XG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIFtzdGFydHBvcywgW2xpbmVOdW0sIGVuZCArIGxpbmVQb3NPZmZzZXRdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnRwb3M7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLm5leHRMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpbmVJZHggKz0gMTtcbiAgICAgICAgdGhpcy5saW5lUG9zT2Zmc2V0ID0gLXRoaXMucG9zO1xuICAgIH07XG4gICAgLy8gSWYgcmUgbWF0Y2hlcyBhdCBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBzdWJqZWN0LCBhZHZhbmNlXG4gICAgLy8gcG9zaXRpb24gaW4gc3ViamVjdCBhbmQgcmV0dXJuIHRoZSBtYXRjaDsgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocmUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHRoaXMuc3ViamVjdC5zbGljZSh0aGlzLnBvcykpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbS5pbmRleCArIG1bMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbVswXTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIGNvZGUgZm9yIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGN1cnJlbnQgc3ViamVjdCBwb3NpdGlvbiwgb3IgLTFcbiAgICAvLyB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdWJqZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvLyBQYXJzZSB6ZXJvIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVycywgaW5jbHVkaW5nIGF0IG1vc3Qgb25lIG5ld2xpbmVcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnNwbmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWF0Y2gocmVTcG5sKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBBbGwgb2YgdGhlIHBhcnNlcnMgYmVsb3cgdHJ5IHRvIG1hdGNoIHNvbWV0aGluZyBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgIC8vIGluIHRoZSBzdWJqZWN0LiAgSWYgdGhleSBzdWNjZWVkIGluIG1hdGNoaW5nIGFueXRoaW5nLCB0aGV5XG4gICAgLy8gcmV0dXJuIHRoZSBpbmxpbmUgbWF0Y2hlZCwgYWR2YW5jaW5nIHRoZSBzdWJqZWN0LlxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYmFja3RpY2tzLCBhZGRpbmcgZWl0aGVyIGEgYmFja3RpY2sgY29kZSBzcGFuIG9yIGFcbiAgICAvLyBsaXRlcmFsIHNlcXVlbmNlIG9mIGJhY2t0aWNrcy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQmFja3RpY2tzID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5tYXRjaChyZVRpY2tzSGVyZSk7XG4gICAgICAgIGlmICh0aWNrcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZnRlck9wZW5UaWNrcyA9IHRoaXMucG9zO1xuICAgICAgICB2YXIgbWF0Y2hlZDtcbiAgICAgICAgd2hpbGUgKChtYXRjaGVkID0gdGhpcy5tYXRjaChyZVRpY2tzKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkID09PSB0aWNrcykge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IHRoaXMuc3ViamVjdC5zbGljZShhZnRlck9wZW5UaWNrcywgdGhpcy5wb3MgLSB0aWNrcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2Vwb3MgPSB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGNvbnRlbnRzLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdExpbmUgPSBsYXN0KGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lSWR4ICs9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IC0odGhpcy5wb3MgLSBsYXN0TGluZS5sZW5ndGggLSB0aWNrcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2Vwb3NbMV0gPSB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gbGluZXMuam9pbignICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUoJ2NvZGUnLCBzb3VyY2Vwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLm1hdGNoKC9bXiBdLykgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHNbMF0gPT0gJyAnICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzW2NvbnRlbnRzLmxlbmd0aCAtIDFdID09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxpdGVyYWwgPSBjb250ZW50cy5zbGljZSgxLCBjb250ZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IGNvbnRlbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnRpY2tDb3VudCA9IHRpY2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgd2UgZGlkbid0IG1hdGNoIGEgY2xvc2luZyBiYWNrdGljayBzZXF1ZW5jZS5cbiAgICAgICAgdGhpcy5wb3MgPSBhZnRlck9wZW5UaWNrcztcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoZXNtX3RleHQodGlja3MsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcyAtIDEpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gUGFyc2UgYSBiYWNrc2xhc2gtZXNjYXBlZCBzcGVjaWFsIGNoYXJhY3RlciwgYWRkaW5nIGVpdGhlciB0aGUgZXNjYXBlZFxuICAgIC8vIGNoYXJhY3RlciwgYSBoYXJkIGxpbmUgYnJlYWsgKGlmIHRoZSBiYWNrc2xhc2ggaXMgZm9sbG93ZWQgYnkgYSBuZXdsaW5lKSxcbiAgICAvLyBvciBhIGxpdGVyYWwgYmFja3NsYXNoIHRvIHRoZSBibG9jaydzIGNoaWxkcmVuLiAgQXNzdW1lcyBjdXJyZW50IGNoYXJhY3RlclxuICAgIC8vIGlzIGEgYmFja3NsYXNoLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VCYWNrc2xhc2ggPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN1YmogPSB0aGlzLnN1YmplY3Q7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX05FV0xJTkUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZSgnbGluZWJyZWFrJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MgLSAxLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVFc2NhcGFibGUudGVzdChzdWJqLmNoYXJBdCh0aGlzLnBvcykpKSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dChzdWJqLmNoYXJBdCh0aGlzLnBvcyksIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dCgnXFxcXCcsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYW4gYXV0b2xpbmsgKFVSTCBvciBlbWFpbCBpbiBwb2ludHkgYnJhY2tldHMpLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VBdXRvbGluayA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIGRlc3Q7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIGlmICgobSA9IHRoaXMubWF0Y2gocmVFbWFpbEF1dG9saW5rKSkpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtLnNsaWNlKDEsIG0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZSgnbGluaycsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgbm9kZS5kZXN0aW5hdGlvbiA9IG5vcm1hbGl6ZVVSSShcIm1haWx0bzpcIiArIGRlc3QpO1xuICAgICAgICAgICAgbm9kZS50aXRsZSA9ICcnO1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChlc21fdGV4dChkZXN0LCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcyArIDEsIHRoaXMucG9zIC0gMSkpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUF1dG9saW5rKSkpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtLnNsaWNlKDEsIG0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZSgnbGluaycsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgbm9kZS5kZXN0aW5hdGlvbiA9IG5vcm1hbGl6ZVVSSShkZXN0KTtcbiAgICAgICAgICAgIG5vZGUudGl0bGUgPSAnJztcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZXNtX3RleHQoZGVzdCwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MgKyAxLCB0aGlzLnBvcyAtIDEpKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYSByYXcgSFRNTCB0YWcuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUh0bWxUYWcgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICB2YXIgbSA9IHRoaXMubWF0Y2gocmVIdG1sVGFnKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUoJ2h0bWxJbmxpbmUnLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgbm9kZS5saXRlcmFsID0gbTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gU2NhbiBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgd2l0aCBjb2RlIGNjLCBhbmQgcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0XG4gICAgLy8gdGhlIG51bWJlciBvZiBkZWxpbWl0ZXJzIGFuZCB3aGV0aGVyIHRoZXkgYXJlIHBvc2l0aW9uZWQgc3VjaCB0aGF0XG4gICAgLy8gdGhleSBjYW4gb3BlbiBhbmQvb3IgY2xvc2UgZW1waGFzaXMgb3Igc3Ryb25nIGVtcGhhc2lzLiAgQSB1dGlsaXR5XG4gICAgLy8gZnVuY3Rpb24gZm9yIHN0cm9uZy9lbXBoIHBhcnNpbmcuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5zY2FuRGVsaW1zID0gZnVuY3Rpb24gKGNjKSB7XG4gICAgICAgIHZhciBudW1kZWxpbXMgPSAwO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKGNjID09PSBDX1NJTkdMRVFVT1RFIHx8IGNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICBudW1kZWxpbXMrKztcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09IGNjKSB7XG4gICAgICAgICAgICAgICAgbnVtZGVsaW1zKys7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtZGVsaW1zID09PSAwIHx8IChudW1kZWxpbXMgPCAyICYmIChjYyA9PT0gQ19USUxERSB8fCBjYyA9PT0gQ19ET0xMQVIpKSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyQmVmb3JlID0gc3RhcnRwb3MgPT09IDAgPyAnXFxuJyA6IHRoaXMuc3ViamVjdC5jaGFyQXQoc3RhcnRwb3MgLSAxKTtcbiAgICAgICAgdmFyIGNjQWZ0ZXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdmFyIGNoYXJBZnRlcjtcbiAgICAgICAgaWYgKGNjQWZ0ZXIgPT09IC0xKSB7XG4gICAgICAgICAgICBjaGFyQWZ0ZXIgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJBZnRlciA9IGZyb21Db2RlUG9pbnQkMShjY0FmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXJJc1doaXRlc3BhY2UgPSByZVVuaWNvZGVXaGl0ZXNwYWNlQ2hhci50ZXN0KGNoYXJBZnRlcik7XG4gICAgICAgIHZhciBhZnRlcklzUHVuY3R1YXRpb24gPSByZVB1bmN0dWF0aW9uLnRlc3QoY2hhckFmdGVyKTtcbiAgICAgICAgdmFyIGJlZm9yZUlzV2hpdGVzcGFjZSA9IHJlVW5pY29kZVdoaXRlc3BhY2VDaGFyLnRlc3QoY2hhckJlZm9yZSk7XG4gICAgICAgIHZhciBiZWZvcmVJc1B1bmN0dWF0aW9uID0gcmVQdW5jdHVhdGlvbi50ZXN0KGNoYXJCZWZvcmUpO1xuICAgICAgICB2YXIgbGVmdEZsYW5raW5nID0gIWFmdGVySXNXaGl0ZXNwYWNlICYmICghYWZ0ZXJJc1B1bmN0dWF0aW9uIHx8IGJlZm9yZUlzV2hpdGVzcGFjZSB8fCBiZWZvcmVJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgdmFyIHJpZ2h0RmxhbmtpbmcgPSAhYmVmb3JlSXNXaGl0ZXNwYWNlICYmICghYmVmb3JlSXNQdW5jdHVhdGlvbiB8fCBhZnRlcklzV2hpdGVzcGFjZSB8fCBhZnRlcklzUHVuY3R1YXRpb24pO1xuICAgICAgICB2YXIgY2FuT3BlbjtcbiAgICAgICAgdmFyIGNhbkNsb3NlO1xuICAgICAgICBpZiAoY2MgPT09IENfVU5ERVJTQ09SRSkge1xuICAgICAgICAgICAgY2FuT3BlbiA9IGxlZnRGbGFua2luZyAmJiAoIXJpZ2h0RmxhbmtpbmcgfHwgYmVmb3JlSXNQdW5jdHVhdGlvbik7XG4gICAgICAgICAgICBjYW5DbG9zZSA9IHJpZ2h0RmxhbmtpbmcgJiYgKCFsZWZ0RmxhbmtpbmcgfHwgYWZ0ZXJJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSB8fCBjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICAgICAgY2FuT3BlbiA9IGxlZnRGbGFua2luZyAmJiAhcmlnaHRGbGFua2luZztcbiAgICAgICAgICAgIGNhbkNsb3NlID0gcmlnaHRGbGFua2luZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgIGNhbk9wZW4gPSAhYWZ0ZXJJc1doaXRlc3BhY2U7XG4gICAgICAgICAgICBjYW5DbG9zZSA9ICFiZWZvcmVJc1doaXRlc3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW5PcGVuID0gbGVmdEZsYW5raW5nO1xuICAgICAgICAgICAgY2FuQ2xvc2UgPSByaWdodEZsYW5raW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgIHJldHVybiB7IG51bWRlbGltczogbnVtZGVsaW1zLCBjYW5PcGVuOiBjYW5PcGVuLCBjYW5DbG9zZTogY2FuQ2xvc2UgfTtcbiAgICB9O1xuICAgIC8vIEhhbmRsZSBhIGRlbGltaXRlciBtYXJrZXIgZm9yIGVtcGhhc2lzIG9yIGEgcXVvdGUuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5oYW5kbGVEZWxpbSA9IGZ1bmN0aW9uIChjYywgYmxvY2spIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuc2NhbkRlbGltcyhjYyk7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWRlbGltcyA9IHJlcy5udW1kZWxpbXM7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgdmFyIGNvbnRlbnRzO1xuICAgICAgICB0aGlzLnBvcyArPSBudW1kZWxpbXM7XG4gICAgICAgIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSkge1xuICAgICAgICAgICAgY29udGVudHMgPSAnXFx1MjAxOSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gJ1xcdTIwMUMnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGVudHMgPSB0aGlzLnN1YmplY3Quc2xpY2Uoc3RhcnRwb3MgLSAxLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBlc21fdGV4dChjb250ZW50cywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAvLyBBZGQgZW50cnkgdG8gc3RhY2sgZm9yIHRoaXMgb3BlbmVyXG4gICAgICAgIGlmICgocmVzLmNhbk9wZW4gfHwgcmVzLmNhbkNsb3NlKSAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5zbWFydCB8fCAoY2MgIT09IENfU0lOR0xFUVVPVEUgJiYgY2MgIT09IENfRE9VQkxFUVVPVEUpKSkge1xuICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0ge1xuICAgICAgICAgICAgICAgIGNjOiBjYyxcbiAgICAgICAgICAgICAgICBudW1kZWxpbXM6IG51bWRlbGltcyxcbiAgICAgICAgICAgICAgICBvcmlnZGVsaW1zOiBudW1kZWxpbXMsXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogdGhpcy5kZWxpbWl0ZXJzLFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY2FuT3BlbjogcmVzLmNhbk9wZW4sXG4gICAgICAgICAgICAgICAgY2FuQ2xvc2U6IHJlcy5jYW5DbG9zZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxpbWl0ZXJzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXJzLnByZXZpb3VzLm5leHQgPSB0aGlzLmRlbGltaXRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnJlbW92ZURlbGltaXRlciA9IGZ1bmN0aW9uIChkZWxpbSkge1xuICAgICAgICBpZiAoZGVsaW0ucHJldmlvdXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGltLnByZXZpb3VzLm5leHQgPSBkZWxpbS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxpbS5uZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB0b3Agb2Ygc3RhY2tcbiAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IGRlbGltLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsaW0ubmV4dC5wcmV2aW91cyA9IGRlbGltLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnJlbW92ZURlbGltaXRlcnNCZXR3ZWVuID0gZnVuY3Rpb24gKGJvdHRvbSwgdG9wKSB7XG4gICAgICAgIGlmIChib3R0b20ubmV4dCAhPT0gdG9wKSB7XG4gICAgICAgICAgICBib3R0b20ubmV4dCA9IHRvcDtcbiAgICAgICAgICAgIHRvcC5wcmV2aW91cyA9IGJvdHRvbTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbGwgZGVsaW1pdGVycyAtIGVtcGhhc2lzLCBzdHJvbmcgZW1waGFzaXMsIHN0cmlrZXRocm91Z2goZ2ZtKVxuICAgICAqIElmIHRoZSBzbWFydCBwdW5jdHVhdGlvbiBvcHRpb25zIGlzIHRydWUsXG4gICAgICogY29udmVydCBzaW5nbGUvZG91YmxlIHF1b3RlcyB0byBjb3JyZXNwb25kaW5nIHVuaWNvZGUgY2hhcmFjdGVycy5cbiAgICAgKiovXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wcm9jZXNzRW1waGFzaXMgPSBmdW5jdGlvbiAoc3RhY2tCb3R0b20pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgb3BlbmVyO1xuICAgICAgICB2YXIgY2xvc2VyO1xuICAgICAgICB2YXIgb2xkQ2xvc2VyO1xuICAgICAgICB2YXIgb3BlbmVySW5sLCBjbG9zZXJJbmw7XG4gICAgICAgIHZhciBvcGVuZXJGb3VuZDtcbiAgICAgICAgdmFyIG9kZE1hdGNoID0gZmFsc2U7XG4gICAgICAgIHZhciBvcGVuZXJzQm90dG9tID0gKF9hID0ge30sXG4gICAgICAgICAgICBfYVtDX1VOREVSU0NPUkVdID0gW3N0YWNrQm90dG9tLCBzdGFja0JvdHRvbSwgc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2FbQ19BU1RFUklTS10gPSBbc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tLCBzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX1NJTkdMRVFVT1RFXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX0RPVUJMRVFVT1RFXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX1RJTERFXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX0RPTExBUl0gPSBbc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2EpO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IGNsb3NlciBhYm92ZSBzdGFja0JvdHRvbTpcbiAgICAgICAgY2xvc2VyID0gdGhpcy5kZWxpbWl0ZXJzO1xuICAgICAgICB3aGlsZSAoY2xvc2VyICE9PSBudWxsICYmIGNsb3Nlci5wcmV2aW91cyAhPT0gc3RhY2tCb3R0b20pIHtcbiAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3ZlIGZvcndhcmQsIGxvb2tpbmcgZm9yIGNsb3NlcnMsIGFuZCBoYW5kbGluZyBlYWNoXG4gICAgICAgIHdoaWxlIChjbG9zZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZXJjYyA9IGNsb3Nlci5jYztcbiAgICAgICAgICAgIHZhciBjbG9zZXJFbXBoID0gY2xvc2VyY2MgPT09IENfVU5ERVJTQ09SRSB8fCBjbG9zZXJjYyA9PT0gQ19BU1RFUklTSztcbiAgICAgICAgICAgIGlmICghY2xvc2VyLmNhbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmb3VuZCBlbXBoYXNpcyBjbG9zZXIuIG5vdyBsb29rIGJhY2sgZm9yIGZpcnN0IG1hdGNoaW5nIG9wZW5lcjpcbiAgICAgICAgICAgICAgICBvcGVuZXIgPSBjbG9zZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgb3BlbmVyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAob3BlbmVyICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZW5lciAhPT0gc3RhY2tCb3R0b20gJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyICE9PSBvcGVuZXJzQm90dG9tW2Nsb3NlcmNjXVtjbG9zZXJFbXBoID8gY2xvc2VyLm9yaWdkZWxpbXMgJSAzIDogMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgb2RkTWF0Y2ggPVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyRW1waCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbG9zZXIuY2FuT3BlbiB8fCBvcGVuZXIuY2FuQ2xvc2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyLm9yaWdkZWxpbXMgJSAzICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wZW5lci5vcmlnZGVsaW1zICsgY2xvc2VyLm9yaWdkZWxpbXMpICUgMyA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lci5jYyA9PT0gY2xvc2VyLmNjICYmIG9wZW5lci5jYW5PcGVuICYmICFvZGRNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gb3BlbmVyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbGRDbG9zZXIgPSBjbG9zZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlckVtcGggfHwgY2xvc2VyY2MgPT09IENfVElMREUgfHwgY2xvc2VyY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKG51bGwgb3BlbmVyIGNoZWNrIGZvciB0eXBlIG5hcnJvd2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBhY3R1YWwgbnVtYmVyIG9mIGRlbGltaXRlcnMgdXNlZCBmcm9tIGNsb3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZURlbGltcyA9IGNsb3Nlci5udW1kZWxpbXMgPj0gMiAmJiBvcGVuZXIubnVtZGVsaW1zID49IDIgPyAyIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbXB0eURlbGltcyA9IGNsb3NlckVtcGggPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubCA9IG9wZW5lci5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sID0gY2xvc2VyLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidWlsZCBjb250ZW50cyBmb3IgbmV3IGVtcGggZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVUeXBlID0gY2xvc2VyRW1waFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXNlRGVsaW1zID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2VtcGgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3N0cm9uZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzdHJpa2UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlcmNjID09PSBDX0RPTExBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gJ2N1c3RvbUlubGluZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5lckVuZFBvcyA9IG9wZW5lcklubC5zb3VyY2Vwb3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VyU3RhcnRQb3MgPSBjbG9zZXJJbmwuc291cmNlcG9zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zb3VyY2Vwb3MgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wZW5lckVuZFBvc1swXSwgb3BlbmVyRW5kUG9zWzFdIC0gdXNlRGVsaW1zICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Nsb3NlclN0YXJ0UG9zWzBdLCBjbG9zZXJTdGFydFBvc1sxXSArIHVzZURlbGltcyAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubC5zb3VyY2Vwb3NbMV1bMV0gLT0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sLnNvdXJjZXBvc1swXVsxXSArPSB1c2VEZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwubGl0ZXJhbCA9IG9wZW5lcklubC5saXRlcmFsLnNsaWNlKHVzZURlbGltcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwubGl0ZXJhbCA9IGNsb3NlcklubC5saXRlcmFsLnNsaWNlKHVzZURlbGltcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIubnVtZGVsaW1zIC09IHVzZURlbGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlci5udW1kZWxpbXMgLT0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHVzZWQgZGVsaW1pdGVycyBmcm9tIHN0YWNrIGVsdHMgYW5kIGlubGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBvcGVuZXJJbmwubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRtcCAmJiB0bXAgIT09IGNsb3NlcklubCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0bXAubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5hcHBlbmRDaGlsZCh0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidWlsZCBjdXN0b20gaW5saW5lIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXJjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBuZXdOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSB0ZXh0Tm9kZS5saXRlcmFsIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gbGl0ZXJhbC5zcGxpdCgvXFxzLylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5pbmZvID0gaW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbC5sZW5ndGggPD0gaW5mby5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5zb3VyY2Vwb3NbMF1bMV0gKz0gaW5mby5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLmxpdGVyYWwgPSBsaXRlcmFsLnJlcGxhY2UoaW5mbyArIFwiIFwiLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLmluc2VydEFmdGVyKG5ld05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVsdHMgYmV0d2VlbiBvcGVuZXIgYW5kIGNsb3NlciBpbiBkZWxpbWl0ZXJzIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcnNCZXR3ZWVuKG9wZW5lciwgY2xvc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wZW5lciBoYXMgMCBkZWxpbXMsIHJlbW92ZSBpdCBhbmQgdGhlIGlubGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgb3BlbmVyIGhhcyAxIGRlbGltcyBhbmQgY2hhcmFjdGVyIGlzIHRpbGRlLCByZW1vdmUgZGVsaW1pdGVyIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXIubnVtZGVsaW1zIDw9IGVtcHR5RGVsaW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lci5udW1kZWxpbXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLnVubGluaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcihvcGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2xvc2VyIGhhcyAwIGRlbGltcywgcmVtb3ZlIGl0IGFuZCB0aGUgaW5saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjbG9zZXIgaGFzIDEgZGVsaW1zIGFuZCBjaGFyYWN0ZXIgaXMgdGlsZGUsIHJlbW92ZSBkZWxpbWl0ZXIgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlci5udW1kZWxpbXMgPD0gZW1wdHlEZWxpbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyLm51bWRlbGltcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wc3RhY2sgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcihjbG9zZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IHRlbXBzdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbG9zZXJjYyA9PT0gQ19TSU5HTEVRVU9URSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXIubm9kZS5saXRlcmFsID0gJ1xcdTIwMTknO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxOCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlcmNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxRCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLm5vZGUubGl0ZXJhbCA9ICdcXHUyMDFDJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgZm9yIGZ1dHVyZSBzZWFyY2hlcyBmb3Igb3BlbmVyczpcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXJjY11bY2xvc2VyRW1waCA/IG9sZENsb3Nlci5vcmlnZGVsaW1zICUgMyA6IDBdID0gb2xkQ2xvc2VyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZENsb3Nlci5jYW5PcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gcmVtb3ZlIGEgY2xvc2VyIHRoYXQgY2FuJ3QgYmUgYW4gb3BlbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25jZSB3ZSd2ZSBzZWVuIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgb3BlbmVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIob2xkQ2xvc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgYWxsIGRlbGltaXRlcnNcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVsaW1pdGVycyAhPT0gbnVsbCAmJiB0aGlzLmRlbGltaXRlcnMgIT09IHN0YWNrQm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcih0aGlzLmRlbGltaXRlcnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGxpbmsgdGl0bGUgKHNhbnMgcXVvdGVzKSwgcmV0dXJuaW5nIHRoZSBzdHJpbmdcbiAgICAvLyBvciBudWxsIGlmIG5vIG1hdGNoLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VMaW5rVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMubWF0Y2gocmVMaW5rVGl0bGUpO1xuICAgICAgICBpZiAodGl0bGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNob3Agb2ZmIHF1b3RlcyBmcm9tIHRpdGxlIGFuZCB1bmVzY2FwZTpcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlU3RyaW5nKHRpdGxlLnN1YnN0cigxLCB0aXRsZS5sZW5ndGggLSAyKSk7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGxpbmsgZGVzdGluYXRpb24sIHJldHVybmluZyB0aGUgc3RyaW5nIG9yIG51bGwgaWYgbm8gbWF0Y2guXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpbmtEZXN0aW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMubWF0Y2gocmVMaW5rRGVzdGluYXRpb25CcmFjZXMpO1xuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfTEVTU1RIQU4kMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQFRPRE8gaGFuZHJvbGxlZCBwYXJzZXI7IHJlcyBzaG91bGQgYmUgbnVsbCBvciB0aGUgc3RyaW5nXG4gICAgICAgICAgICB2YXIgc2F2ZXBvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdmFyIG9wZW5wYXJlbnMgPSAwO1xuICAgICAgICAgICAgdmFyIGMgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAoKGMgPSB0aGlzLnBlZWsoKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IENfQkFDS1NMQVNIICYmIHJlRXNjYXBhYmxlLnRlc3QodGhpcy5zdWJqZWN0LmNoYXJBdCh0aGlzLnBvcyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZWVrKCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IENfT1BFTl9QQVJFTikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBvcGVucGFyZW5zICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5wYXJlbnMgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVucGFyZW5zIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVXaGl0ZXNwYWNlQ2hhci5leGVjKGZyb21Db2RlUG9pbnQkMShjKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gc2F2ZXBvcyAmJiBjICE9PSBDX0NMT1NFX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BlbnBhcmVucyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gdGhpcy5zdWJqZWN0LnN1YnN0cihzYXZlcG9zLCB0aGlzLnBvcyAtIHNhdmVwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVSSSh1bmVzY2FwZVN0cmluZyhyZXMpKTtcbiAgICAgICAgfSAvLyBjaG9wIG9mZiBzdXJyb3VuZGluZyA8Li4+OlxuICAgICAgICByZXR1cm4gbm9ybWFsaXplVVJJKHVuZXNjYXBlU3RyaW5nKHJlcy5zdWJzdHIoMSwgcmVzLmxlbmd0aCAtIDIpKSk7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGEgbGluayBsYWJlbCwgcmV0dXJuaW5nIG51bWJlciBvZiBjaGFyYWN0ZXJzIHBhcnNlZC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlua0xhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMubWF0Y2gocmVMaW5rTGFiZWwpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCB8fCBtLmxlbmd0aCA+IDEwMDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLmxlbmd0aDtcbiAgICB9O1xuICAgIC8vIEFkZCBvcGVuIGJyYWNrZXQgdG8gZGVsaW1pdGVyIHN0YWNrIGFuZCBhZGQgYSB0ZXh0IG5vZGUgdG8gYmxvY2sncyBjaGlsZHJlbi5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlT3BlbkJyYWNrZXQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIHZhciBub2RlID0gZXNtX3RleHQoJ1snLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgdGhpcy5hZGRCcmFja2V0KG5vZGUsIHN0YXJ0cG9zLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gSUYgbmV4dCBjaGFyYWN0ZXIgaXMgWywgYW5kICEgZGVsaW1pdGVyIHRvIGRlbGltaXRlciBzdGFjayBhbmRcbiAgICAvLyBhZGQgYSB0ZXh0IG5vZGUgdG8gYmxvY2sncyBjaGlsZHJlbi4gIE90aGVyd2lzZSBqdXN0IGFkZCBhIHRleHQgbm9kZS5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQmFuZyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX09QRU5fQlJBQ0tFVCQxKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBlc21fdGV4dCgnIVsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyAtIDEsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgICAgIHRoaXMuYWRkQnJhY2tldChub2RlLCBzdGFydHBvcyArIDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBlc21fdGV4dCgnIScsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBUcnkgdG8gbWF0Y2ggY2xvc2UgYnJhY2tldCBhZ2FpbnN0IGFuIG9wZW5pbmcgaW4gdGhlIGRlbGltaXRlclxuICAgIC8vIHN0YWNrLiAgQWRkIGVpdGhlciBhIGxpbmsgb3IgaW1hZ2UsIG9yIGEgcGxhaW4gWyBjaGFyYWN0ZXIsXG4gICAgLy8gdG8gYmxvY2sncyBjaGlsZHJlbi4gIElmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgZGVsaW1pdGVyLFxuICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBkZWxpbWl0ZXIgc3RhY2suXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsb3NlQnJhY2tldCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgZGVzdCA9IG51bGw7XG4gICAgICAgIHZhciB0aXRsZSA9IG51bGw7XG4gICAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICAvLyBnZXQgbGFzdCBbIG9yICFbXG4gICAgICAgIHZhciBvcGVuZXIgPSB0aGlzLmJyYWNrZXRzO1xuICAgICAgICBpZiAob3BlbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBubyBtYXRjaGVkIG9wZW5lciwganVzdCByZXR1cm4gYSBsaXRlcmFsXG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dCgnXScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3BlbmVyLmFjdGl2ZSkge1xuICAgICAgICAgICAgLy8gbm8gbWF0Y2hlZCBvcGVuZXIsIGp1c3QgcmV0dXJuIGEgbGl0ZXJhbFxuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoZXNtX3RleHQoJ10nLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgc3RhcnRwb3MpKSk7XG4gICAgICAgICAgICAvLyB0YWtlIG9wZW5lciBvZmYgYnJhY2tldHMgc3RhY2tcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIG9wZW4gaXMgYSBwb3RlbnRpYWwgb3BlbmVyXG4gICAgICAgIHZhciBpc0ltYWdlID0gb3BlbmVyLmltYWdlO1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGxpbmsvaW1hZ2VcbiAgICAgICAgdmFyIHNhdmVwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gSW5saW5lIGxpbms/XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19PUEVOX1BBUkVOKSB7XG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAgICAgKGRlc3QgPSB0aGlzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKCkpICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zcG5sKCkgJiZcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUncyBhIHNwYWNlIGJlZm9yZSB0aGUgdGl0bGU6XG4gICAgICAgICAgICAgICAgKChyZVdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5zdWJqZWN0LmNoYXJBdCh0aGlzLnBvcyAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICAgICAodGl0bGUgPSB0aGlzLnBhcnNlTGlua1RpdGxlKCkpKSB8fFxuICAgICAgICAgICAgICAgICAgICB0cnVlKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrKCkgPT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBzYXZlcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWZMYWJlbCA9ICcnO1xuICAgICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgICAgIC8vIE5leHQsIHNlZSBpZiB0aGVyZSdzIGEgbGluayBsYWJlbFxuICAgICAgICAgICAgdmFyIGJlZm9yZWxhYmVsID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMucGFyc2VMaW5rTGFiZWwoKTtcbiAgICAgICAgICAgIGlmIChuID4gMikge1xuICAgICAgICAgICAgICAgIHJlZkxhYmVsID0gdGhpcy5zdWJqZWN0LnNsaWNlKGJlZm9yZWxhYmVsLCBiZWZvcmVsYWJlbCArIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wZW5lci5icmFja2V0QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBFbXB0eSBvciBtaXNzaW5nIHNlY29uZCBsYWJlbCBtZWFucyB0byB1c2UgdGhlIGZpcnN0IGxhYmVsIGFzIHRoZSByZWZlcmVuY2UuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlZmVyZW5jZSBtdXN0IG5vdCBjb250YWluIGEgYnJhY2tldC4gSWYgd2Uga25vdyB0aGVyZSdzIGEgYnJhY2tldCwgd2UgZG9uJ3QgZXZlbiBib3RoZXIgY2hlY2tpbmcgaXQuXG4gICAgICAgICAgICAgICAgcmVmTGFiZWwgPSB0aGlzLnN1YmplY3Quc2xpY2Uob3BlbmVyLmluZGV4LCBzdGFydHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rLCByZXdpbmQgYmVmb3JlIHNwYWNlcyB3ZSBza2lwcGVkLlxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gc2F2ZXBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZMYWJlbCkge1xuICAgICAgICAgICAgICAgIHJlZkxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHJlZkxhYmVsKTtcbiAgICAgICAgICAgICAgICAvLyBsb29rdXAgcmF3bGFiZWwgaW4gcmVmTWFwXG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLnJlZk1hcFtyZWZMYWJlbF07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdCA9IGxpbmsuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbGluay50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUoaXNJbWFnZSA/ICdpbWFnZScgOiAnbGluaycpO1xuICAgICAgICAgICAgbm9kZS5kZXN0aW5hdGlvbiA9IGRlc3Q7XG4gICAgICAgICAgICBub2RlLnRpdGxlID0gdGl0bGUgfHwgJyc7XG4gICAgICAgICAgICBub2RlLnNvdXJjZXBvcyA9IFtvcGVuZXIuc3RhcnRwb3MsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zKV07XG4gICAgICAgICAgICB2YXIgdG1wID0gb3BlbmVyLm5vZGUubmV4dDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgd2hpbGUgKHRtcCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSB0bXAubmV4dDtcbiAgICAgICAgICAgICAgICB0bXAudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0bXApO1xuICAgICAgICAgICAgICAgIHRtcCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0VtcGhhc2lzKG9wZW5lci5wcmV2aW91c0RlbGltaXRlcik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJyYWNrZXQoKTtcbiAgICAgICAgICAgIG9wZW5lci5ub2RlLnVubGluaygpO1xuICAgICAgICAgICAgLy8gV2UgcmVtb3ZlIHRoaXMgYnJhY2tldCBhbmQgcHJvY2Vzc0VtcGhhc2lzIHdpbGwgcmVtb3ZlIGxhdGVyIGRlbGltaXRlcnMuXG4gICAgICAgICAgICAvLyBOb3csIGZvciBhIGxpbmssIHdlIGFsc28gZGVhY3RpdmF0ZSBlYXJsaWVyIGxpbmsgb3BlbmVycy5cbiAgICAgICAgICAgIC8vIChubyBsaW5rcyBpbiBsaW5rcylcbiAgICAgICAgICAgIGlmICghaXNJbWFnZSkge1xuICAgICAgICAgICAgICAgIG9wZW5lciA9IHRoaXMuYnJhY2tldHM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG9wZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wZW5lci5pbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLmFjdGl2ZSA9IGZhbHNlOyAvLyBkZWFjdGl2YXRlIHRoaXMgb3BlbmVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gb3BlbmVyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcFtibG9jay5pZF0gPSB7IG5vZGU6IGJsb2NrLCByZWZMYWJlbDogcmVmTGFiZWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIG5vIG1hdGNoXG4gICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpOyAvLyByZW1vdmUgdGhpcyBvcGVuZXIgZnJvbSBzdGFja1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dCgnXScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXBbYmxvY2suaWRdID0geyBub2RlOiBibG9jaywgcmVmTGFiZWw6IHJlZkxhYmVsIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLmFkZEJyYWNrZXQgPSBmdW5jdGlvbiAobm9kZSwgaW5kZXgsIGltYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmJyYWNrZXRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJyYWNrZXRzLmJyYWNrZXRBZnRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5icmFja2V0cyA9IHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICBzdGFydHBvczogdGhpcy5zb3VyY2Vwb3MoaW5kZXggKyAoaW1hZ2UgPyAwIDogMSkpLFxuICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuYnJhY2tldHMsXG4gICAgICAgICAgICBwcmV2aW91c0RlbGltaXRlcjogdGhpcy5kZWxpbWl0ZXJzLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5yZW1vdmVCcmFja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5icmFja2V0cykge1xuICAgICAgICAgICAgdGhpcy5icmFja2V0cyA9IHRoaXMuYnJhY2tldHMucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYW4gZW50aXR5LlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUVudGl0eUhlcmUpKSkge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoZXNtX3RleHQobGliLmRlY29kZUhUTUwobSksIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIGEgcnVuIG9mIG9yZGluYXJ5IGNoYXJhY3RlcnMsIG9yIGEgc2luZ2xlIGNoYXJhY3RlciB3aXRoXG4gICAgLy8gYSBzcGVjaWFsIG1lYW5pbmcgaW4gbWFya2Rvd24sIGFzIGEgcGxhaW4gc3RyaW5nLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZU1haW4pKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXQgPSBtLnJlcGxhY2UocmVFbGxpcHNlcywgJ1xcdTIwMjYnKS5yZXBsYWNlKHJlRGFzaCwgZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVtQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnMubGVuZ3RoICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNpYmxlIGJ5IDMsIHVzZSBhbGwgZW0gZGFzaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBlbUNvdW50ID0gY2hhcnMubGVuZ3RoIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFycy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc2libGUgYnkgMiwgdXNlIGFsbCBlbiBkYXNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuQ291bnQgPSBjaGFycy5sZW5ndGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJzLmxlbmd0aCAlIDMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIDIgZXh0cmEgZGFzaGVzLCB1c2UgZW4gZGFzaCBmb3IgbGFzdCAyOyBlbSBkYXNoZXMgZm9yIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1Db3VudCA9IChjaGFycy5sZW5ndGggLSAyKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZW4gZGFzaGVzIGZvciBsYXN0IDQgaHlwaGVuczsgZW0gZGFzaGVzIGZvciByZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBlbkNvdW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtQ291bnQgPSAoY2hhcnMubGVuZ3RoIC0gNCkgLyAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBlYXQoJ1xcdTIwMTQnLCBlbUNvdW50KSArIHJlcGVhdCgnXFx1MjAxMycsIGVuQ291bnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGVzbV90ZXh0KGxpdCwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBlc21fdGV4dChtLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIGEgbmV3bGluZS4gIElmIGl0IHdhcyBwcmVjZWRlZCBieSB0d28gc3BhY2VzLCByZXR1cm4gYSBoYXJkXG4gICAgLy8gbGluZSBicmVhazsgb3RoZXJ3aXNlIGEgc29mdCBsaW5lIGJyZWFrLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VOZXdsaW5lID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDE7IC8vIGFzc3VtZSB3ZSdyZSBhdCBhIFxcblxuICAgICAgICAvLyBjaGVjayBwcmV2aW91cyBub2RlIGZvciB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgdmFyIGxhc3RjID0gYmxvY2subGFzdENoaWxkO1xuICAgICAgICBpZiAobGFzdGMgJiYgbGFzdGMudHlwZSA9PT0gJ3RleHQnICYmIGxhc3RjLmxpdGVyYWxbbGFzdGMubGl0ZXJhbC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICB2YXIgaGFyZGJyZWFrID0gbGFzdGMubGl0ZXJhbFtsYXN0Yy5saXRlcmFsLmxlbmd0aCAtIDJdID09PSAnICc7XG4gICAgICAgICAgICB2YXIgbGl0TGVuID0gbGFzdGMubGl0ZXJhbC5sZW5ndGg7XG4gICAgICAgICAgICBsYXN0Yy5saXRlcmFsID0gbGFzdGMubGl0ZXJhbC5yZXBsYWNlKHJlRmluYWxTcGFjZSwgJycpO1xuICAgICAgICAgICAgdmFyIGZpbmFsU3BhY2VMZW4gPSBsaXRMZW4gLSBsYXN0Yy5saXRlcmFsLmxlbmd0aDtcbiAgICAgICAgICAgIGxhc3RjLnNvdXJjZXBvc1sxXVsxXSAtPSBmaW5hbFNwYWNlTGVuO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoY3JlYXRlTm9kZShoYXJkYnJlYWsgPyAnbGluZWJyZWFrJyA6ICdzb2Z0YnJlYWsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyAtIGZpbmFsU3BhY2VMZW4sIHRoaXMucG9zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoY3JlYXRlTm9kZSgnc29mdGJyZWFrJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgdGhpcy5tYXRjaChyZUluaXRpYWxTcGFjZSk7IC8vIGdvYmJsZSBsZWFkaW5nIHNwYWNlcyBpbiBuZXh0IGxpbmVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGEgbGluayByZWZlcmVuY2UsIG1vZGlmeWluZyByZWZtYXAuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChibG9jaywgcmVmTWFwKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdmFyIHRpdGxlID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIGxhYmVsOlxuICAgICAgICB2YXIgbWF0Y2hDaGFycyA9IHRoaXMucGFyc2VMaW5rTGFiZWwoKTtcbiAgICAgICAgaWYgKG1hdGNoQ2hhcnMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYXdsYWJlbCA9IHRoaXMuc3ViamVjdC5zdWJzdHIoMCwgbWF0Y2hDaGFycyk7XG4gICAgICAgIC8vIGNvbG9uOlxuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfQ09MT04pIHtcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIGxpbmsgdXJsXG4gICAgICAgIHRoaXMuc3BubCgpO1xuICAgICAgICB2YXIgZGVzdCA9IHRoaXMucGFyc2VMaW5rRGVzdGluYXRpb24oKTtcbiAgICAgICAgaWYgKGRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVmb3JldGl0bGUgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5zcG5sKCk7XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPT0gYmVmb3JldGl0bGUpIHtcbiAgICAgICAgICAgIHRpdGxlID0gdGhpcy5wYXJzZUxpbmtUaXRsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIC8vIHJld2luZCBiZWZvcmUgc3BhY2VzXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGJlZm9yZXRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSdyZSBhdCBsaW5lIGVuZDpcbiAgICAgICAgdmFyIGF0TGluZUVuZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKHJlU3BhY2VBdEVuZE9mTGluZSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aXRsZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBhdExpbmVFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwb3RlbnRpYWwgdGl0bGUgd2UgZm91bmQgaXMgbm90IGF0IHRoZSBsaW5lIGVuZCxcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgY291bGQgc3RpbGwgYmUgYSBsZWdhbCBsaW5rIHJlZmVyZW5jZSBpZiB3ZVxuICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgdGhlIHRpdGxlXG4gICAgICAgICAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgICAgICAgICAvLyByZXdpbmQgYmVmb3JlIHNwYWNlc1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gYmVmb3JldGl0bGU7XG4gICAgICAgICAgICAgICAgLy8gYW5kIGluc3RlYWQgY2hlY2sgaWYgdGhlIGxpbmsgVVJMIGlzIGF0IHRoZSBsaW5lIGVuZFxuICAgICAgICAgICAgICAgIGF0TGluZUVuZCA9IHRoaXMubWF0Y2gocmVTcGFjZUF0RW5kT2ZMaW5lKSAhPT0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWF0TGluZUVuZCkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3JtYWxMYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShyYXdsYWJlbCk7XG4gICAgICAgIGlmIChub3JtYWxMYWJlbCA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIGxhYmVsIG11c3QgY29udGFpbiBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZXBvcyA9IHRoaXMuZ2V0UmVmZXJlbmNlRGVmU291cmNlcG9zKGJsb2NrKTtcbiAgICAgICAgYmxvY2suc291cmNlcG9zWzBdWzBdID0gc291cmNlcG9zWzFdWzBdICsgMTtcbiAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlKCdyZWZEZWYnLCBzb3VyY2Vwb3MpO1xuICAgICAgICBub2RlLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIG5vZGUuZGVzdCA9IGRlc3Q7XG4gICAgICAgIG5vZGUubGFiZWwgPSBub3JtYWxMYWJlbDtcbiAgICAgICAgYmxvY2suaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICBpZiAoIXJlZk1hcFtub3JtYWxMYWJlbF0pIHtcbiAgICAgICAgICAgIHJlZk1hcFtub3JtYWxMYWJlbF0gPSBjcmVhdGVSZWZEZWZTdGF0ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSBzdGFydHBvcztcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUubWVyZ2VUZXh0Tm9kZXMgPSBmdW5jdGlvbiAod2Fsa2VyKSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgdmFyIHRleHROb2RlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nLCBub2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgICAgIGlmIChlbnRlcmluZyAmJiBub2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRleHROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRleHROb2RlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gdGV4dE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9kZS5zb3VyY2Vwb3MgJiYgbGFzdE5vZGUuc291cmNlcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5zb3VyY2Vwb3NbMV0gPSBsYXN0Tm9kZS5zb3VyY2Vwb3NbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5uZXh0ID0gbGFzdE5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb2RlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLm5leHQucHJldiA9IGZpcnN0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZXh0Tm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLmxpdGVyYWwgKz0gdGV4dE5vZGVzW2ldLmxpdGVyYWw7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2Rlc1tpXS51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dE5vZGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuZ2V0UmVmZXJlbmNlRGVmU291cmNlcG9zID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGJsb2NrLnN0cmluZ0NvbnRlbnQuc3BsaXQoL1xcbnxcXHJcXG4vKTtcbiAgICAgICAgdmFyIHBhc3NlZFVybExpbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHF1b3RhdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiAwLCBjaDogMCB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgaWYgKHJlV2hpdGVzcGFjZUNoYXIudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9cXDovLnRlc3QobGluZSkgJiYgcXVvdGF0aW9uQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFzc2VkVXJsTGluZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSBsaW5lLmluZGV4T2YoJzonKSA9PT0gbGluZS5sZW5ndGggLSAxID8gaSArIDEgOiBpO1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiBsaW5lT2Zmc2V0LCBjaDogbGluZXNbbGluZU9mZnNldF0ubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgcGFzc2VkVXJsTGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzaG91bGQgY29uc2lkZXIgZXh0ZW5kYWJsZSB0aXRsZVxuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBsaW5lLm1hdGNoKC8nfFwiL2cpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBxdW90YXRpb25Db3VudCArPSBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdW90YXRpb25Db3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiBpLCBjaDogbGluZS5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW2Jsb2NrLnNvdXJjZXBvc1swXVswXSwgYmxvY2suc291cmNlcG9zWzBdWzFdXSxcbiAgICAgICAgICAgIFtibG9jay5zb3VyY2Vwb3NbMF1bMF0gKyBsYXN0TGluZU9mZnNldC5saW5lLCBsYXN0TGluZU9mZnNldC5jaF0sXG4gICAgICAgIF07XG4gICAgfTtcbiAgICAvLyBQYXJzZSB0aGUgbmV4dCBpbmxpbmUgZWxlbWVudCBpbiBzdWJqZWN0LCBhZHZhbmNpbmcgc3ViamVjdCBwb3NpdGlvbi5cbiAgICAvLyBPbiBzdWNjZXNzLCBhZGQgdGhlIHJlc3VsdCB0byBibG9jaydzIGNoaWxkcmVuIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAvLyBPbiBmYWlsdXJlLCByZXR1cm4gZmFsc2UuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciByZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGMgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIENfTkVXTElORTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlTmV3bGluZShibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQkFDS1NMQVNIOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYWNrc2xhc2goYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0JBQ0tUSUNLOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYWNrdGlja3MoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0FTVEVSSVNLOlxuICAgICAgICAgICAgY2FzZSBDX1VOREVSU0NPUkU6XG4gICAgICAgICAgICBjYXNlIENfVElMREU6XG4gICAgICAgICAgICBjYXNlIENfRE9MTEFSOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMuaGFuZGxlRGVsaW0oYywgYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX1NJTkdMRVFVT1RFOlxuICAgICAgICAgICAgY2FzZSBDX0RPVUJMRVFVT1RFOlxuICAgICAgICAgICAgICAgIHJlcyA9ICEhKChfYSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNtYXJ0KSAmJiB0aGlzLmhhbmRsZURlbGltKGMsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19PUEVOX0JSQUNLRVQkMTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlT3BlbkJyYWNrZXQoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0JBTkc6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhbmcoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0NMT1NFX0JSQUNLRVQ6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUNsb3NlQnJhY2tldChibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfTEVTU1RIQU4kMTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQXV0b2xpbmsoYmxvY2spIHx8IHRoaXMucGFyc2VIdG1sVGFnKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19BTVBFUlNBTkQ6XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jay5kaXNhYmxlZEVudGl0eVBhcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VFbnRpdHkoYmxvY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZVN0cmluZyhibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dChmcm9tQ29kZVBvaW50JDEoYyksIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcyArIDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBQYXJzZSBzdHJpbmcgY29udGVudCBpbiBibG9jayBpbnRvIGlubGluZSBjaGlsZHJlbixcbiAgICAvLyB1c2luZyByZWZtYXAgdG8gcmVzb2x2ZSByZWZlcmVuY2VzLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gYmxvY2suc3RyaW5nQ29udGVudC50cmltKCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmFja2V0cyA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZU9mZnNldHMgPSBibG9jay5saW5lT2Zmc2V0cyB8fCBbMF07XG4gICAgICAgIHRoaXMubGluZUlkeCA9IDA7XG4gICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IDA7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0TnVtID0gYmxvY2suc291cmNlcG9zWzBdWzBdO1xuICAgICAgICBpZiAoaXNIZWFkaW5nKGJsb2NrKSkge1xuICAgICAgICAgICAgdGhpcy5saW5lT2Zmc2V0c1swXSArPSBibG9jay5sZXZlbCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMucGFyc2VJbmxpbmUoYmxvY2spKSB7IH1cbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7IC8vIGFsbG93IHJhdyBzdHJpbmcgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgdGhpcy5wcm9jZXNzRW1waGFzaXMobnVsbCk7XG4gICAgICAgIHRoaXMubWVyZ2VUZXh0Tm9kZXMoYmxvY2sud2Fsa2VyKCkpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGV4dGVuZGVkQXV0b2xpbmtzID0gX2EuZXh0ZW5kZWRBdXRvbGlua3MsIGN1c3RvbVBhcnNlciA9IF9hLmN1c3RvbVBhcnNlcjtcbiAgICAgICAgaWYgKGV4dGVuZGVkQXV0b2xpbmtzKSB7XG4gICAgICAgICAgICBjb252ZXJ0RXh0QXV0b0xpbmtzKGJsb2NrLndhbGtlcigpLCBleHRlbmRlZEF1dG9saW5rcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1c3RvbVBhcnNlciAmJiBibG9jay5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMTtcbiAgICAgICAgICAgIHZhciB3YWxrZXIgPSBibG9jay5maXJzdENoaWxkLndhbGtlcigpO1xuICAgICAgICAgICAgd2hpbGUgKChldmVudF8xID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50XzEubm9kZSwgZW50ZXJpbmcgPSBldmVudF8xLmVudGVyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21QYXJzZXJbbm9kZS50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21QYXJzZXJbbm9kZS50eXBlXShub2RlLCB7IGVudGVyaW5nOiBlbnRlcmluZywgb3B0aW9uczogdGhpcy5vcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElubGluZVBhcnNlcjtcbn0oKSk7XG52YXIgcmVUYXNrTGlzdEl0ZW1NYXJrZXIgPSAvXlxcWyhbIFxcdHhYXSlcXF1bIFxcdF0rLztcbi8vIGZpbmFsaXplIGZvciBibG9jayBoYW5kbGVyXG5mdW5jdGlvbiB0YXNrTGlzdEl0ZW1GaW5hbGl6ZShfLCBibG9jaykge1xuICAgIGlmIChibG9jay5maXJzdENoaWxkICYmIGJsb2NrLmZpcnN0Q2hpbGQudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgdmFyIHAgPSBibG9jay5maXJzdENoaWxkO1xuICAgICAgICB2YXIgbSA9IHAuc3RyaW5nQ29udGVudC5tYXRjaChyZVRhc2tMaXN0SXRlbU1hcmtlcik7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICB2YXIgbUxlbiA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcC5zdHJpbmdDb250ZW50ID0gcC5zdHJpbmdDb250ZW50LnN1YnN0cmluZyhtTGVuIC0gMSk7XG4gICAgICAgICAgICBwLnNvdXJjZXBvc1swXVsxXSArPSBtTGVuO1xuICAgICAgICAgICAgcC5saW5lT2Zmc2V0c1swXSArPSBtTGVuO1xuICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGFzayA9IHRydWU7XG4gICAgICAgICAgICBibG9jay5saXN0RGF0YS5jaGVja2VkID0gL1t4WF0vLnRlc3QobVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgdGFibGUgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVIZWFkJyB8fCB0ID09PSAndGFibGVCb2R5JztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlQm9keSQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ3RhYmxlUm93JztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlSGVhZCQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVSb3cnIHx8IHQgPT09ICd0YWJsZURlbGltUm93JztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlRGVsaW1Sb3cgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZURlbGltQ2VsbCc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0YWJsZURlbGltQ2VsbCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlUm93ID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVDZWxsJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlQ2VsbCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIENPREVfSU5ERU5UID0gNDtcbnZhciBDX1RBQiA9IDk7XG52YXIgQ19HUkVBVEVSVEhBTiA9IDYyO1xudmFyIENfTEVTU1RIQU4gPSA2MDtcbnZhciBDX1NQQUNFID0gMzI7XG52YXIgQ19PUEVOX0JSQUNLRVQgPSA5MTtcbnZhciByZU5vblNwYWNlID0gL1teIFxcdFxcZlxcdlxcclxcbl0vO1xudmFyIHJlQ2xvc2luZ0NvZGVGZW5jZSA9IC9eKD86YHszLH18fnszLH0pKD89ICokKS87XG4vLyBSZXR1cm5zIHRydWUgaWYgYmxvY2sgZW5kcyB3aXRoIGEgYmxhbmsgbGluZSwgZGVzY2VuZGluZyBpZiBuZWVkZWRcbi8vIGludG8gbGlzdHMgYW5kIHN1Ymxpc3RzLlxuZnVuY3Rpb24gZW5kc1dpdGhCbGFua0xpbmUoYmxvY2spIHtcbiAgICB2YXIgY3VyQmxvY2sgPSBibG9jaztcbiAgICB3aGlsZSAoY3VyQmxvY2spIHtcbiAgICAgICAgaWYgKGN1ckJsb2NrLmxhc3RMaW5lQmxhbmspIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gY3VyQmxvY2sudHlwZTtcbiAgICAgICAgaWYgKCFjdXJCbG9jay5sYXN0TGluZUNoZWNrZWQgJiYgKHQgPT09ICdsaXN0JyB8fCB0ID09PSAnaXRlbScpKSB7XG4gICAgICAgICAgICBjdXJCbG9jay5sYXN0TGluZUNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgY3VyQmxvY2sgPSBjdXJCbG9jay5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJCbG9jay5sYXN0TGluZUNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGVlayhsbiwgcG9zKSB7XG4gICAgaWYgKHBvcyA8IGxuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbG4uY2hhckNvZGVBdChwb3MpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgc3RyaW5nIGNvbnRhaW5zIG9ubHkgc3BhY2UgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIGlzQmxhbmsocykge1xuICAgIHJldHVybiAhcmVOb25TcGFjZS50ZXN0KHMpO1xufVxuZnVuY3Rpb24gaXNTcGFjZU9yVGFiKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gQ19TUEFDRSB8fCBjID09PSBDX1RBQjtcbn1cbnZhciByZUNsb3NpbmdDdXN0b21CbG9jayA9IC9eXFwkXFwkJC87XG52YXIgY3VzdG9tQmxvY2skMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKHJlQ2xvc2luZ0N1c3RvbUJsb2NrKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBjbG9zaW5nIGN1c3RvbSBibG9ja1xuICAgICAgICAgICAgcGFyc2VyLmxhc3RMaW5lTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIDIgLyogRmluaXNoZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBvcHRpb25hbCBzcGFjZXMgb2YgY3VzdG9tIGJsb2NrIG9mZnNldFxuICAgICAgICB2YXIgaSA9IGNvbnRhaW5lci5vZmZzZXQ7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiBpc1NwYWNlT3JUYWIocGVlayhsaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IGxpbmUgYmVjb21lcyBpbmZvIHN0cmluZ1xuICAgICAgICB2YXIgY29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgIHZhciBuZXdsaW5lUG9zID0gY29udGVudC5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGNvbnRlbnQuc2xpY2UoMCwgbmV3bGluZVBvcyk7XG4gICAgICAgIHZhciByZXN0ID0gY29udGVudC5zbGljZShuZXdsaW5lUG9zICsgMSk7XG4gICAgICAgIHZhciBpbmZvU3RyaW5nID0gZmlyc3RMaW5lLm1hdGNoKC9eKFxccyopKC4qKS8pO1xuICAgICAgICBibG9jay5pbmZvID0gdW5lc2NhcGVTdHJpbmcoaW5mb1N0cmluZ1syXS50cmltKCkpO1xuICAgICAgICBibG9jay5saXRlcmFsID0gcmVzdDtcbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgbm9vcCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgZG9jdW1lbnQkMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgIT09ICdpdGVtJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGxpc3QgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYmxvY2suZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBub24tZmluYWwgbGlzdCBpdGVtIGVuZGluZyB3aXRoIGJsYW5rIGxpbmU6XG4gICAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUoaXRlbSkgJiYgaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byBjaGlsZHJlbiBvZiBsaXN0IGl0ZW0sIHRvIHNlZSBpZiB0aGVyZSBhcmVcbiAgICAgICAgICAgIC8vIHNwYWNlcyBiZXR3ZWVuIGFueSBvZiB0aGVtOlxuICAgICAgICAgICAgdmFyIHN1Yml0ZW0gPSBpdGVtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoc3ViaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZShzdWJpdGVtKSAmJiAoaXRlbS5uZXh0IHx8IHN1Yml0ZW0ubmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yml0ZW0gPSBzdWJpdGVtLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5uZXh0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgYmxvY2tRdW90ZSQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHZhciBsbiA9IHBhcnNlci5jdXJyZW50TGluZTtcbiAgICAgICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcGVlayhsbiwgcGFyc2VyLm5leHROb25zcGFjZSkgPT09IENfR1JFQVRFUlRIQU4pIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoaXNTcGFjZU9yVGFiKHBlZWsobG4sIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgIT09ICdpdGVtJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGl0ZW0gPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmZpcnN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBCbGFuayBsaW5lIGFmdGVyIGVtcHR5IGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnNlci5pbmRlbnQgPj0gY29udGFpbmVyLmxpc3REYXRhLm1hcmtlck9mZnNldCArIGNvbnRhaW5lci5saXN0RGF0YS5wYWRkaW5nKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChjb250YWluZXIubGlzdERhdGEubWFya2VyT2Zmc2V0ICsgY29udGFpbmVyLmxpc3REYXRhLnBhZGRpbmcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiB0YXNrTGlzdEl0ZW1GaW5hbGl6ZSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCAhPT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgaGVhZGluZyA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhIGhlYWRpbmcgY2FuIG5ldmVyIGNvbnRhaW5lciA+IDEgbGluZSwgc28gZmFpbCB0byBtYXRjaDpcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0aGVtYXRpY0JyZWFrJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYSB0aGVtYXRpYyBicmVhayBjYW4gbmV2ZXIgY29udGFpbmVyID4gMSBsaW5lLCBzbyBmYWlsIHRvIG1hdGNoOlxuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGNvZGVCbG9jayA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsbiA9IHBhcnNlci5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIGluZGVudCA9IHBhcnNlci5pbmRlbnQ7XG4gICAgICAgIGlmIChjb250YWluZXIuaXNGZW5jZWQpIHtcbiAgICAgICAgICAgIC8vIGZlbmNlZFxuICAgICAgICAgICAgdmFyIG1hdGNoID0gaW5kZW50IDw9IDMgJiZcbiAgICAgICAgICAgICAgICBsbi5jaGFyQXQocGFyc2VyLm5leHROb25zcGFjZSkgPT09IGNvbnRhaW5lci5mZW5jZUNoYXIgJiZcbiAgICAgICAgICAgICAgICBsbi5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUNsb3NpbmdDb2RlRmVuY2UpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzBdLmxlbmd0aCA+PSBjb250YWluZXIuZmVuY2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBjbG9zaW5nIGZlbmNlIC0gd2UncmUgYXQgZW5kIG9mIGxpbmUsIHNvIHdlIGNhbiByZXR1cm5cbiAgICAgICAgICAgICAgICBwYXJzZXIubGFzdExpbmVMZW5ndGggPSBwYXJzZXIub2Zmc2V0ICsgaW5kZW50ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBGaW5pc2hlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgb3B0aW9uYWwgc3BhY2VzIG9mIGZlbmNlIG9mZnNldFxuICAgICAgICAgICAgdmFyIGkgPSBjb250YWluZXIuZmVuY2VPZmZzZXQ7XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgaXNTcGFjZU9yVGFiKHBlZWsobG4sIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluZGVudGVkXG4gICAgICAgICAgICBpZiAoaW5kZW50ID49IENPREVfSU5ERU5UKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoQ09ERV9JTkRFTlQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2suaXNGZW5jZWQpIHtcbiAgICAgICAgICAgIC8vIGZlbmNlZFxuICAgICAgICAgICAgLy8gZmlyc3QgbGluZSBiZWNvbWVzIGluZm8gc3RyaW5nXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgbmV3bGluZVBvcyA9IGNvbnRlbnQuaW5kZXhPZignXFxuJyk7XG4gICAgICAgICAgICB2YXIgZmlyc3RMaW5lID0gY29udGVudC5zbGljZSgwLCBuZXdsaW5lUG9zKTtcbiAgICAgICAgICAgIHZhciByZXN0ID0gY29udGVudC5zbGljZShuZXdsaW5lUG9zICsgMSk7XG4gICAgICAgICAgICB2YXIgaW5mb1N0cmluZyA9IGZpcnN0TGluZS5tYXRjaCgvXihcXHMqKSguKikvKTtcbiAgICAgICAgICAgIGJsb2NrLmluZm9QYWRkaW5nID0gaW5mb1N0cmluZ1sxXS5sZW5ndGg7XG4gICAgICAgICAgICBibG9jay5pbmZvID0gdW5lc2NhcGVTdHJpbmcoaW5mb1N0cmluZ1syXS50cmltKCkpO1xuICAgICAgICAgICAgYmxvY2subGl0ZXJhbCA9IHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbmRlbnRlZFxuICAgICAgICAgICAgYmxvY2subGl0ZXJhbCA9IChfYSA9IGJsb2NrLnN0cmluZ0NvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC8oXFxuICopKyQvLCAnXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7IC8vIGFsbG93IEdDXG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgaHRtbEJsb2NrJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gcGFyc2VyLmJsYW5rICYmIChjb250YWluZXIuaHRtbEJsb2NrVHlwZSA9PT0gNiB8fCBjb250YWluZXIuaHRtbEJsb2NrVHlwZSA9PT0gNylcbiAgICAgICAgICAgID8gMSAvKiBTdG9wICovXG4gICAgICAgICAgICA6IDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYmxvY2subGl0ZXJhbCA9ICgoX2EgPSBibG9jay5zdHJpbmdDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgvKFxcbiAqKSskLywgJycpKSB8fCBudWxsO1xuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDsgLy8gYWxsb3cgR0NcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBwYXJhZ3JhcGggPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5ibGFuayA/IDEgLyogU3RvcCAqLyA6IDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKHBhcnNlciwgYmxvY2spIHtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zO1xuICAgICAgICB2YXIgaGFzUmVmZXJlbmNlRGVmcyA9IGZhbHNlO1xuICAgICAgICAvLyB0cnkgcGFyc2luZyB0aGUgYmVnaW5uaW5nIGFzIGxpbmsgcmVmZXJlbmNlIGRlZmluaXRpb25zOlxuICAgICAgICB3aGlsZSAocGVlayhibG9jay5zdHJpbmdDb250ZW50LCAwKSA9PT0gQ19PUEVOX0JSQUNLRVQgJiZcbiAgICAgICAgICAgIChwb3MgPSBwYXJzZXIuaW5saW5lUGFyc2VyLnBhcnNlUmVmZXJlbmNlKGJsb2NrLCBwYXJzZXIucmVmTWFwKSkpIHtcbiAgICAgICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBibG9jay5zdHJpbmdDb250ZW50LnNsaWNlKHBvcyk7XG4gICAgICAgICAgICBoYXNSZWZlcmVuY2VEZWZzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlRGVmcyAmJiBpc0JsYW5rKGJsb2NrLnN0cmluZ0NvbnRlbnQpKSB7XG4gICAgICAgICAgICBibG9jay51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xudmFyIHJlZkRlZiA9IG5vb3A7XG52YXIgZnJvbnRNYXR0ZXIkMiA9IG5vb3A7XG52YXIgYmxvY2tIYW5kbGVycyA9IHtcbiAgICBkb2N1bWVudDogZG9jdW1lbnQkMSxcbiAgICBsaXN0OiBsaXN0LFxuICAgIGJsb2NrUXVvdGU6IGJsb2NrUXVvdGUkMSxcbiAgICBpdGVtOiBpdGVtLFxuICAgIGhlYWRpbmc6IGhlYWRpbmcsXG4gICAgdGhlbWF0aWNCcmVhazogdGhlbWF0aWNCcmVhayQxLFxuICAgIGNvZGVCbG9jazogY29kZUJsb2NrLFxuICAgIGh0bWxCbG9jazogaHRtbEJsb2NrJDEsXG4gICAgcGFyYWdyYXBoOiBwYXJhZ3JhcGgsXG4gICAgdGFibGU6IHRhYmxlLFxuICAgIHRhYmxlQm9keTogdGFibGVCb2R5JDEsXG4gICAgdGFibGVIZWFkOiB0YWJsZUhlYWQkMSxcbiAgICB0YWJsZVJvdzogdGFibGVSb3csXG4gICAgdGFibGVDZWxsOiB0YWJsZUNlbGwsXG4gICAgdGFibGVEZWxpbVJvdzogdGFibGVEZWxpbVJvdyxcbiAgICB0YWJsZURlbGltQ2VsbDogdGFibGVEZWxpbUNlbGwsXG4gICAgcmVmRGVmOiByZWZEZWYsXG4gICAgY3VzdG9tQmxvY2s6IGN1c3RvbUJsb2NrJDEsXG4gICAgZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyJDIsXG59O1xuZnVuY3Rpb24gcGFyc2VSb3dDb250ZW50KGNvbnRlbnQpIHtcbiAgICB2YXIgc3RhcnRJZHggPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoY29udGVudFtpXSA9PT0gJ3wnICYmIGNvbnRlbnRbaSAtIDFdICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnRJZHgsIGkpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0SWR4ID09PSAwICYmIGlzRW1wdHkoY2VsbCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydElkeCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydElkeCA8IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjZWxsID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnRJZHgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGNlbGwpKSB7XG4gICAgICAgICAgICBjZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbb2Zmc2V0LCBjZWxsc107XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVRhYmxlQ2VsbHMoY2VsbFR5cGUsIGNvbnRlbnRzLCBsaW5lTnVtLCBjaFBvcykge1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgY29udGVudHNfMSA9IGNvbnRlbnRzOyBfaSA8IGNvbnRlbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gY29udGVudHNfMVtfaV07XG4gICAgICAgIHZhciBwcmVTcGFjZXMgPSBjb250ZW50Lm1hdGNoKC9eWyBcXHRdKy8pO1xuICAgICAgICB2YXIgcGFkZGluZ0xlZnQgPSBwcmVTcGFjZXMgPyBwcmVTcGFjZXNbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgdmFyIHBhZGRpbmdSaWdodCA9IHZvaWQgMCwgdHJpbW1lZCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHBhZGRpbmdMZWZ0ID09PSBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRyaW1tZWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3N0U3BhY2VzID0gY29udGVudC5tYXRjaCgvWyBcXHRdKyQvKTtcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHBvc3RTcGFjZXMgPyBwb3N0U3BhY2VzWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICB0cmltbWVkID0gY29udGVudC5zbGljZShwYWRkaW5nTGVmdCwgY29udGVudC5sZW5ndGggLSBwYWRkaW5nUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaFBvc1N0YXJ0ID0gY2hQb3MgKyBwYWRkaW5nTGVmdDtcbiAgICAgICAgdmFyIHRhYmxlQ2VsbCA9IGNyZWF0ZU5vZGUoY2VsbFR5cGUsIFtcbiAgICAgICAgICAgIFtsaW5lTnVtLCBjaFBvc10sXG4gICAgICAgICAgICBbbGluZU51bSwgY2hQb3MgKyBjb250ZW50Lmxlbmd0aCAtIDFdLFxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGVDZWxsLnN0cmluZ0NvbnRlbnQgPSB0cmltbWVkLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTsgLy8gcmVwbGFjZSBlc2FjcGVkIHBpcGUoXFx8KVxuICAgICAgICB0YWJsZUNlbGwuc3RhcnRJZHggPSBjZWxscy5sZW5ndGg7XG4gICAgICAgIHRhYmxlQ2VsbC5lbmRJZHggPSBjZWxscy5sZW5ndGg7XG4gICAgICAgIHRhYmxlQ2VsbC5saW5lT2Zmc2V0cyA9IFtjaFBvc1N0YXJ0IC0gMV07XG4gICAgICAgIHRhYmxlQ2VsbC5wYWRkaW5nTGVmdCA9IHBhZGRpbmdMZWZ0O1xuICAgICAgICB0YWJsZUNlbGwucGFkZGluZ1JpZ2h0ID0gcGFkZGluZ1JpZ2h0O1xuICAgICAgICBjZWxscy5wdXNoKHRhYmxlQ2VsbCk7XG4gICAgICAgIGNoUG9zICs9IGNvbnRlbnQubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzO1xufVxuZnVuY3Rpb24gZ2V0Q29sdW1uRnJvbURlbGltQ2VsbChjZWxsTm9kZSkge1xuICAgIHZhciBhbGlnbiA9IG51bGw7XG4gICAgdmFyIGNvbnRlbnQgPSBjZWxsTm9kZS5zdHJpbmdDb250ZW50O1xuICAgIHZhciBmaXJzdENoID0gY29udGVudFswXTtcbiAgICB2YXIgbGFzdENoID0gY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2ggPT09ICc6Jykge1xuICAgICAgICBhbGlnbiA9IGZpcnN0Q2ggPT09ICc6JyA/ICdjZW50ZXInIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RDaCA9PT0gJzonKSB7XG4gICAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH1cbiAgICByZXR1cm4geyBhbGlnbjogYWxpZ24gfTtcbn1cbnZhciB0YWJsZUhlYWQgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgc3RyaW5nQ29udGVudCA9IGNvbnRhaW5lci5zdHJpbmdDb250ZW50O1xuICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgIXBhcnNlci5pbmRlbnRlZCAmJiAhcGFyc2VyLmJsYW5rKSB7XG4gICAgICAgIHZhciBsYXN0TmV3TGluZUlkeCA9IHN0cmluZ0NvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGxhc3RMaW5lU3RhcnRJZHggPSBzdHJpbmdDb250ZW50Lmxhc3RJbmRleE9mKCdcXG4nLCBsYXN0TmV3TGluZUlkeCAtIDEpICsgMTtcbiAgICAgICAgdmFyIGhlYWRlckNvbnRlbnQgPSBzdHJpbmdDb250ZW50LnNsaWNlKGxhc3RMaW5lU3RhcnRJZHgsIGxhc3ROZXdMaW5lSWR4KTtcbiAgICAgICAgdmFyIGRlbGltQ29udGVudCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VSb3dDb250ZW50KGhlYWRlckNvbnRlbnQpLCBoZWFkZXJPZmZzZXQgPSBfYVswXSwgaGVhZGVyQ2VsbHMgPSBfYVsxXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VSb3dDb250ZW50KGRlbGltQ29udGVudCksIGRlbGltT2Zmc2V0ID0gX2JbMF0sIGRlbGltQ2VsbHMgPSBfYlsxXTtcbiAgICAgICAgdmFyIHJlVmFsaWREZWxpbUNlbGxfMSA9IC9eWyBcXHRdKjo/LSs6P1sgXFx0XSokLztcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgY2hlY2tpbmcgaWYgdGhlIG51bWJlciBvZiBoZWFkZXIgY2VsbHMgYW5kIGRlbGltaXRlciBjZWxscyBhcmUgdGhlIHNhbWVcbiAgICAgICAgLy8gdG8gY29uc2lkZXIgdGhlIGNhc2Ugb2YgbWVyZ2VkLWNvbHVtbiAodmlhIHBsdWdpbilcbiAgICAgICAgIWhlYWRlckNlbGxzLmxlbmd0aCB8fFxuICAgICAgICAgICAgIWRlbGltQ2VsbHMubGVuZ3RoIHx8XG4gICAgICAgICAgICBkZWxpbUNlbGxzLnNvbWUoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuICFyZVZhbGlkRGVsaW1DZWxsXzEudGVzdChjZWxsKTsgfSkgfHxcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgdG8gcmVnYXJkIHNldFRleHRIZWFkaW5nIGFzIHRhYmVsIGRlbGltIGNlbGwgd2l0aCAnZGlzYWxsb3dEZWVwSGVhZGluZycgb3B0aW9uXG4gICAgICAgICAgICAoZGVsaW1DZWxscy5sZW5ndGggPT09IDEgJiYgZGVsaW1Db250ZW50LmluZGV4T2YoJ3wnKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gY29udGFpbmVyLmxpbmVPZmZzZXRzO1xuICAgICAgICB2YXIgZmlyc3RMaW5lTnVtID0gcGFyc2VyLmxpbmVOdW1iZXIgLSAxO1xuICAgICAgICB2YXIgZmlyc3RMaW5lU3RhcnQgPSBsYXN0KGxpbmVPZmZzZXRzKSArIDE7XG4gICAgICAgIHZhciB0YWJsZSA9IGNyZWF0ZU5vZGUoJ3RhYmxlJywgW1xuICAgICAgICAgICAgW2ZpcnN0TGluZU51bSwgZmlyc3RMaW5lU3RhcnRdLFxuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIub2Zmc2V0XSxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgICAgIHRhYmxlLmNvbHVtbnMgPSBkZWxpbUNlbGxzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBhbGlnbjogbnVsbCB9KTsgfSk7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZnRlcih0YWJsZSk7XG4gICAgICAgIGlmIChsaW5lT2Zmc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHJpbmdDb250ZW50ID0gc3RyaW5nQ29udGVudC5zbGljZSgwLCBsYXN0TGluZVN0YXJ0SWR4KTtcbiAgICAgICAgICAgIHZhciBwYXJhTGFzdExpbmVTdGFydElkeCA9IHN0cmluZ0NvbnRlbnQubGFzdEluZGV4T2YoJ1xcbicsIGxhc3RMaW5lU3RhcnRJZHggLSAyKSArIDE7XG4gICAgICAgICAgICB2YXIgcGFyYUxhc3RMaW5lTGVuID0gbGFzdExpbmVTdGFydElkeCAtIHBhcmFMYXN0TGluZVN0YXJ0SWR4IC0gMTtcbiAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IGxpbmVPZmZzZXRzW2xpbmVPZmZzZXRzLmxlbmd0aCAtIDJdICsgcGFyYUxhc3RMaW5lTGVuO1xuICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgZmlyc3RMaW5lTnVtIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgdmFyIHRhYmxlSGVhZF8xID0gY3JlYXRlTm9kZSgndGFibGVIZWFkJywgW1xuICAgICAgICAgICAgW2ZpcnN0TGluZU51bSwgZmlyc3RMaW5lU3RhcnRdLFxuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIub2Zmc2V0XSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRhYmxlSGVhZF8xKTtcbiAgICAgICAgdmFyIHRhYmxlSGVhZFJvd18xID0gY3JlYXRlTm9kZSgndGFibGVSb3cnLCBbXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydF0sXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydCArIGhlYWRlckNvbnRlbnQubGVuZ3RoIC0gMV0sXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdGFibGVEZWxpbVJvd18xID0gY3JlYXRlTm9kZSgndGFibGVEZWxpbVJvdycsIFtcbiAgICAgICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDFdLFxuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIub2Zmc2V0XSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRhYmxlSGVhZF8xLmFwcGVuZENoaWxkKHRhYmxlSGVhZFJvd18xKTtcbiAgICAgICAgdGFibGVIZWFkXzEuYXBwZW5kQ2hpbGQodGFibGVEZWxpbVJvd18xKTtcbiAgICAgICAgZ2VuZXJhdGVUYWJsZUNlbGxzKCd0YWJsZUNlbGwnLCBoZWFkZXJDZWxscywgZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydCArIGhlYWRlck9mZnNldCkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbE5vZGUpIHtcbiAgICAgICAgICAgIHRhYmxlSGVhZFJvd18xLmFwcGVuZENoaWxkKGNlbGxOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWxpbUNlbGxOb2RlcyA9IGdlbmVyYXRlVGFibGVDZWxscygndGFibGVEZWxpbUNlbGwnLCBkZWxpbUNlbGxzLCBwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDEgKyBkZWxpbU9mZnNldCk7XG4gICAgICAgIGRlbGltQ2VsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNlbGxOb2RlKSB7XG4gICAgICAgICAgICB0YWJsZURlbGltUm93XzEuYXBwZW5kQ2hpbGQoY2VsbE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGFibGUuY29sdW1ucyA9IGRlbGltQ2VsbE5vZGVzLm1hcChnZXRDb2x1bW5Gcm9tRGVsaW1DZWxsKTtcbiAgICAgICAgcGFyc2VyLnRpcCA9IHRhYmxlO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciB0YWJsZUJvZHkgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICBpZiAoKGNvbnRhaW5lci50eXBlICE9PSAndGFibGUnICYmIGNvbnRhaW5lci50eXBlICE9PSAndGFibGVCb2R5JykgfHxcbiAgICAgICAgKCFwYXJzZXIuYmxhbmsgJiYgcGFyc2VyLmN1cnJlbnRMaW5lLmluZGV4T2YoJ3wnKSA9PT0gLTEpKSB7XG4gICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgaWYgKHBhcnNlci5ibGFuaykge1xuICAgICAgICB2YXIgdGFibGVfMSA9IGNvbnRhaW5lcjtcbiAgICAgICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAndGFibGVCb2R5Jykge1xuICAgICAgICAgICAgdGFibGVfMSA9IGNvbnRhaW5lci5wYXJlbnQ7XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBwYXJzZXIubGluZU51bWJlciAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5maW5hbGl6ZSh0YWJsZV8xLCBwYXJzZXIubGluZU51bWJlciAtIDEpO1xuICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICB2YXIgdGFibGVCb2R5ID0gY29udGFpbmVyO1xuICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3RhYmxlJykge1xuICAgICAgICB0YWJsZUJvZHkgPSBwYXJzZXIuYWRkQ2hpbGQoJ3RhYmxlQm9keScsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICB0YWJsZUJvZHkuc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfVxuICAgIHZhciB0YWJsZVJvdyA9IGNyZWF0ZU5vZGUoJ3RhYmxlUm93JywgW1xuICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyAxXSxcbiAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoXSxcbiAgICBdKTtcbiAgICB0YWJsZUJvZHkuYXBwZW5kQ2hpbGQodGFibGVSb3cpO1xuICAgIHZhciB0YWJsZSA9IHRhYmxlQm9keS5wYXJlbnQ7XG4gICAgdmFyIGNvbnRlbnQgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgdmFyIF9hID0gcGFyc2VSb3dDb250ZW50KGNvbnRlbnQpLCBvZmZzZXQgPSBfYVswXSwgY2VsbENvbnRlbnRzID0gX2FbMV07XG4gICAgZ2VuZXJhdGVUYWJsZUNlbGxzKCd0YWJsZUNlbGwnLCBjZWxsQ29udGVudHMsIHBhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMSArIG9mZnNldCkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbE5vZGUsIGlkeCkge1xuICAgICAgICBpZiAoaWR4ID49IHRhYmxlLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjZWxsTm9kZS5pZ25vcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZVJvdy5hcHBlbmRDaGlsZChjZWxsTm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbn07XG52YXIgcmVDdXN0b21CbG9jayA9IC9eKFxcJFxcJCkoXFxzKlthLXpBLVpdKSsvO1xudmFyIHJlQ2FuQmVDdXN0b21JbmxpbmUgPSAvXihcXCRcXCQpKFxccypbYS16QS1aXSkrLiooXFwkXFwkKS87XG52YXIgY3VzdG9tQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgICFyZUNhbkJlQ3VzdG9tSW5saW5lLnRlc3QocGFyc2VyLmN1cnJlbnRMaW5lKSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUubWF0Y2gocmVDdXN0b21CbG9jaykpKSB7XG4gICAgICAgIHZhciBzeW50YXhMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gcGFyc2VyLmFkZENoaWxkKCdjdXN0b21CbG9jaycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBjb250YWluZXIuc3ludGF4TGVuZ3RoID0gc3ludGF4TGVuZ3RoO1xuICAgICAgICBjb250YWluZXIub2Zmc2V0ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoc3ludGF4TGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIHJlQ29kZUZlbmNlID0gL15gezMsfSg/IS4qYCl8Xn57Myx9LztcbnZhciByZUh0bWxCbG9ja09wZW4gPSBbXG4gICAgLy4vLFxuICAgIC9ePCg/OnNjcmlwdHxwcmV8c3R5bGUpKD86XFxzfD58JCkvaSxcbiAgICAvXjwhLS0vLFxuICAgIC9ePFs/XS8sXG4gICAgL148IVtBLVpdLyxcbiAgICAvXjwhXFxbQ0RBVEFcXFsvLFxuICAgIC9ePFsvXT8oPzphZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbnxjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxMjM0NTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9ufHB8cGFyYW18c2VjdGlvbnxzb3VyY2V8c3VtbWFyeXx0YWJsZXx0Ym9keXx0ZHx0Zm9vdHx0aHx0aGVhZHx0aXRsZXx0cnx0cmFja3x1bCkoPzpcXHN8Wy9dP1s+XXwkKS9pLFxuICAgIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBPUEVOVEFHICsgXCJ8XCIgKyBDTE9TRVRBRyArIFwiKVxcXFxzKiRcIiwgJ2knKSxcbl07XG52YXIgcmVTZXRleHRIZWFkaW5nTGluZSA9IC9eKD86PSt8LSspWyBcXHRdKiQvO1xudmFyIHJlQVRYSGVhZGluZ01hcmtlciA9IC9eI3sxLDZ9KD86WyBcXHRdK3wkKS87XG52YXIgcmVUaGVtYXRpY0JyZWFrID0gL14oPzooPzpcXCpbIFxcdF0qKXszLH18KD86X1sgXFx0XSopezMsfXwoPzotWyBcXHRdKil7Myx9KVsgXFx0XSokLztcbnZhciByZUJ1bGxldExpc3RNYXJrZXIgPSAvXlsqKy1dLztcbnZhciByZU9yZGVyZWRMaXN0TWFya2VyID0gL14oXFxkezEsOX0pKFsuKV0pLztcbi8vIFBhcnNlIGEgbGlzdCBtYXJrZXIgYW5kIHJldHVybiBkYXRhIG9uIHRoZSBtYXJrZXIgKHR5cGUsXG4vLyBzdGFydCwgZGVsaW1pdGVyLCBidWxsZXQgY2hhcmFjdGVyLCBwYWRkaW5nKSBvciBudWxsLlxuZnVuY3Rpb24gcGFyc2VMaXN0TWFya2VyKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIHJlc3QgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBuZXh0YztcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgdHlwZTogJ2J1bGxldCcsXG4gICAgICAgIHRpZ2h0OiB0cnVlLFxuICAgICAgICBidWxsZXRDaGFyOiAnJyxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGRlbGltaXRlcjogJycsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmtlck9mZnNldDogcGFyc2VyLmluZGVudCxcbiAgICAgICAgLy8gR0ZNOiBUYXNrIExpc3QgSXRlbVxuICAgICAgICB0YXNrOiBmYWxzZSxcbiAgICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgfTtcbiAgICBpZiAocGFyc2VyLmluZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gcmVzdC5tYXRjaChyZUJ1bGxldExpc3RNYXJrZXIpKSkge1xuICAgICAgICBkYXRhLnR5cGUgPSAnYnVsbGV0JztcbiAgICAgICAgZGF0YS5idWxsZXRDaGFyID0gbWF0Y2hbMF1bMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKChtYXRjaCA9IHJlc3QubWF0Y2gocmVPcmRlcmVkTGlzdE1hcmtlcikpICYmXG4gICAgICAgIChjb250YWluZXIudHlwZSAhPT0gJ3BhcmFncmFwaCcgfHwgbWF0Y2hbMV0gPT09ICcxJykpIHtcbiAgICAgICAgZGF0YS50eXBlID0gJ29yZGVyZWQnO1xuICAgICAgICBkYXRhLnN0YXJ0ID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgZGF0YS5kZWxpbWl0ZXIgPSBtYXRjaFsyXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBzcGFjZXMgYWZ0ZXJcbiAgICBuZXh0YyA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICBpZiAoIShuZXh0YyA9PT0gLTEgfHwgbmV4dGMgPT09IENfVEFCIHx8IG5leHRjID09PSBDX1NQQUNFKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgaXQgaW50ZXJydXB0cyBwYXJhZ3JhcGgsIG1ha2Ugc3VyZSBmaXJzdCBsaW5lIGlzbid0IGJsYW5rXG4gICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJyAmJlxuICAgICAgICAhcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UgKyBtYXRjaFswXS5sZW5ndGgpLm1hdGNoKHJlTm9uU3BhY2UpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyB3ZSd2ZSBnb3QgYSBtYXRjaCEgYWR2YW5jZSBvZmZzZXQgYW5kIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTsgLy8gdG8gc3RhcnQgb2YgbWFya2VyXG4gICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQobWF0Y2hbMF0ubGVuZ3RoLCB0cnVlKTsgLy8gdG8gZW5kIG9mIG1hcmtlclxuICAgIHZhciBzcGFjZXNTdGFydENvbCA9IHBhcnNlci5jb2x1bW47XG4gICAgdmFyIHNwYWNlc1N0YXJ0T2Zmc2V0ID0gcGFyc2VyLm9mZnNldDtcbiAgICBkbyB7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICBuZXh0YyA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KTtcbiAgICB9IHdoaWxlIChwYXJzZXIuY29sdW1uIC0gc3BhY2VzU3RhcnRDb2wgPCA1ICYmIGlzU3BhY2VPclRhYihuZXh0YykpO1xuICAgIHZhciBibGFua0l0ZW0gPSBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm9mZnNldCkgPT09IC0xO1xuICAgIHZhciBzcGFjZXNBZnRlck1hcmtlciA9IHBhcnNlci5jb2x1bW4gLSBzcGFjZXNTdGFydENvbDtcbiAgICBpZiAoc3BhY2VzQWZ0ZXJNYXJrZXIgPj0gNSB8fCBzcGFjZXNBZnRlck1hcmtlciA8IDEgfHwgYmxhbmtJdGVtKSB7XG4gICAgICAgIGRhdGEucGFkZGluZyA9IG1hdGNoWzBdLmxlbmd0aCArIDE7XG4gICAgICAgIHBhcnNlci5jb2x1bW4gPSBzcGFjZXNTdGFydENvbDtcbiAgICAgICAgcGFyc2VyLm9mZnNldCA9IHNwYWNlc1N0YXJ0T2Zmc2V0O1xuICAgICAgICBpZiAoaXNTcGFjZU9yVGFiKHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhLnBhZGRpbmcgPSBtYXRjaFswXS5sZW5ndGggKyBzcGFjZXNBZnRlck1hcmtlcjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBsaXN0IGl0ZW1zIGFyZSBvZiB0aGUgc2FtZSB0eXBlLFxuLy8gd2l0aCB0aGUgc2FtZSBkZWxpbWl0ZXIgYW5kIGJ1bGxldCBjaGFyYWN0ZXIuICBUaGlzIGlzIHVzZWRcbi8vIGluIGFnZ2xvbWVyYXRpbmcgbGlzdCBpdGVtcyBpbnRvIGxpc3RzLlxuZnVuY3Rpb24gbGlzdHNNYXRjaChsaXN0RGF0YSwgaXRlbURhdGEpIHtcbiAgICByZXR1cm4gKGxpc3REYXRhLnR5cGUgPT09IGl0ZW1EYXRhLnR5cGUgJiZcbiAgICAgICAgbGlzdERhdGEuZGVsaW1pdGVyID09PSBpdGVtRGF0YS5kZWxpbWl0ZXIgJiZcbiAgICAgICAgbGlzdERhdGEuYnVsbGV0Q2hhciA9PT0gaXRlbURhdGEuYnVsbGV0Q2hhcik7XG59XG5mdW5jdGlvbiBpc0Rpc2FsbG93ZWREZWVwSGVhZGluZyhwYXJzZXIsIG5vZGUpIHtcbiAgICByZXR1cm4gcGFyc2VyLm9wdGlvbnMuZGlzYWxsb3dEZWVwSGVhZGluZyAmJiAobm9kZS50eXBlID09PSAnYmxvY2tRdW90ZScgfHwgbm9kZS50eXBlID09PSAnaXRlbScpO1xufVxudmFyIGJsb2NrUXVvdGUgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBDX0dSRUFURVJUSEFOKSB7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIGZhbHNlKTtcbiAgICAgICAgLy8gb3B0aW9uYWwgZm9sbG93aW5nIHNwYWNlXG4gICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHBhcnNlci5hZGRDaGlsZCgnYmxvY2tRdW90ZScsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICByZXR1cm4gMSAvKiBDb250YWluZXIgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGF0eEhlYWRpbmcgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgLy8gVGhlIG5lc3RlZCBIZWFkaW5nIGlzIGRpc2FsbG93ZWQgaW4gbGlzdCBhbmQgYmxvY2txdW90ZSB3aXRoICdkaXNhbGxvd0RlZXBIZWFkaW5nJyBvcHRpb25cbiAgICAgICAgIWlzRGlzYWxsb3dlZERlZXBIZWFkaW5nKHBhcnNlciwgY29udGFpbmVyKSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVBVFhIZWFkaW5nTWFya2VyKSkpIHtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQobWF0Y2hbMF0ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgaGVhZGluZyA9IHBhcnNlci5hZGRDaGlsZCgnaGVhZGluZycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBoZWFkaW5nLmxldmVsID0gbWF0Y2hbMF0udHJpbSgpLmxlbmd0aDsgLy8gbnVtYmVyIG9mICNzXG4gICAgICAgIGhlYWRpbmcuaGVhZGluZ1R5cGUgPSAnYXR4JztcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICMjI3M6XG4gICAgICAgIGhlYWRpbmcuc3RyaW5nQ29udGVudCA9IHBhcnNlci5jdXJyZW50TGluZVxuICAgICAgICAgICAgLnNsaWNlKHBhcnNlci5vZmZzZXQpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlsgXFx0XSojK1sgXFx0XSokLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvWyBcXHRdKyMrWyBcXHRdKiQvLCAnJyk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgZmVuY2VkQ29kZUJsb2NrID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVDb2RlRmVuY2UpKSkge1xuICAgICAgICB2YXIgZmVuY2VMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gcGFyc2VyLmFkZENoaWxkKCdjb2RlQmxvY2snLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgY29udGFpbmVyLmlzRmVuY2VkID0gdHJ1ZTtcbiAgICAgICAgY29udGFpbmVyLmZlbmNlTGVuZ3RoID0gZmVuY2VMZW5ndGg7XG4gICAgICAgIGNvbnRhaW5lci5mZW5jZUNoYXIgPSBtYXRjaFswXVswXTtcbiAgICAgICAgY29udGFpbmVyLmZlbmNlT2Zmc2V0ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoZmVuY2VMZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgaHRtbEJsb2NrID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBDX0xFU1NUSEFOKSB7XG4gICAgICAgIHZhciBzID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICB2YXIgZGlzYWxsb3dlZFRhZ3MgPSBwYXJzZXIub3B0aW9ucy5kaXNhbGxvd2VkSHRtbEJsb2NrVGFncztcbiAgICAgICAgdmFyIGJsb2NrVHlwZSA9IHZvaWQgMDtcbiAgICAgICAgZm9yIChibG9ja1R5cGUgPSAxOyBibG9ja1R5cGUgPD0gNzsgYmxvY2tUeXBlKyspIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gcy5tYXRjaChyZUh0bWxCbG9ja09wZW5bYmxvY2tUeXBlXSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1R5cGUgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWxsb3dlZFRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlRGlzYWxsb3dlZFRhZ3MgPSBuZXcgUmVnRXhwKFwiPC8/KD86XCIgKyBkaXNhbGxvd2VkVGFncy5qb2luKCd8JykgKyBcIilcIiwgJ2knKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZURpc2FsbG93ZWRUYWdzLnRlc3QobWF0Y2hlZFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGFkanVzdCBwYXJzZXIub2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIHNwYWNlcyBhcmUgcGFydCBvZiB0aGUgSFRNTCBibG9jazpcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHBhcnNlci5hZGRDaGlsZCgnaHRtbEJsb2NrJywgcGFyc2VyLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYi5odG1sQmxvY2tUeXBlID0gYmxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgc2VUZXh0SGVhZGluZyA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgIT09IG51bGwgJiZcbiAgICAgICAgIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICBjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiZcbiAgICAgICAgLy8gVGhlIG5lc3RlZCBIZWFkaW5nIGlzIGRpc2FsbG93ZWQgaW4gbGlzdCBhbmQgYmxvY2txdW90ZSB3aXRoICdkaXNhbGxvd0RlZXBIZWFkaW5nJyBvcHRpb25cbiAgICAgICAgIWlzRGlzYWxsb3dlZERlZXBIZWFkaW5nKHBhcnNlciwgY29udGFpbmVyLnBhcmVudCkgJiZcbiAgICAgICAgKG1hdGNoID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpLm1hdGNoKHJlU2V0ZXh0SGVhZGluZ0xpbmUpKSkge1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgLy8gcmVzb2x2ZSByZWZlcmVuY2UgbGluayBkZWZpbml0aW9uc1xuICAgICAgICB2YXIgcG9zID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAocGVlayhjb250YWluZXIuc3RyaW5nQ29udGVudCwgMCkgPT09IENfT1BFTl9CUkFDS0VUICYmXG4gICAgICAgICAgICAocG9zID0gcGFyc2VyLmlubGluZVBhcnNlci5wYXJzZVJlZmVyZW5jZShjb250YWluZXIsIHBhcnNlci5yZWZNYXApKSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgPSBjb250YWluZXIuc3RyaW5nQ29udGVudC5zbGljZShwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXIuc3RyaW5nQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGluZyA9IGNyZWF0ZU5vZGUoJ2hlYWRpbmcnLCBjb250YWluZXIuc291cmNlcG9zKTtcbiAgICAgICAgICAgIGhlYWRpbmcubGV2ZWwgPSBtYXRjaFswXVswXSA9PT0gJz0nID8gMSA6IDI7XG4gICAgICAgICAgICBoZWFkaW5nLmhlYWRpbmdUeXBlID0gJ3NldGV4dCc7XG4gICAgICAgICAgICBoZWFkaW5nLnN0cmluZ0NvbnRlbnQgPSBjb250YWluZXIuc3RyaW5nQ29udGVudDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZnRlcihoZWFkaW5nKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci51bmxpbmsoKTtcbiAgICAgICAgICAgIHBhcnNlci50aXAgPSBoZWFkaW5nO1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgdGhlbWF0aWNCcmVhayA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiByZVRoZW1hdGljQnJlYWsudGVzdChwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICBwYXJzZXIuYWRkQ2hpbGQoJ3RoZW1hdGljQnJlYWsnLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgbGlzdEl0ZW0gPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgY3Vyck5vZGUgPSBjb250YWluZXI7XG4gICAgaWYgKCghcGFyc2VyLmluZGVudGVkIHx8IGNvbnRhaW5lci50eXBlID09PSAnbGlzdCcpICYmXG4gICAgICAgIChkYXRhID0gcGFyc2VMaXN0TWFya2VyKHBhcnNlciwgY3Vyck5vZGUpKSkge1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgLy8gYWRkIHRoZSBsaXN0IGlmIG5lZWRlZFxuICAgICAgICBpZiAocGFyc2VyLnRpcC50eXBlICE9PSAnbGlzdCcgfHwgIWxpc3RzTWF0Y2goY3Vyck5vZGUubGlzdERhdGEsIGRhdGEpKSB7XG4gICAgICAgICAgICBjdXJyTm9kZSA9IHBhcnNlci5hZGRDaGlsZCgnbGlzdCcsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICAgICAgY3Vyck5vZGUubGlzdERhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgbGlzdCBpdGVtXG4gICAgICAgIGN1cnJOb2RlID0gcGFyc2VyLmFkZENoaWxkKCdpdGVtJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGN1cnJOb2RlLmxpc3REYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIDEgLyogQ29udGFpbmVyICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbi8vIGluZGVudGVkIGNvZGUgYmxvY2tcbnZhciBpbmRlbnRlZENvZGVCbG9jayA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICBpZiAocGFyc2VyLmluZGVudGVkICYmIHBhcnNlci50aXAudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiYgIXBhcnNlci5ibGFuaykge1xuICAgICAgICAvLyBpbmRlbnRlZCBjb2RlXG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KENPREVfSU5ERU5ULCB0cnVlKTtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHBhcnNlci5hZGRDaGlsZCgnY29kZUJsb2NrJywgcGFyc2VyLm9mZnNldCk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGJsb2NrU3RhcnRzID0gW1xuICAgIGJsb2NrUXVvdGUsXG4gICAgYXR4SGVhZGluZyxcbiAgICBmZW5jZWRDb2RlQmxvY2ssXG4gICAgaHRtbEJsb2NrLFxuICAgIHNlVGV4dEhlYWRpbmcsXG4gICAgdGhlbWF0aWNCcmVhayxcbiAgICBsaXN0SXRlbSxcbiAgICBpbmRlbnRlZENvZGVCbG9jayxcbiAgICB0YWJsZUhlYWQsXG4gICAgdGFibGVCb2R5LFxuICAgIGN1c3RvbUJsb2NrLFxuXTtcbi8vIGAtLS1gIGZvciBZQU1MLCBgKysrYCBmb3IgVE9NTCwgYDs7O2AgZm9yIEpTT05cbnZhciByZUZyb250TWF0dGVyID0gL14oLXszfXxcXCt7M318O3szfSkkLztcbnZhciBmcm9udE1hdHRlciQxID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIGN1cnJlbnRMaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lLCBsaW5lTnVtYmVyID0gcGFyc2VyLmxpbmVOdW1iZXIsIGluZGVudGVkID0gcGFyc2VyLmluZGVudGVkO1xuICAgIGlmIChsaW5lTnVtYmVyID09PSAxICYmXG4gICAgICAgICFpbmRlbnRlZCAmJlxuICAgICAgICBjb250YWluZXIudHlwZSA9PT0gJ2RvY3VtZW50JyAmJlxuICAgICAgICByZUZyb250TWF0dGVyLnRlc3QoY3VycmVudExpbmUpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgZnJvbnRNYXR0ZXJfMSA9IHBhcnNlci5hZGRDaGlsZCgnZnJvbnRNYXR0ZXInLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgZnJvbnRNYXR0ZXJfMS5zdHJpbmdDb250ZW50ID0gY3VycmVudExpbmU7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGN1cnJlbnRMaW5lLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBmcm9udE1hdHRlciA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKHJlRnJvbnRNYXR0ZXIpO1xuICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdmcm9udE1hdHRlcicgJiYgbWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHJpbmdDb250ZW50ICs9IGxpbmU7XG4gICAgICAgICAgICBwYXJzZXIubGFzdExpbmVMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBwYXJzZXIubGluZU51bWJlcik7XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBGaW5pc2hlZCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBibG9jay5saXRlcmFsID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgcmVIdG1sQmxvY2tDbG9zZSA9IFtcbiAgICAvLi8sXG4gICAgLzxcXC8oPzpzY3JpcHR8cHJlfHN0eWxlKT4vaSxcbiAgICAvLS0+LyxcbiAgICAvXFw/Pi8sXG4gICAgLz4vLFxuICAgIC9cXF1cXF0+Lyxcbl07XG52YXIgcmVNYXliZVNwZWNpYWwgPSAvXlsjYH4qK189PD4wLTktOyRdLztcbnZhciByZUxpbmVFbmRpbmckMSA9IC9cXHJcXG58XFxufFxcci87XG5mdW5jdGlvbiBlc21fZG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUoJ2RvY3VtZW50JywgW1xuICAgICAgICBbMSwgMV0sXG4gICAgICAgIFswLCAwXSxcbiAgICBdKTtcbn1cbnZhciBkZWZhdWx0T3B0aW9ucyQxID0ge1xuICAgIHNtYXJ0OiBmYWxzZSxcbiAgICB0YWdGaWx0ZXI6IGZhbHNlLFxuICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBmYWxzZSxcbiAgICBkaXNhbGxvd2VkSHRtbEJsb2NrVGFnczogW10sXG4gICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogZmFsc2UsXG4gICAgZGlzYWxsb3dEZWVwSGVhZGluZzogZmFsc2UsXG4gICAgY3VzdG9tUGFyc2VyOiBudWxsLFxuICAgIGZyb250TWF0dGVyOiBmYWxzZSxcbn07XG52YXIgUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGVzbV9hc3NpZ24oZXNtX2Fzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMkMSksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvYyA9IGVzbV9kb2N1bWVudCgpO1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLm9sZHRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2UgPSAwO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZUNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB0aGlzLmluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbENsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5yZWZNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZnJvbnRNYXR0ZXIpIHtcbiAgICAgICAgICAgIGJsb2NrSGFuZGxlcnMuZnJvbnRNYXR0ZXIgPSBmcm9udE1hdHRlcjtcbiAgICAgICAgICAgIGJsb2NrU3RhcnRzLnVuc2hpZnQoZnJvbnRNYXR0ZXIkMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIgPSBuZXcgSW5saW5lUGFyc2VyKHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIFBhcnNlci5wcm90b3R5cGUuYWR2YW5jZU9mZnNldCA9IGZ1bmN0aW9uIChjb3VudCwgY29sdW1ucykge1xuICAgICAgICBpZiAoY29sdW1ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gdGhpcy5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIGNoYXJzVG9UYWIsIGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKGNvdW50ID4gMCAmJiAoYyA9IGN1cnJlbnRMaW5lW3RoaXMub2Zmc2V0XSkpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIGNoYXJzVG9UYWIgPSA0IC0gKHRoaXMuY29sdW1uICUgNCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGNoYXJzVG9UYWIgPiBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNUb0FkdmFuY2UgPSBjaGFyc1RvVGFiID4gY291bnQgPyBjb3VudCA6IGNoYXJzVG9UYWI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBjaGFyc1RvVGFiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IDE7IC8vIGFzc3VtZSBhc2NpaTsgYmxvY2sgc3RhcnRzIGFyZSBhc2NpaVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuYWR2YW5jZU5leHROb25zcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLm5leHROb25zcGFjZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSB0aGlzLm5leHROb25zcGFjZUNvbHVtbjtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5maW5kTmV4dE5vbnNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudExpbmUgPSB0aGlzLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgaSA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgY29scyA9IHRoaXMuY29sdW1uO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKChjID0gY3VycmVudExpbmUuY2hhckF0KGkpKSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29scysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29scyArPSA0IC0gKGNvbHMgJSA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmxhbmsgPSBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJyB8fCBjID09PSAnJztcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2UgPSBpO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZUNvbHVtbiA9IGNvbHM7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW4gLSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdGhpcy5pbmRlbnRlZCA9IHRoaXMuaW5kZW50ID49IENPREVfSU5ERU5UO1xuICAgIH07XG4gICAgLy8gQWRkIGEgbGluZSB0byB0aGUgYmxvY2sgYXQgdGhlIHRpcC4gIFdlIGFzc3VtZSB0aGUgdGlwXG4gICAgLy8gY2FuIGFjY2VwdCBsaW5lcyAtLSB0aGF0IGNoZWNrIHNob3VsZCBiZSBkb25lIGJlZm9yZSBjYWxsaW5nIHRoaXMuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5hZGRMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYikge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMTsgLy8gc2tpcCBvdmVyIHRhYlxuICAgICAgICAgICAgLy8gYWRkIHNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICAgICAgICB2YXIgY2hhcnNUb1RhYiA9IDQgLSAodGhpcy5jb2x1bW4gJSA0KTtcbiAgICAgICAgICAgIHRoaXMudGlwLnN0cmluZ0NvbnRlbnQgKz0gcmVwZWF0KCcgJywgY2hhcnNUb1RhYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGlwLmxpbmVPZmZzZXRzKSB7XG4gICAgICAgICAgICB0aGlzLnRpcC5saW5lT2Zmc2V0cy5wdXNoKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGlwLmxpbmVPZmZzZXRzID0gW3RoaXMub2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpcC5zdHJpbmdDb250ZW50ICs9IHRoaXMuY3VycmVudExpbmUuc2xpY2UodGhpcy5vZmZzZXQpICsgXCJcXG5cIjtcbiAgICB9O1xuICAgIC8vIEFkZCBibG9jayBvZiB0eXBlIHRhZyBhcyBhIGNoaWxkIG9mIHRoZSB0aXAuICBJZiB0aGUgdGlwIGNhbid0XG4gICAgLy8gYWNjZXB0IGNoaWxkcmVuLCBjbG9zZSBhbmQgZmluYWxpemUgaXQgYW5kIHRyeSBpdHMgcGFyZW50LFxuICAgIC8vIGFuZCBzbyBvbiB0aWwgd2UgZmluZCBhIGJsb2NrIHRoYXQgY2FuIGFjY2VwdCBjaGlsZHJlbi5cbiAgICBQYXJzZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKHRhZywgb2Zmc2V0KSB7XG4gICAgICAgIHdoaWxlICghYmxvY2tIYW5kbGVyc1t0aGlzLnRpcC50eXBlXS5jYW5Db250YWluKHRhZykpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUodGhpcy50aXAsIHRoaXMubGluZU51bWJlciAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBvZmZzZXQgKyAxOyAvLyBvZmZzZXQgMCA9IGNvbHVtbiAxXG4gICAgICAgIHZhciBuZXdCbG9jayA9IGNyZWF0ZU5vZGUodGFnLCBbXG4gICAgICAgICAgICBbdGhpcy5saW5lTnVtYmVyLCBjb2x1bW5OdW1iZXJdLFxuICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICBdKTtcbiAgICAgICAgbmV3QmxvY2suc3RyaW5nQ29udGVudCA9ICcnO1xuICAgICAgICB0aGlzLnRpcC5hcHBlbmRDaGlsZChuZXdCbG9jayk7XG4gICAgICAgIHRoaXMudGlwID0gbmV3QmxvY2s7XG4gICAgICAgIHJldHVybiBuZXdCbG9jaztcbiAgICB9O1xuICAgIC8vIEZpbmFsaXplIGFuZCBjbG9zZSBhbnkgdW5tYXRjaGVkIGJsb2Nrcy5cbiAgICBQYXJzZXIucHJvdG90eXBlLmNsb3NlVW5tYXRjaGVkQmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsQ2xvc2VkKSB7XG4gICAgICAgICAgICAvLyBmaW5hbGl6ZSBhbnkgYmxvY2tzIG5vdCBtYXRjaGVkXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5vbGR0aXAgIT09IHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSB0aGlzLm9sZHRpcC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLm9sZHRpcCwgdGhpcy5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGR0aXAgPSBwYXJlbnRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWxsQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRmluYWxpemUgYSBibG9jay4gIENsb3NlIGl0IGFuZCBkbyBhbnkgbmVjZXNzYXJ5IHBvc3Rwcm9jZXNzaW5nLFxuICAgIC8vIGUuZy4gY3JlYXRpbmcgc3RyaW5nQ29udGVudCBmcm9tIHN0cmluZ3MsIHNldHRpbmcgdGhlICd0aWdodCdcbiAgICAvLyBvciAnbG9vc2UnIHN0YXR1cyBvZiBhIGxpc3QsIGFuZCBwYXJzaW5nIHRoZSBiZWdpbm5pbmdzXG4gICAgLy8gb2YgcGFyYWdyYXBocyBmb3IgcmVmZXJlbmNlIGRlZmluaXRpb25zLiAgUmVzZXQgdGhlIHRpcCB0byB0aGVcbiAgICAvLyBwYXJlbnQgb2YgdGhlIGNsb3NlZCBibG9jay5cbiAgICBQYXJzZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGJsb2NrLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgIHZhciBhYm92ZSA9IGJsb2NrLnBhcmVudDtcbiAgICAgICAgYmxvY2sub3BlbiA9IGZhbHNlO1xuICAgICAgICBibG9jay5zb3VyY2Vwb3NbMV0gPSBbbGluZU51bWJlciwgdGhpcy5sYXN0TGluZUxlbmd0aF07XG4gICAgICAgIGJsb2NrSGFuZGxlcnNbYmxvY2sudHlwZV0uZmluYWxpemUodGhpcywgYmxvY2spO1xuICAgICAgICB0aGlzLnRpcCA9IGFib3ZlO1xuICAgIH07XG4gICAgLy8gV2FsayB0aHJvdWdoIGEgYmxvY2sgJiBjaGlsZHJlbiByZWN1cnNpdmVseSwgcGFyc2luZyBzdHJpbmcgY29udGVudFxuICAgIC8vIGludG8gaW5saW5lIGNvbnRlbnQgd2hlcmUgYXBwcm9wcmlhdGUuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wcm9jZXNzSW5saW5lcyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgZXZlbnQ7XG4gICAgICAgIHZhciBjdXN0b21QYXJzZXIgPSB0aGlzLm9wdGlvbnMuY3VzdG9tUGFyc2VyO1xuICAgICAgICB2YXIgd2Fsa2VyID0gYmxvY2sud2Fsa2VyKCk7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnJlZk1hcCA9IHRoaXMucmVmTWFwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5yZWZMaW5rQ2FuZGlkYXRlTWFwID0gdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5yZWZEZWZDYW5kaWRhdGVNYXAgPSB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcDtcbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50Lm5vZGUsIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmc7XG4gICAgICAgICAgICB2YXIgdCA9IG5vZGUudHlwZTtcbiAgICAgICAgICAgIGlmIChjdXN0b21QYXJzZXIgJiYgY3VzdG9tUGFyc2VyW3RdKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUGFyc2VyW3RdKG5vZGUsIHsgZW50ZXJpbmc6IGVudGVyaW5nLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVudGVyaW5nICYmXG4gICAgICAgICAgICAgICAgKHQgPT09ICdwYXJhZ3JhcGgnIHx8XG4gICAgICAgICAgICAgICAgICAgIHQgPT09ICdoZWFkaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAodCA9PT0gJ3RhYmxlQ2VsbCcgJiYgIW5vZGUuaWdub3JlZCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIucGFyc2Uobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEFuYWx5emUgYSBsaW5lIG9mIHRleHQgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgYXBwcm9wcmlhdGVseS5cbiAgICAvLyBXZSBwYXJzZSBtYXJrZG93biB0ZXh0IGJ5IGNhbGxpbmcgdGhpcyBvbiBlYWNoIGxpbmUgb2YgaW5wdXQsXG4gICAgLy8gdGhlbiBmaW5hbGl6aW5nIHRoZSBkb2N1bWVudC5cbiAgICBQYXJzZXIucHJvdG90eXBlLmluY29ycG9yYXRlTGluZSA9IGZ1bmN0aW9uIChsbikge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMub2xkdGlwID0gdGhpcy50aXA7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLmJsYW5rID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyICs9IDE7XG4gICAgICAgIC8vIHJlcGxhY2UgTlVMIGNoYXJhY3RlcnMgZm9yIHNlY3VyaXR5XG4gICAgICAgIGlmIChsbi5pbmRleE9mKCdcXHUwMDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICBsbiA9IGxuLnJlcGxhY2UoL1xcMC9nLCAnXFx1RkZGRCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSBsbjtcbiAgICAgICAgLy8gRm9yIGVhY2ggY29udGFpbmluZyBibG9jaywgdHJ5IHRvIHBhcnNlIHRoZSBhc3NvY2lhdGVkIGxpbmUgc3RhcnQuXG4gICAgICAgIC8vIEJhaWwgb3V0IG9uIGZhaWx1cmU6IGNvbnRhaW5lciB3aWxsIHBvaW50IHRvIHRoZSBsYXN0IG1hdGNoaW5nIGJsb2NrLlxuICAgICAgICAvLyBTZXQgYWxsTWF0Y2hlZCB0byBmYWxzZSBpZiBub3QgYWxsIGNvbnRhaW5lcnMgbWF0Y2guXG4gICAgICAgIHZhciBhbGxNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKChsYXN0Q2hpbGQgPSBjb250YWluZXIubGFzdENoaWxkKSAmJiBsYXN0Q2hpbGQub3Blbikge1xuICAgICAgICAgICAgY29udGFpbmVyID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5maW5kTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGJsb2NrSGFuZGxlcnNbY29udGFpbmVyLnR5cGVdWydjb250aW51ZSddKHRoaXMsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogR28gKi86IC8vIHdlJ3ZlIG1hdGNoZWQsIGtlZXAgZ29pbmdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFN0b3AgKi86IC8vIHdlJ3ZlIGZhaWxlZCB0byBtYXRjaCBhIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGFsbE1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIEZpbmlzaGVkICovOiAvLyB3ZSd2ZSBoaXQgZW5kIG9mIGxpbmUgZm9yIGZlbmNlZCBjb2RlIGNsb3NlIGFuZCBjYW4gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSBsbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRpbnVlIHJldHVybmVkIGlsbGVnYWwgdmFsdWUsIG11c3QgYmUgMCwgMSwgb3IgMicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudDsgLy8gYmFjayB1cCB0byBsYXN0IG1hdGNoaW5nIGJsb2NrXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxDbG9zZWQgPSBjb250YWluZXIgPT09IHRoaXMub2xkdGlwO1xuICAgICAgICB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB2YXIgbWF0Y2hlZExlYWYgPSBjb250YWluZXIudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiYgYmxvY2tIYW5kbGVyc1tjb250YWluZXIudHlwZV0uYWNjZXB0c0xpbmVzO1xuICAgICAgICB2YXIgYmxvY2tTdGFydHNMZW4gPSBibG9ja1N0YXJ0cy5sZW5ndGg7XG4gICAgICAgIC8vIFVubGVzcyBsYXN0IG1hdGNoZWQgY29udGFpbmVyIGlzIGEgY29kZSBibG9jaywgdHJ5IG5ldyBjb250YWluZXIgc3RhcnRzLFxuICAgICAgICAvLyBhZGRpbmcgY2hpbGRyZW4gdG8gdGhlIGxhc3QgbWF0Y2hlZCBjb250YWluZXI6XG4gICAgICAgIHdoaWxlICghbWF0Y2hlZExlYWYpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZE5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGxpdHRsZSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZScgJiZcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHlwZSAhPT0gJ3RhYmxlQm9keScgJiZcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5pbmRlbnRlZCAmJlxuICAgICAgICAgICAgICAgICFyZU1heWJlU3BlY2lhbC50ZXN0KGxuLnNsaWNlKHRoaXMubmV4dE5vbnNwYWNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYmxvY2tTdGFydHNMZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gYmxvY2tTdGFydHNbaV0odGhpcywgY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzID09PSAxIC8qIENvbnRhaW5lciAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLnRpcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcyA9PT0gMiAvKiBMZWFmICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMudGlwO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkTGVhZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBibG9ja1N0YXJ0c0xlbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgbWF0Y2hlZFxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoYXQgcmVtYWlucyBhdCB0aGUgb2Zmc2V0IGlzIGEgdGV4dCBsaW5lLiAgQWRkIHRoZSB0ZXh0IHRvIHRoZVxuICAgICAgICAvLyBhcHByb3ByaWF0ZSBjb250YWluZXIuXG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGZvciBhIGxhenkgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbjpcbiAgICAgICAgaWYgKCF0aGlzLmFsbENsb3NlZCAmJiAhdGhpcy5ibGFuayAmJiB0aGlzLnRpcC50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgLy8gbGF6eSBwYXJhZ3JhcGggY29udGludWF0aW9uXG4gICAgICAgICAgICB0aGlzLmFkZExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdCBhIGxhenkgY29udGludWF0aW9uXG4gICAgICAgICAgICAvLyBmaW5hbGl6ZSBhbnkgYmxvY2tzIG5vdCBtYXRjaGVkXG4gICAgICAgICAgICB0aGlzLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ibGFuayAmJiBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmxhc3RDaGlsZC5sYXN0TGluZUJsYW5rID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gY29udGFpbmVyLnR5cGU7XG4gICAgICAgICAgICAvLyBCbG9jayBxdW90ZSBsaW5lcyBhcmUgbmV2ZXIgYmxhbmsgYXMgdGhleSBzdGFydCB3aXRoID5cbiAgICAgICAgICAgIC8vIGFuZCB3ZSBkb24ndCBjb3VudCBibGFua3MgaW4gZmVuY2VkIGNvZGUgZm9yIHB1cnBvc2VzIG9mIHRpZ2h0L2xvb3NlXG4gICAgICAgICAgICAvLyBsaXN0cyBvciBicmVha2luZyBvdXQgb2YgbGlzdHMuIFdlIGFsc28gZG9uJ3Qgc2V0IF9sYXN0TGluZUJsYW5rXG4gICAgICAgICAgICAvLyBvbiBhbiBlbXB0eSBsaXN0IGl0ZW0sIG9yIGlmIHdlIGp1c3QgY2xvc2VkIGEgZmVuY2VkIGJsb2NrLlxuICAgICAgICAgICAgdmFyIGxhc3RMaW5lQmxhbmsgPSB0aGlzLmJsYW5rICYmXG4gICAgICAgICAgICAgICAgISh0ID09PSAnYmxvY2tRdW90ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29kZUJsb2NrKGNvbnRhaW5lcikgJiYgY29udGFpbmVyLmlzRmVuY2VkKSB8fFxuICAgICAgICAgICAgICAgICAgICAodCA9PT0gJ2l0ZW0nICYmICFjb250YWluZXIuZmlyc3RDaGlsZCAmJiBjb250YWluZXIuc291cmNlcG9zWzBdWzBdID09PSB0aGlzLmxpbmVOdW1iZXIpKTtcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBsYXN0TGluZUJsYW5rIHVwIHRocm91Z2ggcGFyZW50czpcbiAgICAgICAgICAgIHZhciBjb250ID0gY29udGFpbmVyO1xuICAgICAgICAgICAgd2hpbGUgKGNvbnQpIHtcbiAgICAgICAgICAgICAgICBjb250Lmxhc3RMaW5lQmxhbmsgPSBsYXN0TGluZUJsYW5rO1xuICAgICAgICAgICAgICAgIGNvbnQgPSBjb250LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhbmRsZXJzW3RdLmFjY2VwdHNMaW5lcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZSgpO1xuICAgICAgICAgICAgICAgIC8vIGlmIEh0bWxCbG9jaywgY2hlY2sgZm9yIGVuZCBjb25kaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoaXNIdG1sQmxvY2soY29udGFpbmVyKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuaHRtbEJsb2NrVHlwZSA+PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5odG1sQmxvY2tUeXBlIDw9IDUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVIdG1sQmxvY2tDbG9zZVtjb250YWluZXIuaHRtbEJsb2NrVHlwZV0udGVzdCh0aGlzLmN1cnJlbnRMaW5lLnNsaWNlKHRoaXMub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IGxuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShjb250YWluZXIsIHRoaXMubGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vZmZzZXQgPCBsbi5sZW5ndGggJiYgIXRoaXMuYmxhbmspIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgcGFyYWdyYXBoIGNvbnRhaW5lciBmb3IgbGluZVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuYWRkQ2hpbGQoJ3BhcmFncmFwaCcsIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gbG4ubGVuZ3RoO1xuICAgIH07XG4gICAgLy8gVGhlIG1haW4gcGFyc2luZyBmdW5jdGlvbi4gIFJldHVybnMgYSBwYXJzZWQgZG9jdW1lbnQgQVNULlxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoaW5wdXQsIGxpbmVUZXh0cykge1xuICAgICAgICB0aGlzLmRvYyA9IGVzbV9kb2N1bWVudCgpO1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB2YXIgbGluZXMgPSBpbnB1dC5zcGxpdChyZUxpbmVFbmRpbmckMSk7XG4gICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lVGV4dHMgPyBsaW5lVGV4dHMgOiBsaW5lcztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyUmVmTWFwcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpID09PSBDX05FV0xJTkUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBsYXN0IGJsYW5rIGxpbmUgY3JlYXRlZCBieSBmaW5hbCBuZXdsaW5lXG4gICAgICAgICAgICBsZW4gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluY29ycG9yYXRlTGluZShsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMudGlwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMudGlwLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc0lubGluZXModGhpcy5kb2MpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2M7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnRpYWxQYXJzZVN0YXJ0ID0gZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGxpbmVzKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZXNtX2RvY3VtZW50KCk7XG4gICAgICAgIHRoaXMudGlwID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IGxpbmVOdW1iZXIgLSAxO1xuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB2YXIgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluY29ycG9yYXRlTGluZShsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJ0aWFsUGFyc2VFeHRlbmRzID0gZnVuY3Rpb24gKGxpbmVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb3Jwb3JhdGVMaW5lKGxpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJ0aWFsUGFyc2VGaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnRpcCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLnRpcCwgdGhpcy5saW5lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NJbmxpbmVzKHRoaXMuZG9jKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuc2V0UmVmTWFwcyA9IGZ1bmN0aW9uIChyZWZNYXAsIHJlZkxpbmtDYW5kaWRhdGVNYXAsIHJlZkRlZkNhbmRpZGF0ZU1hcCkge1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHJlZk1hcDtcbiAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwID0gcmVmTGlua0NhbmRpZGF0ZU1hcDtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSByZWZEZWZDYW5kaWRhdGVNYXA7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmNsZWFyUmVmTWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgW3RoaXMucmVmTWFwLCB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAsIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwXS5mb3JFYWNoKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIGNsZWFyT2JqKG1hcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKSk7XG5mdW5jdGlvbiBjb21wYXJlUG9zKHAxLCBwMikge1xuICAgIGlmIChwMVswXSA8IHAyWzBdKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAocDFbMF0gPiBwMlswXSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIGlmIChwMVsxXSA8IHAyWzFdKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAocDFbMV0gPiBwMlsxXSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEVRICovO1xufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlQW5kUG9zKF9hLCBwb3MpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBfYVswXSwgZW5kUG9zID0gX2FbMV07XG4gICAgaWYgKGNvbXBhcmVQb3MoZW5kUG9zLCBwb3MpID09PSAxIC8qIExUICovKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZVBvcyhzdGFydFBvcywgcG9zKSA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBFUSAqLztcbn1cbmZ1bmN0aW9uIHJlbW92ZU5leHRVbnRpbChub2RlLCBsYXN0KSB7XG4gICAgaWYgKG5vZGUucGFyZW50ICE9PSBsYXN0LnBhcmVudCB8fCBub2RlID09PSBsYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBub2RlLm5leHQ7XG4gICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPT0gbGFzdCkge1xuICAgICAgICB2YXIgdGVtcCA9IG5leHQubmV4dDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFsncGFyZW50JywgJ3ByZXYnLCAnbmV4dCddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAobmV4dFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGVCeUlkKG5leHRbdHlwZV0uaWQpO1xuICAgICAgICAgICAgICAgIG5leHRbdHlwZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQgPSB0ZW1wO1xuICAgIH1cbiAgICBub2RlLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgaWYgKGxhc3QubmV4dCkge1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnBhcmVudC5sYXN0Q2hpbGQgPSBub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkTm9kZXMocGFyZW50KSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIGN1cnIgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY3Vycikge1xuICAgICAgICBub2Rlcy5wdXNoKGN1cnIpO1xuICAgICAgICBjdXJyID0gY3Vyci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBpbnNlcnROb2Rlc0JlZm9yZSh0YXJnZXQsIG5vZGVzKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBub2Rlc18xID0gbm9kZXM7IF9pIDwgbm9kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc18xW19pXTtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVwZW5kQ2hpbGROb2RlcyhwYXJlbnQsIG5vZGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHBhcmVudC5wcmVwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZU5leHRMaW5lTnVtYmVycyhiYXNlLCBkaWZmKSB7XG4gICAgaWYgKCFiYXNlIHx8ICFiYXNlLnBhcmVudCB8fCBkaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHdhbGtlciA9IGJhc2UucGFyZW50LndhbGtlcigpO1xuICAgIHdhbGtlci5yZXN1bWVBdChiYXNlLCB0cnVlKTtcbiAgICB2YXIgZXZlbnQ7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBub2RlLnNvdXJjZXBvc1swXVswXSArPSBkaWZmO1xuICAgICAgICAgICAgbm9kZS5zb3VyY2Vwb3NbMV1bMF0gKz0gZGlmZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZUFuZExpbmUoX2EsIGxpbmUpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBfYVswXSwgZW5kUG9zID0gX2FbMV07XG4gICAgaWYgKGVuZFBvc1swXSA8IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChzdGFydFBvc1swXSA+IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBFUSAqLztcbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZE5vZGVBdExpbmUocGFyZW50LCBsaW5lKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmVSYW5nZUFuZExpbmUobm9kZS5zb3VyY2Vwb3MsIGxpbmUpO1xuICAgICAgICBpZiAoY29tcCA9PT0gMCAvKiBFUSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgICAgICAvLyBUbyBjb25zaWRlciB0aGF0IHRvcCBsaW5lIGlzIGJsYW5rIGxpbmVcbiAgICAgICAgICAgIHJldHVybiBub2RlLnByZXYgfHwgbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Lmxhc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGxhc3RMZWFmTm9kZShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzYW1lTGluZVRvcEFuY2VzdG9yKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5wYXJlbnQgJiZcbiAgICAgICAgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2RvY3VtZW50JyAmJlxuICAgICAgICBub2RlLnBhcmVudC5zb3VyY2Vwb3NbMF1bMF0gPT09IG5vZGUuc291cmNlcG9zWzBdWzBdKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5kRmlyc3ROb2RlQXRMaW5lKHBhcmVudCwgbGluZSkge1xuICAgIHZhciBub2RlID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcGFyZVJhbmdlQW5kTGluZShub2RlLnNvdXJjZXBvcywgbGluZSk7XG4gICAgICAgIGlmIChjb21wID09PSAwIC8qIEVRICovKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5zb3VyY2Vwb3NbMF1bMF0gPT09IGxpbmUgfHwgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXAgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldikge1xuICAgICAgICByZXR1cm4gc2FtZUxpbmVUb3BBbmNlc3RvcihsYXN0TGVhZk5vZGUocHJldikpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlQXRQb3NpdGlvbihwYXJlbnQsIHBvcykge1xuICAgIHZhciBub2RlID0gcGFyZW50O1xuICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmVSYW5nZUFuZFBvcyhub2RlLnNvdXJjZXBvcywgcG9zKTtcbiAgICAgICAgaWYgKGNvbXAgPT09IDAgLyogRVEgKi8pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcCA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubmV4dCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZmluZE5vZGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGdldE5vZGVCeUlkKGlkKSB8fCBudWxsO1xufVxuZnVuY3Rpb24gaW52b2tlTmV4dFVudGlsKGNhbGxiYWNrLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVuZCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzdGFydCkge1xuICAgICAgICB2YXIgd2Fsa2VyID0gc3RhcnQud2Fsa2VyKCk7XG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBzdGFydCAhPT0gZW5kKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzdGFydCk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmV4dC5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1VubGlua2VkKGlkKSB7XG4gICAgdmFyIG5vZGUgPSBmaW5kTm9kZUJ5SWQoaWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZS50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgaWYgKCFub2RlLnBhcmVudCAmJiAhbm9kZS5wcmV2ICYmICFub2RlLm5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxudmFyIHJlTGluZUVuZGluZyA9IC9cXHJcXG58XFxufFxcci87XG5mdW5jdGlvbiBjYW5CZUNvbnRpbnVlZExpc3RJdGVtKGxpbmVUZXh0KSB7XG4gICAgdmFyIHNwYWNlTWF0Y2ggPSBsaW5lVGV4dC5tYXRjaCgvXlsgXFx0XSsvKTtcbiAgICBpZiAoc3BhY2VNYXRjaCAmJiAoc3BhY2VNYXRjaFswXS5sZW5ndGggPj0gMiB8fCAvXFx0Ly50ZXN0KHNwYWNlTWF0Y2hbMF0pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxlZnRUcmltbWVkID0gc3BhY2VNYXRjaCA/IGxpbmVUZXh0LnNsaWNlKHNwYWNlTWF0Y2gubGVuZ3RoKSA6IGxpbmVUZXh0O1xuICAgIHJldHVybiByZUJ1bGxldExpc3RNYXJrZXIudGVzdChsZWZ0VHJpbW1lZCkgfHwgcmVPcmRlcmVkTGlzdE1hcmtlci50ZXN0KGxlZnRUcmltbWVkKTtcbn1cbmZ1bmN0aW9uIGNhbkJlQ29udGludWVkVGFibGVCb2R5KGxpbmVUZXh0KSB7XG4gICAgcmV0dXJuICFpc0JsYW5rKGxpbmVUZXh0KSAmJiBsaW5lVGV4dC5pbmRleE9mKCd8JykgIT09IC0xO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmRGVmU3RhdGUobm9kZSkge1xuICAgIHZhciBpZCA9IG5vZGUuaWQsIHRpdGxlID0gbm9kZS50aXRsZSwgc291cmNlcG9zID0gbm9kZS5zb3VyY2Vwb3MsIGRlc3QgPSBub2RlLmRlc3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIHNvdXJjZXBvczogc291cmNlcG9zLFxuICAgICAgICB1bmxpbmtlZDogZmFsc2UsXG4gICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0LFxuICAgIH07XG59XG52YXIgVG9hc3RNYXJrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0TWFyayhjb250ZW50cywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uID0gISEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGFyc2VyLnNldFJlZk1hcHModGhpcy5yZWZNYXAsIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcCA9IHsgY2hhbmdlOiBbXSB9O1xuICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzIHx8ICcnO1xuICAgICAgICB0aGlzLmxpbmVUZXh0cyA9IGNvbnRlbnRzLnNwbGl0KHJlTGluZUVuZGluZyk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucGFyc2VyLnBhcnNlKGNvbnRlbnRzLCB0aGlzLmxpbmVUZXh0cyk7XG4gICAgfVxuICAgIFRvYXN0TWFyay5wcm90b3R5cGUudXBkYXRlTGluZVRleHRzID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBlbmRQb3MsIG5ld1RleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgc3RhcnRMaW5lID0gc3RhcnRQb3NbMF0sIHN0YXJ0Q29sID0gc3RhcnRQb3NbMV07XG4gICAgICAgIHZhciBlbmRMaW5lID0gZW5kUG9zWzBdLCBlbmRDb2wgPSBlbmRQb3NbMV07XG4gICAgICAgIHZhciBuZXdMaW5lcyA9IG5ld1RleHQuc3BsaXQocmVMaW5lRW5kaW5nKTtcbiAgICAgICAgdmFyIG5ld0xpbmVMZW4gPSBuZXdMaW5lcy5sZW5ndGg7XG4gICAgICAgIHZhciBzdGFydExpbmVUZXh0ID0gdGhpcy5saW5lVGV4dHNbc3RhcnRMaW5lIC0gMV07XG4gICAgICAgIHZhciBlbmRMaW5lVGV4dCA9IHRoaXMubGluZVRleHRzW2VuZExpbmUgLSAxXTtcbiAgICAgICAgbmV3TGluZXNbMF0gPSBzdGFydExpbmVUZXh0LnNsaWNlKDAsIHN0YXJ0Q29sIC0gMSkgKyBuZXdMaW5lc1swXTtcbiAgICAgICAgbmV3TGluZXNbbmV3TGluZUxlbiAtIDFdID0gbmV3TGluZXNbbmV3TGluZUxlbiAtIDFdICsgZW5kTGluZVRleHQuc2xpY2UoZW5kQ29sIC0gMSk7XG4gICAgICAgIHZhciByZW1vdmVkTGluZUxlbiA9IGVuZExpbmUgLSBzdGFydExpbmUgKyAxO1xuICAgICAgICAoX2EgPSB0aGlzLmxpbmVUZXh0cykuc3BsaWNlLmFwcGx5KF9hLCBlc21fc3ByZWFkQXJyYXkoW3N0YXJ0TGluZSAtIDEsIHJlbW92ZWRMaW5lTGVuXSwgbmV3TGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVMZW4gLSByZW1vdmVkTGluZUxlbjtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUudXBkYXRlUm9vdE5vZGVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVRleHRzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmxpbmVUZXh0c1swXSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5sYXN0TGluZUJsYW5rID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5zb3VyY2Vwb3MgPSBbXG4gICAgICAgICAgICAgICAgWzEsIDFdLFxuICAgICAgICAgICAgICAgIFsxLCAwXSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucm9vdC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5sYXN0TGluZUJsYW5rID0gdGhpcy5yb290Lmxhc3RDaGlsZC5sYXN0TGluZUJsYW5rO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSB0aGlzLmxpbmVUZXh0cztcbiAgICAgICAgdmFyIGlkeCA9IGxpbmVUZXh0cy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobGluZVRleHRzW2lkeF0gPT09ICcnKSB7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVRleHRzLmxlbmd0aCAtIDIgPiBpZHgpIHtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdC5zb3VyY2Vwb3NbMV0gPSBbaWR4ICsgMSwgbGluZVRleHRzW2lkeF0ubGVuZ3RoXTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVwbGFjZVJhbmdlTm9kZXMgPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCBuZXdOb2Rlcykge1xuICAgICAgICBpZiAoIXN0YXJ0Tm9kZSkge1xuICAgICAgICAgICAgaWYgKGVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnROb2Rlc0JlZm9yZShlbmROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZUJ5SWQoZW5kTm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgZW5kTm9kZS51bmxpbmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXBlbmRDaGlsZE5vZGVzKHRoaXMucm9vdCwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zZXJ0Tm9kZXNCZWZvcmUoc3RhcnROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICByZW1vdmVOZXh0VW50aWwoc3RhcnROb2RlLCBlbmROb2RlKTtcbiAgICAgICAgICAgIFtzdGFydE5vZGUuaWQsIGVuZE5vZGUuaWRdLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByZW1vdmVOb2RlQnlJZChpZCk7IH0pO1xuICAgICAgICAgICAgc3RhcnROb2RlLnVubGluaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldE5vZGVSYW5nZSA9IGZ1bmN0aW9uIChzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICAgIHZhciBzdGFydE5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgc3RhcnRQb3NbMF0pO1xuICAgICAgICB2YXIgZW5kTm9kZSA9IGZpbmRDaGlsZE5vZGVBdExpbmUodGhpcy5yb290LCBlbmRQb3NbMF0pO1xuICAgICAgICAvLyBleHRlbmQgbm9kZSByYW5nZSB0byBpbmNsdWRlIGEgZm9sbG93aW5nIGJsb2NrIHdoaWNoIGRvZXNuJ3QgaGF2ZSBwcmVjZWRpbmcgYmxhbmsgbGluZVxuICAgICAgICBpZiAoZW5kTm9kZSAmJiBlbmROb2RlLm5leHQgJiYgZW5kUG9zWzBdICsgMSA9PT0gZW5kTm9kZS5uZXh0LnNvdXJjZXBvc1swXVswXSkge1xuICAgICAgICAgICAgZW5kTm9kZSA9IGVuZE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXJ0Tm9kZSwgZW5kTm9kZV07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIocGFyYW0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZXh0ZW5kRW5kTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxpbmVUZXh0c1tsaW5lXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucGFyc2VSYW5nZSA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICAgICAgICAvLyBleHRlbmRzIHN0YXJ0aW5nIHJhbmdlIGlmIHRoZSBmaXJzdCBub2RlIGNhbiBiZSBhIGNvbnRpbnVlZCBsaXN0IGl0ZW1cbiAgICAgICAgaWYgKHN0YXJ0Tm9kZSAmJlxuICAgICAgICAgICAgc3RhcnROb2RlLnByZXYgJiZcbiAgICAgICAgICAgICgoaXNMaXN0KHN0YXJ0Tm9kZS5wcmV2KSAmJiBjYW5CZUNvbnRpbnVlZExpc3RJdGVtKHRoaXMubGluZVRleHRzW3N0YXJ0TGluZSAtIDFdKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNUYWJsZShzdGFydE5vZGUucHJldikgJiYgY2FuQmVDb250aW51ZWRUYWJsZUJvZHkodGhpcy5saW5lVGV4dHNbc3RhcnRMaW5lIC0gMV0pKSkpIHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZS5wcmV2O1xuICAgICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnROb2RlLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRpdGVkTGluZXMgPSB0aGlzLmxpbmVUZXh0cy5zbGljZShzdGFydExpbmUgLSAxLCBlbmRMaW5lKTtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnBhcnNlci5wYXJ0aWFsUGFyc2VTdGFydChzdGFydExpbmUsIGVkaXRlZExpbmVzKTtcbiAgICAgICAgLy8gZXh0ZW5kcyBlbmRpbmcgcmFuZ2UgaWYgdGhlIGZvbGxvd2luZyBub2RlIGNhbiBiZSBhIGZlbmNlZCBjb2RlIGJsb2NrIG9yIGEgY29udGludWVkIGxpc3QgaXRlbVxuICAgICAgICB2YXIgbmV4dE5vZGUgPSBlbmROb2RlID8gZW5kTm9kZS5uZXh0IDogdGhpcy5yb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBsYXN0Q2hpbGQgPSByb290Lmxhc3RDaGlsZDtcbiAgICAgICAgdmFyIGlzT3BlbmVkTGFzdENoaWxkQ29kZUJsb2NrID0gbGFzdENoaWxkICYmIGlzQ29kZUJsb2NrKGxhc3RDaGlsZCkgJiYgbGFzdENoaWxkLm9wZW47XG4gICAgICAgIHZhciBpc09wZW5lZExhc3RDaGlsZEN1c3RvbUJsb2NrID0gbGFzdENoaWxkICYmIGlzQ3VzdG9tQmxvY2sobGFzdENoaWxkKSAmJiBsYXN0Q2hpbGQub3BlbjtcbiAgICAgICAgdmFyIGlzTGFzdENoaWxkTGlzdCA9IGxhc3RDaGlsZCAmJiBpc0xpc3QobGFzdENoaWxkKTtcbiAgICAgICAgd2hpbGUgKCgoaXNPcGVuZWRMYXN0Q2hpbGRDb2RlQmxvY2sgfHwgaXNPcGVuZWRMYXN0Q2hpbGRDdXN0b21CbG9jaykgJiYgbmV4dE5vZGUpIHx8XG4gICAgICAgICAgICAoaXNMYXN0Q2hpbGRMaXN0ICYmIG5leHROb2RlICYmIChuZXh0Tm9kZS50eXBlID09PSAnbGlzdCcgfHwgbmV4dE5vZGUuc291cmNlcG9zWzBdWzFdID49IDIpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZExpbmUgPSB0aGlzLmV4dGVuZEVuZExpbmUobmV4dE5vZGUuc291cmNlcG9zWzFdWzBdKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLnBhcnRpYWxQYXJzZUV4dGVuZHModGhpcy5saW5lVGV4dHMuc2xpY2UoZW5kTGluZSwgbmV3RW5kTGluZSkpO1xuICAgICAgICAgICAgaWYgKCFzdGFydE5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBlbmROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTm9kZSA9IG5leHROb2RlO1xuICAgICAgICAgICAgZW5kTGluZSA9IG5ld0VuZExpbmU7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZXIucGFydGlhbFBhcnNlRmluaXNoKCk7XG4gICAgICAgIHZhciBuZXdOb2RlcyA9IGdldENoaWxkTm9kZXMocm9vdCk7XG4gICAgICAgIHJldHVybiB7IG5ld05vZGVzOiBuZXdOb2RlcywgZXh0U3RhcnROb2RlOiBzdGFydE5vZGUsIGV4dEVuZE5vZGU6IGVuZE5vZGUgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0UmVtb3ZlZE5vZGVSYW5nZSA9IGZ1bmN0aW9uIChleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUpIHtcbiAgICAgICAgaWYgKCFleHRTdGFydE5vZGUgfHxcbiAgICAgICAgICAgIChleHRTdGFydE5vZGUgJiYgaXNSZWZEZWYoZXh0U3RhcnROb2RlKSkgfHxcbiAgICAgICAgICAgIChleHRFbmROb2RlICYmIGlzUmVmRGVmKGV4dEVuZE5vZGUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBbZXh0U3RhcnROb2RlLmlkLCBleHRFbmROb2RlLmlkXSxcbiAgICAgICAgICAgIGxpbmU6IFtleHRTdGFydE5vZGUuc291cmNlcG9zWzBdWzBdIC0gMSwgZXh0RW5kTm9kZS5zb3VyY2Vwb3NbMV1bMF0gLSAxXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUubWFya0RlbGV0ZWRSZWZNYXAgPSBmdW5jdGlvbiAoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIHZhciBtYXJrRGVsZXRlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmRGVmKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZEZWZTdGF0ZSA9IF90aGlzLnJlZk1hcFtub2RlLmxhYmVsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkRlZlN0YXRlICYmIG5vZGUuaWQgPT09IHJlZkRlZlN0YXRlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZEZWZTdGF0ZS51bmxpbmtlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4dFN0YXJ0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGludm9rZU5leHRVbnRpbChtYXJrRGVsZXRlZCwgZXh0U3RhcnROb2RlLnBhcmVudCwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0RW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGludm9rZU5leHRVbnRpbChtYXJrRGVsZXRlZCwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVwbGFjZVdpdGhOZXdSZWZEZWZTdGF0ZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZNYXApKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZVdpdGhfMSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmRGVmKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IG5vZGUubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZEZWZTdGF0ZSA9IF90aGlzLnJlZk1hcFtsYWJlbF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVmRGVmU3RhdGUgfHwgcmVmRGVmU3RhdGUudW5saW5rZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZk1hcFtsYWJlbF0gPSBjcmVhdGVSZWZEZWZTdGF0ZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlTmV4dFVudGlsKHJlcGxhY2VXaXRoXzEsIG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVwbGFjZVdpdGhSZWZEZWZDYW5kaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QodGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAsIGZ1bmN0aW9uIChfLCBjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBjYW5kaWRhdGUubGFiZWwsIHNvdXJjZXBvcyA9IGNhbmRpZGF0ZS5zb3VyY2Vwb3M7XG4gICAgICAgICAgICAgICAgdmFyIHJlZkRlZlN0YXRlID0gX3RoaXMucmVmTWFwW2xhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZkRlZlN0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlZkRlZlN0YXRlLnVubGlua2VkIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlZkRlZlN0YXRlLnNvdXJjZXBvc1swXVswXSA+IHNvdXJjZXBvc1swXVswXSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZNYXBbbGFiZWxdID0gY3JlYXRlUmVmRGVmU3RhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRSYW5nZVdpdGhSZWZEZWYgPSBmdW5jdGlvbiAoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmVEaWZmKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZURlZmluaXRpb24gJiYgIWlzRW1wdHlPYmoodGhpcy5yZWZNYXApKSB7XG4gICAgICAgICAgICB2YXIgcHJldk5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgc3RhcnRMaW5lIC0gMSk7XG4gICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgZW5kTGluZSArIDEpO1xuICAgICAgICAgICAgaWYgKHByZXZOb2RlICYmIGlzUmVmRGVmKHByZXZOb2RlKSAmJiBwcmV2Tm9kZSAhPT0gc3RhcnROb2RlICYmIHByZXZOb2RlICE9PSBlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnROb2RlID0gcHJldk5vZGU7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnROb2RlLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSAmJiBpc1JlZkRlZihuZXh0Tm9kZSkgJiYgbmV4dE5vZGUgIT09IHN0YXJ0Tm9kZSAmJiBuZXh0Tm9kZSAhPT0gZW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGVuZE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICBlbmRMaW5lID0gdGhpcy5leHRlbmRFbmRMaW5lKGVuZE5vZGUuc291cmNlcG9zWzFdWzBdICsgbGluZURpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhcnROb2RlLCBlbmROb2RlLCBzdGFydExpbmUsIGVuZExpbmVdO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdGFydFBvcywgZW5kUG9zLCBsaW5lRGlmZikge1xuICAgICAgICBpZiAobGluZURpZmYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbGluZURpZmYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Tm9kZVJhbmdlKHN0YXJ0UG9zLCBlbmRQb3MpO1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gcmFuZ2VbMF0sIGVuZE5vZGUgPSByYW5nZVsxXTtcbiAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHN0YXJ0Tm9kZSA/IE1hdGgubWluKHN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF0sIHN0YXJ0UG9zWzBdKSA6IHN0YXJ0UG9zWzBdO1xuICAgICAgICB2YXIgZW5kTGluZSA9IHRoaXMuZXh0ZW5kRW5kTGluZSgoZW5kTm9kZSA/IE1hdGgubWF4KGVuZE5vZGUuc291cmNlcG9zWzFdWzBdLCBlbmRQb3NbMF0pIDogZW5kUG9zWzBdKSArIGxpbmVEaWZmKTtcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gdGhpcy5wYXJzZVJhbmdlLmFwcGx5KHRoaXMsIHRoaXMuZ2V0UmFuZ2VXaXRoUmVmRGVmKHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnROb2RlLCBlbmROb2RlLCBsaW5lRGlmZikpO1xuICAgICAgICB2YXIgbmV3Tm9kZXMgPSBwYXJzZVJlc3VsdC5uZXdOb2RlcywgZXh0U3RhcnROb2RlID0gcGFyc2VSZXN1bHQuZXh0U3RhcnROb2RlLCBleHRFbmROb2RlID0gcGFyc2VSZXN1bHQuZXh0RW5kTm9kZTtcbiAgICAgICAgdmFyIHJlbW92ZWROb2RlUmFuZ2UgPSB0aGlzLmdldFJlbW92ZWROb2RlUmFuZ2UoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKTtcbiAgICAgICAgdmFyIG5leHROb2RlID0gZXh0RW5kTm9kZSA/IGV4dEVuZE5vZGUubmV4dCA6IHRoaXMucm9vdC5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtEZWxldGVkUmVmTWFwKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSYW5nZU5vZGVzKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aE5ld1JlZkRlZlN0YXRlKG5ld05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlTm9kZXMoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IG5ld05vZGVzLCByZW1vdmVkTm9kZVJhbmdlOiByZW1vdmVkTm9kZVJhbmdlLCBuZXh0Tm9kZTogbmV4dE5vZGUgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucGFyc2VSZWZMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QodGhpcy5yZWZNYXAsIGZ1bmN0aW9uIChsYWJlbCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudW5saW5rZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJlZk1hcFtsYWJlbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QoX3RoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgZnVuY3Rpb24gKF8sIGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNhbmRpZGF0ZS5ub2RlLCByZWZMYWJlbCA9IGNhbmRpZGF0ZS5yZWZMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkxhYmVsID09PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX3RoaXMucGFyc2Uobm9kZS5zb3VyY2Vwb3NbMF0sIG5vZGUuc291cmNlcG9zWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlbW92ZVVubGlua2VkQ2FuZGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApKSB7XG4gICAgICAgICAgICBbdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcF0uZm9yRWFjaChmdW5jdGlvbiAoY2FuZGlkYXRlTWFwKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZU9iamVjdChjYW5kaWRhdGVNYXAsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmxpbmtlZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYW5kaWRhdGVNYXBbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5lZGl0TWFya2Rvd24gPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcywgbmV3VGV4dCkge1xuICAgICAgICB2YXIgbGluZURpZmYgPSB0aGlzLnVwZGF0ZUxpbmVUZXh0cyhzdGFydFBvcywgZW5kUG9zLCBuZXdUZXh0KTtcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gdGhpcy5wYXJzZShzdGFydFBvcywgZW5kUG9zLCBsaW5lRGlmZik7XG4gICAgICAgIHZhciBlZGl0UmVzdWx0ID0gb21pdChwYXJzZVJlc3VsdCwgJ25leHROb2RlJyk7XG4gICAgICAgIHVwZGF0ZU5leHRMaW5lTnVtYmVycyhwYXJzZVJlc3VsdC5uZXh0Tm9kZSwgbGluZURpZmYpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJvb3ROb2RlU3RhdGUoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtlZGl0UmVzdWx0XTtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVVbmxpbmtlZENhbmRpZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aFJlZkRlZkNhbmRpZGF0ZSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcnNlUmVmTGluaygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldExpbmVUZXh0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZVRleHRzO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRSb290Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZmluZE5vZGVBdFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgbm9kZSA9IGZpbmROb2RlQXRQb3NpdGlvbih0aGlzLnJvb3QsIHBvcyk7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kRmlyc3ROb2RlQXRMaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRGaXJzdE5vZGVBdExpbmUodGhpcy5yb290LCBsaW5lKTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdO1xuICAgICAgICB2YXIgaWR4ID0gaGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kTm9kZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGZpbmROb2RlQnlJZChpZCk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlbW92ZUFsbE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUFsbE5vZGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdE1hcms7XG59KCkpO1xudmFyIGRpc2FsbG93ZWRUYWdzID0gW1xuICAgICd0aXRsZScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnc3R5bGUnLFxuICAgICd4bXAnLFxuICAgICdpZnJhbWUnLFxuICAgICdub2VtYmVkJyxcbiAgICAnbm9mcmFtZXMnLFxuICAgICdzY3JpcHQnLFxuICAgICdwbGFpbnRleHQnLFxuXTtcbnZhciByZURpc2FsbG93ZWRUYWcgPSBuZXcgUmVnRXhwKFwiPCgvPyg/OlwiICsgZGlzYWxsb3dlZFRhZ3Muam9pbignfCcpICsgXCIpW14+XSo+KVwiLCAnaWcnKTtcbmZ1bmN0aW9uIGZpbHRlckRpc2FsbG93ZWRUYWdzKHN0cikge1xuICAgIGlmIChyZURpc2FsbG93ZWRUYWcudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZURpc2FsbG93ZWRUYWcsIGZ1bmN0aW9uIChfLCBncm91cCkgeyByZXR1cm4gXCImbHQ7XCIgKyBncm91cDsgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG52YXIgYmFzZUNvbnZlcnRvcnMgPSB7XG4gICAgaGVhZGluZzogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogXCJoXCIgKyBub2RlLmxldmVsLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGV4dDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNvZnRicmVhazogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG9wdGlvbnMuc29mdGJyZWFrLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGluZWJyZWFrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICBjb250ZW50OiAnPGJyIC8+XFxuJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGVtcGg6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdlbScsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdHJvbmc6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdzdHJvbmcnLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyYWdyYXBoOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIGdyYW5kcGFyZW50ID0gKF9iID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQ7XG4gICAgICAgIGlmIChncmFuZHBhcmVudCAmJiBncmFuZHBhcmVudC50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgIGlmIChncmFuZHBhcmVudC5saXN0RGF0YS50aWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAncCcsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnaHInLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgc2VsZkNsb3NlOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYmxvY2tRdW90ZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgaW5uZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGlzdDogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgX2IgPSBub2RlLmxpc3REYXRhLCB0eXBlID0gX2IudHlwZSwgc3RhcnQgPSBfYi5zdGFydDtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0eXBlID09PSAnYnVsbGV0JyA/ICd1bCcgOiAnb2wnO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ29sJyAmJiBzdGFydCAhPT0gbnVsbCAmJiBzdGFydCAhPT0gMSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5zdGFydCA9IHN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGh0bWxJbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBjb250ZW50ID0gb3B0aW9ucy50YWdGaWx0ZXIgPyBmaWx0ZXJEaXNhbGxvd2VkVGFncyhub2RlLmxpdGVyYWwpIDogbm9kZS5saXRlcmFsO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfTtcbiAgICB9LFxuICAgIGh0bWxCbG9jazogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBvcHRpb25zLnRhZ0ZpbHRlciA/IGZpbHRlckRpc2FsbG93ZWRUYWdzKG5vZGUubGl0ZXJhbCkgOiBub2RlLmxpdGVyYWw7XG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2h0bWwnLCBjb250ZW50OiBjb250ZW50IH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdodG1sJywgY29udGVudDogY29udGVudCwgb3V0ZXJOZXdMaW5lOiB0cnVlIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZm9TdHIgPSBub2RlLmluZm87XG4gICAgICAgIHZhciBpbmZvV29yZHMgPSBpbmZvU3RyID8gaW5mb1N0ci5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgIHZhciBjb2RlQ2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICBpZiAoaW5mb1dvcmRzLmxlbmd0aCA+IDAgJiYgaW5mb1dvcmRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvZGVDbGFzc05hbWVzLnB1c2goXCJsYW5ndWFnZS1cIiArIGVzY2FwZVhtbChpbmZvV29yZHNbMF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdwcmUnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnY29kZScsIGNsYXNzTmFtZXM6IGNvZGVDbGFzc05hbWVzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAncHJlJywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIF9iID0gbm9kZSwgdGl0bGUgPSBfYi50aXRsZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdhJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBlc21fYXNzaWduKHsgaHJlZjogZXNjYXBlWG1sKGRlc3RpbmF0aW9uKSB9LCAodGl0bGUgJiYgeyB0aXRsZTogZXNjYXBlWG1sKHRpdGxlKSB9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdhJyB9O1xuICAgIH0sXG4gICAgaW1hZ2U6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZ2V0Q2hpbGRyZW5UZXh0ID0gX2EuZ2V0Q2hpbGRyZW5UZXh0LCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBfYiA9IG5vZGUsIHRpdGxlID0gX2IudGl0bGUsIGRlc3RpbmF0aW9uID0gX2IuZGVzdGluYXRpb247XG4gICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2ltZycsXG4gICAgICAgICAgICBzZWxmQ2xvc2U6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBlc21fYXNzaWduKHsgc3JjOiBlc2NhcGVYbWwoZGVzdGluYXRpb24pLCBhbHQ6IGdldENoaWxkcmVuVGV4dChub2RlKSB9LCAodGl0bGUgJiYgeyB0aXRsZTogZXNjYXBlWG1sKHRpdGxlKSB9KSksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjdXN0b21CbG9jazogZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpIHtcbiAgICAgICAgdmFyIGluZm8gPSBub2RlLmluZm8udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBjdXN0b21Db252ZXJ0b3IgPSBjb252ZXJ0b3JzW2luZm9dO1xuICAgICAgICBpZiAoY3VzdG9tQ29udmVydG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21Db252ZXJ0b3Iobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltAdG9hc3QtdWkvZWRpdG9yXSAtIFRoZSBlcnJvciBvY2N1cnJlZCB3aGVuIFwiICsgaW5mbyArIFwiIGJsb2NrIG5vZGUgd2FzIHBhcnNlZCBpbiBtYXJrZG93biByZW5kZXJlcjogXCIgKyBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdkaXYnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgZnJvbnRNYXR0ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGZyb250IG1hdHRlciBpcyBtZXRhZGF0YSwgaXQgc2hvdWxkIG5vdCBiZSByZW5kZXIuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBzdHlsZTogJ3doaXRlLXNwYWNlOiBwcmU7IGRpc3BsYXk6IG5vbmU7JyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgY3VzdG9tSW5saW5lOiBmdW5jdGlvbiAobm9kZSwgY29udGV4dCwgY29udmVydG9ycykge1xuICAgICAgICB2YXIgX2EgPSBub2RlLCBpbmZvID0gX2EuaW5mbywgZmlyc3RDaGlsZCA9IF9hLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBub21hbGl6ZWRJbmZvID0gaW5mby50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9tYWxpemVkSW5mb107XG4gICAgICAgIHZhciBlbnRlcmluZyA9IGNvbnRleHQuZW50ZXJpbmc7XG4gICAgICAgIGlmIChjdXN0b21Db252ZXJ0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0B0b2FzdC11aS9lZGl0b3JdIC0gVGhlIGVycm9yIG9jY3VycmVkIHdoZW4gXCIgKyBub21hbGl6ZWRJbmZvICsgXCIgaW5saW5lIG5vZGUgd2FzIHBhcnNlZCBpbiBtYXJrZG93biByZW5kZXJlcjogXCIgKyBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50ZXJpbmdcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnc3BhbicgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogXCIkJFwiICsgaW5mbyArIChmaXJzdENoaWxkID8gJyAnIDogJycpIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogJyQkJyB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ3NwYW4nIH0sXG4gICAgICAgICAgICBdO1xuICAgIH0sXG59O1xudmFyIGdmbUNvbnZlcnRvcnMgPSB7XG4gICAgc3RyaWtlOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnZGVsJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGl0ZW06IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIF9iID0gbm9kZS5saXN0RGF0YSwgY2hlY2tlZCA9IF9iLmNoZWNrZWQsIHRhc2sgPSBfYi50YXNrO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBpdGVtVGFnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UYWcsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmQ2xvc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBlc21fYXNzaWduKGVzbV9hc3NpZ24oe30sIChjaGVja2VkICYmIHsgY2hlY2tlZDogJycgfSkpLCB7IGRpc2FibGVkOiAnJywgdHlwZTogJ2NoZWNrYm94JyB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyAnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbVRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RhYmxlJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RoZWFkJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlQm9keTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3Rib2R5JyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlUm93OiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ3RyJyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uTGVuID0gbm9kZS5wYXJlbnQucGFyZW50LmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxhc3RDb2xJZHggPSBub2RlLmxhc3RDaGlsZC5lbmRJZHg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGFzdENvbElkeCArIDE7IGkgPCBjb2x1bW5MZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGQnLFxuICAgICAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGQnLFxuICAgICAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0cicsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgdGFibGVDZWxsOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChub2RlLmlnbm9yZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFibGVQYXJ0ID0gbm9kZS5wYXJlbnQucGFyZW50O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRhYmxlUGFydC50eXBlID09PSAndGFibGVIZWFkJyA/ICd0aCcgOiAndGQnO1xuICAgICAgICB2YXIgdGFibGUgPSB0YWJsZVBhcnQucGFyZW50O1xuICAgICAgICB2YXIgY29sdW1uSW5mbyA9IHRhYmxlLmNvbHVtbnNbbm9kZS5zdGFydElkeF07XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gKGNvbHVtbkluZm8gPT09IG51bGwgfHwgY29sdW1uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uSW5mby5hbGlnbikgPyB7IGFsaWduOiBjb2x1bW5JbmZvLmFsaWduIH0gOiBudWxsO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBlc21fYXNzaWduKHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiB0YWdOYW1lLCBvdXRlck5ld0xpbmU6IHRydWUgfSwgKGF0dHJpYnV0ZXMgJiYgeyBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc29mdGJyZWFrOiAnXFxuJyxcbiAgICBnZm06IGZhbHNlLFxuICAgIHRhZ0ZpbHRlcjogZmFsc2UsXG4gICAgbm9kZUlkOiBmYWxzZSxcbn07XG5mdW5jdGlvbiBnZXRDaGlsZHJlblRleHQobm9kZSkge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgd2Fsa2VyID0gbm9kZS53YWxrZXIoKTtcbiAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgbm9kZV8xID0gZXZlbnQubm9kZTtcbiAgICAgICAgaWYgKG5vZGVfMS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vZGVfMS5saXRlcmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xufVxudmFyIFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZXNtX2Fzc2lnbihlc21fYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyksIGN1c3RvbU9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbnZlcnRvcnMgPSB0aGlzLmNyZWF0ZUNvbnZlcnRvcnMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5jb252ZXJ0b3JzO1xuICAgIH1cbiAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29udmVydG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRvcnMgPSBlc21fYXNzaWduKHt9LCBiYXNlQ29udmVydG9ycyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICBjb252ZXJ0b3JzID0gZXNtX2Fzc2lnbihlc21fYXNzaWduKHt9LCBjb252ZXJ0b3JzKSwgZ2ZtQ29udmVydG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb252ZXJ0b3JzKSB7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yc18xID0gdGhpcy5vcHRpb25zLmNvbnZlcnRvcnM7XG4gICAgICAgICAgICB2YXIgbm9kZVR5cGVzID0gT2JqZWN0LmtleXMoY3VzdG9tQ29udmVydG9yc18xKTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q29udmVydG9yc18xID0gZXNtX2Fzc2lnbihlc21fYXNzaWduKHt9LCBiYXNlQ29udmVydG9ycyksIGdmbUNvbnZlcnRvcnMpO1xuICAgICAgICAgICAgbm9kZVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZ0NvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSBjdXN0b21Db252ZXJ0b3JzXzFbbm9kZVR5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0b3JUeXBlID0gT2JqZWN0LmtleXMoZGVmYXVsdENvbnZlcnRvcnNfMSkuaW5kZXhPZihub2RlVHlwZSkgPT09IC0xXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZVR5cGUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICA6IG5vZGVUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChvcmdDb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udmVydG9yc1tjb252ZXJ0b3JUeXBlXSA9IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9yaWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yZ0NvbnZlcnRvcihub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0b3Iobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW2NvbnZlcnRvclR5cGVdID0gY29udmVydG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0b3JzO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmdldENvbnZlcnRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRvcnM7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocm9vdE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdmFyIHdhbGtlciA9IHJvb3ROb2RlLndhbGtlcigpO1xuICAgICAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzXzEuY29udmVydG9yc1tub2RlLnR5cGVdO1xuICAgICAgICAgICAgaWYgKCFjb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGVudGVyaW5nOiBlbnRlcmluZyxcbiAgICAgICAgICAgICAgICBsZWFmOiAhaXNDb250YWluZXIobm9kZSksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogdGhpc18xLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW5UZXh0OiBnZXRDaGlsZHJlblRleHQsXG4gICAgICAgICAgICAgICAgc2tpcENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRlZCA9IGlzQ3VzdG9tQmxvY2sobm9kZSkgfHwgaXNDdXN0b21JbmxpbmUobm9kZSlcbiAgICAgICAgICAgICAgICA/IGNvbnZlcnRvcihub2RlLCBjb250ZXh0LCB0aGlzXzEuY29udmVydG9ycylcbiAgICAgICAgICAgICAgICA6IGNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbE5vZGVzID0gQXJyYXkuaXNBcnJheShjb252ZXJ0ZWQpID8gY29udmVydGVkIDogW2NvbnZlcnRlZF07XG4gICAgICAgICAgICAgICAgaHRtbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGh0bWxOb2RlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbE5vZGUudHlwZSA9PT0gJ29wZW5UYWcnICYmIF90aGlzLm9wdGlvbnMubm9kZUlkICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWh0bWxOb2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sTm9kZS5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sTm9kZS5hdHRyaWJ1dGVzWydkYXRhLW5vZGVpZCddID0gU3RyaW5nKG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckhUTUxOb2RlKGh0bWxOb2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIucmVzdW1lQXQobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkTmV3TGluZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuam9pbignJyk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySFRNTE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnb3BlblRhZyc6XG4gICAgICAgICAgICBjYXNlICdjbG9zZVRhZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFbGVtZW50Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJhd0h0bWxOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gbm8tZGVmYXVsdC1jYXNlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZU9wZW5UYWdTdHJpbmcgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IG5vZGUudGFnTmFtZSwgY2xhc3NOYW1lcyA9IG5vZGUuY2xhc3NOYW1lcywgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChcIjxcIiArIHRhZ05hbWUpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lcyAmJiBjbGFzc05hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCIgY2xhc3M9XFxcIlwiICsgY2xhc3NOYW1lcy5qb2luKCcgJykgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1ZmZlci5wdXNoKFwiIFwiICsgYXR0ck5hbWUgKyBcIj1cXFwiXCIgKyBhdHRyVmFsdWUgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zZWxmQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goJyAvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIucHVzaCgnPicpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlQ2xvc2VUYWdTdHJpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBfYS50YWdOYW1lO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIik7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuYWRkTmV3TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCAmJiBsYXN0KGxhc3QodGhpcy5idWZmZXIpKSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goJ1xcbicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuYWRkT3V0ZXJOZXdMaW5lID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUub3V0ZXJOZXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE5ld0xpbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmFkZElubmVyTmV3TGluZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlubmVyTmV3TGluZSkge1xuICAgICAgICAgICAgdGhpcy5hZGROZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUZXh0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goZXNjYXBlWG1sKG5vZGUuY29udGVudCkpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclJhd0h0bWxOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobm9kZS5jb250ZW50KTtcbiAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRWxlbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnb3BlblRhZycpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZU9wZW5UYWdTdHJpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5zZWxmQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5uZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRJbm5lck5ld0xpbmUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlQ2xvc2VUYWdTdHJpbmcobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufSgpKTtcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaE93blByb3BlcnRpZXMuanNcbnZhciBjb2xsZWN0aW9uX2ZvckVhY2hPd25Qcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTYpO1xudmFyIGZvckVhY2hPd25Qcm9wZXJ0aWVzX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvbGxlY3Rpb25fZm9yRWFjaE93blByb3BlcnRpZXMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9vYmplY3QvZXh0ZW5kLmpzXG52YXIgZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjkpO1xudmFyIGV4dGVuZF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihleHRlbmQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21FdmVudC9vbi5qc1xudmFyIG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDgpO1xudmFyIG9uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKG9uKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvZG9tRXZlbnQvb2ZmLmpzXG52YXIgb2ZmID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDkpO1xudmFyIG9mZl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihvZmYpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL2FkZENsYXNzLmpzXG52YXIgYWRkQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNCk7XG52YXIgYWRkQ2xhc3NfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYWRkQ2xhc3MpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL3JlbW92ZUNsYXNzLmpzXG52YXIgcmVtb3ZlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2Mik7XG52YXIgcmVtb3ZlQ2xhc3NfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVtb3ZlQ2xhc3MpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL2Nzcy5qc1xudmFyIGNzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIyKTtcbnZhciBjc3NfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3NzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi90b0FycmF5LmpzXG52YXIgY29sbGVjdGlvbl90b0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTApO1xudmFyIHRvQXJyYXlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29sbGVjdGlvbl90b0FycmF5KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc0FycmF5LmpzXG52YXIgdHlwZV9pc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjIpO1xudmFyIGlzQXJyYXlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odHlwZV9pc0FycmF5KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc1N0cmluZy5qc1xudmFyIHR5cGVfaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1OCk7XG52YXIgaXNTdHJpbmdfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odHlwZV9pc1N0cmluZyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L3R5cGUvaXNVbmRlZmluZWQuanNcbnZhciB0eXBlX2lzVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjkpO1xudmFyIGlzVW5kZWZpbmVkX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHR5cGVfaXNVbmRlZmluZWQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL2hhc0NsYXNzLmpzXG52YXIgaGFzQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxNCk7XG52YXIgaGFzQ2xhc3NfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaGFzQ2xhc3MpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL21hdGNoZXMuanNcbnZhciBkb21VdGlsX21hdGNoZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3MSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvY29uc3RhbnRzLnRzXG52YXIgVEFHX05BTUUgPSAnW0EtWmEtel1bQS1aYS16MC05LV0qJztcbnZhciBBVFRSSUJVVEVfTkFNRSA9ICdbYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKic7XG52YXIgVU5RVU9URURfVkFMVUUgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgU0lOR0xFX1FVT1RFRF9WQUxVRSA9IFwiJ1teJ10qJ1wiO1xudmFyIERPVUJMRV9RVU9URURfVkFMVUUgPSAnXCJbXlwiXSpcIic7XG52YXIgQVRUUklCVVRFX1ZBTFVFID0gXCIoPzpcIiArIFVOUVVPVEVEX1ZBTFVFICsgXCJ8XCIgKyBTSU5HTEVfUVVPVEVEX1ZBTFVFICsgXCJ8XCIgKyBET1VCTEVfUVVPVEVEX1ZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFX1ZBTFVFX1NQRUMgPSBcIlwiICsgJyg/OlxcXFxzKj1cXFxccyonICsgQVRUUklCVVRFX1ZBTFVFICsgXCIpXCI7XG52YXIgY29uc3RhbnRzX0FUVFJJQlVURSA9IFwiXCIgKyAnKD86XFxcXHMrJyArIEFUVFJJQlVURV9OQU1FICsgQVRUUklCVVRFX1ZBTFVFX1NQRUMgKyBcIj8pXCI7XG52YXIgY29uc3RhbnRzX09QRU5fVEFHID0gXCI8KFwiICsgVEFHX05BTUUgKyBcIikoXCIgKyBjb25zdGFudHNfQVRUUklCVVRFICsgXCIpKlxcXFxzKi8/PlwiO1xudmFyIENMT1NFX1RBRyA9IFwiPC8oXCIgKyBUQUdfTkFNRSArIFwiKVxcXFxzKls+XVwiO1xudmFyIGNvbnN0YW50c19IVE1MX1RBRyA9IFwiKD86XCIgKyBjb25zdGFudHNfT1BFTl9UQUcgKyBcInxcIiArIENMT1NFX1RBRyArIFwiKVwiO1xudmFyIHJlSFRNTFRhZyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBjb25zdGFudHNfSFRNTF9UQUcsICdpJyk7XG52YXIgY29uc3RhbnRzX3JlQlIgPSAvPGJyXFxzKlxcLyo+L2k7XG52YXIgcmVIVE1MQ29tbWVudCA9IC88ISAtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPi87XG52YXIgY29uc3RhbnRzX0FMVEVSTkFUSVZFX1RBR19GT1JfQlIgPSAnPC9wPjxwPic7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc051bGwuanNcbnZhciB0eXBlX2lzTnVsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTM0KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvcmVxdWVzdC9zZW5kSG9zdG5hbWUuanNcbnZhciByZXF1ZXN0X3NlbmRIb3N0bmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkxKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9jb21tb24udHNcblxuXG5cblxuXG52YXIgaXNNYWMgPSAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgcmVTcGFjZU1vcmVUaGFuT25lID0gL1tcXHUwMDIwXSsvZztcbnZhciBjb21tb25fcmVFc2NhcGVDaGFycyA9IC9bPigpe31bXFxdKy0uISN8XS9nO1xudmFyIHJlRXNjYXBlSFRNTCA9IC88KFthLXpBLVpfXVthLXpBLVowLTlcXC0uX10qKShcXHN8W15cXFxcPl0pKlxcLz8+fDwoXFwvKShbYS16QS1aX11bYS16QS1aMC05XFwtLl9dKilcXHMqXFwvPz58PCEtLVteLV0rLS0+fDwoW2EtekEtWl9dW2EtekEtWjAtOVxcLS46L10qKT4vZztcbnZhciByZUVzY2FwZUJhY2tTbGFzaCA9IC9cXFxcWyFcIiMkJSYnKCkqKywtLi86Ozw9Pj9AW1xcXV5fYHt8fX5cXFxcXS9nO1xudmFyIHJlRXNjYXBlUGFpcmVkQ2hhcnMgPSAvWypffmBdL2c7XG52YXIgcmVNZEltYWdlU3ludGF4ID0gLyFcXFsuKlxcXVxcKC4qXFwpL2c7XG52YXIgcmVFc2NhcGVkQ2hhckluTGlua1N5bnRheCA9IC9bW1xcXV0vZztcbnZhciByZUVzY2FwZUJhY2tTbGFzaEluU2VudGVuY2UgPSAvKD86XnxbXlxcXFxdKVxcXFwoPyFcXFxcKS9nO1xudmFyIGNvbW1vbl9YTUxTUEVDSUFMID0gJ1smPD5cIl0nO1xudmFyIGNvbW1vbl9yZVhtbFNwZWNpYWwgPSBuZXcgUmVnRXhwKGNvbW1vbl9YTUxTUEVDSUFMLCAnZycpO1xuZnVuY3Rpb24gY29tbW9uX3JlcGxhY2VVbnNhZmVDaGFyKGNoYXIpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjaGFyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbW1vbl9lc2NhcGVYbWwodGV4dCkge1xuICAgIGlmIChjb21tb25fcmVYbWxTcGVjaWFsLnRlc3QodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShjb21tb25fcmVYbWxTcGVjaWFsLCBjb21tb25fcmVwbGFjZVVuc2FmZUNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIHNlbmRIb3N0TmFtZSgpIHtcbiAgICBzZW5kSG9zdG5hbWUoJ2VkaXRvcicsICdVQS0xMjk5NjY5MjktMScpO1xufVxuZnVuY3Rpb24gY29tbW9uX2luY2x1ZGVzKGFyciwgdGFyZ2V0SXRlbSkge1xuICAgIHJldHVybiBhcnIuaW5kZXhPZih0YXJnZXRJdGVtKSAhPT0gLTE7XG59XG52YXIgYXZhaWxhYmxlTGlua0F0dHJpYnV0ZXMgPSBbJ3JlbCcsICd0YXJnZXQnLCAnaHJlZmxhbmcnLCAndHlwZSddO1xudmFyIHJlTWFya2Rvd25UZXh0VG9Fc2NhcGVNYXAgPSB7XG4gICAgY29kZWJsb2NrOiAvKF4gezR9W15cXG5dK1xcbiopKy8sXG4gICAgdGhlbWF0aWNCcmVhazogL14gKigoXFwqICopezMsfXwoLSAqKXszLH0gKnwoXyAqKXszLH0pICovLFxuICAgIGF0eEhlYWRpbmc6IC9eKCN7MSw2fSkgK1tcXHNcXFNdKy8sXG4gICAgc2VUZXh0aGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezIsfSAqLyxcbiAgICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rLiopKy8sXG4gICAgbGlzdDogL14gKihcXCorfC0rfFxcZCtcXC4pIFtcXHNcXFNdKy8sXG4gICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqLyxcbiAgICBsaW5rOiAvIT9cXFsuKlxcXVxcKC4qXFwpLyxcbiAgICByZWZsaW5rOiAvIT9cXFsuKlxcXVxccypcXFsoW15cXF1dKilcXF0vLFxuICAgIHZlcnRpY2FsQmFyOiAvXFx1MDA3Qy8sXG4gICAgZmVuY2VkQ29kZWJsb2NrOiAvXigoYHx+KXszLH0pLyxcbn07XG5mdW5jdGlvbiBzYW5pdGl6ZUxpbmtBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgaWYgKCFhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBsaW5rQXR0cmlidXRlcyA9IHt9O1xuICAgIGF2YWlsYWJsZUxpbmtBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkX2RlZmF1bHQoKShhdHRyaWJ1dGVba2V5XSkpIHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzW2tleV0gPSBhdHRyaWJ1dGVba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsaW5rQXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIGNvbW1vbl9yZXBlYXQodGV4dCwgY291bnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHJlc3VsdCArPSB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOZWVkRXNjYXBlVGV4dCh0ZXh0KSB7XG4gICAgdmFyIG5lZWRFc2NhcGUgPSBmYWxzZTtcbiAgICBmb3JFYWNoT3duUHJvcGVydGllcyhyZU1hcmtkb3duVGV4dFRvRXNjYXBlTWFwLCBmdW5jdGlvbiAocmVNYXJrZG93blRleHRUb0VzY2FwZSkge1xuICAgICAgICBpZiAocmVNYXJrZG93blRleHRUb0VzY2FwZS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICBuZWVkRXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW5lZWRFc2NhcGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5lZWRFc2NhcGU7XG59XG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yTGluayh0ZXh0KSB7XG4gICAgdmFyIGltYWdlU3ludGF4UmFuZ2VzID0gW107XG4gICAgdmFyIHJlc3VsdCA9IHJlTWRJbWFnZVN5bnRheC5leGVjKHRleHQpO1xuICAgIHdoaWxlIChyZXN1bHQpIHtcbiAgICAgICAgaW1hZ2VTeW50YXhSYW5nZXMucHVzaChbcmVzdWx0LmluZGV4LCByZXN1bHQuaW5kZXggKyByZXN1bHRbMF0ubGVuZ3RoXSk7XG4gICAgICAgIHJlc3VsdCA9IHJlTWRJbWFnZVN5bnRheC5leGVjKHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlRXNjYXBlZENoYXJJbkxpbmtTeW50YXgsIGZ1bmN0aW9uIChtYXRjaGVkLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGlzRGVsaW1pdGVyID0gaW1hZ2VTeW50YXhSYW5nZXMuc29tZShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIG9mZnNldCA+IHJhbmdlWzBdICYmIG9mZnNldCA8IHJhbmdlWzFdOyB9KTtcbiAgICAgICAgcmV0dXJuIGlzRGVsaW1pdGVyID8gbWF0Y2hlZCA6IFwiXFxcXFwiICsgbWF0Y2hlZDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNvbW1vbl9lc2NhcGUodGV4dCkge1xuICAgIHZhciBhaGVhZFJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoZWQpIHsgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hlZDsgfTtcbiAgICB2YXIgYmVoaW5kUmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2hlZCkgeyByZXR1cm4gbWF0Y2hlZCArIFwiXFxcXFwiOyB9O1xuICAgIHZhciBlc2NhcGVkVGV4dCA9IHRleHQucmVwbGFjZShyZVNwYWNlTW9yZVRoYW5PbmUsICcgJyk7XG4gICAgaWYgKHJlRXNjYXBlQmFja1NsYXNoLnRlc3QoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZUJhY2tTbGFzaCwgYWhlYWRSZXBsYWNlcik7XG4gICAgfVxuICAgIGlmIChyZUVzY2FwZUJhY2tTbGFzaEluU2VudGVuY2UudGVzdChlc2NhcGVkVGV4dCkpIHtcbiAgICAgICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlQmFja1NsYXNoSW5TZW50ZW5jZSwgYmVoaW5kUmVwbGFjZXIpO1xuICAgIH1cbiAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVQYWlyZWRDaGFycywgYWhlYWRSZXBsYWNlcik7XG4gICAgaWYgKHJlRXNjYXBlSFRNTC50ZXN0KGVzY2FwZWRUZXh0KSkge1xuICAgICAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVIVE1MLCBhaGVhZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgaWYgKGlzTmVlZEVzY2FwZVRleHQoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShjb21tb25fcmVFc2NhcGVDaGFycywgYWhlYWRSZXBsYWNlcik7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbn1cbmZ1bmN0aW9uIHF1b3RlKHRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmICh0ZXh0LmluZGV4T2YoJ1wiJykgPT09IC0xKSB7XG4gICAgICAgIHJlc3VsdCA9ICdcIlwiJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRleHQuaW5kZXhPZihcIidcIikgPT09IC0xID8gXCInJ1wiIDogJygpJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFswXSArIHRleHQgKyByZXN1bHRbMV07XG59XG5mdW5jdGlvbiBjb21tb25faXNOaWwodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOdWxsKHZhbHVlKSB8fCBpc1VuZGVmaW5lZCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwobzEsIG8yKSB7XG4gICAgaWYgKG8xID09PSBudWxsICYmIG8xID09PSBvMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG8yICE9PSAnb2JqZWN0JyB8fCBjb21tb25faXNOaWwobzEpIHx8IGNvbW1vbl9pc05pbChvMikpIHtcbiAgICAgICAgcmV0dXJuIG8xID09PSBvMjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG8xKSB7XG4gICAgICAgIGlmIChvMVtrZXldICE9PSBvMltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG8yKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBvMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbW1vbl9sYXN0KGFycikge1xuICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gY29tbW9uX2JldHdlZW4odmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXg7XG59XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xufVxuZnVuY3Rpb24gZGVlcE1lcmdlZENvcHkodGFyZ2V0T2JqLCBvYmopIHtcbiAgICB2YXIgcmVzdWx0T2JqID0gdHNsaWJfZXM2X2Fzc2lnbih7fSwgdGFyZ2V0T2JqKTtcbiAgICBpZiAodGFyZ2V0T2JqICYmIG9iaikge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChyZXN1bHRPYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwQ29weUFycmF5KG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdE9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwTWVyZ2VkQ29weShyZXN1bHRPYmpbcHJvcF0sIG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwQ29weShvYmpbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRPYmo7XG59XG5mdW5jdGlvbiBkZWVwQ29weUFycmF5KGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW0pID8gZGVlcENvcHlBcnJheShpdGVtKSA6IGRlZXBDb3B5KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVlcENvcHkob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ApIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgIGFjY1twcm9wXSA9IEFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSA/IGRlZXBDb3B5QXJyYXkob2JqW3Byb3BdKSA6IGRlZXBDb3B5KG9ialtwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2NbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjb21tb25fYXNzaWduKHRhcmdldE9iaiwgb2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdm9pZCAwKSB7IG9iaiA9IHt9OyB9XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICh0YXJnZXRPYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgdHlwZW9mIHRhcmdldE9ialtwcm9wXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmpbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21tb25fYXNzaWduKHRhcmdldE9ialtwcm9wXSwgb2JqW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXRPYmo7XG59XG5mdW5jdGlvbiBnZXRTb3J0ZWROdW1QYWlyKHZhbHVlQSwgdmFsdWVCKSB7XG4gICAgcmV0dXJuIHZhbHVlQSA+IHZhbHVlQiA/IFt2YWx1ZUIsIHZhbHVlQV0gOiBbdmFsdWVBLCB2YWx1ZUJdO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvZG9tLnRzXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbkJveChzdHlsZSwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIHZhciBsZWZ0ID0gcGFyc2VJbnQoc3R5bGUubGVmdCwgMTApO1xuICAgIHZhciB0b3AgPSBwYXJzZUludChzdHlsZS50b3AsIDEwKTtcbiAgICB2YXIgd2lkdGggPSBwYXJzZUludChzdHlsZS53aWR0aCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ0xlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xuICAgIHZhciBoZWlnaHQgPSBwYXJzZUludChzdHlsZS5oZWlnaHQsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3AsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICByZXR1cm4gb2Zmc2V0WCA+PSBsZWZ0ICYmIG9mZnNldFggPD0gbGVmdCArIHdpZHRoICYmIG9mZnNldFkgPj0gdG9wICYmIG9mZnNldFkgPD0gdG9wICsgaGVpZ2h0O1xufVxudmFyIENMU19QUkVGSVggPSAndG9hc3R1aS1lZGl0b3ItJztcbmZ1bmN0aW9uIGNscygpIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBuYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgX2EgPSAwLCBuYW1lc18xID0gbmFtZXM7IF9hIDwgbmFtZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc18xW19hXTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IG5hbWVbMF0gPyBuYW1lWzFdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJcIiArIENMU19QUkVGSVggKyBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignICcpO1xufVxuZnVuY3Rpb24gY2xzV2l0aE1kUHJlZml4KCkge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5tYXAoZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gQ0xTX1BSRUZJWCArIFwibWQtXCIgKyBjbGFzc05hbWU7IH0pLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLm5vZGVUeXBlKSA9PT0gTm9kZS5URVhUX05PREU7XG59XG5mdW5jdGlvbiBpc0VsZW1Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHZhciBub2RlTGlzdCA9IHRvQXJyYXkoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgaWYgKG5vZGVMaXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbm9kZUxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGFwcGVuZE5vZGVzKG5vZGUsIG5vZGVzVG9BcHBlbmQpIHtcbiAgICBub2Rlc1RvQXBwZW5kID0gaXNBcnJheShub2Rlc1RvQXBwZW5kKSA/IHRvQXJyYXkobm9kZXNUb0FwcGVuZCkgOiBbbm9kZXNUb0FwcGVuZF07XG4gICAgbm9kZXNUb0FwcGVuZC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlVG9BcHBlbmQpIHtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChub2RlVG9BcHBlbmQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlTm9kZShpbnNlcnRlZE5vZGUsIG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zZXJ0ZWROb2RlLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bndyYXBOb2RlKG5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICByZXN1bHQucHVzaChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUuZmlyc3RDaGlsZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTm9kZShub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBzdGF0ZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZF9kZWZhdWx0KCkoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlID0gIWhhc0NsYXNzX2RlZmF1bHQoKShlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cbiAgICB2YXIgdG9nZ2xlRm4gPSBzdGF0ZSA/IChhZGRDbGFzc19kZWZhdWx0KCkpIDogKHJlbW92ZUNsYXNzX2RlZmF1bHQoKSk7XG4gICAgdG9nZ2xlRm4oZWxlbWVudCwgY2xhc3NOYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoKGNvbnRlbnRzLCB0YXJnZXQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKGlzU3RyaW5nX2RlZmF1bHQoKShjb250ZW50cykpIHtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGNvbnRlbnRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRlbnRzKTtcbiAgICB9XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBnZXRPdXRlcldpZHRoKGVsKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHJldHVybiAoWydtYXJnaW4tbGVmdCcsICdtYXJnaW4tcmlnaHQnXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHlwZSkgeyByZXR1cm4gYWNjICsgcGFyc2VJbnQoY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSh0eXBlKSwgMTApOyB9LCAwKSArIGVsLm9mZnNldFdpZHRoKTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3Qobm9kZSwgZm91bmQpIHtcbiAgICB2YXIgY29uZGl0aW9uO1xuICAgIGlmIChpc1N0cmluZyhmb3VuZCkpIHtcbiAgICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gbWF0Y2hlcyh0YXJnZXQsIGZvdW5kKTsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCA9PT0gZm91bmQ7IH07XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChpc0VsZW1Ob2RlKG5vZGUpICYmIGNvbmRpdGlvbihub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRUb3RhbE9mZnNldChlbCwgcm9vdCkge1xuICAgIHZhciBvZmZzZXRUb3AgPSAwO1xuICAgIHZhciBvZmZzZXRMZWZ0ID0gMDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IHJvb3QpIHtcbiAgICAgICAgdmFyIHRvcCA9IGVsLm9mZnNldFRvcCwgbGVmdCA9IGVsLm9mZnNldExlZnQsIG9mZnNldFBhcmVudCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICAgICAgb2Zmc2V0VG9wICs9IHRvcDtcbiAgICAgICAgb2Zmc2V0TGVmdCArPSBsZWZ0O1xuICAgICAgICBpZiAob2Zmc2V0UGFyZW50ID09PSByb290Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB7IG9mZnNldFRvcDogb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0IH07XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUh0bWwoaHRtbCwgbmVlZEh0bWxUZXh0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAobmVlZEh0bWxUZXh0KSB7XG4gICAgICAgIHJlc3VsdCA9IGh0bWwuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShodG1sLmNoaWxkTm9kZXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZnJhZztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRvbV9lbXB0eShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kTm9kZShub2RlLCBhcHBlbmRlZCkge1xuICAgIGlmIChpc1N0cmluZyhhcHBlbmRlZCkpIHtcbiAgICAgICAgbm9kZS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGFwcGVuZGVkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBub2RlcyA9IGFwcGVuZGVkLmxlbmd0aFxuICAgICAgICAgICAgPyB0b0FycmF5KGFwcGVuZGVkKVxuICAgICAgICAgICAgOiBbYXBwZW5kZWRdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHJlcGVuZE5vZGUobm9kZSwgYXBwZW5kZWQpIHtcbiAgICBpZiAoaXNTdHJpbmcoYXBwZW5kZWQpKSB7XG4gICAgICAgIG5vZGUuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgYXBwZW5kZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGVzID0gYXBwZW5kZWQubGVuZ3RoXG4gICAgICAgICAgICA/IHRvQXJyYXkoYXBwZW5kZWQpXG4gICAgICAgICAgICA6IFthcHBlbmRlZF07XG4gICAgICAgIGZvciAodmFyIGkgPSBub2Rlcy5sZW5ndGggLSAxLCBsZW4gPSAwOyBpID49IGxlbjsgaSAtPSAxKSB7XG4gICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShub2Rlc1tpXSwgbm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcywgZWxlbWVudCkge1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIGlmIChpc05pbChhdHRyaWJ1dGVzW2F0dHJOYW1lXSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyaWJ1dGVzW2F0dHJOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VCUldpdGhFbXB0eUJsb2NrKGh0bWwpIHtcbiAgICAvLyByZW1vdmUgYnIgaW4gcGFyYWdyYXBoIHRvIGNvbXBhdGlibGUgd2l0aCBtYXJrZG93blxuICAgIHZhciByZXBsYWNlZEhUTUwgPSBodG1sLnJlcGxhY2UoLzxwPjxiclxccypcXC8qPjxcXC9wPi9naSwgJzxwPjwvcD4nKTtcbiAgICB2YXIgcmVIVE1MVGFnID0gbmV3IFJlZ0V4cChIVE1MX1RBRywgJ2lnJyk7XG4gICAgdmFyIGh0bWxUYWdNYXRjaGVkID0gcmVwbGFjZWRIVE1MLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgaHRtbFRhZ01hdGNoZWQgPT09IG51bGwgfHwgaHRtbFRhZ01hdGNoZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0bWxUYWdNYXRjaGVkLmZvckVhY2goZnVuY3Rpb24gKGh0bWxUYWcsIGluZGV4KSB7XG4gICAgICAgIGlmIChyZUJSLnRlc3QoaHRtbFRhZykpIHtcbiAgICAgICAgICAgIHZhciBhbHRlcm5hdGl2ZVRhZyA9IEFMVEVSTkFUSVZFX1RBR19GT1JfQlI7XG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlRhZyA9IGh0bWxUYWdNYXRjaGVkW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIG9wZW5UYWdNYXRjaGVkID0gcHJldlRhZy5tYXRjaChPUEVOX1RBRyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5UYWdNYXRjaGVkICYmICEvYnIvaS50ZXN0KG9wZW5UYWdNYXRjaGVkWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnTmFtZSA9IG9wZW5UYWdNYXRjaGVkWzFdO1xuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZVRhZyA9IFwiPC9cIiArIHRhZ05hbWUgKyBcIj48XCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZWRIVE1MID0gcmVwbGFjZWRIVE1MLnJlcGxhY2UocmVCUiwgYWx0ZXJuYXRpdmVUYWcpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcGxhY2VkSFRNTDtcbn1cbmZ1bmN0aW9uIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKGh0bWwpIHtcbiAgICB2YXIgcmVQcm9zZU1pcnJvckltYWdlID0gLzxpbWcgY2xhc3M9XCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIiBhbHQ9XCJcIj4vZztcbiAgICB2YXIgcmVQcm9zZU1pcnJvclRyYWlsaW5nQnJlYWsgPSAvIGNsYXNzPVwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiL2c7XG4gICAgdmFyIHJlc3VsdEhUTUwgPSBodG1sO1xuICAgIHJlc3VsdEhUTUwgPSByZXN1bHRIVE1MLnJlcGxhY2UocmVQcm9zZU1pcnJvckltYWdlLCAnJyk7XG4gICAgcmVzdWx0SFRNTCA9IHJlc3VsdEhUTUwucmVwbGFjZShyZVByb3NlTWlycm9yVHJhaWxpbmdCcmVhaywgJycpO1xuICAgIHJldHVybiByZXN1bHRIVE1MO1xufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L3R5cGUvaXNGdW5jdGlvbi5qc1xudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5NCk7XG52YXIgaXNGdW5jdGlvbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc0Z1bmN0aW9uKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9tYXJrZG93bi50c1xuXG5mdW5jdGlvbiBoYXNTcGVjaWZpY1R5cGVBbmNlc3RvcihtZE5vZGUpIHtcbiAgICB2YXIgdHlwZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0eXBlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgd2hpbGUgKG1kTm9kZSAmJiBtZE5vZGUucGFyZW50ICYmIG1kTm9kZS5wYXJlbnQudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICBpZiAoaW5jbHVkZXModHlwZXMsIG1kTm9kZS5wYXJlbnQudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1hcmtkb3duX2dldE1kU3RhcnRMaW5lKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzBdWzBdO1xufVxuZnVuY3Rpb24gbWFya2Rvd25fZ2V0TWRFbmRMaW5lKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzFdWzBdO1xufVxuZnVuY3Rpb24gZ2V0TWRTdGFydENoKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzBdWzFdO1xufVxuZnVuY3Rpb24gZ2V0TWRFbmRDaChtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlLnNvdXJjZXBvc1sxXVsxXTtcbn1cbmZ1bmN0aW9uIGlzTXVsdGlMaW5lTm9kZShtZE5vZGUpIHtcbiAgICB2YXIgdHlwZSA9IG1kTm9kZS50eXBlO1xuICAgIHJldHVybiB0eXBlID09PSAnY29kZUJsb2NrJyB8fCB0eXBlID09PSAncGFyYWdyYXBoJztcbn1cbmZ1bmN0aW9uIGlzSFRNTE5vZGUobWROb2RlKSB7XG4gICAgdmFyIHR5cGUgPSBtZE5vZGUudHlwZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2h0bWxCbG9jaycgfHwgdHlwZSA9PT0gJ2h0bWxJbmxpbmUnO1xufVxuZnVuY3Rpb24gbWFya2Rvd25faXNTdHlsZWRJbmxpbmVOb2RlKG1kTm9kZSkge1xuICAgIHZhciB0eXBlID0gbWROb2RlLnR5cGU7XG4gICAgcmV0dXJuICh0eXBlID09PSAnc3RyaWtlJyB8fFxuICAgICAgICB0eXBlID09PSAnc3Ryb25nJyB8fFxuICAgICAgICB0eXBlID09PSAnZW1waCcgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2NvZGUnIHx8XG4gICAgICAgIHR5cGUgPT09ICdsaW5rJyB8fFxuICAgICAgICB0eXBlID09PSAnaW1hZ2UnKTtcbn1cbmZ1bmN0aW9uIGlzQ29kZUJsb2NrTm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlICYmIG1kTm9kZS50eXBlID09PSAnY29kZUJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tQmxvY2tOb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUgJiYgbWROb2RlLnR5cGUgPT09ICdjdXN0b21CbG9jayc7XG59XG5mdW5jdGlvbiBpc0xpc3ROb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUgJiYgKG1kTm9kZS50eXBlID09PSAnaXRlbScgfHwgbWROb2RlLnR5cGUgPT09ICdsaXN0Jyk7XG59XG5mdW5jdGlvbiBpc09yZGVyZWRMaXN0Tm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gaXNMaXN0Tm9kZShtZE5vZGUpICYmIG1kTm9kZS5saXN0RGF0YS50eXBlID09PSAnb3JkZXJlZCc7XG59XG5mdW5jdGlvbiBpc0J1bGxldExpc3ROb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBpc0xpc3ROb2RlKG1kTm9kZSkgJiYgbWROb2RlLmxpc3REYXRhLnR5cGUgIT09ICdvcmRlcmVkJztcbn1cbmZ1bmN0aW9uIGlzVGFibGVDZWxsTm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlICYmIChtZE5vZGUudHlwZSA9PT0gJ3RhYmxlQ2VsbCcgfHwgbWROb2RlLnR5cGUgPT09ICd0YWJsZURlbGltQ2VsbCcpO1xufVxuZnVuY3Rpb24gaXNJbmxpbmVOb2RlKG1kTm9kZSkge1xuICAgIHN3aXRjaCAobWROb2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgY2FzZSAnaHRtbElubGluZSc6XG4gICAgICAgIGNhc2UgJ2xpbmVicmVhayc6XG4gICAgICAgIGNhc2UgJ3NvZnRicmVhayc6XG4gICAgICAgIGNhc2UgJ2N1c3RvbUlubGluZSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdE5vZGUobWROb2RlLCBjb25kaXRpb24sIGluY2x1ZGVTZWxmKSB7XG4gICAgaWYgKGluY2x1ZGVTZWxmID09PSB2b2lkIDApIHsgaW5jbHVkZVNlbGYgPSB0cnVlOyB9XG4gICAgbWROb2RlID0gaW5jbHVkZVNlbGYgPyBtZE5vZGUgOiBtZE5vZGUucGFyZW50O1xuICAgIHdoaWxlIChtZE5vZGUgJiYgbWROb2RlLnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihtZE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWROb2RlO1xuICAgICAgICB9XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VQYXJlbnROb2RlcyhtZE5vZGUsIGl0ZXJhdGVlLCBpbmNsdWRlU2VsZikge1xuICAgIGlmIChpbmNsdWRlU2VsZiA9PT0gdm9pZCAwKSB7IGluY2x1ZGVTZWxmID0gdHJ1ZTsgfVxuICAgIG1kTm9kZSA9IGluY2x1ZGVTZWxmID8gbWROb2RlIDogbWROb2RlLnBhcmVudDtcbiAgICB3aGlsZSAobWROb2RlICYmIG1kTm9kZS50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIGl0ZXJhdGVlKG1kTm9kZSk7XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkT2Zmc2V0UG9zKG9yaWdpblBvcywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIFtvcmlnaW5Qb3NbMF0sIG9yaWdpblBvc1sxXSArIG9mZnNldF07XG59XG5mdW5jdGlvbiBzZXRPZmZzZXRQb3Mob3JpZ2luUG9zLCBuZXdPZmZzZXQpIHtcbiAgICByZXR1cm4gW29yaWdpblBvc1swXSwgbmV3T2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIGdldElubGluZU1hcmtkb3duVGV4dChtZE5vZGUpIHtcbiAgICB2YXIgdGV4dCA9IG1kTm9kZS5maXJzdENoaWxkLmxpdGVyYWw7XG4gICAgc3dpdGNoIChtZE5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgICAgIHJldHVybiBcIipcIiArIHRleHQgKyBcIipcIjtcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICAgIHJldHVybiBcIioqXCIgKyB0ZXh0ICsgXCIqKlwiO1xuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICAgICAgcmV0dXJuIFwifn5cIiArIHRleHQgKyBcIn5+XCI7XG4gICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAgcmV0dXJuIFwiYFwiICsgdGV4dCArIFwiYFwiO1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbiAgICAgICAgICAgIHZhciBfYSA9IG1kTm9kZSwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbiwgdGl0bGUgPSBfYS50aXRsZTtcbiAgICAgICAgICAgIHZhciBkZWxpbSA9IG1kTm9kZS50eXBlID09PSAnbGluaycgPyAnJyA6ICchJztcbiAgICAgICAgICAgIHJldHVybiBkZWxpbSArIFwiW1wiICsgdGV4dCArIFwiXShcIiArIGRlc3RpbmF0aW9uICsgKHRpdGxlID8gXCIgXFxcIlwiICsgdGl0bGUgKyBcIlxcXCJcIiA6ICcnKSArIFwiKVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFya2Rvd25faXNDb250YWluZXIobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgY2FzZSAnYmxvY2tRdW90ZSc6XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlSGVhZCc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQm9keSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlUm93JzpcbiAgICAgICAgY2FzZSAndGFibGVDZWxsJzpcbiAgICAgICAgY2FzZSAndGFibGVEZWxpbVJvdyc6XG4gICAgICAgIGNhc2UgJ2N1c3RvbUlubGluZSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXJrZG93bl9nZXRDaGlsZHJlblRleHQobm9kZSkge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgd2Fsa2VyID0gbm9kZS53YWxrZXIoKTtcbiAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGNoaWxkTm9kZS5saXRlcmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd2lkZ2V0L3J1bGVzLnRzXG5cbnZhciB3aWRnZXRSdWxlcyA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFtdKSk7XG52YXIgd2lkZ2V0UnVsZU1hcCA9IHt9O1xudmFyIHJlV2lkZ2V0UHJlZml4ID0gL1xcJFxcJHdpZGdldFxcZCtcXHMvO1xuZnVuY3Rpb24gdW53cmFwV2lkZ2V0U3ludGF4KHRleHQpIHtcbiAgICB2YXIgaW5kZXggPSB0ZXh0LnNlYXJjaChyZVdpZGdldFByZWZpeCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB2YXIgcmVzdCA9IHRleHQuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gcmVzdC5yZXBsYWNlKHJlV2lkZ2V0UHJlZml4LCAnJykucmVwbGFjZSgnJCQnLCAnJyk7XG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIHRleHQgKz0gdW53cmFwV2lkZ2V0U3ludGF4KHJlcGxhY2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVXaWRnZXRDb250ZW50KGluZm8sIHRleHQpIHtcbiAgICByZXR1cm4gXCIkJFwiICsgaW5mbyArIFwiIFwiICsgdGV4dCArIFwiJCRcIjtcbn1cbmZ1bmN0aW9uIHdpZGdldFRvRE9NKGluZm8sIHRleHQpIHtcbiAgICB2YXIgX2EgPSB3aWRnZXRSdWxlTWFwW2luZm9dLCBydWxlID0gX2EucnVsZSwgdG9ET00gPSBfYS50b0RPTTtcbiAgICB2YXIgbWF0Y2hlcyA9IHVud3JhcFdpZGdldFN5bnRheCh0ZXh0KS5tYXRjaChydWxlKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB0ZXh0ID0gbWF0Y2hlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHRvRE9NKHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0V2lkZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHdpZGdldFJ1bGVzO1xufVxuZnVuY3Rpb24gc2V0V2lkZ2V0UnVsZXMocnVsZXMpIHtcbiAgICB3aWRnZXRSdWxlcyA9IHJ1bGVzO1xuICAgIHdpZGdldFJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgIHdpZGdldFJ1bGVNYXBbXCJ3aWRnZXRcIiArIGluZGV4XSA9IHJ1bGU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZU5vZGVzKG5vZGVzLCB0ZXh0LCBzY2hlbWEsIHJ1bGVJbmRleCkge1xuICAgIHJldHVybiBub2Rlcy5jb25jYXQoY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KHRleHQsIHNjaGVtYSwgcnVsZUluZGV4KSk7XG59XG4vKipcbiAqIGNyZWF0ZSBub2RlcyB3aXRoIHBsYWluIHRleHQgYW5kIHJlcGxhY2UgdGV4dCBtYXRjaGVkIHRvIHRoZSB3aWRnZXQgcnVsZXMgd2l0aCB0aGUgd2lkZ2V0IG5vZGVcbiAqIEZvciBleGFtcGxlLCBpbiBjYXNlIHRoZSB0ZXh0IGFuZCB3aWRnZXQgcnVsZXMgYXMgYmVsb3dcbiAqXG4gKiB0ZXh0OiAkdGVzdCBwbGFpbiB0ZXh0ICN0ZXN0XG4gKiB3aWRnZXQgcnVsZXM6IFt7IHJ1bGU6IC8kLisvIH0sIHsgcnVsZTogLyMuKy8gfV1cbiAqXG4gKiBUaGUgY3JlYXRpbmcgbm9kZSBwcm9jZXNzIGlzIHJlY3Vyc2l2ZSBhbmQgaXMgYXMgZm9sbG93cy5cbiAqXG4gKiBpbiBmaXJzdCB3aWRnZXQgcnVsZSgvJC4rLylcbiAqICAkdGVzdCAtPiB3aWRnZXQgbm9kZVxuICogIHBsYWluIHRleHQgLT4gbWF0Y2ggd2l0aCBuZXh0IHdpZGdldCBydWxlXG4gKiAgI3Rlc3QgLT4gbWF0Y2ggd2l0aCBuZXh0IHdpZGdldCBydWxlXG4gKlxuICogaW4gc2Vjb25kIHdpZGdldCBydWxlKC8jLisvKVxuICogIHBsYWluIHRleHQgLT4gdGV4dCBub2RlKG5vIHJ1bGUgZm9yIG1hdGNoaW5nKVxuICogICN0ZXN0IC0+IHdpZGdldCBub2RlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzV2l0aFdpZGdldCh0ZXh0LCBzY2hlbWEsIHJ1bGVJbmRleCkge1xuICAgIGlmIChydWxlSW5kZXggPT09IHZvaWQgMCkgeyBydWxlSW5kZXggPSAwOyB9XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIHJ1bGUgPSAod2lkZ2V0UnVsZXNbcnVsZUluZGV4XSB8fCB7fSkucnVsZTtcbiAgICB2YXIgbmV4dFJ1bGVJbmRleCA9IHJ1bGVJbmRleCArIDE7XG4gICAgdGV4dCA9IHVud3JhcFdpZGdldFN5bnRheCh0ZXh0KTtcbiAgICBpZiAocnVsZSAmJiBydWxlLnRlc3QodGV4dCkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAoKGluZGV4ID0gdGV4dC5zZWFyY2gocnVsZSkpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSB0ZXh0LnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICAvLyBnZXQgd2lkZ2V0IG5vZGUgb24gZmlyc3Qgc3BsaXR0ZWQgdGV4dCB1c2luZyBuZXh0IHdpZGdldCBydWxlXG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIG5vZGVzID0gbWVyZ2VOb2Rlcyhub2RlcywgcHJldiwgc2NoZW1hLCBuZXh0UnVsZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJ1aWxkIHdpZGdldCBub2RlIHVzaW5nIGN1cnJlbnQgd2lkZ2V0IHJ1bGVcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhpbmRleCk7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRleHQubWF0Y2gocnVsZSlbMF07XG4gICAgICAgICAgICB2YXIgaW5mbyA9IFwid2lkZ2V0XCIgKyBydWxlSW5kZXg7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHNjaGVtYS5ub2Rlcy53aWRnZXQuY3JlYXRlKHsgaW5mbzogaW5mbyB9LCBzY2hlbWEudGV4dChjcmVhdGVXaWRnZXRDb250ZW50KGluZm8sIGxpdGVyYWwpKSkpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKGxpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgd2lkZ2V0IG5vZGUgb24gbGFzdCBzcGxpdHRlZCB0ZXh0IHVzaW5nIG5leHQgd2lkZ2V0IHJ1bGVcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIG5vZGVzID0gbWVyZ2VOb2Rlcyhub2RlcywgdGV4dCwgc2NoZW1hLCBuZXh0UnVsZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0KSB7XG4gICAgICAgIG5vZGVzID1cbiAgICAgICAgICAgIHJ1bGVJbmRleCA8IHdpZGdldFJ1bGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICA/IG1lcmdlTm9kZXMobm9kZXMsIHRleHQsIHNjaGVtYSwgbmV4dFJ1bGVJbmRleClcbiAgICAgICAgICAgICAgICA6IFtzY2hlbWEudGV4dCh0ZXh0KV07XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGdldFdpZGdldENvbnRlbnQod2lkZ2V0Tm9kZSkge1xuICAgIHZhciBldmVudDtcbiAgICB2YXIgdGV4dCA9ICcnO1xuICAgIHZhciB3YWxrZXIgPSB3aWRnZXROb2RlLndhbGtlcigpO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgbm9kZSA9IGV2ZW50Lm5vZGUsIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgaWYgKG5vZGUgIT09IHdpZGdldE5vZGUgJiYgbm9kZS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IGdldElubGluZU1hcmtkb3duVGV4dChub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHdhbGtlci5yZXN1bWVBdCh3aWRnZXROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBub2RlLmxpdGVyYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2RvbXB1cmlmeS9kaXN0L3B1cmlmeS5qc1xudmFyIHB1cmlmeSA9IF9fd2VicGFja19yZXF1aXJlX18oMzY4KTtcbnZhciBwdXJpZnlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocHVyaWZ5KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zYW5pdGl6ZXIvaHRtbFNhbml0aXplci50c1xuXG5cblxudmFyIENBTl9CRV9XSElURV9UQUdfTElTVCA9IFsnaWZyYW1lJywgJ2VtYmVkJ107XG52YXIgd2hpdGVUYWdMaXN0ID0gW107XG5mdW5jdGlvbiBodG1sU2FuaXRpemVyX3JlZ2lzdGVyVGFnV2hpdGVsaXN0SWZQb3NzaWJsZSh0YWdOYW1lKSB7XG4gICAgaWYgKGNvbW1vbl9pbmNsdWRlcyhDQU5fQkVfV0hJVEVfVEFHX0xJU1QsIHRhZ05hbWUpKSB7XG4gICAgICAgIHdoaXRlVGFnTGlzdC5wdXNoKHRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FuaXRpemVIVE1MKGh0bWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHVyaWZ5X2RlZmF1bHQoKS5zYW5pdGl6ZShodG1sLCB0c2xpYl9lczZfYXNzaWduKHsgQUREX1RBR1M6IHdoaXRlVGFnTGlzdCwgQUREX0FUVFI6IFsncmVsJywgJ3RhcmdldCcsICdocmVmbGFuZycsICd0eXBlJ10sIEZPUkJJRF9UQUdTOiBbXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAgJ3NjcmlwdCcsXG4gICAgICAgICAgICAndGV4dGFyZWEnLFxuICAgICAgICAgICAgJ2Zvcm0nLFxuICAgICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgICAnc2VsZWN0JyxcbiAgICAgICAgICAgICdtZXRhJyxcbiAgICAgICAgICAgICdzdHlsZScsXG4gICAgICAgICAgICAnbGluaycsXG4gICAgICAgICAgICAndGl0bGUnLFxuICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAnYmFzZScsXG4gICAgICAgIF0gfSwgb3B0aW9ucykpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd3lzaXd5Zy9ub2Rlcy9odG1sLnRzXG5cblxuXG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuSFRNTChub2RlLCB0eXBlTmFtZSkge1xuICAgIHJldHVybiBub2RlXG4gICAgICAgIC5saXRlcmFsLnJlcGxhY2UobmV3IFJlZ0V4cChcIig8XFxcXHMqXCIgKyB0eXBlTmFtZSArIFwiW14+XSo+KXwoPC9cIiArIHR5cGVOYW1lICsgXCJcXFxccypbPl0pXCIsICdpZycpLCAnJylcbiAgICAgICAgLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGdldEhUTUxBdHRyc0J5SFRNTFN0cmluZyhodG1sKSB7XG4gICAgaHRtbCA9IGh0bWwubWF0Y2gocmVIVE1MVGFnKVswXTtcbiAgICB2YXIgYXR0cnMgPSBodG1sLm1hdGNoKG5ldyBSZWdFeHAoY29uc3RhbnRzX0FUVFJJQlVURSwgJ2cnKSk7XG4gICAgcmV0dXJuIGF0dHJzXG4gICAgICAgID8gYXR0cnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGF0dHIudHJpbSgpLnNwbGl0KCc9JyksIG5hbWUgPSBfYVswXSwgdmFsdWVzID0gX2Euc2xpY2UoMSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IHZhbHVlcy5qb2luKCc9JykucmVwbGFjZSgvJ3xcIi9nLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pXG4gICAgICAgIDoge307XG59XG5mdW5jdGlvbiBnZXRIVE1MQXR0cnMoZG9tKSB7XG4gICAgcmV0dXJuIHRvQXJyYXlfZGVmYXVsdCgpKGRvbS5hdHRyaWJ1dGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cikge1xuICAgICAgICBhY2NbYXR0ci5ub2RlTmFtZV0gPSBhdHRyLm5vZGVWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZURPTShub2RlLCB0eXBlTmFtZSwgc2FuaXRpemVyLCB3d1RvRE9NQWRhcHRvcikge1xuICAgIHZhciBkb20gPSB3d1RvRE9NQWRhcHRvci5nZXRUb0RPTU5vZGUodHlwZU5hbWUpKG5vZGUpO1xuICAgIHZhciBodG1sID0gc2FuaXRpemVyKGRvbS5vdXRlckhUTUwpO1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBkb20gPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB2YXIgaHRtbEF0dHJzID0gZ2V0SFRNTEF0dHJzKGRvbSk7XG4gICAgcmV0dXJuIHsgZG9tOiBkb20sIGh0bWxBdHRyczogaHRtbEF0dHJzIH07XG59XG52YXIgc2NoZW1hRmFjdG9yeSA9IHtcbiAgICBodG1sQmxvY2s6IGZ1bmN0aW9uICh0eXBlTmFtZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXRvbTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGh0bWxBdHRyczogeyBkZWZhdWx0OiB7fSB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuSFRNTDogeyBkZWZhdWx0OiAnJyB9LFxuICAgICAgICAgICAgICAgIGh0bWxCbG9jazogeyBkZWZhdWx0OiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogdHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRyczogZ2V0SFRNTEF0dHJzKGRvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IVE1MOiBkb20uaW5uZXJIVE1MLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHNhbml0aXplRE9NKG5vZGUsIHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSwgZG9tID0gX2EuZG9tLCBodG1sQXR0cnMgPSBfYS5odG1sQXR0cnM7XG4gICAgICAgICAgICAgICAgaHRtbEF0dHJzLmNsYXNzID0gaHRtbEF0dHJzLmNsYXNzID8gaHRtbEF0dHJzLmNsYXNzICsgXCIgaHRtbC1ibG9ja1wiIDogJ2h0bWwtYmxvY2snO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFt0eXBlTmFtZSwgaHRtbEF0dHJzXSwgdG9BcnJheV9kZWZhdWx0KCkoZG9tLmNoaWxkTm9kZXMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBodG1sSW5saW5lOiBmdW5jdGlvbiAodHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IHt9IH0sXG4gICAgICAgICAgICAgICAgaHRtbElubGluZTogeyBkZWZhdWx0OiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogdHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRyczogZ2V0SFRNTEF0dHJzKGRvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxBdHRycyA9IHNhbml0aXplRE9NKG5vZGUsIHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKS5odG1sQXR0cnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlTmFtZSwgaHRtbEF0dHJzLCAwXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVIVE1MU2NoZW1hTWFwKGNvbnZlcnRvck1hcCwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikge1xuICAgIHZhciBodG1sU2NoZW1hTWFwID0geyBub2Rlczoge30sIG1hcmtzOiB7fSB9O1xuICAgIFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChodG1sVHlwZSkge1xuICAgICAgICBpZiAoY29udmVydG9yTWFwW2h0bWxUeXBlXSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udmVydG9yTWFwW2h0bWxUeXBlXSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUeXBlID0gaHRtbFR5cGUgPT09ICdodG1sQmxvY2snID8gJ25vZGVzJyA6ICdtYXJrcyc7XG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGFnIHdoaXRlIGxpc3QgZm9yIHByZXZlbnRpbmcgdG8gcmVtb3ZlIHRoZSBodG1sIGluIHNhbml0aXplclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyVGFnV2hpdGVsaXN0SWZQb3NzaWJsZSh0eXBlKTtcbiAgICAgICAgICAgICAgICBodG1sU2NoZW1hTWFwW3RhcmdldFR5cGVdW3R5cGVdID0gc2NoZW1hRmFjdG9yeVtodG1sVHlwZV0odHlwZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBodG1sU2NoZW1hTWFwO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWFya2Rvd24vaHRtbFJlbmRlckNvbnZlcnRvcnMudHNcblxuXG5cblxuXG5cbnZhciByZUNsb3NlVGFnID0gL15cXHMqPFxccypcXC8vO1xudmFyIGh0bWxSZW5kZXJDb252ZXJ0b3JzX2Jhc2VDb252ZXJ0b3JzID0ge1xuICAgIHBhcmFncmFwaDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBvcmlnaW4gPSBfYS5vcmlnaW4sIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5ub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAncCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4oKTtcbiAgICB9LFxuICAgIHNvZnRicmVhazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGlzUHJldk5vZGVIVE1MID0gbm9kZS5wcmV2ICYmIG5vZGUucHJldi50eXBlID09PSAnaHRtbElubGluZSc7XG4gICAgICAgIHZhciBpc1ByZXZCUiA9IGlzUHJldk5vZGVIVE1MICYmIC88YnIgP1xcLz8+Ly50ZXN0KG5vZGUucHJldi5saXRlcmFsKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBpc1ByZXZCUiA/ICdcXG4nIDogJzxicj5cXG4nO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfTtcbiAgICB9LFxuICAgIGl0ZW06IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmxpc3REYXRhLnRhc2spIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzWydkYXRhLXRhc2snXSA9ICcnO1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgndGFzay1saXN0LWl0ZW0nKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0RGF0YS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnY2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzWydkYXRhLXRhc2stY2hlY2tlZCddID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHsgJ2RhdGEtYmFja3RpY2tzJzogU3RyaW5nKG5vZGUudGlja0NvdW50KSB9O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJywgYXR0cmlidXRlczogYXR0cmlidXRlcyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF9hID0gbm9kZSwgZmVuY2VMZW5ndGggPSBfYS5mZW5jZUxlbmd0aCwgaW5mbyA9IF9hLmluZm87XG4gICAgICAgIHZhciBpbmZvV29yZHMgPSBpbmZvID8gaW5mby5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgIHZhciBwcmVDbGFzc2VzID0gW107XG4gICAgICAgIHZhciBjb2RlQXR0cnMgPSB7fTtcbiAgICAgICAgaWYgKGZlbmNlTGVuZ3RoID4gMykge1xuICAgICAgICAgICAgY29kZUF0dHJzWydkYXRhLWJhY2t0aWNrcyddID0gZmVuY2VMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm9Xb3Jkcy5sZW5ndGggPiAwICYmIGluZm9Xb3Jkc1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFuZyA9IGluZm9Xb3Jkc1swXTtcbiAgICAgICAgICAgIHByZUNsYXNzZXMucHVzaChcImxhbmctXCIgKyBsYW5nKTtcbiAgICAgICAgICAgIGNvZGVBdHRyc1snZGF0YS1sYW5ndWFnZSddID0gbGFuZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdwcmUnLCBjbGFzc05hbWVzOiBwcmVDbGFzc2VzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2NvZGUnLCBhdHRyaWJ1dGVzOiBjb2RlQXR0cnMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdwcmUnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBjdXN0b21JbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgb3JpZ2luID0gX2Eub3JpZ2luLCBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBpbmZvID0gbm9kZS5pbmZvO1xuICAgICAgICBpZiAoaW5mby5pbmRleE9mKCd3aWRnZXQnKSAhPT0gLTEgJiYgZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBnZXRXaWRnZXRDb250ZW50KG5vZGUpO1xuICAgICAgICAgICAgdmFyIGh0bWxJbmxpbmUgPSB3aWRnZXRUb0RPTShpbmZvLCBjb250ZW50KS5vdXRlckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnc3BhbicsIGNsYXNzTmFtZXM6IFsndHVpLXdpZGdldCddIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGh0bWxJbmxpbmUgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdzcGFuJyB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luKCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRIVE1MUmVuZGVyQ29udmVydG9ycyhsaW5rQXR0cmlidXRlcywgY3VzdG9tQ29udmVydG9ycykge1xuICAgIHZhciBjb252ZXJ0b3JzID0gdHNsaWJfZXM2X2Fzc2lnbih7fSwgaHRtbFJlbmRlckNvbnZlcnRvcnNfYmFzZUNvbnZlcnRvcnMpO1xuICAgIGlmIChsaW5rQXR0cmlidXRlcykge1xuICAgICAgICBjb252ZXJ0b3JzLmxpbmsgPSBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBvcmlnaW4gPSBfYS5vcmlnaW47XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luKCk7XG4gICAgICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXR0cmlidXRlcyA9IHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgcmVzdWx0LmF0dHJpYnV0ZXMpLCBsaW5rQXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY3VzdG9tQ29udmVydG9ycykge1xuICAgICAgICBPYmplY3Qua2V5cyhjdXN0b21Db252ZXJ0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlVHlwZSkge1xuICAgICAgICAgICAgdmFyIG9yZ0NvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgaWYgKG9yZ0NvbnZlcnRvciAmJiBpc0Z1bmN0aW9uX2RlZmF1bHQoKShjdXN0b21Db252ZXJ0b3IpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydG9yc1tub2RlVHlwZV0gPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29udGV4dCA9IHRzbGliX2VzNl9hc3NpZ24oe30sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0Lm9yaWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yZ0NvbnZlcnRvcihub2RlLCBjb250ZXh0KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbW9uX2luY2x1ZGVzKFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXSwgbm9kZVR5cGUpICYmICFpc0Z1bmN0aW9uX2RlZmF1bHQoKShjdXN0b21Db252ZXJ0b3IpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydG9yc1tub2RlVHlwZV0gPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IG5vZGUubGl0ZXJhbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RIVE1MID0gbWF0Y2hlZFswXSwgb3BlblRhZ05hbWUgPSBtYXRjaGVkWzFdLCBjbG9zZVRhZ05hbWUgPSBtYXRjaGVkWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gKG9wZW5UYWdOYW1lIHx8IGNsb3NlVGFnTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodG1sQ29udmVydG9yID0gY3VzdG9tQ29udmVydG9yW3R5cGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbkhUTUwgPSBnZXRDaGlsZHJlbkhUTUwobm9kZSwgdHlwZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0bWxDb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGZvciBwcmV2ZW50aW5nIHRvIG92ZXJ3cml0ZSB0aGUgb3JpZ2luaWFsIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSB0c2xpYl9lczZfYXNzaWduKHt9LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmF0dHJzID0gZ2V0SFRNTEF0dHJzQnlIVE1MU3RyaW5nKHJvb3RIVE1MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmNoaWxkcmVuSFRNTCA9IGNoaWxkcmVuSFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnR5cGUgPSB0eXBlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVudGVyaW5nID0gIXJlQ2xvc2VUYWcudGVzdChub2RlLmxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBodG1sQ29udmVydG9yKG5ld05vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0Lm9yaWdpbigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW25vZGVUeXBlXSA9IGN1c3RvbUNvbnZlcnRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0b3JzO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWFya2Rvd24vc2Nyb2xsL2RvbS50c1xuXG5cbnZhciBuZXN0YWJsZVR5cGVzID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoWydsaXN0JywgJ2l0ZW0nLCAnYmxvY2tRdW90ZSddKSk7XG52YXIgbmVzdGFibGVUYWdOYW1lcyA9IFsnVUwnLCAnT0wnLCAnQkxPQ0tRVU9URSddO1xuZnVuY3Rpb24gaXNCbGFua0xpbmUoZG9jLCBpbmRleCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcG1Ob2RlID0gZG9jLmNoaWxkKGluZGV4KTtcbiAgICByZXR1cm4gIXBtTm9kZS5jaGlsZENvdW50IHx8IChwbU5vZGUuY2hpbGRDb3VudCA9PT0gMSAmJiAhKChfYSA9IHBtTm9kZS5maXJzdENoaWxkLnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmltKCkpKTtcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclJhbmdlSGVpZ2h0SW5mbyhkb2MsIG1kTm9kZSwgY2hpbGRyZW4pIHtcbiAgICB2YXIgc3RhcnQgPSBnZXRNZFN0YXJ0TGluZShtZE5vZGUpIC0gMTtcbiAgICB2YXIgZW5kID0gZ2V0TWRFbmRMaW5lKG1kTm9kZSkgLSAxO1xuICAgIHZhciByZWN0ID0gY2hpbGRyZW5bc3RhcnRdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBoZWlnaHQgPSBjaGlsZHJlbltlbmRdLm9mZnNldFRvcCAtXG4gICAgICAgIGNoaWxkcmVuW3N0YXJ0XS5vZmZzZXRUb3AgK1xuICAgICAgICBjaGlsZHJlbltlbmRdLmNsaWVudEhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IGhlaWdodCA8PSAwXG4gICAgICAgICAgICA/IGNoaWxkcmVuW3N0YXJ0XS5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIDogaGVpZ2h0ICsgZ2V0QmxhbmtMaW5lc0hlaWdodChkb2MsIGNoaWxkcmVuLCBNYXRoLm1pbihlbmQgKyAxLCBkb2MuY2hpbGRDb3VudCAtIDEpKSxcbiAgICAgICAgcmVjdDogcmVjdCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QmxhbmtMaW5lc0hlaWdodChkb2MsIGNoaWxkcmVuLCBzdGFydCkge1xuICAgIHZhciBlbmQgPSBkb2MuY2hpbGRDb3VudCAtIDE7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCAmJiBpc0JsYW5rTGluZShkb2MsIHN0YXJ0KSkge1xuICAgICAgICBoZWlnaHQgKz0gY2hpbGRyZW5bc3RhcnRdLmNsaWVudEhlaWdodDtcbiAgICAgICAgc3RhcnQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbn1cbmZ1bmN0aW9uIGZpbmRBbmNlc3RvckhhdmluZ0lkKGVsLCByb290KSB7XG4gICAgd2hpbGUgKCFlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJykgJiYgZWwucGFyZW50RWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGRvbV9nZXRUb3RhbE9mZnNldFRvcChlbCwgcm9vdCkge1xuICAgIHZhciBvZmZzZXRUb3AgPSAwO1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gcm9vdCkge1xuICAgICAgICBpZiAoIWNvbW1vbl9pbmNsdWRlcyhuZXN0YWJsZVRhZ05hbWVzLCBlbC50YWdOYW1lKSkge1xuICAgICAgICAgICAgb2Zmc2V0VG9wICs9IGVsLm9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwub2Zmc2V0UGFyZW50ID09PSByb290Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0VG9wO1xufVxuZnVuY3Rpb24gZmluZEFkamFjZW50RWxlbWVudFRvU2Nyb2xsVG9wKHNjcm9sbFRvcCwgcm9vdCkge1xuICAgIHZhciBlbCA9IHJvb3Q7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIHdoaWxlIChlbCkge1xuICAgICAgICB2YXIgZmlyc3RFbGVtZW50Q2hpbGQgPSBlbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgaWYgKCFmaXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RTaWJsaW5nID0gZmluZExhc3RTaWJsaW5nRWxlbWVudFRvU2Nyb2xsVG9wKGZpcnN0RWxlbWVudENoaWxkLCBzY3JvbGxUb3AsIGRvbV9nZXRUb3RhbE9mZnNldFRvcChlbCwgcm9vdCkpO1xuICAgICAgICBwcmV2ID0gZWw7XG4gICAgICAgIGVsID0gbGFzdFNpYmxpbmc7XG4gICAgfVxuICAgIHZhciBhZGphY2VudEVsID0gZWwgfHwgcHJldjtcbiAgICByZXR1cm4gYWRqYWNlbnRFbCA9PT0gcm9vdCA/IG51bGwgOiBhZGphY2VudEVsO1xufVxuZnVuY3Rpb24gZmluZExhc3RTaWJsaW5nRWxlbWVudFRvU2Nyb2xsVG9wKGVsLCBzY3JvbGxUb3AsIG9mZnNldFRvcCkge1xuICAgIGlmIChlbCAmJiBzY3JvbGxUb3AgPiBvZmZzZXRUb3AgKyBlbC5vZmZzZXRUb3ApIHtcbiAgICAgICAgcmV0dXJuIChmaW5kTGFzdFNpYmxpbmdFbGVtZW50VG9TY3JvbGxUb3AoZWwubmV4dEVsZW1lbnRTaWJsaW5nLCBzY3JvbGxUb3AsIG9mZnNldFRvcCkgfHwgZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEFkZGl0aW9uYWxQb3Moc2Nyb2xsVG9wLCBvZmZzZXRUb3AsIGhlaWdodCwgdGFyZ2V0Tm9kZUhlaWdodCkge1xuICAgIHZhciByYXRpbyA9IE1hdGgubWluKChzY3JvbGxUb3AgLSBvZmZzZXRUb3ApIC8gaGVpZ2h0LCAxKTtcbiAgICByZXR1cm4gcmF0aW8gKiB0YXJnZXROb2RlSGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZU9iaihwcmV2aWV3Q29udGVudCwgbWROb2RlKSB7XG4gICAgdmFyIGVsID0gcHJldmlld0NvbnRlbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLW5vZGVpZD1cXFwiXCIgKyBtZE5vZGUuaWQgKyBcIlxcXCJdXCIpO1xuICAgIHdoaWxlICghZWwgfHwgaXNTdHlsZWRJbmxpbmVOb2RlKG1kTm9kZSkpIHtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICAgICAgZWwgPSBwcmV2aWV3Q29udGVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZWlkPVxcXCJcIiArIG1kTm9kZS5pZCArIFwiXFxcIl1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZXROb25OZXN0YWJsZU5vZGVPYmooeyBtZE5vZGU6IG1kTm9kZSwgZWw6IGVsIH0pO1xufVxuZnVuY3Rpb24gZ2V0Tm9uTmVzdGFibGVOb2RlT2JqKF9hKSB7XG4gICAgdmFyIG1kTm9kZSA9IF9hLm1kTm9kZSwgZWwgPSBfYS5lbDtcbiAgICB3aGlsZSAoKGluY2x1ZGVzKG5lc3RhYmxlVHlwZXMsIG1kTm9kZS50eXBlKSB8fCBtZE5vZGUudHlwZSA9PT0gJ3RhYmxlJykgJiYgbWROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGVsID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB7IG1kTm9kZTogbWROb2RlLCBlbDogZWwgfTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21hcmtkb3duL3Njcm9sbC9vZmZzZXQudHNcblxuXG52YXIgb2Zmc2V0SW5mb01hcCA9IHt9O1xuZnVuY3Rpb24gc2V0SGVpZ2h0KGlkLCBoZWlnaHQpIHtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXSA9IG9mZnNldEluZm9NYXBbaWRdIHx8IHt9O1xuICAgIG9mZnNldEluZm9NYXBbaWRdLmhlaWdodCA9IGhlaWdodDtcbn1cbmZ1bmN0aW9uIHNldE9mZnNldFRvcChpZCwgb2Zmc2V0VG9wKSB7XG4gICAgb2Zmc2V0SW5mb01hcFtpZF0gPSBvZmZzZXRJbmZvTWFwW2lkXSB8fCB7fTtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXS5vZmZzZXRUb3AgPSBvZmZzZXRUb3A7XG59XG5mdW5jdGlvbiBnZXRIZWlnaHQoaWQpIHtcbiAgICByZXR1cm4gb2Zmc2V0SW5mb01hcFtpZF0gJiYgb2Zmc2V0SW5mb01hcFtpZF0uaGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0VG9wKGlkKSB7XG4gICAgcmV0dXJuIG9mZnNldEluZm9NYXBbaWRdICYmIG9mZnNldEluZm9NYXBbaWRdLm9mZnNldFRvcDtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9mZnNldEluZm9CeU5vZGUobm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIGRlbGV0ZSBvZmZzZXRJbmZvTWFwW051bWJlcihub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKSldO1xuICAgICAgICB0b0FycmF5X2RlZmF1bHQoKShub2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmVtb3ZlT2Zmc2V0SW5mb0J5Tm9kZShjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFuZFNhdmVPZmZzZXRJbmZvKG5vZGUsIHJvb3QsIG1kTm9kZUlkKSB7XG4gICAgdmFyIGNhY2hlZEhlaWdodCA9IGdldEhlaWdodChtZE5vZGVJZCk7XG4gICAgdmFyIGNhY2hlZFRvcCA9IGdldE9mZnNldFRvcChtZE5vZGVJZCk7XG4gICAgdmFyIG5vZGVIZWlnaHQgPSBjYWNoZWRIZWlnaHQgfHwgbm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIG9mZnNldFRvcCA9IGNhY2hlZFRvcCB8fCBnZXRUb3RhbE9mZnNldFRvcChub2RlLCByb290KSB8fCBub2RlLm9mZnNldFRvcDtcbiAgICBpZiAoIWNhY2hlZEhlaWdodCkge1xuICAgICAgICBzZXRIZWlnaHQobWROb2RlSWQsIG5vZGVIZWlnaHQpO1xuICAgIH1cbiAgICBpZiAoIWNhY2hlZFRvcCkge1xuICAgICAgICBzZXRPZmZzZXRUb3AobWROb2RlSWQsIG9mZnNldFRvcCk7XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGVIZWlnaHQ6IG5vZGVIZWlnaHQsIG9mZnNldFRvcDogb2Zmc2V0VG9wIH07XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tYXJrZG93bi9tZFByZXZpZXcudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgQ0xBU1NfSElHSExJR0hUID0gY2xzKCdtZC1wcmV2aWV3LWhpZ2hsaWdodCcpO1xuZnVuY3Rpb24gZmluZFRhYmxlQ2VsbCh0YWJsZVJvdywgY2hPZmZzZXQpIHtcbiAgICB2YXIgY2VsbCA9IHRhYmxlUm93LmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNlbGwgJiYgY2VsbC5uZXh0KSB7XG4gICAgICAgIGlmIChnZXRNZFN0YXJ0Q2goY2VsbC5uZXh0KSA+IGNoT2Zmc2V0ICsgMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbCA9IGNlbGwubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG59XG4vKipcbiAqIENsYXNzIE1hcmtkb3duIFByZXZpZXdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gYmFzZSBlbGVtZW50XG4gKiBAcGFyYW0ge2V2ZW50RW1pdHRlcn0gZXZlbnRFbWl0dGVyIC0gZXZlbnQgbWFuYWdlclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5pc1ZpZXdlciAtIHRydWUgZm9yIHZpZXctb25seSBtb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaGlnaGxpZ2h0IC0gdHJ1ZSBmb3IgdXNpbmcgbGl2ZS1oaWdobGlnaHQgZmVhdHVyZVxuICogQHBhcmFtIHtvYmplY3R9IG9waXRvbnMubGlua0F0dHJpYnV0ZXMgLSBhdHRyaWJ1dGVzIGZvciBsaW5rIGVsZW1lbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGl0b25zLmN1c3RvbUhUTUxSZW5kZXJlciAtIG1hcCBvZiBjdXN0b20gSFRNTCByZW5kZXIgZnVuY3Rpb25zXG4gKlxuICogQGlnbm9yZVxuICovXG52YXIgTWFya2Rvd25QcmV2aWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcmtkb3duUHJldmlldyhldmVudEVtaXR0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuaXNWaWV3ZXIgPSAhIW9wdGlvbnMuaXNWaWV3ZXI7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NOYW1lID0gY2xzKCdtZC1wcmV2aWV3Jyk7XG4gICAgICAgIHZhciBsaW5rQXR0cmlidXRlcyA9IG9wdGlvbnMubGlua0F0dHJpYnV0ZXMsIGN1c3RvbUhUTUxSZW5kZXJlciA9IG9wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyLCBzYW5pdGl6ZXIgPSBvcHRpb25zLnNhbml0aXplciwgX2EgPSBvcHRpb25zLmhpZ2hsaWdodCwgaGlnaGxpZ2h0ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2E7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgICAgICAgbm9kZUlkOiB0cnVlLFxuICAgICAgICAgICAgY29udmVydG9yczogZ2V0SFRNTFJlbmRlckNvbnZlcnRvcnMobGlua0F0dHJpYnV0ZXMsIGN1c3RvbUhUTUxSZW5kZXJlciksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN1cnNvck5vZGVJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FuaXRpemVyID0gc2FuaXRpemVyO1xuICAgICAgICB0aGlzLmluaXRFdmVudChoaWdobGlnaHQpO1xuICAgICAgICB0aGlzLmluaXRDb250ZW50U2VjdGlvbigpO1xuICAgICAgICAvLyBUbyBwcmV2ZW50IG92ZXJmbG93aW5nIGNvbnRlbnRzIGluIHRoZSB2aWV3ZXJcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlld0NvbnRlbnQuc3R5bGUub3ZlcmZsb3dXcmFwID0gJ2JyZWFrLXdvcmQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuaW5pdENvbnRlbnRTZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByZXZpZXdDb250ZW50ID0gY3JlYXRlRWxlbWVudFdpdGgoXCI8ZGl2IGNsYXNzPVxcXCJcIiArIGNscygnY29udGVudHMnKSArIFwiXFxcIj48L2Rpdj5cIik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZpZXdlcikge1xuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLnByZXZpZXdDb250ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS50b2dnbGVBY3RpdmUgPSBmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWwsICdhY3RpdmUnLCBhY3RpdmUpO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbigndXBkYXRlUHJldmlldycsIHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlVG9vbGJhclN0YXRlJywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IF9hLm1kTm9kZSwgY3Vyc29yUG9zID0gX2EuY3Vyc29yUG9zO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUN1cnNvck5vZGUobWROb2RlLCBjdXJzb3JQb3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbl9kZWZhdWx0KCkodGhpcy5lbCwgJ3Njcm9sbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Njcm9sbCcsICdwcmV2aWV3JywgZmluZEFkamFjZW50RWxlbWVudFRvU2Nyb2xsVG9wKGV2ZW50LnRhcmdldC5zY3JvbGxUb3AsIF90aGlzLnByZXZpZXdDb250ZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdUYWJQcmV2aWV3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudG9nZ2xlQWN0aXZlKHRydWUpOyB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VQcmV2aWV3VGFiV3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUoZmFsc2UpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JOb2RlSWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RWwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZCh0aGlzLmN1cnNvck5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEVsKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfZGVmYXVsdCgpKGN1cnJlbnRFbCwgQ0xBU1NfSElHSExJR0hUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS51cGRhdGVDdXJzb3JOb2RlID0gZnVuY3Rpb24gKGN1cnNvck5vZGUsIGN1cnNvclBvcykge1xuICAgICAgICBpZiAoY3Vyc29yTm9kZSkge1xuICAgICAgICAgICAgY3Vyc29yTm9kZSA9IGZpbmRDbG9zZXN0Tm9kZShjdXJzb3JOb2RlLCBmdW5jdGlvbiAobWROb2RlKSB7IHJldHVybiAhaXNJbmxpbmVOb2RlKG1kTm9kZSk7IH0pO1xuICAgICAgICAgICAgaWYgKGN1cnNvck5vZGUudHlwZSA9PT0gJ3RhYmxlUm93Jykge1xuICAgICAgICAgICAgICAgIGN1cnNvck5vZGUgPSBmaW5kVGFibGVDZWxsKGN1cnNvck5vZGUsIGN1cnNvclBvc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJzb3JOb2RlLnR5cGUgPT09ICd0YWJsZUJvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgbGluZSBuZXh0IHRvIHRhYmxlXG4gICAgICAgICAgICAgICAgY3Vyc29yTm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnNvck5vZGVJZCA9IGN1cnNvck5vZGUgPyBjdXJzb3JOb2RlLmlkIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yTm9kZUlkID09PSBjdXJzb3JOb2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkRUwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZCh0aGlzLmN1cnNvck5vZGVJZCk7XG4gICAgICAgIHZhciBuZXdFTCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKGN1cnNvck5vZGVJZCk7XG4gICAgICAgIGlmIChvbGRFTCkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfZGVmYXVsdCgpKG9sZEVMLCBDTEFTU19ISUdITElHSFQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdFTCkge1xuICAgICAgICAgICAgYWRkQ2xhc3NfZGVmYXVsdCgpKG5ld0VMLCBDTEFTU19ISUdITElHSFQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yTm9kZUlkID0gY3Vyc29yTm9kZUlkO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRFbGVtZW50QnlOb2RlSWQgPSBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBub2RlSWRcbiAgICAgICAgICAgID8gdGhpcy5wcmV2aWV3Q29udGVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZWlkPVxcXCJcIiArIG5vZGVJZCArIFwiXFxcIl1cIilcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY2hhbmdlZC5mb3JFYWNoKGZ1bmN0aW9uIChlZGl0UmVzdWx0KSB7IHJldHVybiBfdGhpcy5yZXBsYWNlUmFuZ2VOb2RlcyhlZGl0UmVzdWx0KTsgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2FmdGVyUHJldmlld1JlbmRlcicsIHRoaXMpO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5yZXBsYWNlUmFuZ2VOb2RlcyA9IGZ1bmN0aW9uIChlZGl0UmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlcyA9IGVkaXRSZXN1bHQubm9kZXMsIHJlbW92ZWROb2RlUmFuZ2UgPSBlZGl0UmVzdWx0LnJlbW92ZWROb2RlUmFuZ2U7XG4gICAgICAgIHZhciBjb250ZW50RWwgPSB0aGlzLnByZXZpZXdDb250ZW50O1xuICAgICAgICB2YXIgbmV3SHRtbCA9IHRoaXMuZXZlbnRFbWl0dGVyLmVtaXRSZWR1Y2UoJ2JlZm9yZVByZXZpZXdSZW5kZXInLCB0aGlzLnNhbml0aXplcihub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLnJlbmRlcmVyLnJlbmRlcihub2RlKTsgfSkuam9pbignJykpKTtcbiAgICAgICAgaWYgKCFyZW1vdmVkTm9kZVJhbmdlKSB7XG4gICAgICAgICAgICBjb250ZW50RWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgbmV3SHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2EgPSByZW1vdmVkTm9kZVJhbmdlLmlkLCBzdGFydE5vZGVJZCA9IF9hWzBdLCBlbmROb2RlSWQgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBzdGFydEVsID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQoc3RhcnROb2RlSWQpO1xuICAgICAgICAgICAgdmFyIGVuZEVsID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQoZW5kTm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChzdGFydEVsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFbC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWJlZ2luJywgbmV3SHRtbCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gc3RhcnRFbDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGVuZEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0RWwgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBuZXh0RWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gbnVsbCB8fCBlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlT2Zmc2V0SW5mb0J5Tm9kZShlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmdldFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlcjtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmX2RlZmF1bHQoKSh0aGlzLmVsLCAnc2Nyb2xsJyk7XG4gICAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0SFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKHRoaXMucHJldmlld0NvbnRlbnQuaW5uZXJIVE1MKTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0SFRNTCA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIHRoaXMucHJldmlld0NvbnRlbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICBjc3NfZGVmYXVsdCgpKHRoaXMuZWwsIHsgaGVpZ2h0OiBoZWlnaHQgKyBcInB4XCIgfSk7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnNldE1pbkhlaWdodCA9IGZ1bmN0aW9uIChtaW5IZWlnaHQpIHtcbiAgICAgICAgY3NzX2RlZmF1bHQoKSh0aGlzLmVsLCB7IG1pbkhlaWdodDogbWluSGVpZ2h0ICsgXCJweFwiIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtkb3duUHJldmlldztcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtZFByZXZpZXcgPSAoTWFya2Rvd25QcmV2aWV3KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwicHJvc2VtaXJyb3Itc3RhdGVcIixcImNvbW1vbmpzMlwiOlwicHJvc2VtaXJyb3Itc3RhdGVcIixcImFtZFwiOlwicHJvc2VtaXJyb3Itc3RhdGVcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9zdGF0ZV9jb21tb25qczJfcHJvc2VtaXJyb3Jfc3RhdGVfYW1kX3Byb3NlbWlycm9yX3N0YXRlXyA9IF9fd2VicGFja19yZXF1aXJlX18oODE0KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcInByb3NlbWlycm9yLWlucHV0cnVsZXNcIixcImNvbW1vbmpzMlwiOlwicHJvc2VtaXJyb3ItaW5wdXRydWxlc1wiLFwiYW1kXCI6XCJwcm9zZW1pcnJvci1pbnB1dHJ1bGVzXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3JfaW5wdXRydWxlc19jb21tb25qczJfcHJvc2VtaXJyb3JfaW5wdXRydWxlc19hbWRfcHJvc2VtaXJyb3JfaW5wdXRydWxlc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3OSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJwcm9zZW1pcnJvci12aWV3XCIsXCJjb21tb25qczJcIjpcInByb3NlbWlycm9yLXZpZXdcIixcImFtZFwiOlwicHJvc2VtaXJyb3Itdmlld1wifVxudmFyIGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3ZpZXdfY29tbW9uanMyX3Byb3NlbWlycm9yX3ZpZXdfYW1kX3Byb3NlbWlycm9yX3ZpZXdfID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwicHJvc2VtaXJyb3Ita2V5bWFwXCIsXCJjb21tb25qczJcIjpcInByb3NlbWlycm9yLWtleW1hcFwiLFwiYW1kXCI6XCJwcm9zZW1pcnJvci1rZXltYXBcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9rZXltYXBfY29tbW9uanMyX3Byb3NlbWlycm9yX2tleW1hcF9hbWRfcHJvc2VtaXJyb3Jfa2V5bWFwXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDgxKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcInByb3NlbWlycm9yLW1vZGVsXCIsXCJjb21tb25qczJcIjpcInByb3NlbWlycm9yLW1vZGVsXCIsXCJhbWRcIjpcInByb3NlbWlycm9yLW1vZGVsXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3JfbW9kZWxfY29tbW9uanMyX3Byb3NlbWlycm9yX21vZGVsX2FtZF9wcm9zZW1pcnJvcl9tb2RlbF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvYXJyYXkvaW5BcnJheS5qc1xudmFyIGluQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOCk7XG52YXIgaW5BcnJheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpbkFycmF5KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9tYXAudHNcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBpZ25vcmVcbiAqIEBjbGFzc2Rlc2MgRVM2IE1hcFxuICovXG52YXIgbWFwX01hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBNYXAucHJvdG90eXBlLmdldEtleUluZGV4ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gaW5BcnJheV9kZWZhdWx0KCkoa2V5LCB0aGlzLmtleXMpO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1t0aGlzLmdldEtleUluZGV4KGtleSldO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIga2V5SW5kZXggPSB0aGlzLmdldEtleUluZGV4KGtleSk7XG4gICAgICAgIGlmIChrZXlJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc1trZXlJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXlJbmRleChrZXkpID4gLTE7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGtleUluZGV4ID0gdGhpcy5nZXRLZXlJbmRleChrZXkpO1xuICAgICAgICBpZiAoa2V5SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShrZXlJbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2Uoa2V5SW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzQXJnID09PSB2b2lkIDApIHsgdGhpc0FyZyA9IHRoaXM7IH1cbiAgICAgICAgdGhpcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgX3RoaXMua2V5c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBfdGhpcy5rZXlzW2luZGV4XSwgX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcDtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsc19tYXAgPSAobWFwX01hcCk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pMThuL2kxOG4udHNcbi8qKlxuICogQGZpbGVvdmVydmlldyBJbXBsZW1lbnRzIGkxOG5cbiAqIEBhdXRob3IgTkhOIENsb3VkIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxudmFyIERFRkFVTFRfQ09ERSA9ICdlbi1VUyc7XG4vKipcbiAqIENsYXNzIEkxOG5cbiAqIEBpZ25vcmVcbiAqL1xudmFyIEkxOG4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSTE4bigpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gREVGQVVMVF9DT0RFO1xuICAgICAgICB0aGlzLmxhbmdzID0gbmV3IHV0aWxzX21hcCgpO1xuICAgIH1cbiAgICBJMThuLnByb3RvdHlwZS5zZXRDb2RlID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZSB8fCBERUZBVUxUX0NPREU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbGFuZ3VhZ2Ugc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNvZGVzIGxvY2FsZSBjb2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgbGFuZ3VhZ2Ugc2V0XG4gICAgICovXG4gICAgSTE4bi5wcm90b3R5cGUuc2V0TGFuZ3VhZ2UgPSBmdW5jdGlvbiAoY29kZXMsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29kZXMgPSBbXS5jb25jYXQoY29kZXMpO1xuICAgICAgICBjb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmxhbmdzLmhhcyhjb2RlKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxhbmdzLnNldChjb2RlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsYW5nRGF0YSA9IF90aGlzLmxhbmdzLmdldChjb2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYW5ncy5zZXQoY29kZSwgZXh0ZW5kX2RlZmF1bHQoKShsYW5nRGF0YSwgZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEkxOG4ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIGNvZGUpIHtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYW5nU2V0ID0gdGhpcy5sYW5ncy5nZXQoY29kZSk7XG4gICAgICAgIGlmICghbGFuZ1NldCkge1xuICAgICAgICAgICAgbGFuZ1NldCA9IHRoaXMubGFuZ3MuZ2V0KERFRkFVTFRfQ09ERSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSBsYW5nU2V0W2tleV07XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gdGV4dCBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGluIFwiICsgY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gSTE4bjtcbn0oKSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGkxOG4gPSAobmV3IEkxOG4oKSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy93eXNpd3lnL2hlbHBlci9ub2RlLnRzXG5cblxuZnVuY3Rpb24gZmluZE5vZGVCeShwb3MsIGNvbmRpdGlvbikge1xuICAgIHZhciBkZXB0aCA9IHBvcy5kZXB0aDtcbiAgICB3aGlsZSAoZGVwdGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwb3Mubm9kZShkZXB0aCk7XG4gICAgICAgIGlmIChjb25kaXRpb24obm9kZSwgZGVwdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZGVwdGggPiAwID8gcG9zLmJlZm9yZShkZXB0aCkgOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG5vZGVfaXNMaXN0Tm9kZShfYSkge1xuICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICByZXR1cm4gdHlwZS5uYW1lID09PSAnYnVsbGV0TGlzdCcgfHwgdHlwZS5uYW1lID09PSAnb3JkZXJlZExpc3QnO1xufVxuZnVuY3Rpb24gaXNJbkxpc3ROb2RlKHBvcykge1xuICAgIHJldHVybiAhIWZpbmROb2RlQnkocG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAnbGlzdEl0ZW0nIHx8IHR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IHR5cGUubmFtZSA9PT0gJ29yZGVyZWRMaXN0JztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzSW5UYWJsZU5vZGUocG9zKSB7XG4gICAgcmV0dXJuICEhZmluZE5vZGVCeShwb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICd0YWJsZUhlYWRDZWxsJyB8fCB0eXBlLm5hbWUgPT09ICd0YWJsZUJvZHlDZWxsJztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmRMaXN0SXRlbShwb3MpIHtcbiAgICByZXR1cm4gZmluZE5vZGVCeShwb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdsaXN0SXRlbSc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVET01JbmZvUGFyc2VkUmF3SFRNTCh0YWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxsQXR0cnMoYXR0cnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyTmFtZSkge1xuICAgICAgICBpZiAoYXR0ck5hbWUgIT09ICdyYXdIVE1MJyAmJiBhdHRyc1thdHRyTmFtZV0pIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ck5hbWUgPT09ICdjbGFzc05hbWUnID8gJ2NsYXNzJyA6IGF0dHJOYW1lO1xuICAgICAgICAgICAgYWNjW2F0dHJOYW1lXSA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlZENlbGxET00odGFnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICByZXR1cm4gWydyYXdIVE1MJywgJ2NvbHNwYW4nLCAncm93c3BhbicsICdleHRlbmRlZCddLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZUluRE9NID0gYXR0ck5hbWUgPT09ICdyYXdIVE1MJyA/ICdkYXRhLXJhdy1odG1sJyA6IGF0dHJOYW1lO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBkb20uZ2V0QXR0cmlidXRlKGF0dHJOYW1lSW5ET00pO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2F0dHJOYW1lXSA9IGluY2x1ZGVzKFsncmF3SFRNTCcsICdleHRlbmRlZCddLCBhdHRyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXR0clZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE51bWJlcihhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgY2xhc3NOYW1lczogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEN1c3RvbUF0dHJzKGF0dHJzKSB7XG4gICAgdmFyIGh0bWxBdHRycyA9IGF0dHJzLmh0bWxBdHRycywgY2xhc3NOYW1lcyA9IGF0dHJzLmNsYXNzTmFtZXM7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBodG1sQXR0cnMpLCB7IGNsYXNzOiBjbGFzc05hbWVzID8gY2xhc3NOYW1lcy5qb2luKCcgJykgOiBudWxsIH0pO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd3lzaXd5Zy9oZWxwZXIvdGFibGVPZmZzZXRNYXAudHNcblxuXG52YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbnZhciBUYWJsZU9mZnNldE1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZU9mZnNldE1hcCh0YWJsZSwgdGFibGVSb3dzLCB0YWJsZVN0YXJ0UG9zLCByb3dJbmZvKSB7XG4gICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICAgICAgdGhpcy50YWJsZVJvd3MgPSB0YWJsZVJvd3M7XG4gICAgICAgIHRoaXMudGFibGVTdGFydFBvcyA9IHRhYmxlU3RhcnRQb3M7XG4gICAgICAgIHRoaXMucm93SW5mbyA9IHJvd0luZm87XG4gICAgfVxuICAgIFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZSA9IGZ1bmN0aW9uIChjZWxsUG9zKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IGZpbmROb2RlQnkoY2VsbFBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAndGFibGUnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRhYmxlLm5vZGUsIGRlcHRoID0gdGFibGUuZGVwdGgsIG9mZnNldCA9IHRhYmxlLm9mZnNldDtcbiAgICAgICAgICAgIHZhciBjYWNoZWQgPSBjYWNoZS5nZXQobm9kZSk7XG4gICAgICAgICAgICBpZiAoKGNhY2hlZCA9PT0gbnVsbCB8fCBjYWNoZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhY2hlZC50YWJsZVN0YXJ0UG9zKSA9PT0gb2Zmc2V0ICsgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm93c18xID0gW107XG4gICAgICAgICAgICB2YXIgdGFibGVQb3MgPSBjZWxsUG9zLnN0YXJ0KGRlcHRoKTtcbiAgICAgICAgICAgIHZhciB0aGVhZCA9IG5vZGUuY2hpbGQoMCk7XG4gICAgICAgICAgICB2YXIgdGJvZHkgPSBub2RlLmNoaWxkKDEpO1xuICAgICAgICAgICAgdmFyIHRoZWFkQ2VsbEluZm8gPSBjcmVhdGVPZmZzZXRNYXAodGhlYWQsIHRhYmxlUG9zKTtcbiAgICAgICAgICAgIHZhciB0Ym9keUNlbGxJbmZvID0gY3JlYXRlT2Zmc2V0TWFwKHRib2R5LCB0YWJsZVBvcyArIHRoZWFkLm5vZGVTaXplKTtcbiAgICAgICAgICAgIHRoZWFkLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93c18xLnB1c2gocm93KTsgfSk7XG4gICAgICAgICAgICB0Ym9keS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd3NfMS5wdXNoKHJvdyk7IH0pO1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBUYWJsZU9mZnNldE1hcChub2RlLCByb3dzXzEsIHRhYmxlUG9zLCB0aGVhZENlbGxJbmZvLmNvbmNhdCh0Ym9keUNlbGxJbmZvKSk7XG4gICAgICAgICAgICBjYWNoZS5zZXQobm9kZSwgbWFwKTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBcInRvdGFsUm93Q291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0luZm8ubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgXCJ0b3RhbENvbHVtbkNvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmZvWzBdLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidGFibGVTdGFydE9mZnNldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFibGVTdGFydFBvcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidGFibGVFbmRPZmZzZXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYmxlU3RhcnRQb3MgKyB0aGlzLnRhYmxlLm5vZGVTaXplIC0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsSW5mbyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5wb3NBdCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgcm93U3RhcnQgPSB0aGlzLnRhYmxlU3RhcnRQb3M7OyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciByb3dFbmQgPSByb3dTdGFydCArIHRoaXMudGFibGVSb3dzW2ldLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkgPT09IHJvd0lkeCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGNvbElkeDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBjZWxscyBmcm9tIHByZXZpb3VzIHJvdyh2aWEgcm93c3BhbilcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCB0aGlzLnRvdGFsQ29sdW1uQ291bnQgJiYgdGhpcy5yb3dJbmZvW2ldW2luZGV4XS5vZmZzZXQgPCByb3dTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPT09IHRoaXMudG90YWxDb2x1bW5Db3VudCA/IHJvd0VuZCA6IHRoaXMucm93SW5mb1tpXVtpbmRleF0ub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93U3RhcnQgPSByb3dFbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXROb2RlQW5kUG9zID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBjZWxsSW5mbyA9IHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiB0aGlzLnRhYmxlLm5vZGVBdChjZWxsSW5mby5vZmZzZXQgLSB0aGlzLnRhYmxlU3RhcnRPZmZzZXQpLFxuICAgICAgICAgICAgcG9zOiBjZWxsSW5mby5vZmZzZXQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZXh0ZW5kZWRSb3dzcGFuID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5leHRlbmRlZENvbHNwYW4gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFJvd3NwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDb2xzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZGVjcmVhc2VDb2xzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZGVjcmVhc2VSb3dzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q29sc3BhblN0YXJ0SW5mbyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRSb3dzcGFuU3RhcnRJbmZvID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENlbGxTdGFydE9mZnNldCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XS5vZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgPyB0aGlzLnBvc0F0KHJvd0lkeCwgY29sSWR4KSA6IG9mZnNldDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsRW5kT2Zmc2V0ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF0sIG9mZnNldCA9IF9hLm9mZnNldCwgbm9kZVNpemUgPSBfYS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSA/IHRoaXMucG9zQXQocm93SWR4LCBjb2xJZHgpIDogb2Zmc2V0ICsgbm9kZVNpemU7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q2VsbEluZGV4ID0gZnVuY3Rpb24gKGNlbGxQb3MpIHtcbiAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgdGhpcy50b3RhbFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgdmFyIHJvd0luZm8gPSB0aGlzLnJvd0luZm9bcm93SWR4XTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IDA7IGNvbElkeCA8IHRoaXMudG90YWxDb2x1bW5Db3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93SW5mb1tjb2xJZHhdLm9mZnNldCArIDEgPiBjZWxsUG9zLnBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Jvd0lkeCwgY29sSWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRSZWN0T2Zmc2V0cyA9IGZ1bmN0aW9uIChzdGFydENlbGxQb3MsIGVuZENlbGxQb3MpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChlbmRDZWxsUG9zID09PSB2b2lkIDApIHsgZW5kQ2VsbFBvcyA9IHN0YXJ0Q2VsbFBvczsgfVxuICAgICAgICBpZiAoc3RhcnRDZWxsUG9zLnBvcyA+IGVuZENlbGxQb3MucG9zKSB7XG4gICAgICAgICAgICBfYSA9IFtlbmRDZWxsUG9zLCBzdGFydENlbGxQb3NdLCBzdGFydENlbGxQb3MgPSBfYVswXSwgZW5kQ2VsbFBvcyA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfZCA9IHRoaXMuZ2V0Q2VsbEluZGV4KHN0YXJ0Q2VsbFBvcyksIHN0YXJ0Um93SWR4ID0gX2RbMF0sIHN0YXJ0Q29sSWR4ID0gX2RbMV07XG4gICAgICAgIHZhciBfZSA9IHRoaXMuZ2V0Q2VsbEluZGV4KGVuZENlbGxQb3MpLCBlbmRSb3dJZHggPSBfZVswXSwgZW5kQ29sSWR4ID0gX2VbMV07XG4gICAgICAgIF9iID0gZ2V0U29ydGVkTnVtUGFpcihzdGFydFJvd0lkeCwgZW5kUm93SWR4KSwgc3RhcnRSb3dJZHggPSBfYlswXSwgZW5kUm93SWR4ID0gX2JbMV07XG4gICAgICAgIF9jID0gZ2V0U29ydGVkTnVtUGFpcihzdGFydENvbElkeCwgZW5kQ29sSWR4KSwgc3RhcnRDb2xJZHggPSBfY1swXSwgZW5kQ29sSWR4ID0gX2NbMV07XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNwYW5uZWRPZmZzZXRzKHsgc3RhcnRSb3dJZHg6IHN0YXJ0Um93SWR4LCBzdGFydENvbElkeDogc3RhcnRDb2xJZHgsIGVuZFJvd0lkeDogZW5kUm93SWR4LCBlbmRDb2xJZHg6IGVuZENvbElkeCB9KTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRTcGFubmVkT2Zmc2V0cyA9IGZ1bmN0aW9uIChzZWxlY3Rpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25JbmZvO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlT2Zmc2V0TWFwO1xufSgpKTtcblxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbnZhciBjcmVhdGVPZmZzZXRNYXAgPSBmdW5jdGlvbiAoaGVhZE9yQm9keSwgc3RhcnRPZmZzZXQpIHtcbiAgICB2YXIgY2VsbEluZm9NYXRyaXggPSBbXTtcbiAgICBoZWFkT3JCb2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdywgcm93T2Zmc2V0KSB7XG4gICAgICAgIC8vIGdldCByb3cgaW5kZXggYmFzZWQgb24gdGFibGUobm90IHRhYmxlIGhlYWQgb3IgdGFibGUgYm9keSlcbiAgICAgICAgdmFyIHJvd0luZm8gPSB7IHJvd3NwYW5NYXA6IHt9LCBjb2xzcGFuTWFwOiB7fSwgbGVuZ3RoOiAwIH07XG4gICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgY2VsbE9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG5vZGVTaXplID0gX2Eubm9kZVNpemU7XG4gICAgICAgICAgICB2YXIgY29sSWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyb3dJbmZvW2NvbElkeF0pIHtcbiAgICAgICAgICAgICAgICBjb2xJZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd0luZm9bY29sSWR4XSA9IHtcbiAgICAgICAgICAgICAgICAvLyAyIGlzIHRoZSBzdW0gb2YgdGhlIGZyb250IGFuZCBiYWNrIHBvc2l0aW9ucyBvZiB0aGUgdGFnXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBzdGFydE9mZnNldCArIHJvd09mZnNldCArIGNlbGxPZmZzZXQgKyAyLFxuICAgICAgICAgICAgICAgIG5vZGVTaXplOiBub2RlU2l6ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb3dJbmZvLmxlbmd0aCArPSAxO1xuICAgICAgICB9KTtcbiAgICAgICAgY2VsbEluZm9NYXRyaXgucHVzaChyb3dJbmZvKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2VsbEluZm9NYXRyaXg7XG59O1xuZnVuY3Rpb24gbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZShvZmZzZXRNYXBNaXhpbiwgY3JlYXRlT2Zmc2V0TWFwTWl4aW4pIHtcbiAgICBjb21tb25fYXNzaWduKFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgb2Zmc2V0TWFwTWl4aW4pO1xuICAgIGNyZWF0ZU9mZnNldE1hcCA9IGNyZWF0ZU9mZnNldE1hcE1peGluO1xuICAgIHJldHVybiBUYWJsZU9mZnNldE1hcDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlci9wbHVnaW4udHNcblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZXhlY1BsdWdpbihwbHVnaW5JbmZvKSB7XG4gICAgdmFyIHBsdWdpbiA9IHBsdWdpbkluZm8ucGx1Z2luLCBldmVudEVtaXR0ZXIgPSBwbHVnaW5JbmZvLmV2ZW50RW1pdHRlciwgdXNhZ2VTdGF0aXN0aWNzID0gcGx1Z2luSW5mby51c2FnZVN0YXRpc3RpY3MsIGluc3RhbmNlID0gcGx1Z2luSW5mby5pbnN0YW5jZTtcbiAgICB2YXIgcG1TdGF0ZSA9IHsgUGx1Z2luOiBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9zdGF0ZV9jb21tb25qczJfcHJvc2VtaXJyb3Jfc3RhdGVfYW1kX3Byb3NlbWlycm9yX3N0YXRlXy5QbHVnaW4sIFBsdWdpbktleTogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3Jfc3RhdGVfY29tbW9uanMyX3Byb3NlbWlycm9yX3N0YXRlX2FtZF9wcm9zZW1pcnJvcl9zdGF0ZV8uUGx1Z2luS2V5LCBTZWxlY3Rpb246IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3N0YXRlX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9zdGF0ZV9hbWRfcHJvc2VtaXJyb3Jfc3RhdGVfLlNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbjogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3Jfc3RhdGVfY29tbW9uanMyX3Byb3NlbWlycm9yX3N0YXRlX2FtZF9wcm9zZW1pcnJvcl9zdGF0ZV8uVGV4dFNlbGVjdGlvbiB9O1xuICAgIHZhciBwbVZpZXcgPSB7IERlY29yYXRpb246IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3ZpZXdfY29tbW9uanMyX3Byb3NlbWlycm9yX3ZpZXdfYW1kX3Byb3NlbWlycm9yX3ZpZXdfLkRlY29yYXRpb24sIERlY29yYXRpb25TZXQ6IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3ZpZXdfY29tbW9uanMyX3Byb3NlbWlycm9yX3ZpZXdfYW1kX3Byb3NlbWlycm9yX3ZpZXdfLkRlY29yYXRpb25TZXQgfTtcbiAgICB2YXIgcG1Nb2RlbCA9IHsgRnJhZ21lbnQ6IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX21vZGVsX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9tb2RlbF9hbWRfcHJvc2VtaXJyb3JfbW9kZWxfLkZyYWdtZW50IH07XG4gICAgdmFyIHBtUnVsZXMgPSB7IElucHV0UnVsZTogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3JfaW5wdXRydWxlc19jb21tb25qczJfcHJvc2VtaXJyb3JfaW5wdXRydWxlc19hbWRfcHJvc2VtaXJyb3JfaW5wdXRydWxlc18uSW5wdXRSdWxlLCBpbnB1dFJ1bGVzOiBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2FtZF9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzXy5pbnB1dFJ1bGVzLCB1bmRvSW5wdXRSdWxlOiBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2FtZF9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzXy51bmRvSW5wdXRSdWxlIH07XG4gICAgdmFyIHBtS2V5bWFwID0geyBrZXltYXA6IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX2tleW1hcF9jb21tb25qczJfcHJvc2VtaXJyb3Jfa2V5bWFwX2FtZF9wcm9zZW1pcnJvcl9rZXltYXBfLmtleW1hcCB9O1xuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlcixcbiAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB1c2FnZVN0YXRpc3RpY3MsXG4gICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgcG1TdGF0ZTogcG1TdGF0ZSxcbiAgICAgICAgcG1WaWV3OiBwbVZpZXcsXG4gICAgICAgIHBtTW9kZWw6IHBtTW9kZWwsXG4gICAgICAgIHBtUnVsZXM6IHBtUnVsZXMsXG4gICAgICAgIHBtS2V5bWFwOiBwbUtleW1hcCxcbiAgICAgICAgaTE4bjogaTE4bixcbiAgICB9O1xuICAgIGlmIChpc0FycmF5X2RlZmF1bHQoKShwbHVnaW4pKSB7XG4gICAgICAgIHZhciBwbHVnaW5GbiA9IHBsdWdpblswXSwgX2EgPSBwbHVnaW5bMV0sIG9wdGlvbnMgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYTtcbiAgICAgICAgcmV0dXJuIHBsdWdpbkZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luKGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0UGx1Z2luSW5mbyhwbHVnaW5zSW5mbykge1xuICAgIHZhciBwbHVnaW5zID0gcGx1Z2luc0luZm8ucGx1Z2lucywgZXZlbnRFbWl0dGVyID0gcGx1Z2luc0luZm8uZXZlbnRFbWl0dGVyLCB1c2FnZVN0YXRpc3RpY3MgPSBwbHVnaW5zSW5mby51c2FnZVN0YXRpc3RpY3MsIGluc3RhbmNlID0gcGx1Z2luc0luZm8uaW5zdGFuY2U7XG4gICAgZXZlbnRFbWl0dGVyLmxpc3RlbignbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZScsIG1peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUpO1xuICAgIHJldHVybiAocGx1Z2lucyAhPT0gbnVsbCAmJiBwbHVnaW5zICE9PSB2b2lkIDAgPyBwbHVnaW5zIDogW10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbHVnaW4pIHtcbiAgICAgICAgdmFyIHBsdWdpbkluZm9SZXN1bHQgPSBleGVjUGx1Z2luKHtcbiAgICAgICAgICAgIHBsdWdpbjogcGx1Z2luLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiBldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcGx1Z2luSW5mb1Jlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRlZCBwbHVnaW4gaXMgZW1wdHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmtkb3duUGFyc2VycyA9IHBsdWdpbkluZm9SZXN1bHQubWFya2Rvd25QYXJzZXJzLCB0b0hUTUxSZW5kZXJlcnMgPSBwbHVnaW5JbmZvUmVzdWx0LnRvSFRNTFJlbmRlcmVycywgdG9NYXJrZG93blJlbmRlcmVycyA9IHBsdWdpbkluZm9SZXN1bHQudG9NYXJrZG93blJlbmRlcmVycywgbWFya2Rvd25QbHVnaW5zID0gcGx1Z2luSW5mb1Jlc3VsdC5tYXJrZG93blBsdWdpbnMsIHd5c2l3eWdQbHVnaW5zID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnUGx1Z2lucywgd3lzaXd5Z05vZGVWaWV3cyA9IHBsdWdpbkluZm9SZXN1bHQud3lzaXd5Z05vZGVWaWV3cywgbWFya2Rvd25Db21tYW5kcyA9IHBsdWdpbkluZm9SZXN1bHQubWFya2Rvd25Db21tYW5kcywgd3lzaXd5Z0NvbW1hbmRzID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnQ29tbWFuZHMsIHRvb2xiYXJJdGVtcyA9IHBsdWdpbkluZm9SZXN1bHQudG9vbGJhckl0ZW1zO1xuICAgICAgICBpZiAodG9IVE1MUmVuZGVyZXJzKSB7XG4gICAgICAgICAgICBhY2MudG9IVE1MUmVuZGVyZXJzID0gZGVlcE1lcmdlZENvcHkoYWNjLnRvSFRNTFJlbmRlcmVycywgdG9IVE1MUmVuZGVyZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9NYXJrZG93blJlbmRlcmVycykge1xuICAgICAgICAgICAgYWNjLnRvTWFya2Rvd25SZW5kZXJlcnMgPSBkZWVwTWVyZ2VkQ29weShhY2MudG9NYXJrZG93blJlbmRlcmVycywgdG9NYXJrZG93blJlbmRlcmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtkb3duUGx1Z2lucykge1xuICAgICAgICAgICAgYWNjLm1kUGx1Z2lucyA9IGFjYy5tZFBsdWdpbnMuY29uY2F0KG1hcmtkb3duUGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHd5c2l3eWdQbHVnaW5zKSB7XG4gICAgICAgICAgICBhY2Mud3dQbHVnaW5zID0gYWNjLnd3UGx1Z2lucy5jb25jYXQod3lzaXd5Z1BsdWdpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3eXNpd3lnTm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBhY2Mud3dOb2RlVmlld3MgPSB0c2xpYl9lczZfYXNzaWduKHRzbGliX2VzNl9hc3NpZ24oe30sIGFjYy53d05vZGVWaWV3cyksIHd5c2l3eWdOb2RlVmlld3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZG93bkNvbW1hbmRzKSB7XG4gICAgICAgICAgICBhY2MubWRDb21tYW5kcyA9IHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgYWNjLm1kQ29tbWFuZHMpLCBtYXJrZG93bkNvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3lzaXd5Z0NvbW1hbmRzKSB7XG4gICAgICAgICAgICBhY2Mud3dDb21tYW5kcyA9IHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgYWNjLnd3Q29tbWFuZHMpLCB3eXNpd3lnQ29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29sYmFySXRlbXMpIHtcbiAgICAgICAgICAgIGFjYy50b29sYmFySXRlbXMgPSBhY2MudG9vbGJhckl0ZW1zLmNvbmNhdCh0b29sYmFySXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZG93blBhcnNlcnMpIHtcbiAgICAgICAgICAgIGFjYy5tYXJrZG93blBhcnNlcnMgPSB0c2xpYl9lczZfYXNzaWduKHRzbGliX2VzNl9hc3NpZ24oe30sIGFjYy5tYXJrZG93blBhcnNlcnMpLCBtYXJrZG93blBhcnNlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge1xuICAgICAgICB0b0hUTUxSZW5kZXJlcnM6IHt9LFxuICAgICAgICB0b01hcmtkb3duUmVuZGVyZXJzOiB7fSxcbiAgICAgICAgbWRQbHVnaW5zOiBbXSxcbiAgICAgICAgd3dQbHVnaW5zOiBbXSxcbiAgICAgICAgd3dOb2RlVmlld3M6IHt9LFxuICAgICAgICBtZENvbW1hbmRzOiB7fSxcbiAgICAgICAgd3dDb21tYW5kczoge30sXG4gICAgICAgIHRvb2xiYXJJdGVtczogW10sXG4gICAgICAgIG1hcmtkb3duUGFyc2Vyczoge30sXG4gICAgfSk7XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc0ZhbHN5LmpzXG52YXIgaXNGYWxzeSA9IF9fd2VicGFja19yZXF1aXJlX18oNDA0KTtcbnZhciBpc0ZhbHN5X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzRmFsc3kpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2V2ZW50L2V2ZW50RW1pdHRlci50c1xuXG5cblxuXG52YXIgZXZlbnRUeXBlTGlzdCA9IFtcbiAgICAnYWZ0ZXJQcmV2aWV3UmVuZGVyJyxcbiAgICAndXBkYXRlUHJldmlldycsXG4gICAgJ2NoYW5nZU1vZGUnLFxuICAgICduZWVkQ2hhbmdlTW9kZScsXG4gICAgJ2NvbW1hbmQnLFxuICAgICdjaGFuZ2VQcmV2aWV3U3R5bGUnLFxuICAgICdjaGFuZ2VQcmV2aWV3VGFiUHJldmlldycsXG4gICAgJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScsXG4gICAgJ3Njcm9sbCcsXG4gICAgJ2NvbnRleHRtZW51JyxcbiAgICAnc2hvdycsXG4gICAgJ2hpZGUnLFxuICAgICdjaGFuZ2VMYW5ndWFnZScsXG4gICAgJ2NoYW5nZVRvb2xiYXJTdGF0ZScsXG4gICAgJ3RvZ2dsZVNjcm9sbFN5bmMnLFxuICAgICdtaXhpblRhYmxlT2Zmc2V0TWFwUHJvdG90eXBlJyxcbiAgICAnc2V0Rm9jdXNlZE5vZGUnLFxuICAgICdyZW1vdmVQb3B1cFdpZGdldCcsXG4gICAgJ3F1ZXJ5JyxcbiAgICAvLyBwcm92aWRlIGV2ZW50IGZvciB1c2VyXG4gICAgJ29wZW5Qb3B1cCcsXG4gICAgJ2Nsb3NlUG9wdXAnLFxuICAgICdhZGRJbWFnZUJsb2JIb29rJyxcbiAgICAnYmVmb3JlUHJldmlld1JlbmRlcicsXG4gICAgJ2JlZm9yZUNvbnZlcnRXeXNpd3lnVG9NYXJrZG93bicsXG4gICAgJ2xvYWQnLFxuICAgICdsb2FkVUknLFxuICAgICdjaGFuZ2UnLFxuICAgICdjYXJldENoYW5nZScsXG4gICAgJ2Rlc3Ryb3knLFxuICAgICdmb2N1cycsXG4gICAgJ2JsdXInLFxuICAgICdrZXlkb3duJyxcbiAgICAna2V5dXAnLFxuXTtcbi8qKlxuICogQ2xhc3MgRXZlbnRFbWl0dGVyXG4gKiBAaWdub3JlXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyB1dGlsc19tYXAoKTtcbiAgICAgICAgdGhpcy5ldmVudFR5cGVzID0gZXZlbnRUeXBlTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHR5cGVzLCB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfZXM2X2Fzc2lnbih0c2xpYl9lczZfYXNzaWduKHt9LCB0eXBlcyksIHsgdHlwZTogdHlwZSB9KTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLmhvbGQgPSBmYWxzZTtcbiAgICAgICAgZXZlbnRUeXBlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZEV2ZW50VHlwZShldmVudFR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGV2ZW50IGFuZCBiaW5kIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHR5cGVJbmZvID0gdGhpcy5nZXRUeXBlSW5mbyh0eXBlKTtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZUluZm8udHlwZSkgfHwgW107XG4gICAgICAgIGlmICghdGhpcy5oYXNFdmVudFR5cGUodHlwZUluZm8udHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGV2ZW50IHR5cGUgXCIgKyB0eXBlSW5mby50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZUluZm8ubmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBoYW5kbGVyLm5hbWVzcGFjZSA9IHR5cGVJbmZvLm5hbWVzcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudEhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZlbnRzLnNldCh0eXBlSW5mby50eXBlLCBldmVudEhhbmRsZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWUgdG8gZW1pdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZUluZm8gPSB0aGlzLmdldFR5cGVJbmZvKHR5cGUpO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlSW5mby50eXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmhvbGQgJiYgZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZXIuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkX2RlZmF1bHQoKShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBnaXZlbiBldmVudCBhbmQgcmV0dXJuIHJlc3VsdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBlbWl0XG4gICAgICogQHBhcmFtIHthbnl9IHNvdXJjZSBTb3VyY2UgdG8gY2hhbmdlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXRSZWR1Y2UgPSBmdW5jdGlvbiAodHlwZSwgc291cmNlKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIXRoaXMuaG9sZCAmJiBldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBldmVudEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlci5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW3NvdXJjZV0sIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmFsc3lfZGVmYXVsdCgpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnQgdHlwZSBhbmQgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHJldHVybnMge3t0eXBlOiBzdHJpbmcsIG5hbWVzcGFjZTogc3RyaW5nfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0VHlwZUluZm8gPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgc3BsaXRlZCA9IHR5cGUuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHNwbGl0ZWRbMF0sXG4gICAgICAgICAgICBuYW1lc3BhY2U6IHNwbGl0ZWRbMV0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIGV2ZW50IHR5cGUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5oYXNFdmVudFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkX2RlZmF1bHQoKSh0aGlzLmV2ZW50VHlwZXNbdGhpcy5nZXRUeXBlSW5mbyh0eXBlKS50eXBlXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgZXZlbnQgdHlwZSB3aGVuIGdpdmVuIGV2ZW50IG5vdCBleGlzdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0V2ZW50VHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgYWxyZWFkeSBoYXZlIGV2ZW50IHR5cGUgXCIgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50VHlwZXNbdHlwZV0gPSB0eXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGhhbmRsZXIgZnJvbSBnaXZlbiBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRUeXBlSW5mbyhldmVudFR5cGUpLCB0eXBlID0gX2EudHlwZSwgbmFtZXNwYWNlID0gX2EubmFtZXNwYWNlO1xuICAgICAgICBpZiAodHlwZSAmJiBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhIYW5kbGVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgJiYgIW5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0eXBlICYmIG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoXywgZXZ0VHlwZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhUeXBlSW5mbyhldnRUeXBlLCBuYW1lc3BhY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSAmJiBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aFR5cGVJbmZvKHR5cGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudCBoYW5kbGVyIHdpdGggZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aEhhbmRsZXIgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVySW5kZXggPSBldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpID49IDApIHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXJzLnNwbGljZShoYW5kbGVySW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgaGFuZGxlciB3aXRoIGV2ZW50IHR5cGUgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIEV2ZW50IG5hbWVzcGFjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudEhhbmRsZXJXaXRoVHlwZUluZm8gPSBmdW5jdGlvbiAodHlwZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBoYW5kbGVyc1RvU3Vydml2ZSA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNUb1N1cnZpdmUucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMuc2V0KHR5cGUsIGhhbmRsZXJzVG9TdXJ2aXZlKTtcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhvbGRFdmVudEludm9rZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLmhvbGQgPSB0cnVlO1xuICAgICAgICBmbigpO1xuICAgICAgICB0aGlzLmhvbGQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZXZlbnRFbWl0dGVyID0gKEV2ZW50RW1pdHRlcik7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy92aWV3ZXIudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUQVNLX0FUVFJfTkFNRSA9ICdkYXRhLXRhc2snO1xudmFyIERJU0FCTEVEX1RBU0tfQVRUUl9OQU1FID0gJ2RhdGEtdGFzay1kaXNhYmxlZCc7XG52YXIgVEFTS19DSEVDS0VEX0NMQVNTX05BTUUgPSAnY2hlY2tlZCc7XG5mdW5jdGlvbiByZWdpc3RlckhUTUxUYWdUb1doaXRlbGlzdChjb252ZXJ0b3JNYXApIHtcbiAgICBbJ2h0bWxCbG9jaycsICdodG1sSW5saW5lJ10uZm9yRWFjaChmdW5jdGlvbiAoaHRtbFR5cGUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pIHtcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRhZyB3aGl0ZSBsaXN0IGZvciBwcmV2ZW50aW5nIHRvIHJlbW92ZSB0aGUgaHRtbCBpbiBzYW5pdGl6ZXJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIGh0bWxTYW5pdGl6ZXJfcmVnaXN0ZXJUYWdXaGl0ZWxpc3RJZlBvc3NpYmxlKHR5cGUpOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBDbGFzcyBUb2FzdFVJRWRpdG9yVmlld2VyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb24gb2JqZWN0XG4gKiAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5lbCAtIGNvbnRhaW5lciBlbGVtZW50XG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmluaXRpYWxWYWx1ZV0gRWRpdG9yJ3MgaW5pdGlhbCB2YWx1ZVxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5ldmVudHNdIC0gRXZlbnRzXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5sb2FkXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgZnVsbHkgbG9hZFxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuY2hhbmdlXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBjb250ZW50IGNoYW5nZWRcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmNhcmV0Q2hhbmdlXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBmb3JtYXQgY2hhbmdlIGJ5IGN1cnNvciBwb3NpdGlvblxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuZm9jdXNdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBnZXQgZm9jdXNcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmJsdXJdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBsb29zZSBmb2N1c1xuICogICAgIEBwYXJhbSB7QXJyYXkuPGZ1bmN0aW9ufEFycmF5Pn0gW29wdGlvbnMucGx1Z2luc10gLSBBcnJheSBvZiBwbHVnaW5zLiBBIHBsdWdpbiBjYW4gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgW2Z1bmN0aW9uLCBvcHRpb25zXS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXh0ZW5kZWRBdXRvbGlua3NdIC0gVXNpbmcgZXh0ZW5kZWQgQXV0b2xpbmtzIHNwZWNpZmllZCBpbiBHRk0gc3BlY1xuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5saW5rQXR0cmlidXRlc10gLSBBdHRyaWJ1dGVzIG9mIGFuY2hvciBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbCwgdGFyZ2V0LCBocmVmbGFuZywgdHlwZVxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXI9bnVsbF0gLSBPYmplY3QgY29udGFpbmluZyBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb25zIGNvcnJlc3BvbmQgdG8gY2hhbmdlIG1hcmtkb3duIG5vZGUgdG8gcHJldmlldyBIVE1MIG9yIHd5c2l3eWcgbm9kZVxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbj1mYWxzZV0gLSB3aGV0aGVyIHVzZSB0aGUgc3BlY2lmaWNhdGlvbiBvZiBsaW5rIHJlZmVyZW5jZSBkZWZpbml0aW9uXG4gKiAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuY3VzdG9tSFRNTFNhbml0aXplcj1udWxsXSAtIGN1c3RvbSBIVE1MIHNhbml0aXplclxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZnJvbnRNYXR0ZXI9ZmFsc2VdIC0gd2hldGhlciB1c2UgdGhlIGZyb250IG1hdHRlclxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aGVtZV0gLSBUaGUgdGhlbWUgdG8gc3R5bGUgdGhlIHZpZXdlciB3aXRoLiBUaGUgZGVmYXVsdCBpcyBpbmNsdWRlZCBpbiB0b2FzdHVpLWVkaXRvci5jc3MuXG4gKi9cbnZhciBUb2FzdFVJRWRpdG9yVmlld2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0VUlFZGl0b3JWaWV3ZXIob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmRfZGVmYXVsdCgpKHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBudWxsLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFJlbmRlcmVyOiBudWxsLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBjdXN0b21IVE1MU2FuaXRpemVyOiBudWxsLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB0cnVlLFxuICAgICAgICAgICAgdGhlbWU6ICdsaWdodCcsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBldmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0gc2FuaXRpemVMaW5rQXR0cmlidXRlKHRoaXMub3B0aW9ucy5saW5rQXR0cmlidXRlcyk7XG4gICAgICAgIHZhciBfYSA9IGdldFBsdWdpbkluZm8oe1xuICAgICAgICAgICAgcGx1Z2luczogdGhpcy5vcHRpb25zLnBsdWdpbnMsXG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IHRoaXMuZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB0aGlzLm9wdGlvbnMudXNhZ2VTdGF0aXN0aWNzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgICAgIH0pIHx8IHt9LCB0b0hUTUxSZW5kZXJlcnMgPSBfYS50b0hUTUxSZW5kZXJlcnMsIG1hcmtkb3duUGFyc2VycyA9IF9hLm1hcmtkb3duUGFyc2VycztcbiAgICAgICAgdmFyIF9iID0gdGhpcy5vcHRpb25zLCBjdXN0b21IVE1MUmVuZGVyZXIgPSBfYi5jdXN0b21IVE1MUmVuZGVyZXIsIGV4dGVuZGVkQXV0b2xpbmtzID0gX2IuZXh0ZW5kZWRBdXRvbGlua3MsIHJlZmVyZW5jZURlZmluaXRpb24gPSBfYi5yZWZlcmVuY2VEZWZpbml0aW9uLCBmcm9udE1hdHRlciA9IF9iLmZyb250TWF0dGVyLCBjdXN0b21IVE1MU2FuaXRpemVyID0gX2IuY3VzdG9tSFRNTFNhbml0aXplcjtcbiAgICAgICAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBsaW5rQXR0cmlidXRlcyxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxSZW5kZXJlcjogdHNsaWJfZXM2X2Fzc2lnbih0c2xpYl9lczZfYXNzaWduKHt9LCB0b0hUTUxSZW5kZXJlcnMpLCBjdXN0b21IVE1MUmVuZGVyZXIpLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmcm9udE1hdHRlcixcbiAgICAgICAgICAgIHNhbml0aXplcjogY3VzdG9tSFRNTFNhbml0aXplciB8fCBzYW5pdGl6ZUhUTUwsXG4gICAgICAgIH07XG4gICAgICAgIHJlZ2lzdGVySFRNTFRhZ1RvV2hpdGVsaXN0KHJlbmRlcmVyT3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV2ZW50cykge1xuICAgICAgICAgICAgZm9yRWFjaE93blByb3BlcnRpZXNfZGVmYXVsdCgpKHRoaXMub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub24oa2V5LCBmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSB0aGlzLm9wdGlvbnMsIGVsID0gX2MuZWwsIGluaXRpYWxWYWx1ZSA9IF9jLmluaXRpYWxWYWx1ZSwgdGhlbWUgPSBfYy50aGVtZTtcbiAgICAgICAgdmFyIGV4aXN0aW5nSFRNTCA9IGVsLmlubmVySFRNTDtcbiAgICAgICAgaWYgKHRoZW1lICE9PSAnbGlnaHQnKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyh0aGVtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLnRvYXN0TWFyayA9IG5ldyBUb2FzdE1hcmsoJycsIHtcbiAgICAgICAgICAgIGRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzOiBbJ2JyJywgJ2ltZyddLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGRpc2FsbG93RGVlcEhlYWRpbmc6IHRydWUsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG4gICAgICAgICAgICBjdXN0b21QYXJzZXI6IG1hcmtkb3duUGFyc2VycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJldmlldyA9IG5ldyBtZFByZXZpZXcodGhpcy5ldmVudEVtaXR0ZXIsIHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgcmVuZGVyZXJPcHRpb25zKSwgeyBpc1ZpZXdlcjogdHJ1ZSB9KSk7XG4gICAgICAgIG9uX2RlZmF1bHQoKSh0aGlzLnByZXZpZXcucHJldmlld0NvbnRlbnQsICdtb3VzZWRvd24nLCB0aGlzLnRvZ2dsZVRhc2suYmluZCh0aGlzKSk7XG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2Rvd24oaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ0hUTUwpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zZXRIVE1MKGV4aXN0aW5nSFRNTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3LnByZXZpZXdDb250ZW50KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnbG9hZCcsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGFzayBieSBkZXRlY3RpbmcgbW91c2Vkb3duIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXYgLSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUudG9nZ2xlVGFzayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGV2LnRhcmdldDtcbiAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnOmJlZm9yZScpO1xuICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKERJU0FCTEVEX1RBU0tfQVRUUl9OQU1FKSAmJlxuICAgICAgICAgICAgZWxlbWVudC5oYXNBdHRyaWJ1dGUoVEFTS19BVFRSX05BTUUpICYmXG4gICAgICAgICAgICBpc1Bvc2l0aW9uSW5Cb3goc3R5bGUsIGV2Lm9mZnNldFgsIGV2Lm9mZnNldFkpKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhlbGVtZW50LCBUQVNLX0NIRUNLRURfQ0xBU1NfTkFNRSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiAndmlld2VyJyxcbiAgICAgICAgICAgICAgICBkYXRlOiBldixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgY29udGVudCBmb3IgcHJldmlld1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZG93biBNYXJrZG93biB0ZXh0XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuc2V0TWFya2Rvd24gPSBmdW5jdGlvbiAobWFya2Rvd24pIHtcbiAgICAgICAgdmFyIGxpbmVUZXh0cyA9IHRoaXMudG9hc3RNYXJrLmdldExpbmVUZXh0cygpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGluZVRleHRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxhc3RMaW5lID0gY29tbW9uX2xhc3QobGluZVRleHRzKTtcbiAgICAgICAgdmFyIGVuZFNvdXJjZXBvcyA9IFtsZW5ndGgsIGxhc3RMaW5lLmxlbmd0aCArIDFdO1xuICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IHRoaXMudG9hc3RNYXJrLmVkaXRNYXJrZG93bihbMSwgMV0sIGVuZFNvdXJjZXBvcywgbWFya2Rvd24gfHwgJycpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCd1cGRhdGVQcmV2aWV3JywgZWRpdFJlc3VsdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCaW5kIGV2ZW50SGFuZGxlciB0byBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5iaW5kIGV2ZW50SGFuZGxlciBmcm9tIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGhvb2sgdG8gVFVJRWRpdG9yIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmFkZEhvb2sgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbih0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBWaWV3ZXIgcHJldmlldyBmcm9tIGRvY3VtZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmX2RlZmF1bHQoKSh0aGlzLnByZXZpZXcuZWwsICdtb3VzZWRvd24nLCB0aGlzLnRvZ2dsZVRhc2suYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucHJldmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNWaWV3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNNYXJrZG93bk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmlzV3lzaXd5Z01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdFVJRWRpdG9yVmlld2VyO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHZpZXdlciA9IChUb2FzdFVJRWRpdG9yVmlld2VyKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2luZGV4Vmlld2VyLnRzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaW5kZXhWaWV3ZXIgPSAodmlld2VyKTtcblxufSgpO1xuX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdO1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toast-ui/react-editor/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/react-editor/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ default_1),\n/* harmony export */   Viewer: () => (/* binding */ ViewerComponent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _toast_ui_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toast-ui/editor */ \"(ssr)/./node_modules/@toast-ui/editor/dist/esm/index.js\");\n/* harmony import */ var _toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toast-ui/editor/dist/toastui-editor-viewer */ \"(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js\");\n/* harmony import */ var _toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * TOAST UI Editor : React Wrapper\n * @version 3.2.3 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar default_1 = /** @class */ (function (_super) {\n    __extends(default_1, _super);\n    function default_1() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootEl = react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n        return _this;\n    }\n    default_1.prototype.getRootElement = function () {\n        return this.rootEl.current;\n    };\n    default_1.prototype.getInstance = function () {\n        return this.editorInst;\n    };\n    default_1.prototype.getBindingEventNames = function () {\n        var _this = this;\n        return Object.keys(this.props)\n            .filter(function (key) { return /^on[A-Z][a-zA-Z]+/.test(key); })\n            .filter(function (key) { return _this.props[key]; });\n    };\n    default_1.prototype.bindEventHandlers = function (props) {\n        var _this = this;\n        this.getBindingEventNames().forEach(function (key) {\n            var eventName = key[2].toLowerCase() + key.slice(3);\n            _this.editorInst.off(eventName);\n            _this.editorInst.on(eventName, props[key]);\n        });\n    };\n    default_1.prototype.getInitEvents = function () {\n        var _this = this;\n        return this.getBindingEventNames().reduce(function (acc, key) {\n            var eventName = (key[2].toLowerCase() + key.slice(3));\n            acc[eventName] = _this.props[key];\n            return acc;\n        }, {});\n    };\n    default_1.prototype.componentDidMount = function () {\n        this.editorInst = new _toast_ui_editor__WEBPACK_IMPORTED_MODULE_1__[\"default\"](__assign(__assign({ el: this.rootEl.current }, this.props), { events: this.getInitEvents() }));\n    };\n    default_1.prototype.shouldComponentUpdate = function (nextProps) {\n        var instance = this.getInstance();\n        var height = nextProps.height, previewStyle = nextProps.previewStyle;\n        if (height && this.props.height !== height) {\n            instance.setHeight(height);\n        }\n        if (previewStyle && this.props.previewStyle !== previewStyle) {\n            instance.changePreviewStyle(previewStyle);\n        }\n        this.bindEventHandlers(nextProps);\n        return false;\n    };\n    default_1.prototype.render = function () {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: this.rootEl });\n    };\n    return default_1;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component)));\n\nvar ViewerComponent = /** @class */ (function (_super) {\n    __extends(ViewerComponent, _super);\n    function ViewerComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootEl = react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n        return _this;\n    }\n    ViewerComponent.prototype.getRootElement = function () {\n        return this.rootEl.current;\n    };\n    ViewerComponent.prototype.getInstance = function () {\n        return this.viewerInst;\n    };\n    ViewerComponent.prototype.getBindingEventNames = function () {\n        var _this = this;\n        return Object.keys(this.props)\n            .filter(function (key) { return /^on[A-Z][a-zA-Z]+/.test(key); })\n            .filter(function (key) { return _this.props[key]; });\n    };\n    ViewerComponent.prototype.bindEventHandlers = function (props) {\n        var _this = this;\n        this.getBindingEventNames().forEach(function (key) {\n            var eventName = key[2].toLowerCase() + key.slice(3);\n            _this.viewerInst.off(eventName);\n            _this.viewerInst.on(eventName, props[key]);\n        });\n    };\n    ViewerComponent.prototype.getInitEvents = function () {\n        var _this = this;\n        return this.getBindingEventNames().reduce(function (acc, key) {\n            var eventName = (key[2].toLowerCase() + key.slice(3));\n            acc[eventName] = _this.props[key];\n            return acc;\n        }, {});\n    };\n    ViewerComponent.prototype.componentDidMount = function () {\n        this.viewerInst = new (_toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2___default())(__assign(__assign({ el: this.rootEl.current }, this.props), { events: this.getInitEvents() }));\n    };\n    ViewerComponent.prototype.shouldComponentUpdate = function (nextProps) {\n        this.bindEventHandlers(nextProps);\n        return false;\n    };\n    ViewerComponent.prototype.render = function () {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: this.rootEl });\n    };\n    return ViewerComponent;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component)));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL3JlYWN0LWVkaXRvci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUNZO0FBQzJCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1Q0FBdUM7QUFDNUUscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQU0scUJBQXFCLHlCQUF5QixpQkFBaUIsOEJBQThCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFtQixVQUFVLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLHdEQUFlOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVDQUF1QztBQUM1RSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBLDhCQUE4QixvRkFBTSxxQkFBcUIseUJBQXlCLGlCQUFpQiw4QkFBOEI7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBbUIsVUFBVSxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBLENBQUMsQ0FBQyx3REFBZTs7QUFFeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZm9yZ2UvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL3JlYWN0LWVkaXRvci9kaXN0L2VzbS9pbmRleC5qcz9iN2Q3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVE9BU1QgVUkgRWRpdG9yIDogUmVhY3QgV3JhcHBlclxuICogQHZlcnNpb24gMy4yLjMgfCBGcmkgRmViIDE3IDIwMjNcbiAqIEBhdXRob3IgTkhOIENsb3VkIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBFZGl0b3IgZnJvbSAnQHRvYXN0LXVpL2VkaXRvcic7XG5pbXBvcnQgVmlld2VyIGZyb20gJ0B0b2FzdC11aS9lZGl0b3IvZGlzdC90b2FzdHVpLWVkaXRvci12aWV3ZXInO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcblxudmFyIGRlZmF1bHRfMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoZGVmYXVsdF8xLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRfMSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJvb3RFbCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuZ2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RFbC5jdXJyZW50O1xuICAgIH07XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9ySW5zdDtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuZ2V0QmluZGluZ0V2ZW50TmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnByb3BzKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAvXm9uW0EtWl1bYS16QS1aXSsvLnRlc3Qoa2V5KTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMucHJvcHNba2V5XTsgfSk7XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLmJpbmRFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZ2V0QmluZGluZ0V2ZW50TmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKTtcbiAgICAgICAgICAgIF90aGlzLmVkaXRvckluc3Qub2ZmKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5lZGl0b3JJbnN0Lm9uKGV2ZW50TmFtZSwgcHJvcHNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5nZXRJbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCaW5kaW5nRXZlbnROYW1lcygpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSAoa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgYWNjW2V2ZW50TmFtZV0gPSBfdGhpcy5wcm9wc1trZXldO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JJbnN0ID0gbmV3IEVkaXRvcihfX2Fzc2lnbihfX2Fzc2lnbih7IGVsOiB0aGlzLnJvb3RFbC5jdXJyZW50IH0sIHRoaXMucHJvcHMpLCB7IGV2ZW50czogdGhpcy5nZXRJbml0RXZlbnRzKCkgfSkpO1xuICAgIH07XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IG5leHRQcm9wcy5oZWlnaHQsIHByZXZpZXdTdHlsZSA9IG5leHRQcm9wcy5wcmV2aWV3U3R5bGU7XG4gICAgICAgIGlmIChoZWlnaHQgJiYgdGhpcy5wcm9wcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0SGVpZ2h0KGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpZXdTdHlsZSAmJiB0aGlzLnByb3BzLnByZXZpZXdTdHlsZSAhPT0gcHJldmlld1N0eWxlKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jaGFuZ2VQcmV2aWV3U3R5bGUocHJldmlld1N0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpbmRFdmVudEhhbmRsZXJzKG5leHRQcm9wcyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5yb290RWwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gZGVmYXVsdF8xO1xufShSZWFjdC5Db21wb25lbnQpKTtcblxudmFyIFZpZXdlckNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlld2VyQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpZXdlckNvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJvb3RFbCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZpZXdlckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RFbC5jdXJyZW50O1xuICAgIH07XG4gICAgVmlld2VyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld2VySW5zdDtcbiAgICB9O1xuICAgIFZpZXdlckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0QmluZGluZ0V2ZW50TmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnByb3BzKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAvXm9uW0EtWl1bYS16QS1aXSsvLnRlc3Qoa2V5KTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMucHJvcHNba2V5XTsgfSk7XG4gICAgfTtcbiAgICBWaWV3ZXJDb21wb25lbnQucHJvdG90eXBlLmJpbmRFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZ2V0QmluZGluZ0V2ZW50TmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKTtcbiAgICAgICAgICAgIF90aGlzLnZpZXdlckluc3Qub2ZmKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBfdGhpcy52aWV3ZXJJbnN0Lm9uKGV2ZW50TmFtZSwgcHJvcHNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVmlld2VyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCaW5kaW5nRXZlbnROYW1lcygpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSAoa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgYWNjW2V2ZW50TmFtZV0gPSBfdGhpcy5wcm9wc1trZXldO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgVmlld2VyQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3ZXJJbnN0ID0gbmV3IFZpZXdlcihfX2Fzc2lnbihfX2Fzc2lnbih7IGVsOiB0aGlzLnJvb3RFbC5jdXJyZW50IH0sIHRoaXMucHJvcHMpLCB7IGV2ZW50czogdGhpcy5nZXRJbml0RXZlbnRzKCkgfSkpO1xuICAgIH07XG4gICAgVmlld2VyQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuYmluZEV2ZW50SGFuZGxlcnMobmV4dFByb3BzKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVmlld2VyQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLnJvb3RFbCB9KTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3ZXJDb21wb25lbnQ7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuXG5leHBvcnQgeyBkZWZhdWx0XzEgYXMgRWRpdG9yLCBWaWV3ZXJDb21wb25lbnQgYXMgVmlld2VyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/react-editor/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor.css":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/toastui-editor.css ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"dc6b4e2d7563\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L3RvYXN0dWktZWRpdG9yLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmb3JnZS8uL25vZGVfbW9kdWxlcy9AdG9hc3QtdWkvZWRpdG9yL2Rpc3QvdG9hc3R1aS1lZGl0b3IuY3NzPzBiNTUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkYzZiNGUyZDc1NjNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor.css\n");

/***/ })

};
;